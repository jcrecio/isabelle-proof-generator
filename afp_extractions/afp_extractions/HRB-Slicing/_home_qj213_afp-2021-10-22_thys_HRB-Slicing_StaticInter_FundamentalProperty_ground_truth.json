{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/FundamentalProperty.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma observable_set_stack_in_slice:\n  \"S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s') \n  \\<Longrightarrow> \\<forall>mx \\<in> set (tl ms'). \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"", "lemma silent_move_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs [a] = cs'\"", "lemma silent_moves_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" \n  and \"valid_node m\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs as = cs'\"", "lemma observable_move_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) -a\\<rightarrow> (m'#ms',s')\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs [a] = cs'\"", "lemma observable_moves_preserves_stack:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow> (m'#ms',s')\" \n  and \"valid_node m\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs as = cs'\"", "lemma silent_moves_slpa_path:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms''@ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); valid_node m; valid_call_list cs m;\n  \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); valid_return_list rs m; \n  length rs = length cs; ms'' = targetnodes rs;\n  \\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n  ms'' \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n  \\<forall>mx \\<in> set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = [] \\<and> m -as\\<rightarrow>* m' \\<and> ms = ms'\"", "lemma silent_moves_slp:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); valid_node m; \n  \\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n  \\<forall>mx \\<in> set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and> ms = ms'\"", "lemma slpa_silent_moves_callstacks_eq:\n  \"\\<lbrakk>same_level_path_aux cs as; S,f \\<turnstile> (m#msx@ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s');\n  length ms = length ms'; valid_call_list cs m; \n  \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); valid_return_list rs m; \n  length rs = length cs; msx = targetnodes rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\"", "lemma silent_moves_same_level_path:\n  assumes \"S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\" shows \"ms = ms'\"", "lemma silent_moves_call_edge:\n  assumes \"S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and callstack:\"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and rest:\"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  \"ms = targetnodes rs\" \"valid_return_list rs m\" \"length rs = length cs\"\n  obtains as' a as'' where \"as = as'@a#as''\" and \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"call_of_return_node (hd ms') (sourcenode a)\"\n  and \"targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\"\n  | \"ms' = ms\"", "lemma silent_moves_called_node_in_slice1_hd_nodestack_in_slice1:\n  assumes \"S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and \"CFG_node m' \\<in> sum_SDG_slice1 nx\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"ms = targetnodes rs\"\n  and \"valid_return_list rs m\" and \"length rs = length cs\"\n  obtains as' a as'' where \"as = as'@a#as''\" and \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"call_of_return_node (hd ms') (sourcenode a)\"\n  and \"targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\" and \"CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\"\n  | \"ms' = ms\"", "lemma silent_moves_called_node_in_slice1_nodestack_in_slice1:\n  \"\\<lbrakk>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); valid_node m; \n   CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n   \\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); ms = targetnodes rs;\n   valid_return_list rs m; length rs = length cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>mx \\<in> set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"", "lemma silent_moves_slice_intra_path:\n  assumes \"S,slice_kind S \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"\\<forall>a \\<in> set as. intra_kind (kind a)\"", "lemma silent_moves_slice_keeps_state:\n  assumes \"S,slice_kind S \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"s = s'\"", "lemma silent_move_no_slice_edge:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> \\<not> slice_edge S cs a\"", "lemma observable_move_slice_edge:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> slice_edge S cs a\"", "lemma slice_edges_Append:\n  \"\\<lbrakk>slice_edges S cs as = as'; slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n  \\<Longrightarrow> slice_edges S cs (as@asx) = as'@asx'\"", "lemma slice_edges_Nil_split:\n  \"slice_edges S cs (as@as') = []\n  \\<Longrightarrow> slice_edges S cs as = [] \\<and> slice_edges S (upd_cs cs as) as' = []\"", "lemma slice_intra_edges_no_nodes_in_slice:\n  \"\\<lbrakk>slice_edges S cs as = []; \\<forall>a \\<in> set as. intra_kind (kind a);\n    \\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"", "lemma silent_moves_no_slice_edges:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S cs as = [] \\<and> (\\<exists>rs'. tl ms' = targetnodes rs' \\<and>\n  length rs' = length (upd_cs cs as) \\<and> (\\<forall>i<length (upd_cs cs as). \n  call_of_return_node (tl ms'!i) (sourcenode ((upd_cs cs as)!i))))\"", "lemma observable_moves_singular_slice_edge:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S cs as = [last as]\"", "lemma silent_moves_nonempty_nodestack_False:\n  assumes \"S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and \"ms' \\<noteq> []\" and \"CFG_node m' \\<in> sum_SDG_slice1 nx\" and \"nx \\<in> S\"\n  shows False", "lemma transfers_intra_slice_kinds_slice_edges:\n  \"\\<lbrakk>\\<forall>a \\<in> set as. intra_kind (kind a); \\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> transfers (slice_kinds S (slice_edges S cs as)) s =\n  transfers (slice_kinds S as) s\"", "lemma exists_sliced_intra_path_preds:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"slice_edges S cs as = []\" \n  and \"m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  obtains as' where \"m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"preds (slice_kinds S as') (cf#cfs)\"\n  and \"slice_edges S cs as' = []\"", "lemma slp_to_intra_path_with_slice_edges:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" and \"slice_edges S cs as = []\"\n  obtains as' where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"slice_edges S cs as' = []\"", "lemma tom_split_snoc:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>* (ms',s')\" and \"as \\<noteq> []\"\n  obtains asx asx' ms'' s'' where \"as = asx@[last asx']\" \n  and \"S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'')\" and \"S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms',s')\"", "lemma tom_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>* (m'#ms',s')\" and \"valid_node m\" \n  and \"valid_call_list cs m\" and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" \n  and \"valid_return_list rs m\" and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\"", "lemma vpa_trans_observable_moves:\n  assumes \"valid_path_aux cs as\" and \"m -as\\<rightarrow>* m'\" and \"preds (kinds as) s\" \n  and \"transfers (kinds as) s = s'\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  and \"valid_return_list rs m\" \n  and \"length rs = length cs\" and \"length s = Suc (length cs)\" \n  obtains ms ms'' s'' ms' as' as''\n  where \"S,kind \\<turnstile> (m#ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'')\"\n  and \"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" \n  and \"ms = targetnodes rs\" and \"length ms = length cs\"\n  and \"\\<forall>i<length cs. call_of_return_node (ms!i) (sourcenode (cs!i))\"\n  and \"slice_edges S cs as = slice_edges S cs as''\" \n  and \"m -as''@as'\\<rightarrow>* m'\" and \"valid_path_aux cs (as''@as')\"", "lemma valid_path_trans_observable_moves:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\" and \"preds (kinds as) [cf]\" \n  and \"transfers (kinds as) [cf] = s'\"\n  obtains ms'' s'' ms' as' as'' \n  where \"S,kind \\<turnstile> ([m],[cf]) =slice_edges S [] as\\<Rightarrow>* (ms'',s'')\"\n  and \"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\"\n  and \"slice_edges S [] as = slice_edges S [] as''\"\n  and \"m -as''@as'\\<rightarrow>\\<^sub>\\<surd>* m'\"", "lemma WS_weak_sim_trans:\n  assumes \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  and \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\" and \"as \\<noteq> []\"\n  shows \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)) \\<in> WS S \\<and> \n         S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)\"", "lemma stacks_rewrite:\n  assumes \"valid_call_list cs m\" and \"valid_return_list rs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  shows \"\\<forall>i<length cs. call_of_return_node (ms!i) (sourcenode (cs!i))\"", "lemma slice_tom_preds_vp:\n  assumes \"S,slice_kind S \\<turnstile> (m#ms,s) =as\\<Rightarrow>* (m'#ms',s')\" and \"valid_node m\"\n  and \"valid_call_list cs m\" and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  and \"valid_return_list rs m\" and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  obtains as' cs' rs' where \"preds (slice_kinds S as') s\" \n  and \"slice_edges S cs as' = as\" and \"m -as'\\<rightarrow>* m'\" and \"valid_path_aux cs as'\" \n  and \"upd_cs cs as' = cs'\" and \"valid_node m'\" and \"valid_call_list cs' m'\" \n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"transfers (slice_kinds S as') s \\<noteq> []\"\n  and \"transfers (slice_kinds S (slice_edges S cs as')) s =\n    transfers (slice_kinds S as') s\"", "theorem fundamental_property_of_static_slicing:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\" and \"preds (kinds as) [cf]\" and \"CFG_node m' \\<in> S\"\n  obtains as' where \"preds (slice_kinds S as') [cf]\"\n  and \"\\<forall>V \\<in> Use m'. state_val (transfers (slice_kinds S as') [cf]) V = \n                    state_val (transfers (kinds as) [cf]) V\"\n  and \"slice_edges S [] as = slice_edges S [] as'\"\n  and \"transfers (kinds as) [cf] \\<noteq> []\" and \"m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\"", "theorem fundamental_property_of_path_slicing_semantically:\n  assumes \"m \\<triangleq> c\" and \"\\<langle>c,[cf]\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\"\n  obtains m' as cfs' where \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\" and \"m' \\<triangleq> c'\"\n  and \"preds (slice_kinds {CFG_node m'} as) [(cf,undefined)]\"\n  and \"\\<forall>V \\<in> Use m'. \n  state_val (transfers (slice_kinds {CFG_node m'} as) [(cf,undefined)]) V = \n  state_val cfs' V\" and \"map fst cfs' = s'\""], "translations": [["", "lemma observable_set_stack_in_slice:\n  \"S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s') \n  \\<Longrightarrow> \\<forall>mx \\<in> set (tl ms'). \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s') \\<Longrightarrow>\n    \\<forall>mx\\<in>set (tl ms').\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(induct rule:observable_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (observable_move_intra f a s s' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "thus ?case"], ["proof (prove)\nusing this:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set (tl ms').\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set (tl ms').\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (observable_move_call f a s s' Q r p fs a' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  a' \\<in> get_return_edges a", "have \"call_of_return_node (targetnode a') (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode a)", "by(fastforce simp:return_node_def call_of_return_node_def)"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>hd ms = sourcenode a\\<close> \\<open>hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n    \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>\n    \\<open>\\<forall>mx\\<in>set (tl ms). \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # tl ms\n  \\<forall>mx\\<in>set (tl ms).\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  call_of_return_node (targetnode a') (sourcenode a)", "show ?case"], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # tl ms\n  \\<forall>mx\\<in>set (tl ms).\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set (tl ms').\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set (tl ms').\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (observable_move_return f a s s' Q p f' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (tl ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "thus ?case"], ["proof (prove)\nusing this:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set (tl ms').\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases \"tl ms\") auto"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set (tl ms').\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_move_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs [a] = cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs' rs'.\n        \\<lbrakk>valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'; upd_cs cs [a] = cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from assms"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs", "show \"\\<exists>cs' rs'. valid_node m' \\<and> valid_call_list cs' m' \\<and>\n    (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n    valid_return_list rs' m' \\<and> length rs' = length cs' \\<and> ms' = targetnodes rs' \\<and>\n    upd_cs cs [a] = cs'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "proof(induct S f \"m#ms\" s a \"m'#ms'\" s' rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "case (silent_move_intra f a s s' n\\<^sub>c)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl (m # ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms)\n  \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms))) return_node\n  length s' = length s\n  length (m # ms) = length s\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # tl (m # ms)\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>hd (m # ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms) = sourcenode a", "have \"m = sourcenode a\""], ["proof (prove)\nusing this:\n  hd (m # ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m = sourcenode a", "by simp"], ["proof (state)\nthis:\n  m = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>m' # ms' = targetnode a # tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  m' # ms' = targetnode a # tl (m # ms)", "have [simp]:\"m' = targetnode a\" \"ms' = ms\""], ["proof (prove)\nusing this:\n  m' # ms' = targetnode a # tl (m # ms)\n\ngoal (1 subgoal):\n 1. m' = targetnode a &&& ms' = ms", "by simp_all"], ["proof (state)\nthis:\n  m' = targetnode a\n  ms' = ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node m'", "by simp"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_call_list cs m\\<close> \\<open>m = sourcenode a\\<close>\n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs m'\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs m'", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_call_list cs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_return_list rs m\\<close> \\<open>m = sourcenode a\\<close> \n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list rs m'\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list rs m'", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> sourcenode a\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_return_list rs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_return_list rs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"upd_cs cs [a] = cs\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = cs", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs [a] = cs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "ultimately"], ["proof (chain)\npicking this:\n  valid_node m'\n  valid_call_list cs m'\n  valid_return_list rs m'\n  upd_cs cs [a] = cs", "show ?case"], ["proof (prove)\nusing this:\n  valid_node m'\n  valid_call_list cs m'\n  valid_return_list rs m'\n  upd_cs cs [a] = cs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "using \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n      \\<open>length rs = length cs\\<close> \\<open>ms = targetnodes rs\\<close>"], ["proof (prove)\nusing this:\n  valid_node m'\n  valid_call_list cs m'\n  valid_return_list rs m'\n  upd_cs cs [a] = cs\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list cs m'; valid_return_list rs m';\n     upd_cs cs [a] = cs;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs; ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs", "apply(rule_tac x=\"rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list cs m'; valid_return_list rs m';\n     upd_cs cs [a] = cs;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs; ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs m' \\<and>\n                      (\\<forall>i<length rs.\n                          rs ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                      valid_return_list rs m' \\<and>\n                      length rs = length cs \\<and>\n                      ms' = targetnodes rs \\<and> upd_cs cs [a] = cs", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "case (silent_move_call f a s s' Q r p fs a' S)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl (m # ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms))) return_node\n  length (m # ms) = length s\n  length s' = Suc (length s)\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # targetnode a' # tl (m # ms)\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>hd (m # ms) = sourcenode a\\<close> \n      \\<open>m' # ms' = targetnode a # targetnode a' # tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # targetnode a' # tl (m # ms)", "have [simp]:\"m = sourcenode a\" \"m' = targetnode a\" \n      \"ms' = targetnode a' # tl (m # ms)\""], ["proof (prove)\nusing this:\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # targetnode a' # tl (m # ms)\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&&\n    m' = targetnode a &&& ms' = targetnode a' # tl (m # ms)", "by simp_all"], ["proof (state)\nthis:\n  m = sourcenode a\n  m' = targetnode a\n  ms' = targetnode a' # tl (m # ms)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node m'", "by simp"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_call_list cs m\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p", "have \"valid_call_list (a # cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs'';\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "by(case_tac list)(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a", "have \"\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a' # rs).\n       (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_return_list rs m\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n      \\<open>get_proc (sourcenode a') = p\\<close> \\<open>get_proc (targetnode a) = p\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')", "have \"valid_return_list (a'#rs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_return_list (a' # rs) (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> sourcenode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "by(case_tac list)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs", "have \"length (a'#rs) = length (a#cs)\""], ["proof (prove)\nusing this:\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. length (a' # rs) = length (a # cs)", "by simp"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes rs", "have \"targetnode a' # ms = targetnodes (a' # rs)\""], ["proof (prove)\nusing this:\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. targetnode a' # ms = targetnodes (a' # rs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  targetnode a' # ms = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  targetnode a' # ms = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"upd_cs cs [a] = a#cs\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = a # cs", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [a] = a # cs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "ultimately"], ["proof (chain)\npicking this:\n  valid_node m'\n  valid_call_list (a # cs) (targetnode a)\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n  valid_return_list (a' # rs) (targetnode a)\n  length (a' # rs) = length (a # cs)\n  targetnode a' # ms = targetnodes (a' # rs)\n  upd_cs cs [a] = a # cs", "show ?case"], ["proof (prove)\nusing this:\n  valid_node m'\n  valid_call_list (a # cs) (targetnode a)\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n  valid_return_list (a' # rs) (targetnode a)\n  length (a' # rs) = length (a # cs)\n  targetnode a' # ms = targetnodes (a' # rs)\n  upd_cs cs [a] = a # cs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"a#cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list (a # cs) (targetnode a);\n     \\<forall>i<length (a' # rs).\n        (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i);\n     valid_return_list (a' # rs) (targetnode a);\n     length (a' # rs) = length (a # cs);\n     targetnode a' # ms = targetnodes (a' # rs);\n     upd_cs cs [a] = a # cs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list (a # cs) m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges ((a # cs) ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length (a # cs) \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs [a] = a # cs", "apply(rule_tac x=\"a'#rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list (a # cs) (targetnode a);\n     \\<forall>i<length (a' # rs).\n        (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i);\n     valid_return_list (a' # rs) (targetnode a);\n     length (a' # rs) = length (a # cs);\n     targetnode a' # ms = targetnodes (a' # rs);\n     upd_cs cs [a] = a # cs\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list (a # cs) m' \\<and>\n                      (\\<forall>i<length (a' # rs).\n                          (a' # rs) ! i\n                          \\<in> get_return_edges ((a # cs) ! i)) \\<and>\n                      valid_return_list (a' # rs) m' \\<and>\n                      length (a' # rs) = length (a # cs) \\<and>\n                      ms' = targetnodes (a' # rs) \\<and>\n                      upd_cs cs [a] = a # cs", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "case (silent_move_return f a s s' Q p f' S)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl (m # ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms))) return_node\n  length (m # ms) = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  m' # ms' = tl (m # ms)\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>hd (m # ms) = sourcenode a\\<close>\n      \\<open>hd (tl (m # ms)) = targetnode a\\<close> \\<open>m' # ms' = tl (m # ms)\\<close> [symmetric]"], ["proof (chain)\npicking this:\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  tl (m # ms) = m' # ms'", "have [simp]:\"m = sourcenode a\" \"m' = targetnode a\""], ["proof (prove)\nusing this:\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  tl (m # ms) = m' # ms'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& m' = targetnode a", "by simp_all"], ["proof (state)\nthis:\n  m = sourcenode a\n  m' = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>length (m # ms) = length s\\<close> \\<open>length s = Suc (length s')\\<close> \\<open>s' \\<noteq> []\\<close>\n      \\<open>hd (tl (m # ms)) = targetnode a\\<close> \\<open>m' # ms' = tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  length (m # ms) = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd (tl (m # ms)) = targetnode a\n  m' # ms' = tl (m # ms)", "have \"ms = targetnode a # ms'\""], ["proof (prove)\nusing this:\n  length (m # ms) = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd (tl (m # ms)) = targetnode a\n  m' # ms' = tl (m # ms)\n\ngoal (1 subgoal):\n 1. ms = targetnode a # ms'", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = targetnode a # ms'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes rs\n  ms = targetnode a # ms'", "obtain r' rs' where \"rs = r' # rs'\" \n      and \"targetnode a = targetnode r'\" and \"ms' = targetnodes rs'\""], ["proof (prove)\nusing this:\n  ms = targetnodes rs\n  ms = targetnode a # ms'\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; targetnode a = targetnode r';\n         ms' = targetnodes rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rs)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>rs = r' # rs'\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  rs = r' # rs'\n  length rs = length cs", "obtain c' cs' where \"cs = c' # cs'\"\n      and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  rs = r' # rs'\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. (\\<And>c' cs'.\n        \\<lbrakk>cs = c' # cs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cs) auto"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n      \\<open>rs = r' # rs'\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n      and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'", "obtain p' Q' r fs' where \"valid_edge c'\" and \"kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\" \n      and \"p' = get_proc m\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>Q' r p' fs'.\n        \\<lbrakk>valid_edge c';\n         kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         p' = get_proc m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q' r p' fs'.\n                \\<lbrakk>valid_edge c';\n                 kind c' =\n                 Q':r\\<hookrightarrow>\\<^bsub>get_proc\n         (sourcenode a)\\<^esub>fs';\n                 p' = get_proc (sourcenode a)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs'a c.\n        (\\<exists>cs''. c' # cs' = cs'a @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs'a of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n     cs = c' # cs'\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule_tac x=\"[]\" in allE) auto"], ["proof (state)\nthis:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  p' = get_proc m\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>p' = get_proc m\\<close>"], ["proof (chain)\npicking this:\n  p' = get_proc m\n  get_proc (sourcenode a) = p", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  p' = get_proc m\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'", "have \"get_proc (targetnode c') = p\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode c') = p", "by(fastforce intro:get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode c') = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'", "have \"valid_edge r'\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. valid_edge r'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  r' \\<in> get_return_edges c'", "obtain Q'' f'' where \"kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. (\\<And>Q'' f''.\n        kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_edge r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"get_proc (sourcenode r') = p\""], ["proof (prove)\nusing this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode r') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode r') = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge r'\\<close> \\<open>kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"method_exit (sourcenode r')\""], ["proof (prove)\nusing this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode r')", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode r')\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"method_exit (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>method_exit (sourcenode r')\\<close> \\<open>get_proc (sourcenode r') = p\\<close> \n      \\<open>get_proc (sourcenode a) = p\\<close>"], ["proof (chain)\npicking this:\n  method_exit (sourcenode r')\n  get_proc (sourcenode r') = p\n  get_proc (sourcenode a) = p\n  method_exit (sourcenode a)", "have \"sourcenode a = sourcenode r'\""], ["proof (prove)\nusing this:\n  method_exit (sourcenode r')\n  get_proc (sourcenode r') = p\n  get_proc (sourcenode a) = p\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a = sourcenode r'", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  sourcenode a = sourcenode r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_edge a\\<close> \\<open>valid_edge r'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge r'\n  targetnode a = targetnode r'\n  sourcenode a = sourcenode r'", "have \"a = r'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge r'\n  targetnode a = targetnode r'\n  sourcenode a = sourcenode r'\n\ngoal (1 subgoal):\n 1. a = r'", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a = r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  targetnode a = targetnode r'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  targetnode a = targetnode r'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(fastforce intro:get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>\n      \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"valid_call_list cs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode a);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs')(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_return_list rs m\\<close> \\<open>rs = r' # rs'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  rs = r' # rs'\n  targetnode a = targetnode r'", "have \"valid_return_list rs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  rs = r' # rs'\n  targetnode a = targetnode r'\n\ngoal (1 subgoal):\n 1. valid_return_list rs' (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       r' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        rs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"r' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        rs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               r' # cs' @ c # cs'' =\n               (r' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case r' # cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow>\n        last (targetnodes (r' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'", "have \"upd_cs cs [a] = cs'\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        m' # ms' = tl (m # ms); valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "ultimately"], ["proof (chain)\npicking this:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n  cs = c' # cs'\n  length rs' = length cs'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n  valid_node (targetnode a)\n  valid_call_list cs' (targetnode a)\n  valid_return_list rs' (targetnode a)\n  upd_cs cs [a] = cs'", "show ?case"], ["proof (prove)\nusing this:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n  cs = c' # cs'\n  length rs' = length cs'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n  valid_node (targetnode a)\n  valid_call_list cs' (targetnode a)\n  valid_return_list rs' (targetnode a)\n  upd_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"cs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = r' # rs'; targetnode a = targetnode r';\n     ms' = targetnodes rs'; cs = c' # cs'; length rs' = length cs';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     r' \\<in> get_return_edges c'; valid_node (targetnode a);\n     valid_call_list cs' (targetnode a);\n     valid_return_list rs' (targetnode a); upd_cs cs [a] = cs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs' m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges (cs' ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs' \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"rs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = r' # rs'; targetnode a = targetnode r';\n     ms' = targetnodes rs'; cs = c' # cs'; length rs' = length cs';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     r' \\<in> get_return_edges c'; valid_node (targetnode a);\n     valid_call_list cs' (targetnode a);\n     valid_return_list rs' (targetnode a); upd_cs cs [a] = cs'\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs' m' \\<and>\n                      (\\<forall>i<length rs'.\n                          rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                      valid_return_list rs' m' \\<and>\n                      length rs' = length cs' \\<and>\n                      ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" \n  and \"valid_node m\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs as = cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs' rs'.\n        \\<lbrakk>valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'; upd_cs cs as = cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "from assms"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs", "show \"\\<exists>cs' rs'. valid_node m' \\<and> valid_call_list cs' m' \\<and>\n    (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n    valid_return_list rs' m' \\<and> length rs' = length cs' \\<and> ms' = targetnodes rs' \\<and>\n    upd_cs cs as = cs'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "proof(induct S f \"m#ms\" s as \"m'#ms'\" s' \n      arbitrary:m ms cs rs rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s S f cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [] = cs'\n 2. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "case (silent_moves_Nil s n\\<^sub>c f)"], ["proof (state)\nthis:\n  length (m' # ms') = length s\n  valid_node m'\n  valid_call_list cs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m'\n  length rs = length cs\n  ms' = targetnodes rs\n\ngoal (2 subgoals):\n 1. \\<And>s S f cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [] = cs'\n 2. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "thus ?case"], ["proof (prove)\nusing this:\n  length (m' # ms') = length s\n  valid_node m'\n  valid_call_list cs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m'\n  length rs = length cs\n  ms' = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [] = cs'", "apply(rule_tac x=\"cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (m' # ms') = length s; valid_node m';\n     valid_call_list cs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     valid_return_list rs m'; length rs = length cs;\n     ms' = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs [] = cs", "apply(rule_tac x=\"rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (m' # ms') = length s; valid_node m';\n     valid_call_list cs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     valid_return_list rs m'; length rs = length cs;\n     ms' = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs m' \\<and>\n                      (\\<forall>i<length rs.\n                          rs ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                      valid_return_list rs m' \\<and>\n                      length rs = length cs \\<and>\n                      ms' = targetnodes rs \\<and> upd_cs cs [] = cs", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [] = cs'\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "case (silent_moves_Cons S f s a msx'' s'' as sx')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx'',s'')\n  S,f \\<turnstile> (msx'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',sx')\n  \\<lbrakk>msx'' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' rs'.\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and>\n                       ms' = targetnodes rs' \\<and> upd_cs ?cs as = cs'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "note IH = \\<open>\\<And>m ms cs rs. \\<lbrakk>msx'' = m # ms; valid_node m; valid_call_list cs m;\n      \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n      valid_return_list rs m; length rs = length cs; ms = targetnodes rs\\<rbrakk>\n      \\<Longrightarrow> \\<exists>cs' rs'. valid_node m' \\<and> valid_call_list cs' m' \\<and>\n      (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n      valid_return_list rs' m' \\<and> length rs' = length cs' \\<and> ms' = targetnodes rs' \\<and>\n      upd_cs cs as = cs'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx'' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' rs'.\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and>\n                       ms' = targetnodes rs' \\<and> upd_cs ?cs as = cs'\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "from \\<open>S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx'',s'')", "obtain m'' ms'' where \"msx'' = m''#ms''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx'',s'')\n\ngoal (1 subgoal):\n 1. (\\<And>m'' ms''.\n        msx'' = m'' # ms'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases msx'')(auto elim:silent_move.cases)"], ["proof (state)\nthis:\n  msx'' = m'' # ms''\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "with \\<open>S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx'',s'')\\<close> \\<open>valid_call_list cs m\\<close>\n      \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>valid_return_list rs m\\<close>\n      \\<open>length rs = length cs\\<close> \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx'',s'')\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  msx'' = m'' # ms''", "obtain cs'' rs'' where hyps:\"valid_node m''\" \"valid_call_list cs'' m''\"\n      \"\\<forall>i < length rs''. rs''!i \\<in> get_return_edges (cs''!i)\"\n      \"valid_return_list rs'' m''\" \"length rs'' = length cs''\" \n      \"ms'' = targetnodes rs''\" and \"upd_cs cs [a] = cs''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx'',s'')\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  msx'' = m'' # ms''\n\ngoal (1 subgoal):\n 1. (\\<And>cs'' rs''.\n        \\<lbrakk>valid_node m''; valid_call_list cs'' m'';\n         \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i);\n         valid_return_list rs'' m''; length rs'' = length cs'';\n         ms'' = targetnodes rs''; upd_cs cs [a] = cs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:silent_move_preserves_stacks)"], ["proof (state)\nthis:\n  valid_node m''\n  valid_call_list cs'' m''\n  \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i)\n  valid_return_list rs'' m''\n  length rs'' = length cs''\n  ms'' = targetnodes rs''\n  upd_cs cs [a] = cs''\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "from IH[OF _ hyps] \\<open>msx'' = m'' # ms''\\<close>"], ["proof (chain)\npicking this:\n  msx'' = m'' # ms'' \\<Longrightarrow>\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs'' as = cs'\n  msx'' = m'' # ms''", "obtain cs' rs' where results:\"valid_node m'\" \"valid_call_list cs' m'\"\n      \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n      \"valid_return_list rs' m'\" \"length rs' = length cs'\" \"ms' = targetnodes rs'\"\n      and \"upd_cs cs'' as = cs'\""], ["proof (prove)\nusing this:\n  msx'' = m'' # ms'' \\<Longrightarrow>\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs'' as = cs'\n  msx'' = m'' # ms''\n\ngoal (1 subgoal):\n 1. (\\<And>cs' rs'.\n        \\<lbrakk>valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'; upd_cs cs'' as = cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n  upd_cs cs'' as = cs'\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "from \\<open>upd_cs cs [a] = cs''\\<close> \\<open>upd_cs cs'' as = cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs [a] = cs''\n  upd_cs cs'' as = cs'", "have \"upd_cs cs ([a] @ as) = cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs [a] = cs''\n  upd_cs cs'' as = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs ([a] @ as) = cs'", "by(rule upd_cs_Append)"], ["proof (state)\nthis:\n  upd_cs cs ([a] @ as) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                upd_cs cs as = cs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            upd_cs cs (a # as) = cs'", "with results"], ["proof (chain)\npicking this:\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n  upd_cs cs ([a] @ as) = cs'", "show ?case"], ["proof (prove)\nusing this:\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n  upd_cs cs ([a] @ as) = cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs (a # as) = cs'", "apply(rule_tac x=\"cs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list cs' m';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     valid_return_list rs' m'; length rs' = length cs';\n     ms' = targetnodes rs'; upd_cs cs ([a] @ as) = cs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs' m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges (cs' ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs' \\<and>\n                         ms' = targetnodes rs' \\<and>\n                         upd_cs cs (a # as) = cs'", "apply(rule_tac x=\"rs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list cs' m';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     valid_return_list rs' m'; length rs' = length cs';\n     ms' = targetnodes rs'; upd_cs cs ([a] @ as) = cs'\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs' m' \\<and>\n                      (\\<forall>i<length rs'.\n                          rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                      valid_return_list rs' m' \\<and>\n                      length rs' = length cs' \\<and>\n                      ms' = targetnodes rs' \\<and> upd_cs cs (a # as) = cs'", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs (a # as) = cs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs as = cs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_move_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) -a\\<rightarrow> (m'#ms',s')\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs [a] = cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs' rs'.\n        \\<lbrakk>valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'; upd_cs cs [a] = cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from assms"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow> (m' # ms',s')\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs", "show \"\\<exists>cs' rs'. valid_node m' \\<and> valid_call_list cs' m' \\<and>\n    (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n    valid_return_list rs' m' \\<and> length rs' = length cs' \\<and> ms' = targetnodes rs' \\<and>\n    upd_cs cs [a] = cs'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) -a\\<rightarrow> (m' # ms',s')\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "proof(induct S f \"m#ms\" s a \"m'#ms'\" s' rule:observable_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "case (observable_move_intra f a s s' n\\<^sub>c)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl (m # ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd (m # ms) \\<in> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s' = length s\n  length (m # ms) = length s\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # tl (m # ms)\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>hd (m # ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms) = sourcenode a", "have \"m = sourcenode a\""], ["proof (prove)\nusing this:\n  hd (m # ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m = sourcenode a", "by simp"], ["proof (state)\nthis:\n  m = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>m' # ms' = targetnode a # tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  m' # ms' = targetnode a # tl (m # ms)", "have [simp]:\"m' = targetnode a\" \"ms' = ms\""], ["proof (prove)\nusing this:\n  m' # ms' = targetnode a # tl (m # ms)\n\ngoal (1 subgoal):\n 1. m' = targetnode a &&& ms' = ms", "by simp_all"], ["proof (state)\nthis:\n  m' = targetnode a\n  ms' = ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node m'", "by simp"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_call_list cs m\\<close> \\<open>m = sourcenode a\\<close>\n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs m'\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs m'", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_call_list cs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_return_list rs m\\<close> \\<open>m = sourcenode a\\<close> \n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list rs m'\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list rs m'", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> sourcenode a\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_return_list rs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_return_list rs m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"upd_cs cs [a] = cs\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = cs", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs [a] = cs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "ultimately"], ["proof (chain)\npicking this:\n  valid_node m'\n  valid_call_list cs m'\n  valid_return_list rs m'\n  upd_cs cs [a] = cs", "show ?case"], ["proof (prove)\nusing this:\n  valid_node m'\n  valid_call_list cs m'\n  valid_return_list rs m'\n  upd_cs cs [a] = cs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "using \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n      \\<open>length rs = length cs\\<close> \\<open>ms = targetnodes rs\\<close>"], ["proof (prove)\nusing this:\n  valid_node m'\n  valid_call_list cs m'\n  valid_return_list rs m'\n  upd_cs cs [a] = cs\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list cs m'; valid_return_list rs m';\n     upd_cs cs [a] = cs;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs; ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs", "apply(rule_tac x=\"rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list cs m'; valid_return_list rs m';\n     upd_cs cs [a] = cs;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs; ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs m' \\<and>\n                      (\\<forall>i<length rs.\n                          rs ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                      valid_return_list rs m' \\<and>\n                      length rs = length cs \\<and>\n                      ms' = targetnodes rs \\<and> upd_cs cs [a] = cs", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "case (observable_move_call f a s s' Q r p fs a' S)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  \\<forall>m\\<in>set (tl (m # ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length (m # ms) = length s\n  length s' = Suc (length s)\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # targetnode a' # tl (m # ms)\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>hd (m # ms) = sourcenode a\\<close> \n      \\<open>m' # ms' = targetnode a # targetnode a' # tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # targetnode a' # tl (m # ms)", "have [simp]:\"m = sourcenode a\" \"m' = targetnode a\" \n      \"ms' = targetnode a' # tl (m # ms)\""], ["proof (prove)\nusing this:\n  hd (m # ms) = sourcenode a\n  m' # ms' = targetnode a # targetnode a' # tl (m # ms)\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&&\n    m' = targetnode a &&& ms' = targetnode a' # tl (m # ms)", "by simp_all"], ["proof (state)\nthis:\n  m = sourcenode a\n  m' = targetnode a\n  ms' = targetnode a' # tl (m # ms)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node m'", "by simp"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_node m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_call_list cs m\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p", "have \"valid_call_list (a # cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs'';\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "by(case_tac list)(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a", "have \"\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a' # rs).\n       (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_return_list rs m\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n      \\<open>get_proc (sourcenode a') = p\\<close> \\<open>get_proc (targetnode a) = p\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')", "have \"valid_return_list (a'#rs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_return_list (a' # rs) (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> sourcenode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "by(case_tac list)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs", "have \"length (a'#rs) = length (a#cs)\""], ["proof (prove)\nusing this:\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. length (a' # rs) = length (a # cs)", "by simp"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes rs", "have \"targetnode a' # ms = targetnodes (a' # rs)\""], ["proof (prove)\nusing this:\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. targetnode a' # ms = targetnodes (a' # rs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  targetnode a' # ms = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  targetnode a' # ms = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"upd_cs cs [a] = a#cs\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = a # cs", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [a] = a # cs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n 2. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "ultimately"], ["proof (chain)\npicking this:\n  valid_node m'\n  valid_call_list (a # cs) (targetnode a)\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n  valid_return_list (a' # rs) (targetnode a)\n  length (a' # rs) = length (a # cs)\n  targetnode a' # ms = targetnodes (a' # rs)\n  upd_cs cs [a] = a # cs", "show ?case"], ["proof (prove)\nusing this:\n  valid_node m'\n  valid_call_list (a # cs) (targetnode a)\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n  valid_return_list (a' # rs) (targetnode a)\n  length (a' # rs) = length (a # cs)\n  targetnode a' # ms = targetnodes (a' # rs)\n  upd_cs cs [a] = a # cs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"a#cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list (a # cs) (targetnode a);\n     \\<forall>i<length (a' # rs).\n        (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i);\n     valid_return_list (a' # rs) (targetnode a);\n     length (a' # rs) = length (a # cs);\n     targetnode a' # ms = targetnodes (a' # rs);\n     upd_cs cs [a] = a # cs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list (a # cs) m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges ((a # cs) ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length (a # cs) \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs [a] = a # cs", "apply(rule_tac x=\"a'#rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m'; valid_call_list (a # cs) (targetnode a);\n     \\<forall>i<length (a' # rs).\n        (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i);\n     valid_return_list (a' # rs) (targetnode a);\n     length (a' # rs) = length (a # cs);\n     targetnode a' # ms = targetnodes (a' # rs);\n     upd_cs cs [a] = a # cs\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list (a # cs) m' \\<and>\n                      (\\<forall>i<length (a' # rs).\n                          (a' # rs) ! i\n                          \\<in> get_return_edges ((a # cs) ! i)) \\<and>\n                      valid_return_list (a' # rs) m' \\<and>\n                      length (a' # rs) = length (a # cs) \\<and>\n                      ms' = targetnodes (a' # rs) \\<and>\n                      upd_cs cs [a] = a # cs", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "case (observable_move_return f a s s' Q p f' S)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl (m # ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length (m # ms) = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  m' # ms' = tl (m # ms)\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>hd (m # ms) = sourcenode a\\<close>\n      \\<open>hd (tl (m # ms)) = targetnode a\\<close> \\<open>m' # ms' = tl (m # ms)\\<close> [symmetric]"], ["proof (chain)\npicking this:\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  tl (m # ms) = m' # ms'", "have [simp]:\"m = sourcenode a\" \"m' = targetnode a\""], ["proof (prove)\nusing this:\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  tl (m # ms) = m' # ms'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& m' = targetnode a", "by simp_all"], ["proof (state)\nthis:\n  m = sourcenode a\n  m' = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>length (m # ms) = length s\\<close> \\<open>length s = Suc (length s')\\<close> \\<open>s' \\<noteq> []\\<close>\n      \\<open>hd (tl (m # ms)) = targetnode a\\<close> \\<open>m' # ms' = tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  length (m # ms) = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd (tl (m # ms)) = targetnode a\n  m' # ms' = tl (m # ms)", "have \"ms = targetnode a # ms'\""], ["proof (prove)\nusing this:\n  length (m # ms) = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd (tl (m # ms)) = targetnode a\n  m' # ms' = tl (m # ms)\n\ngoal (1 subgoal):\n 1. ms = targetnode a # ms'", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = targetnode a # ms'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes rs\n  ms = targetnode a # ms'", "obtain r' rs' where \"rs = r' # rs'\" \n      and \"targetnode a = targetnode r'\" and \"ms' = targetnodes rs'\""], ["proof (prove)\nusing this:\n  ms = targetnodes rs\n  ms = targetnode a # ms'\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; targetnode a = targetnode r';\n         ms' = targetnodes rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rs)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>rs = r' # rs'\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  rs = r' # rs'\n  length rs = length cs", "obtain c' cs' where \"cs = c' # cs'\"\n      and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  rs = r' # rs'\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. (\\<And>c' cs'.\n        \\<lbrakk>cs = c' # cs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cs) auto"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n      \\<open>rs = r' # rs'\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n      and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'", "obtain p' Q' r fs' where \"valid_edge c'\" and \"kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\" \n      and \"p' = get_proc m\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>Q' r p' fs'.\n        \\<lbrakk>valid_edge c';\n         kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         p' = get_proc m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q' r p' fs'.\n                \\<lbrakk>valid_edge c';\n                 kind c' =\n                 Q':r\\<hookrightarrow>\\<^bsub>get_proc\n         (sourcenode a)\\<^esub>fs';\n                 p' = get_proc (sourcenode a)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs'a c.\n        (\\<exists>cs''. c' # cs' = cs'a @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs'a of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n     cs = c' # cs'\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule_tac x=\"[]\" in allE) auto"], ["proof (state)\nthis:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  p' = get_proc m\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>p' = get_proc m\\<close>"], ["proof (chain)\npicking this:\n  p' = get_proc m\n  get_proc (sourcenode a) = p", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  p' = get_proc m\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'", "have \"get_proc (targetnode c') = p\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode c') = p", "by(fastforce intro:get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode c') = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'", "have \"valid_edge r'\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. valid_edge r'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  r' \\<in> get_return_edges c'", "obtain Q'' f'' where \"kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. (\\<And>Q'' f''.\n        kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_edge r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"get_proc (sourcenode r') = p\""], ["proof (prove)\nusing this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode r') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode r') = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge r'\\<close> \\<open>kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"method_exit (sourcenode r')\""], ["proof (prove)\nusing this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode r')", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode r')\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"method_exit (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>method_exit (sourcenode r')\\<close> \\<open>get_proc (sourcenode r') = p\\<close> \n      \\<open>get_proc (sourcenode a) = p\\<close>"], ["proof (chain)\npicking this:\n  method_exit (sourcenode r')\n  get_proc (sourcenode r') = p\n  get_proc (sourcenode a) = p\n  method_exit (sourcenode a)", "have \"sourcenode a = sourcenode r'\""], ["proof (prove)\nusing this:\n  method_exit (sourcenode r')\n  get_proc (sourcenode r') = p\n  get_proc (sourcenode a) = p\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a = sourcenode r'", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  sourcenode a = sourcenode r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "with \\<open>valid_edge a\\<close> \\<open>valid_edge r'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge r'\n  targetnode a = targetnode r'\n  sourcenode a = sourcenode r'", "have \"a = r'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge r'\n  targetnode a = targetnode r'\n  sourcenode a = sourcenode r'\n\ngoal (1 subgoal):\n 1. a = r'", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a = r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  targetnode a = targetnode r'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  targetnode a = targetnode r'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(fastforce intro:get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>\n      \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"valid_call_list cs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode a);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs')(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>valid_return_list rs m\\<close> \\<open>rs = r' # rs'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  rs = r' # rs'\n  targetnode a = targetnode r'", "have \"valid_return_list rs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  rs = r' # rs'\n  targetnode a = targetnode r'\n\ngoal (1 subgoal):\n 1. valid_return_list rs' (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       r' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        rs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"r' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        rs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               r' # cs' @ c # cs'' =\n               (r' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case r' # cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow>\n        last (targetnodes (r' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "moreover"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'", "have \"upd_cs cs [a] = cs'\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "ultimately"], ["proof (chain)\npicking this:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n  cs = c' # cs'\n  length rs' = length cs'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n  valid_node (targetnode a)\n  valid_call_list cs' (targetnode a)\n  valid_return_list rs' (targetnode a)\n  upd_cs cs [a] = cs'", "show ?case"], ["proof (prove)\nusing this:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  ms' = targetnodes rs'\n  cs = c' # cs'\n  length rs' = length cs'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n  valid_node (targetnode a)\n  valid_call_list cs' (targetnode a)\n  valid_return_list rs' (targetnode a)\n  upd_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"cs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = r' # rs'; targetnode a = targetnode r';\n     ms' = targetnodes rs'; cs = c' # cs'; length rs' = length cs';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     r' \\<in> get_return_edges c'; valid_node (targetnode a);\n     valid_call_list cs' (targetnode a);\n     valid_return_list rs' (targetnode a); upd_cs cs [a] = cs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs' m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges (cs' ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs' \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "apply(rule_tac x=\"rs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = r' # rs'; targetnode a = targetnode r';\n     ms' = targetnodes rs'; cs = c' # cs'; length rs' = length cs';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     r' \\<in> get_return_edges c'; valid_node (targetnode a);\n     valid_call_list cs' (targetnode a);\n     valid_return_list rs' (targetnode a); upd_cs cs [a] = cs'\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs' m' \\<and>\n                      (\\<forall>i<length rs'.\n                          rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                      valid_return_list rs' m' \\<and>\n                      length rs' = length cs' \\<and>\n                      ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs [a] = cs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_moves_preserves_stack:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow> (m'#ms',s')\" \n  and \"valid_node m\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"upd_cs cs as = cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs' rs'.\n        \\<lbrakk>valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'; upd_cs cs as = cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "from \\<open>S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (m' # ms',s')", "obtain msx s'' as' a'\n    where \"as = as'@[a']\" and \"S,f \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (msx,s'')\"\n    and \"S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>as' a' msx s''.\n        \\<lbrakk>as = as' @ [a'];\n         S,f \\<turnstile> (m #\n                           ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (msx,s'');\n         S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m' # ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  as = as' @ [a']\n  S,f \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (msx,s'')\n  S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "from \\<open>S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m' # ms',s')", "obtain m'' ms''\n    where [simp]:\"msx = m''#ms''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>m'' ms''.\n        msx = m'' # ms'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases msx)(auto elim:observable_move.cases)"], ["proof (state)\nthis:\n  msx = m'' # ms''\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "from \\<open>S,f \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (msx,s'')\\<close> \\<open>valid_node m\\<close> \\<open>valid_call_list cs m\\<close>\n    \\<open>\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\\<close> \\<open>valid_return_list rs m\\<close>\n    \\<open>length rs = length cs\\<close> \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (msx,s'')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs", "obtain cs'' rs'' where \"valid_node m''\" and \"valid_call_list cs'' m''\"\n    and \"\\<forall>i < length rs''. rs''!i \\<in> get_return_edges (cs''!i)\"\n    and \"valid_return_list rs'' m''\" and \"length rs'' = length cs''\" \n    and \"ms'' = targetnodes rs''\" and \"upd_cs cs as' = cs''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (msx,s'')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. (\\<And>cs'' rs''.\n        \\<lbrakk>valid_node m''; valid_call_list cs'' m'';\n         \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i);\n         valid_return_list rs'' m''; length rs'' = length cs'';\n         ms'' = targetnodes rs''; upd_cs cs as' = cs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:silent_moves_preserves_stacks)"], ["proof (state)\nthis:\n  valid_node m''\n  valid_call_list cs'' m''\n  \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i)\n  valid_return_list rs'' m''\n  length rs'' = length cs''\n  ms'' = targetnodes rs''\n  upd_cs cs as' = cs''\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "with \\<open>S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m' # ms',s')\n  valid_node m''\n  valid_call_list cs'' m''\n  \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i)\n  valid_return_list rs'' m''\n  length rs'' = length cs''\n  ms'' = targetnodes rs''\n  upd_cs cs as' = cs''", "obtain cs' rs' where results:\"valid_node m'\" \"valid_call_list cs' m'\"\n    \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n    \"valid_return_list rs' m'\" \"length rs' = length cs'\" \"ms' = targetnodes rs'\"\n    and \"upd_cs cs'' [a'] = cs'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (msx,s'') -a'\\<rightarrow> (m' # ms',s')\n  valid_node m''\n  valid_call_list cs'' m''\n  \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i)\n  valid_return_list rs'' m''\n  length rs'' = length cs''\n  ms'' = targetnodes rs''\n  upd_cs cs as' = cs''\n\ngoal (1 subgoal):\n 1. (\\<And>cs' rs'.\n        \\<lbrakk>valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'; upd_cs cs'' [a'] = cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:observable_move_preserves_stacks)"], ["proof (state)\nthis:\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n  upd_cs cs'' [a'] = cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "from \\<open>upd_cs cs as' = cs''\\<close> \\<open>upd_cs cs'' [a'] = cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs as' = cs''\n  upd_cs cs'' [a'] = cs'", "have \"upd_cs cs (as'@[a']) = cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs as' = cs''\n  upd_cs cs'' [a'] = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs (as' @ [a']) = cs'", "by(rule upd_cs_Append)"], ["proof (state)\nthis:\n  upd_cs cs (as' @ [a']) = cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "with \\<open>as = as'@[a']\\<close> results"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n  upd_cs cs (as' @ [a']) = cs'", "show \"\\<exists>cs' rs'. valid_node m' \\<and> valid_call_list cs' m' \\<and>\n    (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n    valid_return_list rs' m' \\<and> length rs' = length cs' \\<and> ms' = targetnodes rs' \\<and>\n    upd_cs cs as = cs'\""], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n  upd_cs cs (as' @ [a']) = cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "apply(rule_tac x=\"cs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as = as' @ [a']; valid_node m'; valid_call_list cs' m';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     valid_return_list rs' m'; length rs' = length cs';\n     ms' = targetnodes rs'; upd_cs cs (as' @ [a']) = cs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs' m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges (cs' ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs' \\<and>\n                         ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "apply(rule_tac x=\"rs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as = as' @ [a']; valid_node m'; valid_call_list cs' m';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     valid_return_list rs' m'; length rs' = length cs';\n     ms' = targetnodes rs'; upd_cs cs (as' @ [a']) = cs'\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs' m' \\<and>\n                      (\\<forall>i<length rs'.\n                          rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                      valid_return_list rs' m' \\<and>\n                      length rs' = length cs' \\<and>\n                      ms' = targetnodes rs' \\<and> upd_cs cs as = cs'", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and> upd_cs cs as = cs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_slpa_path:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms''@ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); valid_node m; valid_call_list cs m;\n  \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); valid_return_list rs m; \n  length rs = length cs; ms'' = targetnodes rs;\n  \\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n  ms'' \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n  \\<forall>mx \\<in> set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = [] \\<and> m -as\\<rightarrow>* m' \\<and> ms = ms'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (m #\n                               ms'' @\n                               ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     valid_node m; valid_call_list cs m;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     valid_return_list rs m; length rs = length cs; ms'' = targetnodes rs;\n     \\<forall>mx\\<in>set ms.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     ms'' \\<noteq> [] \\<longrightarrow>\n     (\\<exists>mx'.\n         call_of_return_node (last ms'') mx' \\<and>\n         mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n     \\<forall>mx\\<in>set ms'.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx'\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                      upd_cs cs as = [] \\<and>\n                      m -as\\<rightarrow>* m' \\<and> ms = ms'", "proof(induct S f \"m#ms''@ms\" s as \"m'#ms'\" s' arbitrary:m ms'' ms cs rs\n    rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s S f ms'' ms cs rs.\n       \\<lbrakk>length (m' # ms'' @ ms) = length s; ms'' @ ms = ms';\n        valid_node m'; valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs [] \\<and>\n                         upd_cs cs [] = [] \\<and>\n                         m' -[]\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>S f s a ms'a s' as s'' m ms'' ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms'' @\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "case (silent_moves_Nil sx S f)"], ["proof (state)\nthis:\n  length (m' # ms'' @ ms) = length sx\n  ms'' @ ms = ms'\n  valid_node m'\n  valid_call_list cs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m'\n  length rs = length cs\n  ms'' = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>s S f ms'' ms cs rs.\n       \\<lbrakk>length (m' # ms'' @ ms) = length s; ms'' @ ms = ms';\n        valid_node m'; valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs [] \\<and>\n                         upd_cs cs [] = [] \\<and>\n                         m' -[]\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>S f s a ms'a s' as s'' m ms'' ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms'' @\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "thus ?case"], ["proof (prove)\nusing this:\n  length (m' # ms'' @ ms) = length sx\n  ms'' @ ms = ms'\n  valid_node m'\n  valid_call_list cs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m'\n  length rs = length cs\n  ms'' = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs [] \\<and>\n    upd_cs cs [] = [] \\<and> m' -[]\\<rightarrow>* m' \\<and> ms = ms'", "apply(cases ms'' rule:rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length (m' # ms'' @ ms) = length sx; ms'' @ ms = ms';\n     valid_node m'; valid_call_list cs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     valid_return_list rs m'; length rs = length cs; ms'' = targetnodes rs;\n     \\<forall>mx\\<in>set ms.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     ms'' \\<noteq> [] \\<longrightarrow>\n     (\\<exists>mx'.\n         call_of_return_node (last ms'') mx' \\<and>\n         mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n     \\<forall>mx\\<in>set ms'.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     ms'' = []\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs [] \\<and>\n                      upd_cs cs [] = [] \\<and>\n                      m' -[]\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>ys y.\n       \\<lbrakk>length (m' # ms'' @ ms) = length sx; ms'' @ ms = ms';\n        valid_node m'; valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs [] \\<and>\n                         upd_cs cs [] = [] \\<and>\n                         m' -[]\\<rightarrow>* m' \\<and> ms = ms'", "apply(auto intro:empty_path simp:targetnodes_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y mx'.\n       \\<lbrakk>Suc (length cs + length ms) = length sx; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length cs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ys @ [y] = map targetnode rs;\n        \\<forall>mx\\<in>targetnode ` set rs \\<union> set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' = map targetnode rs; ms' = map targetnode rs @ ms;\n        call_of_return_node (last (map targetnode rs)) mx';\n        mx'\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> cs = []\n 2. \\<And>ys y mx'.\n       \\<lbrakk>Suc (length cs + length ms) = length sx; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length cs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ys @ [y] = map targetnode rs;\n        \\<forall>mx\\<in>targetnode ` set rs \\<union> set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' = map targetnode rs; ms' = map targetnode rs @ ms;\n        call_of_return_node (last (map targetnode rs)) mx';\n        mx'\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> rs = []", "by(cases rs rule:rev_cases,auto)+"], ["proof (state)\nthis:\n  same_level_path_aux cs [] \\<and>\n  upd_cs cs [] = [] \\<and> m' -[]\\<rightarrow>* m' \\<and> ms = ms'\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms'' ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms'' @\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms'' ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms'' @\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "case (silent_moves_Cons S f sx a msx' sx' as sx'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m #\n                    ms'' @ ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms'' = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms'' ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms'' @\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "thus ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m #\n                    ms'' @ ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms'' = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and>\n    upd_cs cs (a # as) = [] \\<and>\n    m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "proof(induct _ _ \"m#ms''@ms\" _ _ _ _ rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "case (silent_move_intra f a s s' S msx')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms'' @ ms)\n  \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms'' @ ms))) return_node\n  length s' = length s\n  length (m # ms'' @ ms) = length s\n  hd (m # ms'' @ ms) = sourcenode a\n  msx' = targetnode a # tl (m # ms'' @ ms)\n  S,f \\<turnstile> (msx',s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms'' = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note IH = \\<open>\\<And>m ms'' ms cs rs. \\<lbrakk>msx' = m # ms'' @ ms; valid_node m; \n      valid_call_list cs m; \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n      valid_return_list rs m; length rs = length cs; ms'' = targetnodes rs;\n      \\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n      ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n      \\<forall>mx\\<in>set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n      \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = [] \\<and> m -as\\<rightarrow>* m' \\<and> ms = ms'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack = \\<open>\\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack'' = \\<open>ms'' \\<noteq> [] \\<longrightarrow>\n      (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (state)\nthis:\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack' = \\<open>\\<forall>mx\\<in>set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>hd (m # ms'' @ ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms'' @ ms) = sourcenode a", "have \"m = sourcenode a\""], ["proof (prove)\nusing this:\n  hd (m # ms'' @ ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m = sourcenode a", "by simp"], ["proof (state)\nthis:\n  m = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_call_list cs m\\<close> \\<open>m = sourcenode a\\<close>\n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_return_list rs m\\<close> \\<open>m = sourcenode a\\<close> \n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list rs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list rs (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> sourcenode a\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_return_list rs (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>msx' = targetnode a # tl (m # ms'' @ ms)\\<close>"], ["proof (chain)\npicking this:\n  msx' = targetnode a # tl (m # ms'' @ ms)", "have \"msx' = targetnode a # ms'' @ ms\""], ["proof (prove)\nusing this:\n  msx' = targetnode a # tl (m # ms'' @ ms)\n\ngoal (1 subgoal):\n 1. msx' = targetnode a # ms'' @ ms", "by simp"], ["proof (state)\nthis:\n  msx' = targetnode a # ms'' @ ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from IH[OF this \\<open>valid_node (targetnode a)\\<close> \\<open>valid_call_list cs (targetnode a)\\<close>\n      \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n      \\<open>valid_return_list rs (targetnode a)\\<close> \\<open>length rs = length cs\\<close>\n      \\<open>ms'' = targetnodes rs\\<close> callstack callstack'' callstack']"], ["proof (chain)\npicking this:\n  same_level_path_aux cs as \\<and>\n  upd_cs cs as = [] \\<and> targetnode a -as\\<rightarrow>* m' \\<and> ms = ms'", "have \"same_level_path_aux cs as\" and \"upd_cs cs as = []\"\n      and \"targetnode a -as\\<rightarrow>* m'\" and \"ms = ms'\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs as \\<and>\n  upd_cs cs as = [] \\<and> targetnode a -as\\<rightarrow>* m' \\<and> ms = ms'\n\ngoal (1 subgoal):\n 1. (same_level_path_aux cs as &&& upd_cs cs as = []) &&&\n    targetnode a -as\\<rightarrow>* m' &&& ms = ms'", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_aux cs as\n  upd_cs cs as = []\n  targetnode a -as\\<rightarrow>* m'\n  ms = ms'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>intra_kind (kind a)\\<close> \\<open>same_level_path_aux cs as\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  same_level_path_aux cs as", "have \"same_level_path_aux cs (a # as)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as)", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>intra_kind (kind a)\\<close> \\<open>upd_cs cs as = []\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  upd_cs cs as = []", "have \"upd_cs cs (a # as) = []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  upd_cs cs as = []\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # as) = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = []\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "moreover"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = []\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>m = sourcenode a\\<close> \\<open>targetnode a -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  m = sourcenode a\n  targetnode a -as\\<rightarrow>* m'", "have \"m -a # as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  m = sourcenode a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node; length s' = length s;\n        length (m # ms'' @ ms) = length s;\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "ultimately"], ["proof (chain)\npicking this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'", "show ?case"], ["proof (prove)\nusing this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and>\n    upd_cs cs (a # as) = [] \\<and>\n    m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "using \\<open>ms = ms'\\<close>"], ["proof (prove)\nusing this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'\n  ms = ms'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and>\n    upd_cs cs (a # as) = [] \\<and>\n    m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and>\n  upd_cs cs (a # as) = [] \\<and> m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "case (silent_move_call f a s s' Q r p fs a' S msx')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms'' @ ms)\n  \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms'' @ ms))) return_node\n  length (m # ms'' @ ms) = length s\n  length s' = Suc (length s)\n  hd (m # ms'' @ ms) = sourcenode a\n  msx' = targetnode a # targetnode a' # tl (m # ms'' @ ms)\n  S,f \\<turnstile> (msx',s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms'' = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note IH = \\<open>\\<And>m ms'' ms cs rs. \\<lbrakk>msx' = m # ms'' @ ms; valid_node m; valid_call_list cs m;\n      \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); valid_return_list rs m;\n      length rs = length cs; ms'' = targetnodes rs;\n      \\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n      ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n      \\<forall>mx\\<in>set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n      \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = [] \\<and> m -as\\<rightarrow>* m' \\<and> ms = ms'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack = \\<open>\\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack'' = \\<open>ms'' \\<noteq> [] \\<longrightarrow>\n      (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (state)\nthis:\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack' = \\<open>\\<forall>mx\\<in>set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>hd (m # ms'' @ ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms'' @ ms) = sourcenode a", "have \"m = sourcenode a\""], ["proof (prove)\nusing this:\n  hd (m # ms'' @ ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m = sourcenode a", "by simp"], ["proof (state)\nthis:\n  m = sourcenode a\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>valid_call_list cs m\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p", "have \"valid_call_list (a # cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        a # cs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        a # cs = cs' @ c # cs''; cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "by(case_tac list)(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a", "have \"\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a' # rs).\n       (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>valid_return_list rs m\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n      \\<open>get_proc (sourcenode a') = p\\<close> \\<open>get_proc (targetnode a) = p\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')", "have \"valid_return_list (a'#rs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_return_list (a' # rs) (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> sourcenode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "by(case_tac list)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs", "have \"length (a'#rs) = length (a # cs)\""], ["proof (prove)\nusing this:\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. length (a' # rs) = length (a # cs)", "by simp"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>ms'' = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms'' = targetnodes rs", "have \"targetnode a' # ms'' = targetnodes (a'#rs)\""], ["proof (prove)\nusing this:\n  ms'' = targetnodes rs\n\ngoal (1 subgoal):\n 1. targetnode a' # ms'' = targetnodes (a' # rs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  targetnode a' # ms'' = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>msx' = targetnode a # targetnode a' # tl (m # ms'' @ ms)\\<close>"], ["proof (chain)\npicking this:\n  msx' = targetnode a # targetnode a' # tl (m # ms'' @ ms)", "have \"msx' = targetnode a # targetnode a' # ms'' @ ms\""], ["proof (prove)\nusing this:\n  msx' = targetnode a # targetnode a' # tl (m # ms'' @ ms)\n\ngoal (1 subgoal):\n 1. msx' = targetnode a # targetnode a' # ms'' @ ms", "by simp"], ["proof (state)\nthis:\n  msx' = targetnode a # targetnode a' # ms'' @ ms\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "have \"\\<exists>mx'. call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(cases \"ms'' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ms'' = [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case True"], ["proof (state)\nthis:\n  ms'' = []\n\ngoal (2 subgoals):\n 1. ms'' = [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>(\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n        \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close> callstack"], ["proof (chain)\npicking this:\n  (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms'' @ ms)\n  \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' = []", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms'' @ ms)\n  \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' = []\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. ms'' = [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. ms'' = [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  valid_edge a'", "have \"call_of_return_node (targetnode a') (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode a)", "by(fastforce simp:call_of_return_node_def return_node_def)"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (2 subgoals):\n 1. ms'' = [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> True"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' = []\n  call_of_return_node (targetnode a') (sourcenode a)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' = []\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>mx'.\n     call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n     mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case False"], ["proof (state)\nthis:\n  ms'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms'' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with callstack''"], ["proof (chain)\npicking this:\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  ms'' \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  ms'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>mx'.\n       call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>mx'.\n     call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n     mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>mx'.\n     call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n     mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "hence \"targetnode a' # ms'' \\<noteq> [] \\<longrightarrow>\n      (\\<exists>mx'. call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<exists>mx'.\n     call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n     mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. targetnode a' # ms'' \\<noteq> [] \\<longrightarrow>\n    (\\<exists>mx'.\n        call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n        mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by simp"], ["proof (state)\nthis:\n  targetnode a' # ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last (targetnode a' # ms'')) mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from IH[OF _ \\<open>valid_node (targetnode a)\\<close> \\<open>valid_call_list (a # cs) (targetnode a)\\<close>\n      \\<open>\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\\<close>\n      \\<open>valid_return_list (a'#rs) (targetnode a)\\<close> \\<open>length (a'#rs) = length (a # cs)\\<close>\n      \\<open>targetnode a' # ms'' = targetnodes (a'#rs)\\<close> callstack this callstack']\n      \\<open>msx' = targetnode a # targetnode a' # ms'' @ ms\\<close>"], ["proof (chain)\npicking this:\n  msx' = targetnode a # (targetnode a' # ms'') @ ms \\<Longrightarrow>\n  same_level_path_aux (a # cs) as \\<and>\n  upd_cs (a # cs) as = [] \\<and>\n  targetnode a -as\\<rightarrow>* m' \\<and> ms = ms'\n  msx' = targetnode a # targetnode a' # ms'' @ ms", "have \"same_level_path_aux (a # cs) as\" and \"upd_cs (a # cs) as = []\"\n      and \"targetnode a -as\\<rightarrow>* m'\" and \"ms = ms'\""], ["proof (prove)\nusing this:\n  msx' = targetnode a # (targetnode a' # ms'') @ ms \\<Longrightarrow>\n  same_level_path_aux (a # cs) as \\<and>\n  upd_cs (a # cs) as = [] \\<and>\n  targetnode a -as\\<rightarrow>* m' \\<and> ms = ms'\n  msx' = targetnode a # targetnode a' # ms'' @ ms\n\ngoal (1 subgoal):\n 1. (same_level_path_aux (a # cs) as &&& upd_cs (a # cs) as = []) &&&\n    targetnode a -as\\<rightarrow>* m' &&& ms = ms'", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_aux (a # cs) as\n  upd_cs (a # cs) as = []\n  targetnode a -as\\<rightarrow>* m'\n  ms = ms'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>same_level_path_aux (a # cs) as\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as", "have \"same_level_path_aux cs (a # as)\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as)", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>upd_cs (a # cs) as = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs (a # cs) as = []", "have \"upd_cs cs (a # as) = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs (a # cs) as = []\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = []\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "moreover"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = []\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>m = sourcenode a\\<close> \\<open>targetnode a -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  m = sourcenode a\n  targetnode a -as\\<rightarrow>* m'", "have \"m -a # as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  m = sourcenode a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms'' @ ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s' = Suc (length s);\n        hd (m # ms'' @ ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "ultimately"], ["proof (chain)\npicking this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'", "show ?case"], ["proof (prove)\nusing this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and>\n    upd_cs cs (a # as) = [] \\<and>\n    m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "using \\<open>ms = ms'\\<close>"], ["proof (prove)\nusing this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'\n  ms = ms'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and>\n    upd_cs cs (a # as) = [] \\<and>\n    m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and>\n  upd_cs cs (a # as) = [] \\<and> m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "case (silent_move_return f a s s' Q p f' S msx')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms'' @ ms))) return_node\n  length (m # ms'' @ ms) = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd (m # ms'' @ ms) = sourcenode a\n  hd (tl (m # ms'' @ ms)) = targetnode a\n  msx' = tl (m # ms'' @ ms)\n  S,f \\<turnstile> (msx',s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms'' = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note IH = \\<open>\\<And>m ms'' ms cs rs. \\<lbrakk>msx' = m # ms'' @ ms; valid_node m; \n      valid_call_list cs m; \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); \n      valid_return_list rs m; length rs = length cs; ms'' = targetnodes rs;\n      \\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n      ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n      \\<forall>mx\\<in>set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n      \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = [] \\<and> m -as\\<rightarrow>* m' \\<and> ms = ms'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms'' @ ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms'' = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?ms'' \\<noteq> [] \\<longrightarrow>\n   (\\<exists>mx'.\n       call_of_return_node (last ?ms'') mx' \\<and>\n       mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n   \\<forall>mx\\<in>set ms'.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux ?cs as \\<and>\n                    upd_cs ?cs as = [] \\<and>\n                    ?m -as\\<rightarrow>* m' \\<and> ?ms = ms'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack = \\<open>\\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack'' = \\<open>ms'' \\<noteq> [] \\<longrightarrow>\n      (\\<exists>mx'. call_of_return_node (last ms'') mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (state)\nthis:\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "note callstack' = \\<open>\\<forall>mx\\<in>set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "have \"ms'' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms'' \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ms'' = [] \\<Longrightarrow> False", "assume \"ms'' = []\""], ["proof (state)\nthis:\n  ms'' = []\n\ngoal (1 subgoal):\n 1. ms'' = [] \\<Longrightarrow> False", "with callstack\n        \\<open>\\<exists>m\\<in>set (tl (m # ms'' @ ms)). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' = []", "show False"], ["proof (prove)\nusing this:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms'' = []\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ms'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>hd (tl (m # ms'' @ ms)) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  hd (tl (m # ms'' @ ms)) = targetnode a\n  ms'' \\<noteq> []", "obtain xs where \"ms'' = targetnode a # xs\""], ["proof (prove)\nusing this:\n  hd (tl (m # ms'' @ ms)) = targetnode a\n  ms'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        ms'' = targetnode a # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms'') auto"], ["proof (state)\nthis:\n  ms'' = targetnode a # xs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>ms'' = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms'' = targetnodes rs\n  ms'' = targetnode a # xs", "obtain r' rs' where \"rs = r' # rs'\" \n      and \"targetnode a = targetnode r'\" and \"xs = targetnodes rs'\""], ["proof (prove)\nusing this:\n  ms'' = targetnodes rs\n  ms'' = targetnode a # xs\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; targetnode a = targetnode r';\n         xs = targetnodes rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rs)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  rs = r' # rs'\n  targetnode a = targetnode r'\n  xs = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>rs = r' # rs'\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  rs = r' # rs'\n  length rs = length cs", "obtain c' cs' where \"cs = c' # cs'\"\n      and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  rs = r' # rs'\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. (\\<And>c' cs'.\n        \\<lbrakk>cs = c' # cs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cs) auto"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n      \\<open>rs = r' # rs'\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n      and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>hd (m # ms'' @ ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms'' @ ms) = sourcenode a", "have \"m = sourcenode a\""], ["proof (prove)\nusing this:\n  hd (m # ms'' @ ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m = sourcenode a", "by simp"], ["proof (state)\nthis:\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'", "obtain p' Q' r fs' where \"valid_edge c'\" and \"kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\" \n      and \"p' = get_proc m\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>Q' r p' fs'.\n        \\<lbrakk>valid_edge c';\n         kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         p' = get_proc m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q' r p' fs'.\n                \\<lbrakk>valid_edge c';\n                 kind c' =\n                 Q':r\\<hookrightarrow>\\<^bsub>get_proc m\\<^esub>fs';\n                 p' = get_proc m\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs'a c.\n        (\\<exists>cs''. c' # cs' = cs'a @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs'a of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n     cs = c' # cs'\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule_tac x=\"[]\" in allE) auto"], ["proof (state)\nthis:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  p' = get_proc m\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>m = sourcenode a\\<close> \\<open>p' = get_proc m\\<close>"], ["proof (chain)\npicking this:\n  m = sourcenode a\n  p' = get_proc m\n  get_proc (sourcenode a) = p", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  m = sourcenode a\n  p' = get_proc m\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'", "have \"get_proc (targetnode c') = p\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode c') = p", "by(fastforce intro:get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode c') = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'", "have \"valid_edge r'\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. valid_edge r'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  r' \\<in> get_return_edges c'", "obtain Q'' f'' where \"kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Q':r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. (\\<And>Q'' f''.\n        kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>valid_edge r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"get_proc (sourcenode r') = p\""], ["proof (prove)\nusing this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode r') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode r') = p\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge r'\\<close> \\<open>kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"method_exit (sourcenode r')\""], ["proof (prove)\nusing this:\n  valid_edge r'\n  kind r' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode r')", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode r')\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"method_exit (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>method_exit (sourcenode r')\\<close> \\<open>get_proc (sourcenode r') = p\\<close> \n      \\<open>get_proc (sourcenode a) = p\\<close>"], ["proof (chain)\npicking this:\n  method_exit (sourcenode r')\n  get_proc (sourcenode r') = p\n  get_proc (sourcenode a) = p\n  method_exit (sourcenode a)", "have \"sourcenode a = sourcenode r'\""], ["proof (prove)\nusing this:\n  method_exit (sourcenode r')\n  get_proc (sourcenode r') = p\n  get_proc (sourcenode a) = p\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a = sourcenode r'", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  sourcenode a = sourcenode r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "with \\<open>valid_edge a\\<close> \\<open>valid_edge r'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge r'\n  targetnode a = targetnode r'\n  sourcenode a = sourcenode r'", "have \"a = r'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge r'\n  targetnode a = targetnode r'\n  sourcenode a = sourcenode r'\n\ngoal (1 subgoal):\n 1. a = r'", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a = r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  targetnode a = targetnode r'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  targetnode a = targetnode r'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(fastforce intro:get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>\n      \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"valid_call_list cs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode a);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> m\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs')(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_return_list rs m\\<close> \\<open>rs = r' # rs'\\<close> \\<open>targetnode a = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  rs = r' # rs'\n  targetnode a = targetnode r'", "have \"valid_return_list rs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  rs = r' # rs'\n  targetnode a = targetnode r'\n\ngoal (1 subgoal):\n 1. valid_return_list rs' (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       r' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> m\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        rs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"r' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        rs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               r' # cs' @ c # cs'' =\n               (r' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case r' # cs' of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow>\n        last (targetnodes (r' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>msx' = tl (m # ms'' @ ms)\\<close> \\<open>ms'' = targetnode a # xs\\<close>"], ["proof (chain)\npicking this:\n  msx' = tl (m # ms'' @ ms)\n  ms'' = targetnode a # xs", "have \"msx' = targetnode a # xs @ ms\""], ["proof (prove)\nusing this:\n  msx' = tl (m # ms'' @ ms)\n  ms'' = targetnode a # xs\n\ngoal (1 subgoal):\n 1. msx' = targetnode a # xs @ ms", "by simp"], ["proof (state)\nthis:\n  msx' = targetnode a # xs @ ms\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from callstack'' \\<open>ms'' = targetnode a # xs\\<close>"], ["proof (chain)\npicking this:\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  ms'' = targetnode a # xs", "have \"xs \\<noteq> [] \\<longrightarrow>\n      (\\<exists>mx'. call_of_return_node (last xs) mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  ms'' \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last ms'') mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  ms'' = targetnode a # xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<longrightarrow>\n    (\\<exists>mx'.\n        call_of_return_node (last xs) mx' \\<and>\n        mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by fastforce"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node (last xs) mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from IH[OF \\<open>msx' = targetnode a # xs @ ms\\<close> \\<open>valid_node (targetnode a)\\<close>\n      \\<open>valid_call_list cs' (targetnode a)\\<close>\n      \\<open>\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\\<close> \n      \\<open>valid_return_list rs' (targetnode a)\\<close> \\<open>length rs' = length cs'\\<close>\n      \\<open>xs = targetnodes rs'\\<close> callstack this callstack']"], ["proof (chain)\npicking this:\n  same_level_path_aux cs' as \\<and>\n  upd_cs cs' as = [] \\<and>\n  targetnode a -as\\<rightarrow>* m' \\<and> ms = ms'", "have \"same_level_path_aux cs' as\" and \"upd_cs cs' as = []\"\n      and \"targetnode a -as\\<rightarrow>* m'\" and \"ms = ms'\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs' as \\<and>\n  upd_cs cs' as = [] \\<and>\n  targetnode a -as\\<rightarrow>* m' \\<and> ms = ms'\n\ngoal (1 subgoal):\n 1. (same_level_path_aux cs' as &&& upd_cs cs' as = []) &&&\n    targetnode a -as\\<rightarrow>* m' &&& ms = ms'", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_aux cs' as\n  upd_cs cs' as = []\n  targetnode a -as\\<rightarrow>* m'\n  ms = ms'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>same_level_path_aux cs' as\\<close> \\<open>cs = c' # cs'\\<close>\n      \\<open>r' \\<in> get_return_edges c'\\<close> \\<open>a = r'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  same_level_path_aux cs' as\n  cs = c' # cs'\n  r' \\<in> get_return_edges c'\n  a = r'", "have \"same_level_path_aux cs (a # as)\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  same_level_path_aux cs' as\n  cs = c' # cs'\n  r' \\<in> get_return_edges c'\n  a = r'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as)", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>upd_cs cs' as = []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs' as = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'", "have \"upd_cs cs (a # as) = []\""], ["proof (prove)\nusing this:\n  upd_cs cs' as = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "moreover"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>m = sourcenode a\\<close> \\<open>targetnode a -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  m = sourcenode a\n  targetnode a -as\\<rightarrow>* m'", "have \"m -a # as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  m = sourcenode a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms'' @ ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms'' @ ms))) return_node;\n        length (m # ms'' @ ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms'' @ ms) = sourcenode a;\n        hd (tl (m # ms'' @ ms)) = targetnode a; ms'a = tl (m # ms'' @ ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',sx'');\n        \\<And>m ms'' ms cs rs.\n           \\<lbrakk>ms'a = m # ms'' @ ms; valid_node m;\n            valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms'' = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            ms'' \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mx'.\n                call_of_return_node (last ms'') mx' \\<and>\n                mx'\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n            \\<forall>mx\\<in>set ms'.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [] \\<and>\n                             m -as\\<rightarrow>* m' \\<and> ms = ms';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms'' = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        ms'' \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node (last ms'') mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = [] \\<and>\n                         m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "ultimately"], ["proof (chain)\npicking this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'", "show ?case"], ["proof (prove)\nusing this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and>\n    upd_cs cs (a # as) = [] \\<and>\n    m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "using \\<open>ms = ms'\\<close>"], ["proof (prove)\nusing this:\n  same_level_path_aux cs (a # as)\n  upd_cs cs (a # as) = []\n  m -a # as\\<rightarrow>* m'\n  ms = ms'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and>\n    upd_cs cs (a # as) = [] \\<and>\n    m -a # as\\<rightarrow>* m' \\<and> ms = ms'", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and>\n  upd_cs cs (a # as) = [] \\<and> m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and>\n  upd_cs cs (a # as) = [] \\<and> m -a # as\\<rightarrow>* m' \\<and> ms = ms'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_slp:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); valid_node m; \n  \\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n  \\<forall>mx \\<in> set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and> ms = ms'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (m #\n                               ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     valid_node m;\n     \\<forall>mx\\<in>set ms.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<forall>mx\\<in>set ms'.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx'\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                      ms = ms'", "by(fastforce dest!:silent_moves_slpa_path\n                   [of _ _ _ \"[]\" _ _ _ _ _ _ \"[]\" \"[]\",simplified] \n              simp:targetnodes_def valid_call_list_def valid_return_list_def \n                   same_level_path_def slp_def)"], ["", "lemma slpa_silent_moves_callstacks_eq:\n  \"\\<lbrakk>same_level_path_aux cs as; S,f \\<turnstile> (m#msx@ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s');\n  length ms = length ms'; valid_call_list cs m; \n  \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); valid_return_list rs m; \n  length rs = length cs; msx = targetnodes rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as;\n     S,f \\<turnstile> (m #\n                       msx @\n                       ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n     length ms = length ms'; valid_call_list cs m;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     valid_return_list rs m; length rs = length cs;\n     msx = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> ms = ms'", "proof(induct arbitrary:m msx s rs rule:slpa_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs m msx s rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  msx @\n                                  ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                 ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 4. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m #\n                    msx @ ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  length ms = length ms'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  msx = targetnodes rs\n\ngoal (4 subgoals):\n 1. \\<And>cs m msx s rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  msx @\n                                  ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                 ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 4. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (m # msx @ ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m #\n                    msx @ ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "have \"msx@ms = ms'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m #\n                    msx @ ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. msx @ ms = ms'", "by(fastforce elim:silent_moves.cases)"], ["proof (state)\nthis:\n  msx @ ms = ms'\n\ngoal (4 subgoals):\n 1. \\<And>cs m msx s rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  msx @\n                                  ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                 ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 4. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "with \\<open>length ms = length ms'\\<close>"], ["proof (chain)\npicking this:\n  length ms = length ms'\n  msx @ ms = ms'", "show ?case"], ["proof (prove)\nusing this:\n  length ms = length ms'\n  msx @ ms = ms'\n\ngoal (1 subgoal):\n 1. ms = ms'", "by fastforce"], ["proof (state)\nthis:\n  ms = ms'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  \\<lbrakk>S,f \\<turnstile> (?m #\n                             ?msx @\n                             ms,?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s');\n   length ms = length ms'; valid_call_list cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs;\n   ?msx = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  length ms = length ms'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  msx = targetnodes rs\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "note IH = \\<open>\\<And>m msx s rs. \\<lbrakk>S,f \\<turnstile> (m # msx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n    length ms = length ms'; valid_call_list cs m;\n    \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n    valid_return_list rs m; length rs = length cs; msx = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> ms = ms'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>S,f \\<turnstile> (?m #\n                             ?msx @\n                             ms,?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s');\n   length ms = length ms'; valid_call_list cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs;\n   ?msx = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (m # msx @ ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "obtain ms'' s''\n  where \"S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\"\n    and \"S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>ms'' s''.\n        \\<lbrakk>S,f \\<turnstile> (m #\n                                   msx @\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'');\n         S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  intra_kind (kind a)", "have \"valid_edge a\" and [simp]:\"m = sourcenode a\" \"ms'' = targetnode a # msx @ ms\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. valid_edge a &&& m = sourcenode a &&& ms'' = targetnode a # msx @ ms", "by(fastforce elim:silent_move.cases simp:intra_kind_def)+"], ["proof (state)\nthis:\n  valid_edge a\n  m = sourcenode a\n  ms'' = targetnode a # msx @ ms\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_call_list cs m\\<close> \\<open>m = sourcenode a\\<close>\n    \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_return_list rs m\\<close> \\<open>m = sourcenode a\\<close> \n    \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list rs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list rs (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> sourcenode a\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_return_list rs (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "have \"S,f \\<turnstile> (targetnode a # msx @ ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (targetnode a #\n                      msx @\n                      ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (targetnode a #\n                    msx @\n                    ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m msx s rs.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 3. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from IH[OF this \\<open>length ms = length ms'\\<close> \\<open>valid_call_list cs (targetnode a)\\<close>\n    \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n    \\<open>valid_return_list rs (targetnode a)\\<close> \\<open>length rs = length cs\\<close>\n    \\<open>msx = targetnodes rs\\<close>]"], ["proof (chain)\npicking this:\n  ms = ms'", "show ?case"], ["proof (prove)\nusing this:\n  ms = ms'\n\ngoal (1 subgoal):\n 1. ms = ms'", "."], ["proof (state)\nthis:\n  ms = ms'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  \\<lbrakk>S,f \\<turnstile> (?m #\n                             ?msx @\n                             ms,?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s');\n   length ms = length ms'; valid_call_list (a # cs) ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges ((a # cs) ! i);\n   valid_return_list ?rs ?m; length ?rs = length (a # cs);\n   ?msx = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  length ms = length ms'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  msx = targetnodes rs\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "note IH = \\<open>\\<And>m msx s rs. \\<lbrakk>S,f \\<turnstile> (m # msx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n    length ms = length ms'; valid_call_list (a # cs) m;\n    \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n    valid_return_list rs m; length rs = length (a # cs);\n    msx = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> ms = ms'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>S,f \\<turnstile> (?m #\n                             ?msx @\n                             ms,?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s');\n   length ms = length ms'; valid_call_list (a # cs) ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges ((a # cs) ! i);\n   valid_return_list ?rs ?m; length ?rs = length (a # cs);\n   ?msx = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (m # msx @ ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "obtain ms'' s''\n    where \"S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\"\n    and \"S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>ms'' s''.\n        \\<lbrakk>S,f \\<turnstile> (m #\n                                   msx @\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'');\n         S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain a' where \"valid_edge a\" and [simp]:\"m = sourcenode a\"\n    and [simp]:\"ms'' = targetnode a # targetnode a' # msx @ ms\"\n    and \"a' \\<in> get_return_edges a\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a; m = sourcenode a;\n         ms'' = targetnode a # targetnode a' # msx @ ms;\n         a' \\<in> get_return_edges a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a\n  m = sourcenode a\n  ms'' = targetnode a # targetnode a' # msx @ ms\n  a' \\<in> get_return_edges a\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "with \\<open>valid_call_list cs m\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p", "have \"valid_call_list (a # cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); a # cs = cs' @ c # cs'';\n        cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "by(case_tac list)(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a", "have \"\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a' # rs).\n       (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "with \\<open>valid_return_list rs m\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n    \\<open>get_proc (sourcenode a') = p\\<close> \\<open>get_proc (targetnode a) = p\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')", "have \"valid_return_list (a'#rs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_return_list (a' # rs) (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> sourcenode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "by(case_tac list)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs", "have \"length (a'#rs) = length (a#cs)\""], ["proof (prove)\nusing this:\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. length (a' # rs) = length (a # cs)", "by simp"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>msx = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  msx = targetnodes rs", "have \"targetnode a' # msx = targetnodes (a' # rs)\""], ["proof (prove)\nusing this:\n  msx = targetnodes rs\n\ngoal (1 subgoal):\n 1. targetnode a' # msx = targetnodes (a' # rs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  targetnode a' # msx = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "have \"S,f \\<turnstile> (targetnode a # (targetnode a' # msx) @ ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (targetnode a #\n                      (targetnode a' # msx) @\n                      ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (targetnode a #\n                    (targetnode a' # msx) @\n                    ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m msx s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'\n 2. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from IH[OF this \\<open>length ms = length ms'\\<close> \\<open>valid_call_list (a # cs) (targetnode a)\\<close>\n    \\<open>\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\\<close>\n    \\<open>valid_return_list (a'#rs) (targetnode a)\\<close> \\<open>length (a'#rs) = length (a#cs)\\<close>\n    \\<open>targetnode a' # msx = targetnodes (a' # rs)\\<close>]"], ["proof (chain)\npicking this:\n  ms = ms'", "show ?case"], ["proof (prove)\nusing this:\n  ms = ms'\n\ngoal (1 subgoal):\n 1. ms = ms'", "."], ["proof (state)\nthis:\n  ms = ms'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "case (slpa_Return cs a as Q p f' c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>S,f \\<turnstile> (?m #\n                             ?msx @\n                             ms,?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s');\n   length ms = length ms'; valid_call_list cs' ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs' ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs';\n   ?msx = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  length ms = length ms'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  msx = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "note IH = \\<open>\\<And>m msx s rs. \\<lbrakk>S,f \\<turnstile> (m # msx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n    length ms = length ms'; valid_call_list cs' m;\n    \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i); valid_return_list rs m; \n    length rs = length cs'; msx = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> ms = ms'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>S,f \\<turnstile> (?m #\n                             ?msx @\n                             ms,?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s');\n   length ms = length ms'; valid_call_list cs' ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs' ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs';\n   ?msx = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> ms = ms'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (m # msx @ ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "obtain ms'' s''\n    where \"S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\"\n    and \"S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m #\n                    msx @\n                    ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>ms'' s''.\n        \\<lbrakk>S,f \\<turnstile> (m #\n                                   msx @\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'');\n         S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"valid_edge a\" and \"m = sourcenode a\" and \"hd (msx @ ms) = targetnode a\"\n    and \"ms'' = msx @ ms\" and \"s'' \\<noteq> []\" and \"length s = Suc(length s'')\"\n    and \"length (m # msx @ ms) = length s\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # msx @ ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (valid_edge a &&& m = sourcenode a &&& hd (msx @ ms) = targetnode a) &&&\n    (ms'' = msx @ ms &&& s'' \\<noteq> []) &&&\n    length s = Suc (length s'') &&& length (m # msx @ ms) = length s", "by(auto elim:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a\n  m = sourcenode a\n  hd (msx @ ms) = targetnode a\n  ms'' = msx @ ms\n  s'' \\<noteq> []\n  length s = Suc (length s'')\n  length (m # msx @ ms) = length s\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>msx = targetnodes rs\\<close> \\<open>length rs = length cs\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  msx = targetnodes rs\n  length rs = length cs\n  cs = c' # cs'", "obtain mx' msx' where \"msx = mx'#msx'\""], ["proof (prove)\nusing this:\n  msx = targetnodes rs\n  length rs = length cs\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>mx' msx'.\n        msx = mx' # msx' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases msx)(fastforce simp:targetnodes_def)+"], ["proof (state)\nthis:\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "with \\<open>hd (msx @ ms) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  hd (msx @ ms) = targetnode a\n  msx = mx' # msx'", "have \"mx' = targetnode a\""], ["proof (prove)\nusing this:\n  hd (msx @ ms) = targetnode a\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. mx' = targetnode a", "by simp"], ["proof (state)\nthis:\n  mx' = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c'", "by(fastforce simp:valid_call_list_def)"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>\n    \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"valid_call_list cs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode a);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> m\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs')(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>length rs = length cs\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  cs = c' # cs'", "obtain r' rs' \n    where [simp]:\"rs = r'#rs'\" and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rs) auto"], ["proof (state)\nthis:\n  rs = r' # rs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  cs = c' # cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n    and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "with \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'", "have [simp]:\"a = r'\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. a = r'", "by -(rule get_return_edges_unique)"], ["proof (state)\nthis:\n  a = r'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "with \\<open>valid_return_list rs m\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  a = r'", "have \"valid_return_list rs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  a = r'\n\ngoal (1 subgoal):\n 1. valid_return_list rs' (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       r' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> m\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        rs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"r' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>rs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               r' # cs' @ c # cs'' =\n               (r' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case r' # cs' of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow>\n        last (targetnodes (r' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>msx = targetnodes rs\\<close> \\<open>msx = mx'#msx'\\<close> \\<open>rs = r'#rs'\\<close>"], ["proof (chain)\npicking this:\n  msx = targetnodes rs\n  msx = mx' # msx'\n  rs = r' # rs'", "have \"msx' = targetnodes rs'\""], ["proof (prove)\nusing this:\n  msx = targetnodes rs\n  msx = mx' # msx'\n  rs = r' # rs'\n\ngoal (1 subgoal):\n 1. msx' = targetnodes rs'", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  msx' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from \\<open>S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<close> \\<open>msx = mx'#msx'\\<close>\n    \\<open>ms'' = msx @ ms\\<close> \\<open>mx' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  msx = mx' # msx'\n  ms'' = msx @ ms\n  mx' = targetnode a", "have \"S,f \\<turnstile> (targetnode a # msx' @ ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  msx = mx' # msx'\n  ms'' = msx @ ms\n  mx' = targetnode a\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (targetnode a #\n                      msx' @\n                      ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (targetnode a #\n                    msx' @\n                    ms,s'') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p fa c' cs' m msx s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fa;\n        cs = c' # cs'; same_level_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>m msx s rs.\n           \\<lbrakk>S,f \\<turnstile> (m #\nmsx @ ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n            length ms = length ms'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            msx = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> ms = ms';\n        S,f \\<turnstile> (m #\n                          msx @\n                          ms,s) =a #\n                                 as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        length ms = length ms'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        msx = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> ms = ms'", "from IH[OF this \\<open>length ms = length ms'\\<close> \\<open>valid_call_list cs' (targetnode a)\\<close>\n    \\<open>\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\\<close>\n    \\<open>valid_return_list rs' (targetnode a)\\<close> \\<open>length rs' = length cs'\\<close>\n    \\<open>msx' = targetnodes rs'\\<close>]"], ["proof (chain)\npicking this:\n  ms = ms'", "show ?case"], ["proof (prove)\nusing this:\n  ms = ms'\n\ngoal (1 subgoal):\n 1. ms = ms'", "."], ["proof (state)\nthis:\n  ms = ms'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_same_level_path:\n  assumes \"S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\" shows \"ms = ms'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms = ms'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ms = ms'", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "obtain cf cfs where \"s = cf#cfs\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)(auto dest:silent_moves_equal_length)"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. ms = ms'", "with \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  s = cf # cfs", "have \"transfers (kinds as) (cf#cfs) = s'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. transfers (kinds as) (cf # cfs) = s'", "by(fastforce intro:silent_moves_preds_transfers simp:kinds_def)"], ["proof (state)\nthis:\n  transfers (kinds as) (cf # cfs) = s'\n\ngoal (1 subgoal):\n 1. ms = ms'", "with \\<open>m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  transfers (kinds as) (cf # cfs) = s'", "obtain cf' where \"s' = cf'#cfs\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  transfers (kinds as) (cf # cfs) = s'\n\ngoal (1 subgoal):\n 1. (\\<And>cf'. s' = cf' # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule slp_callstack_length_equal,auto)"], ["proof (state)\nthis:\n  s' = cf' # cfs\n\ngoal (1 subgoal):\n 1. ms = ms'", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "have \"length (m#ms) = length s\" and \"length (m'#ms') = length s'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. length (m # ms) = length s &&& length (m' # ms') = length s'", "by(rule silent_moves_equal_length)+"], ["proof (state)\nthis:\n  length (m # ms) = length s\n  length (m' # ms') = length s'\n\ngoal (1 subgoal):\n 1. ms = ms'", "with \\<open>s = cf#cfs\\<close> \\<open>s' = cf'#cfs\\<close>"], ["proof (chain)\npicking this:\n  s = cf # cfs\n  s' = cf' # cfs\n  length (m # ms) = length s\n  length (m' # ms') = length s'", "have \"length ms = length ms'\""], ["proof (prove)\nusing this:\n  s = cf # cfs\n  s' = cf' # cfs\n  length (m # ms) = length s\n  length (m' # ms') = length s'\n\ngoal (1 subgoal):\n 1. length ms = length ms'", "by simp"], ["proof (state)\nthis:\n  length ms = length ms'\n\ngoal (1 subgoal):\n 1. ms = ms'", "from \\<open>m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "have \"same_level_path_aux [] as\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as", "by(simp add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n\ngoal (1 subgoal):\n 1. ms = ms'", "with \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>length ms = length ms'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  length ms = length ms'\n  same_level_path_aux [] as", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  length ms = length ms'\n  same_level_path_aux [] as\n\ngoal (1 subgoal):\n 1. ms = ms'", "by(auto elim!:slpa_silent_moves_callstacks_eq \n    simp:targetnodes_def valid_call_list_def valid_return_list_def)"], ["proof (state)\nthis:\n  ms = ms'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_call_edge:\n  assumes \"S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and callstack:\"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and rest:\"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  \"ms = targetnodes rs\" \"valid_return_list rs m\" \"length rs = length cs\"\n  obtains as' a as'' where \"as = as'@a#as''\" and \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"call_of_return_node (hd ms') (sourcenode a)\"\n  and \"targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\"\n  | \"ms' = ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as' a as''.\n                \\<lbrakk>as = as' @ a # as'';\n                 \\<exists>Q r p fs.\n                    kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n                 call_of_return_node (hd ms') (sourcenode a);\n                 targetnode\n                  a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ms' = ms \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "show \"(\\<exists>as' a as''. as = as' @ a # as'' \\<and> (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n    call_of_return_node (hd ms') (sourcenode a) \\<and> targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "proof(induct as arbitrary:m' ms' s' rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m' ms' s'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa xb.\n                       S,kind \\<turnstile> (m #\n      ms,s) =ys\\<Rightarrow>\\<^sub>\\<tau> (x # xa,xb) \\<longrightarrow>\n                       (\\<exists>as' a as''.\n                           ys = as' @ a # as'' \\<and>\n                           (\\<exists>Q r p fs.\n                               kind a =\n                               Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                           call_of_return_node (hd xa) (sourcenode a) \\<and>\n                           targetnode\n                            a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* x) \\<or>\n                       xa = ms);\n        S,kind \\<turnstile> (m #\n                             ms,s) =xs\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             xs = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n                         ms' = ms", "fix as m' ms' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m' ms' s'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa xb.\n                       S,kind \\<turnstile> (m #\n      ms,s) =ys\\<Rightarrow>\\<^sub>\\<tau> (x # xa,xb) \\<longrightarrow>\n                       (\\<exists>as' a as''.\n                           ys = as' @ a # as'' \\<and>\n                           (\\<exists>Q r p fs.\n                               kind a =\n                               Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                           call_of_return_node (hd xa) (sourcenode a) \\<and>\n                           targetnode\n                            a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* x) \\<or>\n                       xa = ms);\n        S,kind \\<turnstile> (m #\n                             ms,s) =xs\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             xs = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n                         ms' = ms", "assume IH:\"\\<forall>as'. length as' < length as \\<longrightarrow>\n      (\\<forall>mx msx sx. S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx#msx,sx) \\<longrightarrow> \n      (\\<exists>asx a asx'. as' = asx @ a # asx' \\<and> (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd msx) (sourcenode a) \\<and> targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n      msx = ms)\"\n      and \"S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (state)\nthis:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>mx msx sx.\n         S,kind \\<turnstile> (m #\n                              ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                              msx,sx) \\<longrightarrow>\n         (\\<exists>asx a asx'.\n             as' = asx @ a # asx' \\<and>\n             (\\<exists>Q r p fs.\n                 kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n             call_of_return_node (hd msx) (sourcenode a) \\<and>\n             targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n         msx = ms)\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>xs m' ms' s'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa xb.\n                       S,kind \\<turnstile> (m #\n      ms,s) =ys\\<Rightarrow>\\<^sub>\\<tau> (x # xa,xb) \\<longrightarrow>\n                       (\\<exists>as' a as''.\n                           ys = as' @ a # as'' \\<and>\n                           (\\<exists>Q r p fs.\n                               kind a =\n                               Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                           call_of_return_node (hd xa) (sourcenode a) \\<and>\n                           targetnode\n                            a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* x) \\<or>\n                       xa = ms);\n        S,kind \\<turnstile> (m #\n                             ms,s) =xs\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             xs = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n                         ms' = ms", "show \"(\\<exists>as' a as''. as = as' @ a # as'' \\<and> (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and> targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n      ms' = ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "proof(cases as rule:rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = []", "have \"ms = ms'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = []\n\ngoal (1 subgoal):\n 1. ms = ms'", "by(fastforce elim:silent_moves.cases)"], ["proof (state)\nthis:\n  ms = ms'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  ms = ms'\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "by simp"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "case (snoc as' a')"], ["proof (state)\nthis:\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = as' @ [a']", "obtain ms'' s'' where \"S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\"\n        and \"S,kind \\<turnstile> (ms'',s'') =[a']\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (\\<And>ms'' s''.\n        \\<lbrakk>S,kind \\<turnstile> (m #\nms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n         S,kind \\<turnstile> (ms'',s'') =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                   ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves_split)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  S,kind \\<turnstile> (ms'',s'') =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "from snoc"], ["proof (chain)\npicking this:\n  as = as' @ [a']", "have \"length as' < length as\""], ["proof (prove)\nusing this:\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. length as' < length as", "by simp"], ["proof (state)\nthis:\n  length as' < length as\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "from \\<open>S,kind \\<turnstile> (ms'',s'') =[a']\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s')", "have \"S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s')\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s')", "by(fastforce elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       as = ys @ [y] \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with \\<open>S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  intra_kind (kind a')", "have \"valid_edge a'\" and \"m' = targetnode a'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. valid_edge a' &&& m' = targetnode a'", "by(auto elim:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a'\n  m' = targetnode a'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "from \\<open>S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  intra_kind (kind a')", "have \"ms'' = sourcenode a'#ms'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. ms'' = sourcenode a' # ms'", "by -(erule silent_move.cases,auto simp:intra_kind_def,(cases ms'',auto)+)"], ["proof (state)\nthis:\n  ms'' = sourcenode a' # ms'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with IH \\<open>length as' < length as\\<close> \\<open>S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>mx msx sx.\n         S,kind \\<turnstile> (m #\n                              ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                              msx,sx) \\<longrightarrow>\n         (\\<exists>asx a asx'.\n             as' = asx @ a # asx' \\<and>\n             (\\<exists>Q r p fs.\n                 kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n             call_of_return_node (hd msx) (sourcenode a) \\<and>\n             targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n         msx = ms)\n  length as' < length as\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  ms'' = sourcenode a' # ms'", "have \"(\\<exists>asx ax asx'. as' = asx @ ax # asx' \\<and> (\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n          call_of_return_node (hd ms') (sourcenode ax) \\<and> \n          targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or> ms' = ms\""], ["proof (prove)\nusing this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>mx msx sx.\n         S,kind \\<turnstile> (m #\n                              ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                              msx,sx) \\<longrightarrow>\n         (\\<exists>asx a asx'.\n             as' = asx @ a # asx' \\<and>\n             (\\<exists>Q r p fs.\n                 kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n             call_of_return_node (hd msx) (sourcenode a) \\<and>\n             targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n         msx = ms)\n  length as' < length as\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  ms'' = sourcenode a' # ms'\n\ngoal (1 subgoal):\n 1. (\\<exists>asx ax asx'.\n        as' = asx @ ax # asx' \\<and>\n        (\\<exists>Q r p fs.\n            kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode ax) \\<and>\n        targetnode\n         ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n    ms' = ms", "by simp blast"], ["proof (state)\nthis:\n  (\\<exists>asx ax asx'.\n      as' = asx @ ax # asx' \\<and>\n      (\\<exists>Q r p fs.\n          kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode ax) \\<and>\n      targetnode\n       ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n  ms' = ms\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>asx ax asx'.\n      as' = asx @ ax # asx' \\<and>\n      (\\<exists>Q r p fs.\n          kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode ax) \\<and>\n      targetnode\n       ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "assume \"\\<exists>asx ax asx'. as' = asx @ ax # asx' \\<and> \n            (\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n            call_of_return_node (hd ms') (sourcenode ax) \\<and> \n            targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\""], ["proof (state)\nthis:\n  \\<exists>asx ax asx'.\n     as' = asx @ ax # asx' \\<and>\n     (\\<exists>Q r p fs.\n         kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (hd ms') (sourcenode ax) \\<and>\n     targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "then"], ["proof (chain)\npicking this:\n  \\<exists>asx ax asx'.\n     as' = asx @ ax # asx' \\<and>\n     (\\<exists>Q r p fs.\n         kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (hd ms') (sourcenode ax) \\<and>\n     targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'", "obtain asx ax asx' where \"as' = asx @ ax # asx'\"\n            and \"\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n            and \"call_of_return_node (hd ms') (sourcenode ax)\"\n            and \"targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\""], ["proof (prove)\nusing this:\n  \\<exists>asx ax asx'.\n     as' = asx @ ax # asx' \\<and>\n     (\\<exists>Q r p fs.\n         kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (hd ms') (sourcenode ax) \\<and>\n     targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax asx'.\n        \\<lbrakk>as' = asx @ ax # asx';\n         \\<exists>Q r p fs.\n            kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         call_of_return_node (hd ms') (sourcenode ax);\n         targetnode\n          ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as' = asx @ ax # asx'\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode ax)\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>as' = asx @ ax # asx'\\<close>"], ["proof (chain)\npicking this:\n  as' = asx @ ax # asx'", "have \"as'@[a'] = asx @ ax # (asx' @ [a'])\""], ["proof (prove)\nusing this:\n  as' = asx @ ax # asx'\n\ngoal (1 subgoal):\n 1. as' @ [a'] = asx @ ax # asx' @ [a']", "by simp"], ["proof (state)\nthis:\n  as' @ [a'] = asx @ ax # asx' @ [a']\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "moreover"], ["proof (state)\nthis:\n  as' @ [a'] = asx @ ax # asx' @ [a']\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\\<close> \\<open>intra_kind (kind a')\\<close> \n            \\<open>m' = targetnode a'\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n  intra_kind (kind a')\n  m' = targetnode a'\n  valid_edge a'", "have \"targetnode ax -asx'@[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\""], ["proof (prove)\nusing this:\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n  intra_kind (kind a')\n  m' = targetnode a'\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. targetnode ax -asx' @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "by(fastforce intro:path_Append path_edge same_level_path_aux_Append \n              upd_cs_Append simp:slp_def same_level_path_def intra_kind_def)"], ["proof (state)\nthis:\n  targetnode ax -asx' @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "ultimately"], ["proof (chain)\npicking this:\n  as' @ [a'] = asx @ ax # asx' @ [a']\n  targetnode ax -asx' @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "show ?thesis"], ["proof (prove)\nusing this:\n  as' @ [a'] = asx @ ax # asx' @ [a']\n  targetnode ax -asx' @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "using \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \n            \\<open>call_of_return_node (hd ms') (sourcenode ax)\\<close> snoc"], ["proof (prove)\nusing this:\n  as' @ [a'] = asx @ ax # asx' @ [a']\n  targetnode ax -asx' @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode ax)\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "assume \"ms' = ms\""], ["proof (state)\nthis:\n  ms' = ms\n\ngoal (1 subgoal):\n 1. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  ms' = ms\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "by simp"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "case (Call Q r p fs)"], ["proof (state)\nthis:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with \\<open>S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain a''\n          where \"valid_edge a'\" and \"a'' \\<in> get_return_edges a'\"\n          and \"hd ms'' = sourcenode a'\" and \"m' = targetnode a'\"\n          and \"ms' = (targetnode a'')#tl ms''\" and \"length ms'' = length s''\"\n          and \"pred (kind a') s''\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a'; a'' \\<in> get_return_edges a';\n         hd ms'' = sourcenode a'; m' = targetnode a';\n         ms' = targetnode a'' # tl ms''; length ms'' = length s'';\n         pred (kind a') s''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a'\n  a'' \\<in> get_return_edges a'\n  hd ms'' = sourcenode a'\n  m' = targetnode a'\n  ms' = targetnode a'' # tl ms''\n  length ms'' = length s''\n  pred (kind a') s''\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "from \\<open>valid_edge a'\\<close> \\<open>a'' \\<in> get_return_edges a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  a'' \\<in> get_return_edges a'", "have \"valid_edge a''\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  a'' \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. valid_edge a''", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a''\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "from \\<open>valid_edge a''\\<close> \\<open>valid_edge a'\\<close> \\<open>a'' \\<in> get_return_edges a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  valid_edge a'\n  a'' \\<in> get_return_edges a'", "have \"return_node (targetnode a'')\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  valid_edge a'\n  a'' \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. return_node (targetnode a'')", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode a'')\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with \\<open>valid_edge a'\\<close> \\<open>valid_edge a''\\<close>\n          \\<open>a'' \\<in> get_return_edges a'\\<close> \\<open>ms' = (targetnode a'')#tl ms''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge a''\n  a'' \\<in> get_return_edges a'\n  ms' = targetnode a'' # tl ms''\n  return_node (targetnode a'')", "have \"call_of_return_node (hd ms') (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge a''\n  a'' \\<in> get_return_edges a'\n  ms' = targetnode a'' # tl ms''\n  return_node (targetnode a'')\n\ngoal (1 subgoal):\n 1. call_of_return_node (hd ms') (sourcenode a')", "by(simp add:call_of_return_node_def) blast"], ["proof (state)\nthis:\n  call_of_return_node (hd ms') (sourcenode a')\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with snoc \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>m' = targetnode a'\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m' = targetnode a'\n  valid_edge a'\n  call_of_return_node (hd ms') (sourcenode a')", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m' = targetnode a'\n  valid_edge a'\n  call_of_return_node (hd ms') (sourcenode a')\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "by(fastforce intro:empty_path simp:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with \\<open>S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"valid_edge a'\" and \"hd ms'' = sourcenode a'\"\n          and \"hd(tl ms'') = targetnode a'\" and \"m'#ms' = tl ms''\"\n          and \"length ms'' = length s''\" and \"length s'' = Suc(length s')\"\n          and \"s' \\<noteq> []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (valid_edge a' &&&\n     hd ms'' = sourcenode a' &&& hd (tl ms'') = targetnode a') &&&\n    (m' # ms' = tl ms'' &&& length ms'' = length s'') &&&\n    length s'' = Suc (length s') &&& s' \\<noteq> []", "by(auto elim:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a'\n  hd ms'' = sourcenode a'\n  hd (tl ms'') = targetnode a'\n  m' # ms' = tl ms''\n  length ms'' = length s''\n  length s'' = Suc (length s')\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "hence \"ms'' = sourcenode a' # targetnode a' # ms'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  hd ms'' = sourcenode a'\n  hd (tl ms'') = targetnode a'\n  m' # ms' = tl ms''\n  length ms'' = length s''\n  length s'' = Suc (length s')\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms'' = sourcenode a' # targetnode a' # ms'", "by(cases ms'') auto"], ["proof (state)\nthis:\n  ms'' = sourcenode a' # targetnode a' # ms'\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "with \\<open>length as' < length as\\<close> \\<open>S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<close> IH"], ["proof (chain)\npicking this:\n  length as' < length as\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>mx msx sx.\n         S,kind \\<turnstile> (m #\n                              ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                              msx,sx) \\<longrightarrow>\n         (\\<exists>asx a asx'.\n             as' = asx @ a # asx' \\<and>\n             (\\<exists>Q r p fs.\n                 kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n             call_of_return_node (hd msx) (sourcenode a) \\<and>\n             targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n         msx = ms)\n  ms'' = sourcenode a' # targetnode a' # ms'", "have \"(\\<exists>asx ax asx'. as' = asx @ ax # asx' \\<and> (\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n          call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n          targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or> ms = targetnode a' # ms'\""], ["proof (prove)\nusing this:\n  length as' < length as\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>mx msx sx.\n         S,kind \\<turnstile> (m #\n                              ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                              msx,sx) \\<longrightarrow>\n         (\\<exists>asx a asx'.\n             as' = asx @ a # asx' \\<and>\n             (\\<exists>Q r p fs.\n                 kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n             call_of_return_node (hd msx) (sourcenode a) \\<and>\n             targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n         msx = ms)\n  ms'' = sourcenode a' # targetnode a' # ms'\n\ngoal (1 subgoal):\n 1. (\\<exists>asx ax asx'.\n        as' = asx @ ax # asx' \\<and>\n        (\\<exists>Q r p fs.\n            kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n        targetnode\n         ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n    ms = targetnode a' # ms'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length as' < length as;\n     S,kind \\<turnstile> (m #\n                          ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n     \\<forall>as'.\n        length as' < length as \\<longrightarrow>\n        (\\<forall>mx msx sx.\n            S,kind \\<turnstile> (m #\n                                 ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                                 msx,sx) \\<longrightarrow>\n            (\\<exists>asx a asx'.\n                as' = asx @ a # asx' \\<and>\n                (\\<exists>Q r p fs.\n                    kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                call_of_return_node (hd msx) (sourcenode a) \\<and>\n                targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n            msx = ms);\n     ms'' = sourcenode a' # targetnode a' # ms'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>asx ax asx'.\n                          as' = asx @ ax # asx' \\<and>\n                          (\\<exists>Q r p fs.\n                              kind ax =\n                              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                          call_of_return_node (targetnode a')\n                           (sourcenode ax) \\<and>\n                          targetnode\n                           ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n                               a') \\<or>\n                      ms = targetnode a' # ms'", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length as' < length as;\n     S,kind \\<turnstile> (m #\n                          ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n     ms'' = sourcenode a' # targetnode a' # ms';\n     length as' < length as \\<longrightarrow>\n     (\\<forall>mx msx sx.\n         S,kind \\<turnstile> (m #\n                              ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                              msx,sx) \\<longrightarrow>\n         (\\<exists>asx a asx'.\n             as' = asx @ a # asx' \\<and>\n             (\\<exists>Q r p fs.\n                 kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n             call_of_return_node (hd msx) (sourcenode a) \\<and>\n             targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n         msx = ms)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>asx ax asx'.\n                          as' = asx @ ax # asx' \\<and>\n                          (\\<exists>Q r p fs.\n                              kind ax =\n                              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                          call_of_return_node (targetnode a')\n                           (sourcenode ax) \\<and>\n                          targetnode\n                           ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n                               a') \\<or>\n                      ms = targetnode a' # ms'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length as' < length as;\n     S,kind \\<turnstile> (m #\n                          ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                           a' #\n                          targetnode a' # ms',s'');\n     ms'' = sourcenode a' # targetnode a' # ms';\n     \\<forall>mx msx.\n        Ex (silent_moves S kind (m # ms) s as' (mx # msx)) \\<longrightarrow>\n        (\\<exists>asx a asx'.\n            as' = asx @ a # asx' \\<and>\n            (\\<exists>Q r p fs.\n                kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n            call_of_return_node (hd msx) (sourcenode a) \\<and>\n            targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n        msx = ms;\n     ms \\<noteq> targetnode a' # ms'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>asx ax asx'.\n                         as' = asx @ ax # asx' \\<and>\n                         (\\<exists>Q r p fs.\n                             kind ax =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                         call_of_return_node (targetnode a')\n                          (sourcenode ax) \\<and>\n                         targetnode\n                          ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n                              a'", "apply(erule_tac x=\"sourcenode a'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length as' < length as;\n     S,kind \\<turnstile> (m #\n                          ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                           a' #\n                          targetnode a' # ms',s'');\n     ms'' = sourcenode a' # targetnode a' # ms';\n     ms \\<noteq> targetnode a' # ms';\n     \\<forall>msx.\n        Ex (silent_moves S kind (m # ms) s as'\n             (sourcenode a' # msx)) \\<longrightarrow>\n        (\\<exists>asx a asx'.\n            as' = asx @ a # asx' \\<and>\n            (\\<exists>Q r p fs.\n                kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n            call_of_return_node (hd msx) (sourcenode a) \\<and>\n            targetnode\n             a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n        msx = ms\\<rbrakk>\n    \\<Longrightarrow> \\<exists>asx ax asx'.\n                         as' = asx @ ax # asx' \\<and>\n                         (\\<exists>Q r p fs.\n                             kind ax =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                         call_of_return_node (targetnode a')\n                          (sourcenode ax) \\<and>\n                         targetnode\n                          ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n                              a'", "apply(erule_tac x=\"targetnode a' # ms'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length as' < length as;\n     S,kind \\<turnstile> (m #\n                          ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                           a' #\n                          targetnode a' # ms',s'');\n     ms'' = sourcenode a' # targetnode a' # ms';\n     ms \\<noteq> targetnode a' # ms';\n     Ex (silent_moves S kind (m # ms) s as'\n          (sourcenode a' # targetnode a' # ms')) \\<longrightarrow>\n     (\\<exists>asx a asx'.\n         as' = asx @ a # asx' \\<and>\n         (\\<exists>Q r p fs.\n             kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n         call_of_return_node (hd (targetnode a' # ms'))\n          (sourcenode a) \\<and>\n         targetnode\n          a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n     targetnode a' # ms' = ms\\<rbrakk>\n    \\<Longrightarrow> \\<exists>asx ax asx'.\n                         as' = asx @ ax # asx' \\<and>\n                         (\\<exists>Q r p fs.\n                             kind ax =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                         call_of_return_node (targetnode a')\n                          (sourcenode ax) \\<and>\n                         targetnode\n                          ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n                              a'", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>asx ax asx'.\n      as' = asx @ ax # asx' \\<and>\n      (\\<exists>Q r p fs.\n          kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n      targetnode\n       ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n  ms = targetnode a' # ms'\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       (\\<exists>as' a as''.\n           as = as' @ a # as'' \\<and>\n           (\\<exists>Q r p fs.\n               kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n           call_of_return_node (hd ms') (sourcenode a) \\<and>\n           targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n       ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>asx ax asx'.\n      as' = asx @ ax # asx' \\<and>\n      (\\<exists>Q r p fs.\n          kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n      targetnode\n       ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a') \\<or>\n  ms = targetnode a' # ms'\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "assume \"\\<exists>asx ax asx'. as' = asx @ ax # asx' \\<and> \n            (\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n            call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n            targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\""], ["proof (state)\nthis:\n  \\<exists>asx ax asx'.\n     as' = asx @ ax # asx' \\<and>\n     (\\<exists>Q r p fs.\n         kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n     targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "then"], ["proof (chain)\npicking this:\n  \\<exists>asx ax asx'.\n     as' = asx @ ax # asx' \\<and>\n     (\\<exists>Q r p fs.\n         kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n     targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'", "obtain asx ax asx' where \"as' = asx @ ax # asx'\"\n            and \"\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \n            and \"call_of_return_node (targetnode a') (sourcenode ax)\"\n            and \"targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\""], ["proof (prove)\nusing this:\n  \\<exists>asx ax asx'.\n     as' = asx @ ax # asx' \\<and>\n     (\\<exists>Q r p fs.\n         kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n     targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax asx'.\n        \\<lbrakk>as' = asx @ ax # asx';\n         \\<exists>Q r p fs.\n            kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         call_of_return_node (targetnode a') (sourcenode ax);\n         targetnode\n          ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as' = asx @ ax # asx'\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (targetnode a') (sourcenode ax)\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>as' = asx @ ax # asx'\\<close> snoc"], ["proof (chain)\npicking this:\n  as' = asx @ ax # asx'\n  as = as' @ [a']", "have\"length asx < length as\""], ["proof (prove)\nusing this:\n  as' = asx @ ax # asx'\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. length asx < length as", "by simp"], ["proof (state)\nthis:\n  length asx < length as\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "moreover"], ["proof (state)\nthis:\n  length asx < length as\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> snoc \\<open>as' = asx @ ax # asx'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = as' @ [a']\n  as' = asx @ ax # asx'", "obtain msx sx where \"S,kind \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\"\n            and \"S,kind \\<turnstile> (msx,sx) =ax#asx'@[a']\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = as' @ [a']\n  as' = asx @ ax # asx'\n\ngoal (1 subgoal):\n 1. (\\<And>msx sx.\n        \\<lbrakk>S,kind \\<turnstile> (m #\nms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx);\n         S,kind \\<turnstile> (msx,sx) =ax #\n asx' @ [a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves_split)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,kind \\<turnstile> (msx,sx) =ax #\n                                asx' @\n                                [a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (msx,sx) =ax#asx'@[a']\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (msx,sx) =ax #\n                                asx' @\n                                [a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "obtain xs x ys y where \"S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x)\"\n            and \"S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y)\"\n            and \"S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (msx,sx) =ax #\n                                asx' @\n                                [a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>xs x ys y.\n        \\<lbrakk>S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x);\n         S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y);\n         S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs x ys y.\n                \\<lbrakk>S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x);\n                 S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y);\n                 S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n ms',s')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     S,kind \\<turnstile> (msx,sx) =ax #\n                                   asx' @\n                                   [a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s')\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule silent_moves.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ms s Sa f.\n       \\<lbrakk>\\<And>xs x ys y.\n                   \\<lbrakk>S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x);\n                    S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y);\n                    S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n    ms',s')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        S = Sa; kind = f; msx = ms; sx = s; ax # asx' @ [a'] = [];\n        m' # ms' = ms; s' = s; length ms = length s\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>Sa f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>\\<And>xs x ys y.\n                   \\<lbrakk>S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x);\n                    S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y);\n                    S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n    ms',s')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        S = Sa; kind = f; msx = ms; sx = s; ax # asx' @ [a'] = a # as;\n        m' # ms' = ms''; s' = s'';\n        Sa,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        Sa,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ms' s'.\n       \\<lbrakk>\\<And>xs x ys y.\n                   \\<lbrakk>S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x);\n                    S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y);\n                    S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n    ms',s')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =asx' @\n[a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(erule silent_moves_split) auto"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x)\n  S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y)\n  S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x)\\<close> \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x)\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain msx' ax' where \"msx = sourcenode ax#msx'\" \n            and \"ax' \\<in> get_return_edges ax\"\n            and [simp]:\"xs = (targetnode ax)#(targetnode ax')#msx'\"\n            and \"length x = Suc(length sx)\" and \"length msx = length sx\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x)\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>msx' ax'.\n        \\<lbrakk>msx = sourcenode ax # msx'; ax' \\<in> get_return_edges ax;\n         xs = targetnode ax # targetnode ax' # msx';\n         length x = Suc (length sx); length msx = length sx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>msx' ax'.\n                \\<lbrakk>msx = sourcenode ax # msx';\n                 ax' \\<in> get_return_edges ax;\n                 xs = targetnode ax # targetnode ax' # msx';\n                 length x = Suc (length sx); length msx = length sx\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     S,kind \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (xs,x);\n     \\<exists>Q r p fs.\n        kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule silent_move.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms Sa ms'.\n       \\<lbrakk>\\<And>msx' ax'.\n                   \\<lbrakk>msx = sourcenode ax # msx';\n                    ax' \\<in> get_return_edges ax;\n                    xs = targetnode ax # targetnode ax' # msx';\n                    length x = Suc (length sx);\n                    length msx = length sx\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; msx = ms; sx = s; ax = a; xs = ms'; x = s';\n        pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>f a s s' Q r p fs a' ms Sa ms'.\n       \\<lbrakk>\\<And>msx' ax'.\n                   \\<lbrakk>msx = sourcenode ax # msx';\n                    ax' \\<in> get_return_edges ax;\n                    xs = targetnode ax # targetnode ax' # msx';\n                    length x = Suc (length sx);\n                    length msx = length sx\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; msx = ms; sx = s; ax = a; xs = ms'; x = s';\n        pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>f a s s' Q p f' ms Sa ms'.\n       \\<lbrakk>\\<And>msx' ax'.\n                   \\<lbrakk>msx = sourcenode ax # msx';\n                    ax' \\<in> get_return_edges ax;\n                    xs = targetnode ax # targetnode ax' # msx';\n                    length x = Suc (length sx);\n                    length msx = length sx\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; msx = ms; sx = s; ax = a; xs = ms'; x = s';\n        pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:intra_kind_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs a' m m'.\n       \\<lbrakk>\\<And>msx' ax'.\n                   \\<lbrakk>msx = sourcenode ax # msx';\n                    ax' \\<in> get_return_edges ax;\n                    targetnode a' = targetnode ax';\n                    Suc (length msx') = length sx\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        xs = targetnode ax # targetnode a' # tl msx;\n        pred (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) sx; valid_edge ax;\n        kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges ax; Ball (set (tl msx)) return_node;\n        length msx = length sx;\n        length (transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) sx) =\n        Suc (length sx);\n        hd msx = sourcenode ax;\n        x = transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) sx;\n        m \\<in> set (tl msx); call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>Q r p fs a'.\n       \\<lbrakk>\\<And>msx' ax'.\n                   \\<lbrakk>msx = sourcenode ax # msx';\n                    ax' \\<in> get_return_edges ax;\n                    targetnode a' = targetnode ax';\n                    Suc (length msx') = length sx\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        xs = targetnode ax # targetnode a' # tl msx;\n        pred (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) sx; valid_edge ax;\n        kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges ax; Ball (set (tl msx)) return_node;\n        length msx = length sx;\n        length (transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) sx) =\n        Suc (length sx);\n        hd msx = sourcenode ax;\n        x = transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) sx;\n        sourcenode ax\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases msx,auto)+"], ["proof (state)\nthis:\n  msx = sourcenode ax # msx'\n  ax' \\<in> get_return_edges ax\n  xs = targetnode ax # targetnode ax' # msx'\n  length x = Suc (length sx)\n  length msx = length sx\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "obtain msy \n            where \"ys = sourcenode a'#msy\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>msy.\n        ys = sourcenode a' # msy \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>msy. ys = sourcenode a' # msy \\<Longrightarrow> thesis;\n     S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule silent_moves.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ms s Sa f.\n       \\<lbrakk>\\<And>msy.\n                   ys = sourcenode a' # msy \\<Longrightarrow> thesis;\n        S = Sa; kind = f; ys = ms; y = s; [a'] = []; m' # ms' = ms; s' = s;\n        length ms = length s\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>Sa f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>\\<And>msy.\n                   ys = sourcenode a' # msy \\<Longrightarrow> thesis;\n        S = Sa; kind = f; ys = ms; y = s; [a'] = a # as; m' # ms' = ms'';\n        s' = s'';\n        Sa,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        Sa,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ms' s'.\n       \\<lbrakk>\\<And>msy.\n                   ys = sourcenode a' # msy \\<Longrightarrow> thesis;\n        S,kind \\<turnstile> (ys,y) -a'\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =[]\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s')\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(erule silent_move.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ms' s' f a s s'aa ms Sa ms'aa.\n       \\<lbrakk>\\<And>msy.\n                   ys = sourcenode a' # msy \\<Longrightarrow> thesis;\n        S,kind \\<turnstile> (ms',s') =[]\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n        S = Sa; kind = f; ys = ms; y = s; a' = a; ms' = ms'aa; s' = s'aa;\n        pred (f a) s; transfer (f a) s = s'aa; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s'aa = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms'aa = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ms' s' f a s s'aa Q r p fs a'a ms Sa ms'aa.\n       \\<lbrakk>\\<And>msy.\n                   ys = sourcenode a' # msy \\<Longrightarrow> thesis;\n        S,kind \\<turnstile> (ms',s') =[]\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n        S = Sa; kind = f; ys = ms; y = s; a' = a; ms' = ms'aa; s' = s'aa;\n        pred (f a) s; transfer (f a) s = s'aa; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a'a;\n        a'a \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s'aa = Suc (length s); hd ms = sourcenode a;\n        ms'aa = targetnode a # targetnode a'a # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ms' s' f a s s'aa Q p f' ms Sa ms'aa.\n       \\<lbrakk>\\<And>msy.\n                   ys = sourcenode a' # msy \\<Longrightarrow> thesis;\n        S,kind \\<turnstile> (ms',s') =[]\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n        S = Sa; kind = f; ys = ms; y = s; a' = a; ms' = ms'aa; s' = s'aa;\n        pred (f a) s; transfer (f a) s = s'aa; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'aa); s'aa \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms'aa = tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases ys,auto)+"], ["proof (state)\nthis:\n  ys = sourcenode a' # msy\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y)\\<close> \n            \\<open>targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\\<close>\n            \\<open>xs = (targetnode ax)#(targetnode ax')#msx'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y)\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n  xs = targetnode ax # targetnode ax' # msx'\n  ys = sourcenode a' # msy", "have \"(targetnode ax')#msx' = msy\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (xs,x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (ys,y)\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n  xs = targetnode ax # targetnode ax' # msx'\n  ys = sourcenode a' # msy\n\ngoal (1 subgoal):\n 1. targetnode ax' # msx' = msy", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (targetnode ax #\n                                  targetnode ax' #\n                                  msx',x) =asx'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\na' #\n                                     msy,y);\n     targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a';\n     ys = sourcenode a' # msy\\<rbrakk>\n    \\<Longrightarrow> targetnode ax' # msx' = msy", "by(fastforce intro:silent_moves_same_level_path)"], ["proof (state)\nthis:\n  targetnode ax' # msx' = msy\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \n            \\<open>ys = sourcenode a'#msy\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  ys = sourcenode a' # msy\n  targetnode ax' # msx' = msy", "have \"m' = targetnode a'\" and \"msx' = ms'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ys,y) =[a']\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  ys = sourcenode a' # msy\n  targetnode ax' # msx' = msy\n\ngoal (1 subgoal):\n 1. m' = targetnode a' &&& msx' = ms'", "by(fastforce elim:silent_moves.cases silent_move.cases \n                        simp:intra_kind_def)+"], ["proof (state)\nthis:\n  m' = targetnode a'\n  msx' = ms'\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>S,kind \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\\<close> \\<open>msx = sourcenode ax#msx'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  msx = sourcenode ax # msx'\n  m' = targetnode a'\n  msx' = ms'", "have \"S,kind \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (sourcenode ax#ms',sx)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  msx = sourcenode ax # msx'\n  m' = targetnode a'\n  msx' = ms'\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (m #\n                         ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                          ax #\n                         ms',sx)", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (m #\n                       ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (sourcenode ax #\n                       ms',sx)\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "ultimately"], ["proof (chain)\npicking this:\n  length asx < length as\n  S,kind \\<turnstile> (m #\n                       ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (sourcenode ax #\n                       ms',sx)", "have \"(\\<exists>xs x xs'. asx = xs@x#xs' \\<and> \n            (\\<exists>Q r p fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n            call_of_return_node (hd ms') (sourcenode x) \\<and>\n            targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax) \\<or> ms = ms'\""], ["proof (prove)\nusing this:\n  length asx < length as\n  S,kind \\<turnstile> (m #\n                       ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (sourcenode ax #\n                       ms',sx)\n\ngoal (1 subgoal):\n 1. (\\<exists>xs x xs'.\n        asx = xs @ x # xs' \\<and>\n        (\\<exists>Q r p fs.\n            kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode x) \\<and>\n        targetnode\n         x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax) \\<or>\n    ms = ms'", "using IH"], ["proof (prove)\nusing this:\n  length asx < length as\n  S,kind \\<turnstile> (m #\n                       ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (sourcenode ax #\n                       ms',sx)\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>mx msx sx.\n         S,kind \\<turnstile> (m #\n                              ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (mx #\n                              msx,sx) \\<longrightarrow>\n         (\\<exists>asx a asx'.\n             as' = asx @ a # asx' \\<and>\n             (\\<exists>Q r p fs.\n                 kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n             call_of_return_node (hd msx) (sourcenode a) \\<and>\n             targetnode a -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* mx) \\<or>\n         msx = ms)\n\ngoal (1 subgoal):\n 1. (\\<exists>xs x xs'.\n        asx = xs @ x # xs' \\<and>\n        (\\<exists>Q r p fs.\n            kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode x) \\<and>\n        targetnode\n         x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax) \\<or>\n    ms = ms'", "by simp blast"], ["proof (state)\nthis:\n  (\\<exists>xs x xs'.\n      asx = xs @ x # xs' \\<and>\n      (\\<exists>Q r p fs.\n          kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode x) \\<and>\n      targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax) \\<or>\n  ms = ms'\n\ngoal (2 subgoals):\n 1. \\<exists>asx ax asx'.\n       as' = asx @ ax # asx' \\<and>\n       (\\<exists>Q r p fs.\n           kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (targetnode a') (sourcenode ax) \\<and>\n       targetnode\n        ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n            a' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>xs x xs'.\n      asx = xs @ x # xs' \\<and>\n      (\\<exists>Q r p fs.\n          kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode x) \\<and>\n      targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax) \\<or>\n  ms = ms'\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "assume \"\\<exists>xs x xs'. asx = xs@x#xs' \\<and> (\\<exists>Q r p fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n              call_of_return_node (hd ms') (sourcenode x) \\<and>\n              targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\""], ["proof (state)\nthis:\n  \\<exists>xs x xs'.\n     asx = xs @ x # xs' \\<and>\n     (\\<exists>Q r p fs.\n         kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (hd ms') (sourcenode x) \\<and>\n     targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs x xs'.\n     asx = xs @ x # xs' \\<and>\n     (\\<exists>Q r p fs.\n         kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (hd ms') (sourcenode x) \\<and>\n     targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax", "obtain xs x xs' where \"asx = xs@x#xs'\"\n              and \"\\<exists>Q r p fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \n              and \"call_of_return_node (hd ms') (sourcenode x)\"\n              and \"targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\""], ["proof (prove)\nusing this:\n  \\<exists>xs x xs'.\n     asx = xs @ x # xs' \\<and>\n     (\\<exists>Q r p fs.\n         kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     call_of_return_node (hd ms') (sourcenode x) \\<and>\n     targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\n\ngoal (1 subgoal):\n 1. (\\<And>xs x xs'.\n        \\<lbrakk>asx = xs @ x # xs';\n         \\<exists>Q r p fs.\n            kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         call_of_return_node (hd ms') (sourcenode x);\n         targetnode\n          x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  asx = xs @ x # xs'\n  \\<exists>Q r p fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode x)\n  targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>asx = xs@x#xs'\\<close> \\<open>as' = asx @ ax # asx'\\<close> snoc"], ["proof (chain)\npicking this:\n  asx = xs @ x # xs'\n  as' = asx @ ax # asx'\n  as = as' @ [a']", "have \"as = xs@x#(xs'@ax#asx'@[a'])\""], ["proof (prove)\nusing this:\n  asx = xs @ x # xs'\n  as' = asx @ ax # asx'\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. as = xs @ x # xs' @ ax # asx' @ [a']", "by simp"], ["proof (state)\nthis:\n  as = xs @ x # xs' @ ax # asx' @ [a']\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>valid_node m\\<close> rest"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs", "have \"m -as\\<rightarrow>* m'\" and \"valid_path_aux cs as\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* m' &&& valid_path_aux cs as", "by(auto dest:silent_moves_vpa_path[of _ _ _ _ _ _ _ _ _ rs cs]\n                      simp:valid_call_list_def valid_return_list_def targetnodes_def)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* m'\n  valid_path_aux cs as\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "hence \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>* m'\n  valid_path_aux cs as\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<surd>* m'", "by(fastforce intro:valid_path_aux_valid_path simp:vp_def)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with snoc"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'", "have \"m -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\""], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (1 subgoal):\n 1. m -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'", "by(auto elim:path_split_snoc dest:valid_path_aux_split \n                simp:vp_def valid_path_def)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>as' = asx @ ax # asx'\\<close>"], ["proof (chain)\npicking this:\n  as' = asx @ ax # asx'\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'", "have \"valid_edge ax\" and \"targetnode ax -asx'\\<rightarrow>* sourcenode a'\""], ["proof (prove)\nusing this:\n  as' = asx @ ax # asx'\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n\ngoal (1 subgoal):\n 1. valid_edge ax &&& targetnode ax -asx'\\<rightarrow>* sourcenode a'", "by(auto dest:path_split simp:vp_def)"], ["proof (state)\nthis:\n  valid_edge ax\n  targetnode ax -asx'\\<rightarrow>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "hence \"sourcenode ax -ax#asx'\\<rightarrow>* sourcenode a'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  targetnode ax -asx'\\<rightarrow>* sourcenode a'\n\ngoal (1 subgoal):\n 1. sourcenode ax -ax # asx'\\<rightarrow>* sourcenode a'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  sourcenode ax -ax # asx'\\<rightarrow>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'", "have \"sourcenode a' -[a']\\<rightarrow>* targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. sourcenode a' -[a']\\<rightarrow>* targetnode a'", "by(rule path_edge)"], ["proof (state)\nthis:\n  sourcenode a' -[a']\\<rightarrow>* targetnode a'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>sourcenode ax -ax#asx'\\<rightarrow>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax -ax # asx'\\<rightarrow>* sourcenode a'\n  sourcenode a' -[a']\\<rightarrow>* targetnode a'", "have \"sourcenode ax -(ax#asx')@[a']\\<rightarrow>* targetnode a'\""], ["proof (prove)\nusing this:\n  sourcenode ax -ax # asx'\\<rightarrow>* sourcenode a'\n  sourcenode a' -[a']\\<rightarrow>* targetnode a'\n\ngoal (1 subgoal):\n 1. sourcenode ax -(ax # asx') @ [a']\\<rightarrow>* targetnode a'", "by(rule path_Append)"], ["proof (state)\nthis:\n  sourcenode ax -(ax # asx') @ [a']\\<rightarrow>* targetnode a'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* m'\\<close> snoc \\<open>as' = asx @ ax # asx'\\<close> snoc"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n  as = as' @ [a']\n  as' = asx @ ax # asx'\n  as = as' @ [a']", "have \"valid_path_aux ([]@(upd_cs [] asx)) (ax # asx' @ [a'])\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n  as = as' @ [a']\n  as' = asx @ ax # asx'\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. valid_path_aux ([] @ upd_cs [] asx) (ax # asx' @ [a'])", "by(fastforce dest:valid_path_aux_split simp:vp_def valid_path_def)"], ["proof (state)\nthis:\n  valid_path_aux ([] @ upd_cs [] asx) (ax # asx' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "hence \"valid_path_aux [] (ax#asx'@[a'])\""], ["proof (prove)\nusing this:\n  valid_path_aux ([] @ upd_cs [] asx) (ax # asx' @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path_aux [] (ax # asx' @ [a'])", "by(rule valid_path_aux_callstack_prefix)"], ["proof (state)\nthis:\n  valid_path_aux [] (ax # asx' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux [] (ax # asx' @ [a'])", "have \"valid_path_aux [ax] (asx'@[a'])\""], ["proof (prove)\nusing this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux [] (ax # asx' @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path_aux [ax] (asx' @ [a'])", "by fastforce"], ["proof (state)\nthis:\n  valid_path_aux [ax] (asx' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "hence \"valid_path_aux (upd_cs [ax] asx') [a']\""], ["proof (prove)\nusing this:\n  valid_path_aux [ax] (asx' @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs [ax] asx') [a']", "by(rule valid_path_aux_split)"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs [ax] asx') [a']\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'", "have \"same_level_path_aux [] asx'\" and \"upd_cs [] asx' = []\""], ["proof (prove)\nusing this:\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] asx' &&& upd_cs [] asx' = []", "by(simp_all add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] asx'\n  upd_cs [] asx' = []\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "hence \"upd_cs ([]@[ax]) asx' = []@[ax]\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] asx'\n  upd_cs [] asx' = []\n\ngoal (1 subgoal):\n 1. upd_cs ([] @ [ax]) asx' = [] @ [ax]", "by(rule same_level_path_upd_cs_callstack_Append)"], ["proof (state)\nthis:\n  upd_cs ([] @ [ax]) asx' = [] @ [ax]\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>valid_path_aux (upd_cs [ax] asx') [a']\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs [ax] asx') [a']\n  upd_cs ([] @ [ax]) asx' = [] @ [ax]", "have \"valid_path_aux [ax] [a']\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs [ax] asx') [a']\n  upd_cs ([] @ [ax]) asx' = [] @ [ax]\n\ngoal (1 subgoal):\n 1. valid_path_aux [ax] [a']", "by(simp del:valid_path_aux.simps)"], ["proof (state)\nthis:\n  valid_path_aux [ax] [a']\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_aux [ax] [a']", "have \"a' \\<in> get_return_edges ax\""], ["proof (prove)\nusing this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_aux [ax] [a']\n\ngoal (1 subgoal):\n 1. a' \\<in> get_return_edges ax", "by simp"], ["proof (state)\nthis:\n  a' \\<in> get_return_edges ax\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>upd_cs ([]@[ax]) asx' = []@[ax]\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  upd_cs ([] @ [ax]) asx' = [] @ [ax]\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges ax", "have \"upd_cs [ax] (asx'@[a']) = []\""], ["proof (prove)\nusing this:\n  upd_cs ([] @ [ax]) asx' = [] @ [ax]\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. upd_cs [ax] (asx' @ [a']) = []", "by(fastforce intro:upd_cs_Append)"], ["proof (state)\nthis:\n  upd_cs [ax] (asx' @ [a']) = []\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs [ax] (asx' @ [a']) = []", "have \"upd_cs [] (ax#asx'@[a']) = []\""], ["proof (prove)\nusing this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs [ax] (asx' @ [a']) = []\n\ngoal (1 subgoal):\n 1. upd_cs [] (ax # asx' @ [a']) = []", "by fastforce"], ["proof (state)\nthis:\n  upd_cs [] (ax # asx' @ [a']) = []\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'", "have \"same_level_path_aux [] asx'\" and \"upd_cs [] asx' = []\""], ["proof (prove)\nusing this:\n  targetnode ax -asx'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode a'\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] asx' &&& upd_cs [] asx' = []", "by(simp_all add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] asx'\n  upd_cs [] asx' = []\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "hence \"same_level_path_aux ([]@[ax]) asx'\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] asx'\n  upd_cs [] asx' = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux ([] @ [ax]) asx'", "by -(rule same_level_path_aux_callstack_Append)"], ["proof (state)\nthis:\n  same_level_path_aux ([] @ [ax]) asx'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \n              \\<open>a' \\<in> get_return_edges ax\\<close> \\<open>upd_cs ([]@[ax]) asx' = []@[ax]\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges ax\n  upd_cs ([] @ [ax]) asx' = [] @ [ax]\n  same_level_path_aux ([] @ [ax]) asx'", "have \"same_level_path_aux [] ((ax#asx')@[a'])\""], ["proof (prove)\nusing this:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges ax\n  upd_cs ([] @ [ax]) asx' = [] @ [ax]\n  same_level_path_aux ([] @ [ax]) asx'\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ((ax # asx') @ [a'])", "by(fastforce intro:same_level_path_aux_Append)"], ["proof (state)\nthis:\n  same_level_path_aux [] ((ax # asx') @ [a'])\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>upd_cs [] (ax#asx'@[a']) = []\\<close>\n              \\<open>sourcenode ax -(ax#asx')@[a']\\<rightarrow>* targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [] (ax # asx' @ [a']) = []\n  sourcenode ax -(ax # asx') @ [a']\\<rightarrow>* targetnode a'\n  same_level_path_aux [] ((ax # asx') @ [a'])", "have \"sourcenode ax -(ax#asx')@[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\""], ["proof (prove)\nusing this:\n  upd_cs [] (ax # asx' @ [a']) = []\n  sourcenode ax -(ax # asx') @ [a']\\<rightarrow>* targetnode a'\n  same_level_path_aux [] ((ax # asx') @ [a'])\n\ngoal (1 subgoal):\n 1. sourcenode\n     ax -(ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'", "by(simp add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  sourcenode\n   ax -(ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\n  sourcenode\n   ax -(ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'", "have \"targetnode x -xs'@((ax#asx')@[a'])\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\""], ["proof (prove)\nusing this:\n  targetnode x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode ax\n  sourcenode\n   ax -(ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n\ngoal (1 subgoal):\n 1. targetnode\n     x -xs' @\n        (ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'", "by(rule slp_Append)"], ["proof (state)\nthis:\n  targetnode\n   x -xs' @ (ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n\ngoal (2 subgoals):\n 1. \\<exists>xs x xs'.\n       asx = xs @ x # xs' \\<and>\n       (\\<exists>Q r p fs.\n           kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       call_of_return_node (hd ms') (sourcenode x) \\<and>\n       targetnode\n        x -xs'\\<rightarrow>\\<^bsub>sl\\<^esub>* sourcenode\n          ax \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms\n 2. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>\\<exists>Q r p fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \n              \\<open>call_of_return_node (hd ms') (sourcenode x)\\<close>\n              \\<open>as = xs@x#(xs'@ax#asx'@[a'])\\<close> \\<open>m' = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>Q r p fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode x)\n  as = xs @ x # xs' @ ax # asx' @ [a']\n  m' = targetnode a'\n  targetnode\n   x -xs' @ (ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Q r p fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode x)\n  as = xs @ x # xs' @ ax # asx' @ [a']\n  m' = targetnode a'\n  targetnode\n   x -xs' @ (ax # asx') @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "by simp blast"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "assume \"ms = ms'\""], ["proof (state)\nthis:\n  ms = ms'\n\ngoal (1 subgoal):\n 1. ms = ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  ms = ms'\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "by simp"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "assume \"ms = targetnode a' # ms'\""], ["proof (state)\nthis:\n  ms = targetnode a' # ms'\n\ngoal (1 subgoal):\n 1. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n            \\<open>ms'' = sourcenode a' # targetnode a' # ms'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  ms'' = sourcenode a' # targetnode a' # ms'", "have \"\\<exists>m \\<in> set (targetnode a' # ms'). \\<exists>m'. call_of_return_node m m' \\<and> \n            m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') -a'\\<rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  ms'' = sourcenode a' # targetnode a' # ms'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (targetnode a' # ms').\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce elim!:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (targetnode a' # ms').\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "with \\<open>ms = targetnode a' # ms'\\<close> callstack"], ["proof (chain)\npicking this:\n  ms = targetnode a' # ms'\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<exists>m\\<in>set (targetnode a' # ms').\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have False"], ["proof (prove)\nusing this:\n  ms = targetnode a' # ms'\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<exists>m\\<in>set (targetnode a' # ms').\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ms = targetnode a' # ms' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n    ms' = ms", "by simp"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m') \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_called_node_in_slice1_hd_nodestack_in_slice1:\n  assumes \"S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and \"CFG_node m' \\<in> sum_SDG_slice1 nx\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" and \"ms = targetnodes rs\"\n  and \"valid_return_list rs m\" and \"length rs = length cs\"\n  obtains as' a as'' where \"as = as'@a#as''\" and \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"call_of_return_node (hd ms') (sourcenode a)\"\n  and \"targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\" and \"CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\"\n  | \"ms' = ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as' a as''.\n                \\<lbrakk>as = as' @ a # as'';\n                 \\<exists>Q r p fs.\n                    kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n                 call_of_return_node (hd ms') (sourcenode a);\n                 targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n                 CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ms' = ms \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>valid_node m\\<close>\n    \\<open>\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\\<close> \\<open>ms = targetnodes rs\\<close>\n    \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs", "have \"m -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* m'", "by(auto dest:silent_moves_vpa_path[of _ _ _ _ _ _ _ _ _ rs cs]\n            simp:valid_call_list_def valid_return_list_def targetnodes_def)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>valid_node m\\<close>\n    \\<open>\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\\<close> \\<open>ms = targetnodes rs\\<close>\n    \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs", "show \"(\\<exists>as' a as''. as = as' @ a # as'' \\<and> (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n    call_of_return_node (hd ms') (sourcenode a) \\<and> targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n    CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or> ms' = ms\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "proof(rule silent_moves_call_edge)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd ms') (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                             CFG_node (sourcenode a)\n                             \\<in> sum_SDG_slice1 nx) \\<or>\n                         ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "fix as' a as''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd ms') (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                             CFG_node (sourcenode a)\n                             \\<in> sum_SDG_slice1 nx) \\<or>\n                         ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "assume \"as = as'@a#as''\" and \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"call_of_return_node (hd ms') (sourcenode a)\"\n      and \"targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\""], ["proof (state)\nthis:\n  as = as' @ a # as''\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode a)\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd ms') (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                             CFG_node (sourcenode a)\n                             \\<in> sum_SDG_slice1 nx) \\<or>\n                         ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "from \\<open>\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q r p fs \n      where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd ms') (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                             CFG_node (sourcenode a)\n                             \\<in> sum_SDG_slice1 nx) \\<or>\n                         ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "from \\<open>targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "obtain asx where \"targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule same_level_path_inner_path)"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd ms') (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                             CFG_node (sourcenode a)\n                             \\<in> sum_SDG_slice1 nx) \\<or>\n                         ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "from \\<open>m -as\\<rightarrow>* m'\\<close> \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>* m'\n  as = as' @ a # as''", "have \"valid_edge a\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>* m'\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. valid_edge a", "by(fastforce dest:path_split simp:vp_def)"], ["proof (state)\nthis:\n  valid_edge a\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd ms') (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                             CFG_node (sourcenode a)\n                             \\<in> sum_SDG_slice1 nx) \\<or>\n                         ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "have \"m' \\<noteq> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<noteq> (_Exit_)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m' = (_Exit_) \\<Longrightarrow> False", "assume \"m' = (_Exit_)\""], ["proof (state)\nthis:\n  m' = (_Exit_)\n\ngoal (1 subgoal):\n 1. m' = (_Exit_) \\<Longrightarrow> False", "have \"get_proc (_Exit_) = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc (_Exit_) = Main", "by(rule get_proc_Exit)"], ["proof (state)\nthis:\n  get_proc (_Exit_) = Main\n\ngoal (1 subgoal):\n 1. m' = (_Exit_) \\<Longrightarrow> False", "from \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'", "have \"get_proc (targetnode a) = get_proc m'\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc m'", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = get_proc m'\n\ngoal (1 subgoal):\n 1. m' = (_Exit_) \\<Longrightarrow> False", "with \\<open>m' = (_Exit_)\\<close> \\<open>get_proc (_Exit_) = Main\\<close>"], ["proof (chain)\npicking this:\n  m' = (_Exit_)\n  get_proc (_Exit_) = Main\n  get_proc (targetnode a) = get_proc m'", "have \"get_proc (targetnode a) = Main\""], ["proof (prove)\nusing this:\n  m' = (_Exit_)\n  get_proc (_Exit_) = Main\n  get_proc (targetnode a) = get_proc m'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (targetnode a) = Main\n\ngoal (1 subgoal):\n 1. m' = (_Exit_) \\<Longrightarrow> False", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  get_proc (targetnode a) = Main", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  get_proc (targetnode a) = Main\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "by(fastforce dest:get_proc_call)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (1 subgoal):\n 1. m' = (_Exit_) \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m' \\<noteq> (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd ms') (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             (\\<exists>Q r p fs.\n                                 kind a =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             call_of_return_node (hd ms')\n                              (sourcenode a) \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n                             CFG_node (sourcenode a)\n                             \\<in> sum_SDG_slice1 nx) \\<or>\n                         ms' = ms\n 2. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "proof(cases \"targetnode a = m'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a = m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms\n 2. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "case True"], ["proof (state)\nthis:\n  targetnode a = m'\n\ngoal (2 subgoals):\n 1. targetnode a = m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms\n 2. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m'", "have \"CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m'\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m'", "by(fastforce intro:sum_SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m'\n\ngoal (2 subgoals):\n 1. targetnode a = m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms\n 2. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "with \\<open>CFG_node m' \\<in> sum_SDG_slice1 nx\\<close>"], ["proof (chain)\npicking this:\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n  CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m'", "have \"CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\""], ["proof (prove)\nusing this:\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n  CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m'\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx", "by -(rule call_slice1)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n\ngoal (2 subgoals):\n 1. targetnode a = m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms\n 2. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "with \\<open>as = as'@a#as''\\<close> \\<open>\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n        \\<open>call_of_return_node (hd ms') (sourcenode a)\\<close>\n        \\<open>targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode a)\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode a)\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n      CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq> m'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "with \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>m' \\<noteq> (_Exit_)\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  m' \\<noteq> (_Exit_)\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a \\<noteq> m'", "obtain ns where \"CFG_node (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m'\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  m' \\<noteq> (_Exit_)\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a \\<noteq> m'\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node\n         (targetnode\n           a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:in_proc_cdep_SDG_path)"], ["proof (state)\nthis:\n  CFG_node (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "hence \"CFG_node (targetnode a) is-ns\\<rightarrow>\\<^sub>d* CFG_node m'\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m'\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a) is-ns\\<rightarrow>\\<^sub>d* CFG_node m'", "by(fastforce intro:intra_SDG_path_is_SDG_path cdep_SDG_path_intra_SDG_path)"], ["proof (state)\nthis:\n  CFG_node (targetnode a) is-ns\\<rightarrow>\\<^sub>d* CFG_node m'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "with \\<open>CFG_node m' \\<in> sum_SDG_slice1 nx\\<close>"], ["proof (chain)\npicking this:\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n  CFG_node (targetnode a) is-ns\\<rightarrow>\\<^sub>d* CFG_node m'", "have \"CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\""], ["proof (prove)\nusing this:\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n  CFG_node (targetnode a) is-ns\\<rightarrow>\\<^sub>d* CFG_node m'\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx", "by -(rule is_SDG_path_slice1)"], ["proof (state)\nthis:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)", "by(fastforce intro:sum_SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "with \\<open>CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)", "have \"CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx", "by -(rule call_slice1)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m' \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "with \\<open>as = as'@a#as''\\<close> \\<open>\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n        \\<open>call_of_return_node (hd ms') (sourcenode a)\\<close>\n        \\<open>targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode a)\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd ms') (sourcenode a)\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n      CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n      CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n  ms' = ms\n\ngoal (1 subgoal):\n 1. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "assume \"ms' = ms\""], ["proof (state)\nthis:\n  ms' = ms\n\ngoal (1 subgoal):\n 1. ms' = ms \\<Longrightarrow>\n    (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "thus ?thesis"], ["proof (prove)\nusing this:\n  ms' = ms\n\ngoal (1 subgoal):\n 1. (\\<exists>as' a as''.\n        as = as' @ a # as'' \\<and>\n        (\\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        call_of_return_node (hd ms') (sourcenode a) \\<and>\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n    ms' = ms", "by simp"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n      CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as' a as''.\n      as = as' @ a # as'' \\<and>\n      (\\<exists>Q r p fs.\n          kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      call_of_return_node (hd ms') (sourcenode a) \\<and>\n      targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m' \\<and>\n      CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx) \\<or>\n  ms' = ms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_called_node_in_slice1_nodestack_in_slice1:\n  \"\\<lbrakk>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); valid_node m; \n   CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n   \\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); ms = targetnodes rs;\n   valid_return_list rs m; length rs = length cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>mx \\<in> set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (m #\n                                  ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                 ms',s');\n     valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n     \\<forall>mx\\<in>set ms.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     ms = targetnodes rs; valid_return_list rs m;\n     length rs = length cs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mx\\<in>set ms'.\n                         \\<exists>mx'.\n                            call_of_return_node mx mx' \\<and>\n                            mx'\n                            \\<in> \\<lfloor>HRB_slice\n      S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(induct ms' arbitrary:as m' s')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> (m #\n                                     ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set [].\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> (m #\n           ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n                    valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx;\n                    nx \\<in> S;\n                    \\<forall>mx\\<in>set ms.\n                       \\<exists>mx'.\n                          call_of_return_node mx mx' \\<and>\n                          mx'\n                          \\<in> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    ms = targetnodes rs; valid_return_list rs m;\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>mx\\<in>set ms'.\n  \\<exists>mx'.\n     call_of_return_node mx mx' \\<and>\n     mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        S,kind \\<turnstile> (m #\n                             ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            a # ms',s');\n        valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (a # ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (Cons mx msx)"], ["proof (state)\nthis:\n  \\<lbrakk>S,kind \\<turnstile> (m #\n                                ms,s) =?as\\<Rightarrow>\\<^sub>\\<tau> (?m' #\n                                msx,?s');\n   valid_node m; CFG_node ?m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n   \\<forall>mx\\<in>set ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n   ms = targetnodes rs; valid_return_list rs m;\n   length rs = length cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>mx\\<in>set msx.\n                       \\<exists>mx'.\n                          call_of_return_node mx mx' \\<and>\n                          mx'\n                          \\<in> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  S,kind \\<turnstile> (m #\n                       ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                      mx # msx,s')\n  valid_node m\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> (m #\n                                     ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set [].\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> (m #\n           ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n                    valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx;\n                    nx \\<in> S;\n                    \\<forall>mx\\<in>set ms.\n                       \\<exists>mx'.\n                          call_of_return_node mx mx' \\<and>\n                          mx'\n                          \\<in> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    ms = targetnodes rs; valid_return_list rs m;\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>mx\\<in>set ms'.\n  \\<exists>mx'.\n     call_of_return_node mx mx' \\<and>\n     mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        S,kind \\<turnstile> (m #\n                             ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            a # ms',s');\n        valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (a # ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "note IH = \\<open>\\<And>as m' s'. \\<lbrakk>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx,s'); valid_node m; \n    CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n   \\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); ms = targetnodes rs;\n   valid_return_list rs m; length rs = length cs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mx\\<in>set msx. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>S,kind \\<turnstile> (m #\n                                ms,s) =?as\\<Rightarrow>\\<^sub>\\<tau> (?m' #\n                                msx,?s');\n   valid_node m; CFG_node ?m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n   \\<forall>mx\\<in>set ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n   ms = targetnodes rs; valid_return_list rs m;\n   length rs = length cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>mx\\<in>set msx.\n                       \\<exists>mx'.\n                          call_of_return_node mx mx' \\<and>\n                          mx'\n                          \\<in> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> (m #\n                                     ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set [].\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> (m #\n           ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n                    valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx;\n                    nx \\<in> S;\n                    \\<forall>mx\\<in>set ms.\n                       \\<exists>mx'.\n                          call_of_return_node mx mx' \\<and>\n                          mx'\n                          \\<in> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    ms = targetnodes rs; valid_return_list rs m;\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>mx\\<in>set ms'.\n  \\<exists>mx'.\n     call_of_return_node mx mx' \\<and>\n     mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        S,kind \\<turnstile> (m #\n                             ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            a # ms',s');\n        valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (a # ms').\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close> \\<open>valid_node m\\<close>\n    \\<open>CFG_node m' \\<in> sum_SDG_slice1 nx\\<close>\n    \\<open>\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\\<close> \\<open>ms = targetnodes rs\\<close>\n    \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m #\n                       ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                      mx # msx,s')\n  valid_node m\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs", "show ?case"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m #\n                       ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                      mx # msx,s')\n  valid_node m\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(rule silent_moves_called_node_in_slice1_hd_nodestack_in_slice1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "fix as' a as''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"as = as'@a#as''\" and \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"call_of_return_node (hd (mx # msx)) (sourcenode a)\" \n      and \"CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\"\n      and \"targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\""], ["proof (state)\nthis:\n  as = as' @ a # as''\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node (hd (mx # msx)) (sourcenode a)\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<close> \\<open>nx \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S", "have \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:combSlice_refl simp:SDG_to_CFG_set_def HRB_slice_def)"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>S,kind \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close> \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (m #\n                       ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                      mx # msx,s')\n  as = as' @ a # as''", "obtain xs x where \"S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\"\n      and \"S,kind \\<turnstile> (xs,x) =a#as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (m #\n                       ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                      mx # msx,s')\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. (\\<And>xs x.\n        \\<lbrakk>S,kind \\<turnstile> (m #\nms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x);\n         S,kind \\<turnstile> (xs,x) =a #\n                                     as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               mx # msx,s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves_split)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\n  S,kind \\<turnstile> (xs,x) =a #\n                              as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>S,kind \\<turnstile> (xs,x) =a#as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (xs,x) =a #\n                              as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')", "obtain ys y where \"S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\"\n      and \"S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (xs,x) =a #\n                              as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n\ngoal (1 subgoal):\n 1. (\\<And>ys y.\n        \\<lbrakk>S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y);\n         S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               mx # msx,s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\n  S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\\<close> \\<open>\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain xs' a' where \"xs = sourcenode a#xs'\" \n      and \"ys = targetnode a#targetnode a'#xs'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>xs' a'.\n        \\<lbrakk>xs = sourcenode a # xs';\n         ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs' a'.\n                \\<lbrakk>xs = sourcenode a # xs';\n                 ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y);\n     \\<exists>Q r p fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule silent_move.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f aa s s' ms Sa ms'.\n       \\<lbrakk>\\<And>xs' a'.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; xs = ms; x = s; a = aa; ys = ms'; y = s';\n        pred (f aa) s; transfer (f aa) s = s'; valid_edge aa;\n        intra_kind (kind aa);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode aa;\n        ms' = targetnode aa # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>f aa s s' Q r p fs a' ms Sa ms'.\n       \\<lbrakk>\\<And>xs' a'.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; xs = ms; x = s; a = aa; ys = ms'; y = s';\n        pred (f aa) s; transfer (f aa) s = s'; valid_edge aa;\n        kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges aa;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode aa;\n        ms' = targetnode aa # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>f aa s s' Q p f' ms Sa ms'.\n       \\<lbrakk>\\<And>xs' a'.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; xs = ms; x = s; a = aa; ys = ms'; y = s';\n        pred (f aa) s; transfer (f aa) s = s'; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode aa;\n        hd (tl ms) = targetnode aa; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:intra_kind_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs a' m m'.\n       \\<lbrakk>\\<And>xs' a'a.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    targetnode a' = targetnode a'a\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ys = targetnode a # targetnode a' # tl xs;\n        pred (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a; Ball (set (tl xs)) return_node;\n        length xs = length x;\n        length (transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x) =\n        Suc (length x);\n        hd xs = sourcenode a;\n        y = transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x;\n        m \\<in> set (tl xs); call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>Q r p fs a'.\n       \\<lbrakk>\\<And>xs' a'a.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    targetnode a' = targetnode a'a\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ys = targetnode a # targetnode a' # tl xs;\n        pred (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a; Ball (set (tl xs)) return_node;\n        length xs = length x;\n        length (transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x) =\n        Suc (length x);\n        hd xs = sourcenode a;\n        y = transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x;\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases xs,auto)+"], ["proof (state)\nthis:\n  xs = sourcenode a # xs'\n  ys = targetnode a # targetnode a' # xs'\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close> \n      \\<open>ys = targetnode a#targetnode a'#xs'\\<close> \\<open>targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n  ys = targetnode a # targetnode a' # xs'\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "have \"mx = targetnode a'\" and \"xs' = msx\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n  ys = targetnode a # targetnode a' # xs'\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (1 subgoal):\n 1. mx = targetnode a' &&& xs' = msx", "by(auto dest:silent_moves_same_level_path)"], ["proof (state)\nthis:\n  mx = targetnode a'\n  xs' = msx\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>xs = sourcenode a#xs'\\<close> \\<open>S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\\<close>"], ["proof (chain)\npicking this:\n  xs = sourcenode a # xs'\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\n  mx = targetnode a'\n  xs' = msx", "have \"S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode a#msx,x)\""], ["proof (prove)\nusing this:\n  xs = sourcenode a # xs'\n  S,kind \\<turnstile> (m # ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\n  mx = targetnode a'\n  xs' = msx\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (m #\n                         ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                          a #\n                         msx,x)", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (m #\n                       ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode a #\n                       msx,x)\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from IH[OF \\<open>S,kind \\<turnstile> (m#ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode a#msx,x)\\<close> \n      \\<open>valid_node m\\<close> \\<open>CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<close> \\<open>nx \\<in> S\\<close>\n      \\<open>\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\\<close> \\<open>ms = targetnodes rs\\<close>\n      \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have callstack:\"\\<forall>mx\\<in>set msx.\n      \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set msx.\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "."], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>as' a as''.\n       \\<lbrakk>as = as' @ a # as'';\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        call_of_return_node (hd (mx # msx)) (sourcenode a);\n        targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m';\n        CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set (mx # msx).\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>as = as'@a#as''\\<close> \\<open>call_of_return_node (hd (mx # msx)) (sourcenode a)\\<close> \n      \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''\n  call_of_return_node (hd (mx # msx)) (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n  call_of_return_node (hd (mx # msx)) (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set (mx # msx).\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"mx # msx = ms\""], ["proof (state)\nthis:\n  mx # msx = ms\n\ngoal (1 subgoal):\n 1. mx # msx = ms \\<Longrightarrow>\n    \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  mx # msx = ms", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  mx # msx = ms\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set (mx # msx).\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set (mx # msx).\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set (mx # msx).\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> (m #\n                                     ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; CFG_node m' \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>mx\\<in>set [].\n                            \\<exists>mx'.\n                               call_of_return_node mx mx' \\<and>\n                               mx'\n                               \\<in> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "qed simp"], ["", "lemma silent_moves_slice_intra_path:\n  assumes \"S,slice_kind S \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"\\<forall>a \\<in> set as. intra_kind (kind a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>a\\<in>set as. intra_kind (kind a))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<Longrightarrow>\n    False", "hence \"\\<exists>a \\<in> set as. \\<not> intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set as. \\<not> intra_kind (kind a)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set as. \\<not> intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>set as. \\<not> intra_kind (kind a)", "obtain asx ax asx' where \"as = asx@ax#asx'\" \n    and \"\\<forall>a\\<in>set asx. intra_kind (kind a)\" and \"\\<not> intra_kind (kind ax)\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set as. \\<not> intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax asx'.\n        \\<lbrakk>as = asx @ ax # asx';\n         \\<forall>a\\<in>set asx. intra_kind (kind a);\n         \\<not> intra_kind (kind ax)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_first_propE)"], ["proof (state)\nthis:\n  as = asx @ ax # asx'\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n  \\<not> intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<Longrightarrow>\n    False", "from \\<open>S,slice_kind S \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>as = asx@ax#asx'\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = asx @ ax # asx'", "obtain msx sx msx' sx' where \"S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\"\n    and \"S,slice_kind S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\"\n    and \"S,slice_kind S \\<turnstile> (msx',sx') =asx'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  as = asx @ ax # asx'\n\ngoal (1 subgoal):\n 1. (\\<And>msx sx msx' sx'.\n        \\<lbrakk>S,slice_kind\n                    S \\<turnstile> (m #\n                                    ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx);\n         S,slice_kind\n            S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx');\n         S,slice_kind\n            S \\<turnstile> (msx',sx') =asx'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                 ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:silent_moves_split elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,slice_kind\n     S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,slice_kind\n     S \\<turnstile> (msx',sx') =asx'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<Longrightarrow>\n    False", "from \\<open>S,slice_kind S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')", "obtain xs\n    where [simp]:\"msx = sourcenode ax#xs\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        msx = sourcenode ax # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases msx)(auto elim:silent_move.cases)"], ["proof (state)\nthis:\n  msx = sourcenode ax # xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<Longrightarrow>\n    False", "from \\<open>S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\\<close> \\<open>\\<forall>a\\<in>set asx. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  \\<forall>a\\<in>set asx. intra_kind (kind a)", "have [simp]:\"xs = ms\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. xs = ms", "by(fastforce dest:silent_moves_intra_path)"], ["proof (state)\nthis:\n  xs = ms\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"kind ax\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> False\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       False\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> False\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       False\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "with \\<open>\\<not> intra_kind (kind ax)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> intra_kind (kind ax)\n  intra_kind (kind ax)", "show False"], ["proof (prove)\nusing this:\n  \\<not> intra_kind (kind ax)\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       False\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       False\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "case (Call Q r p fs)"], ["proof (state)\nthis:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       False\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "with \\<open>S,slice_kind S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\\<close> \n      \\<open>\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"pred (slice_kind S ax) sx\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> &&&\n    pred (slice_kind S ax) sx", "by(auto elim!:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (slice_kind S ax) sx\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       False\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "from \\<open>sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"slice_kind S ax = (\\<lambda>cf. False):r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. slice_kind S ax =\n    \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(rule slice_kind_Call)"], ["proof (state)\nthis:\n  slice_kind S ax = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       False\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "with \\<open>pred (slice_kind S ax) sx\\<close>"], ["proof (chain)\npicking this:\n  pred (slice_kind S ax) sx\n  slice_kind S ax = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show False"], ["proof (prove)\nusing this:\n  pred (slice_kind S ax) sx\n  slice_kind S ax = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(cases sx) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> False", "with \\<open>S,slice_kind S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\\<close> \n      \\<open>\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "show False"], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (msx,sx) -ax\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim!:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_slice_keeps_state:\n  assumes \"S,slice_kind S \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"s = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s = s'", "from assms"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<forall>a \\<in> set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a)", "by(rule silent_moves_slice_intra_path)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. s = s'", "with assms"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "show ?thesis"], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. s = s'", "proof(induct S \"slice_kind S\" \"m#ms\" s as \"m'#ms'\" s'\n        arbitrary:m rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s S.\n       \\<lbrakk>length (m' # ms) = length s; ms = ms';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s\n 2. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "case (silent_moves_Nil sx n\\<^sub>c)"], ["proof (state)\nthis:\n  length (m' # ms) = length sx\n  ms = ms'\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>s S.\n       \\<lbrakk>length (m' # ms) = length s; ms = ms';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s\n 2. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "thus ?case"], ["proof (prove)\nusing this:\n  length (m' # ms) = length sx\n  ms = ms'\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. sx = sx", "by simp"], ["proof (state)\nthis:\n  sx = sx\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "case (silent_moves_Cons S sx a msx' sx' as s'')"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,slice_kind\n     S \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s'')\n  \\<lbrakk>msx' = ?m # ms;\n   \\<forall>mx\\<in>set ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> sx' = s''\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "note IH = \\<open>\\<And>m.\n      \\<lbrakk>msx' = m # ms;\n      \\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n      \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk> \\<Longrightarrow> sx' = s''\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ms;\n   \\<forall>mx\\<in>set ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> sx' = s''\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "note callstack = \\<open>\\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\"\n      and \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "from \\<open>S,slice_kind S \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\\<close> \\<open>intra_kind (kind a)\\<close>\n      callstack"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  intra_kind (kind a)\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have [simp]:\"msx' = targetnode a#ms\" and \"sx' = transfer (slice_kind S a) sx\"\n      and \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"valid_edge a\" and \"sx \\<noteq> []\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  intra_kind (kind a)\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (msx' = targetnode a # ms &&& sx' = transfer (slice_kind S a) sx) &&&\n    sourcenode a\n    \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> &&&\n    valid_edge a &&& sx \\<noteq> []", "by(auto elim!:silent_move.cases simp:intra_kind_def)"], ["proof (state)\nthis:\n  msx' = targetnode a # ms\n  sx' = transfer (slice_kind S a) sx\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  sx \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "from IH[OF \\<open>msx' = targetnode a#ms\\<close> callstack \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close>]"], ["proof (chain)\npicking this:\n  sx' = s''", "have \"sx' = s''\""], ["proof (prove)\nusing this:\n  sx' = s''\n\ngoal (1 subgoal):\n 1. sx' = s''", "."], ["proof (state)\nthis:\n  sx' = s''\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"sx = sx'\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. sx = sx'", "proof(cases \"kind a\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "case (UpdateEdge f')"], ["proof (state)\nthis:\n  kind a = \\<Up>f'\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = \\<Up>f'", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = \\<Up>f'\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by(rule slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "with \\<open>sx' = transfer (slice_kind S a) sx\\<close> \\<open>sx \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  sx' = transfer (slice_kind S a) sx\n  sx \\<noteq> []\n  slice_kind S a = \\<Up>id", "show ?thesis"], ["proof (prove)\nusing this:\n  sx' = transfer (slice_kind S a) sx\n  sx \\<noteq> []\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. sx = sx'", "by(cases sx) auto"], ["proof (state)\nthis:\n  sx = sx'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "case (PredicateEdge Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = (Q)\\<^sub>\\<surd>", "obtain Q' where \"slice_kind S a = (Q')\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        slice_kind S a = (Q')\\<^sub>\\<surd> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule kind_Predicate_notin_slice_slice_kind_Predicate)"], ["proof (state)\nthis:\n  slice_kind S a = (Q')\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "with \\<open>sx' = transfer (slice_kind S a) sx\\<close> \\<open>sx \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  sx' = transfer (slice_kind S a) sx\n  sx \\<noteq> []\n  slice_kind S a = (Q')\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  sx' = transfer (slice_kind S a) sx\n  sx \\<noteq> []\n  slice_kind S a = (Q')\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sx = sx'", "by(cases sx) auto"], ["proof (state)\nthis:\n  sx = sx'\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> sx = sx'\n 2. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> sx = sx'", "qed (auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  sx = sx'\n\ngoal (1 subgoal):\n 1. \\<And>S s a ms'a s' as s'' m.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m #\n                                   ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> s' = s'';\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> s = s''", "with \\<open>sx' = s''\\<close>"], ["proof (chain)\npicking this:\n  sx' = s''\n  sx = sx'", "show ?case"], ["proof (prove)\nusing this:\n  sx' = s''\n  sx = sx'\n\ngoal (1 subgoal):\n 1. sx = s''", "by simp"], ["proof (state)\nthis:\n  sx = s''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = s'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition of \\<open>slice_edges\\<close>\\<close>"], ["", "definition slice_edge :: \"'node SDG_node set \\<Rightarrow> 'edge list \\<Rightarrow> 'edge \\<Rightarrow> bool\"\nwhere \"slice_edge S cs a \\<equiv> (\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  (case (kind a) of Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow> True | _ \\<Rightarrow> sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["", "lemma silent_move_no_slice_edge:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> \\<not> slice_edge S cs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n     tl ms = targetnodes rs; length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<not> slice_edge S cs a", "proof(induct rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "case (silent_move_intra f a s s' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "note disj = \\<open>(\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n    \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from \\<open>pred (f a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s\n  length ms = length s", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from \\<open>length rs = length cs\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  tl ms = targetnodes rs", "have \"length (tl ms) = length cs\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. length (tl ms) = length cs", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  length (tl ms) = length cs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from disj"], ["proof (chain)\npicking this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "assume \"\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "with \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>\n      \\<open>length (tl ms) = length cs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<exists>c \\<in> set cs. sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>set cs.\n       sourcenode c\n       \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(auto simp:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' i.\n       \\<lbrakk>\\<forall>i<length cs.\n                   call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        length ms - Suc 0 = length cs; call_of_return_node (tl ms ! i) m';\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        i < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>set cs.\n                            sourcenode c\n                            \\<notin> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  \\<exists>c\\<in>set cs.\n     sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>set cs.\n     sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(auto simp:slice_edge_def)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "assume \"hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "with \\<open>hd ms = sourcenode a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  intra_kind (kind a)\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  intra_kind (kind a)\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(auto simp:slice_edge_def simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "case (silent_move_call f a s s' Q r p fs a' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "note disj = \\<open>(\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n    \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from \\<open>pred (f a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s\n  length ms = length s", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from \\<open>length rs = length cs\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  tl ms = targetnodes rs", "have \"length (tl ms) = length cs\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. length (tl ms) = length cs", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  length (tl ms) = length cs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from disj"], ["proof (chain)\npicking this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "assume \"\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "with \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>\n      \\<open>length (tl ms) = length cs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<exists>c \\<in> set cs. sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>set cs.\n       sourcenode c\n       \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(auto simp:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' i.\n       \\<lbrakk>\\<forall>i<length cs.\n                   call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        length ms - Suc 0 = length cs; call_of_return_node (tl ms ! i) m';\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        i < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>set cs.\n                            sourcenode c\n                            \\<notin> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  \\<exists>c\\<in>set cs.\n     sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>set cs.\n     sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(auto simp:slice_edge_def)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "assume \"hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<not> slice_edge S cs a", "with \\<open>hd ms = sourcenode a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(auto simp:slice_edge_def)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "case (silent_move_return f a s s' Q p f' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from \\<open>pred (f a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s\n  length ms = length s", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from \\<open>length rs = length cs\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  tl ms = targetnodes rs", "have \"length (tl ms) = length cs\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. length (tl ms) = length cs", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  length (tl ms) = length cs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "from \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>\n    \\<open>\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>length (tl ms) = length cs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length (tl ms) = length cs", "have \"\\<exists>c \\<in> set cs. sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length (tl ms) = length cs\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>set cs.\n       sourcenode c\n       \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(auto simp:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' i.\n       \\<lbrakk>\\<forall>i<length cs.\n                   call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        length ms - Suc 0 = length cs; call_of_return_node (tl ms ! i) m';\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        i < length cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>set cs.\n                            sourcenode c\n                            \\<notin> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  \\<exists>c\\<in>set cs.\n     sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> \\<not> slice_edge S cs a", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>set cs.\n     sourcenode c \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(auto simp:slice_edge_def)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_move_slice_edge:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> slice_edge S cs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s');\n     tl ms = targetnodes rs; length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> slice_edge S cs a", "proof(induct rule:observable_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "case (observable_move_intra f a s s' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "from \\<open>pred (f a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s\n  length ms = length s", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "from \\<open>length rs = length cs\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  tl ms = targetnodes rs", "have \"length (tl ms) = length cs\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. length (tl ms) = length cs", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  length (tl ms) = length cs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "with \\<open>\\<forall>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>\\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs", "have \"\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs.\n       sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(auto simp:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>m\\<in>set (tl ms).\n                   \\<exists>m'.\n                      call_of_return_node m m' \\<and>\n                      m' \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        length ms - Suc 0 = length cs; i < length cs\\<rbrakk>\n       \\<Longrightarrow> sourcenode (cs ! i)\n                         \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "with \\<open>hd ms = sourcenode a\\<close> \\<open>hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edge S cs a", "by(auto simp:slice_edge_def simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edge S cs a\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "case (observable_move_call f a s s' Q r p fs a' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "from \\<open>pred (f a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s\n  length ms = length s", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "from \\<open>length rs = length cs\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  tl ms = targetnodes rs", "have \"length (tl ms) = length cs\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. length (tl ms) = length cs", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  length (tl ms) = length cs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "with \\<open>\\<forall>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>\\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs", "have \"\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs.\n       sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(auto simp:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>m\\<in>set (tl ms).\n                   \\<exists>m'.\n                      call_of_return_node m m' \\<and>\n                      m' \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        length ms - Suc 0 = length cs; i < length cs\\<rbrakk>\n       \\<Longrightarrow> sourcenode (cs ! i)\n                         \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "with \\<open>hd ms = sourcenode a\\<close> \\<open>hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edge S cs a", "by(auto simp:slice_edge_def)"], ["proof (state)\nthis:\n  slice_edge S cs a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "case (observable_move_return f a s s' Q p f' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "from \\<open>pred (f a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s\n  length ms = length s", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "from \\<open>length rs = length cs\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  tl ms = targetnodes rs", "have \"length (tl ms) = length cs\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. length (tl ms) = length cs", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  length (tl ms) = length cs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "with \\<open>\\<forall>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>\\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs", "have \"\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  length (tl ms) = length cs\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs.\n       sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(auto simp:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>m\\<in>set (tl ms).\n                   \\<exists>m'.\n                      call_of_return_node m m' \\<and>\n                      m' \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        length ms - Suc 0 = length cs; i < length cs\\<rbrakk>\n       \\<Longrightarrow> sourcenode (cs ! i)\n                         \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edge S cs a", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edge S cs a", "by(auto simp:slice_edge_def)"], ["proof (state)\nthis:\n  slice_edge S cs a\n\ngoal:\nNo subgoals!", "qed"], ["", "function slice_edges :: \"'node SDG_node set \\<Rightarrow> 'edge list \\<Rightarrow> 'edge list \\<Rightarrow> 'edge list\"\nwhere \"slice_edges S cs [] = []\"\n  | \"slice_edge S cs a \\<Longrightarrow> \n     slice_edges S cs (a#as) = a#slice_edges S (upd_cs cs [a]) as\"\n  | \"\\<not> slice_edge S cs a \\<Longrightarrow> \n     slice_edges S cs (a#as) = slice_edges S (upd_cs cs [a]) as\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>S cs. x = (S, cs, []) \\<Longrightarrow> P;\n        \\<And>S cs a as.\n           \\<lbrakk>slice_edge S cs a; x = (S, cs, a # as)\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>S cs a as.\n           \\<lbrakk>\\<not> slice_edge S cs a; x = (S, cs, a # as)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>S cs Sa csa. (S, cs, []) = (Sa, csa, []) \\<Longrightarrow> [] = []\n 3. \\<And>S cs Sa csa a as.\n       \\<lbrakk>slice_edge Sa csa a;\n        (S, cs, []) = (Sa, csa, a # as)\\<rbrakk>\n       \\<Longrightarrow> [] = a # slice_edges_sumC (Sa, upd_cs csa [a], as)\n 4. \\<And>S cs Sa csa a as.\n       \\<lbrakk>\\<not> slice_edge Sa csa a;\n        (S, cs, []) = (Sa, csa, a # as)\\<rbrakk>\n       \\<Longrightarrow> [] = slice_edges_sumC (Sa, upd_cs csa [a], as)\n 5. \\<And>S cs a as Sa csa aa asa.\n       \\<lbrakk>slice_edge S cs a; slice_edge Sa csa aa;\n        (S, cs, a # as) = (Sa, csa, aa # asa)\\<rbrakk>\n       \\<Longrightarrow> a # slice_edges_sumC (S, upd_cs cs [a], as) =\n                         aa # slice_edges_sumC (Sa, upd_cs csa [aa], asa)\n 6. \\<And>S cs a as Sa csa aa asa.\n       \\<lbrakk>slice_edge S cs a; \\<not> slice_edge Sa csa aa;\n        (S, cs, a # as) = (Sa, csa, aa # asa)\\<rbrakk>\n       \\<Longrightarrow> a # slice_edges_sumC (S, upd_cs cs [a], as) =\n                         slice_edges_sumC (Sa, upd_cs csa [aa], asa)\n 7. \\<And>S cs a as Sa csa aa asa.\n       \\<lbrakk>\\<not> slice_edge S cs a; \\<not> slice_edge Sa csa aa;\n        (S, cs, a # as) = (Sa, csa, aa # asa)\\<rbrakk>\n       \\<Longrightarrow> slice_edges_sumC (S, upd_cs cs [a], as) =\n                         slice_edges_sumC (Sa, upd_cs csa [aa], asa)", "by(atomize_elim)(auto,case_tac b,auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All slice_edges_dom", "by(lexicographic_order)"], ["", "lemma slice_edges_Append:\n  \"\\<lbrakk>slice_edges S cs as = as'; slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n  \\<Longrightarrow> slice_edges S cs (as@asx) = as'@asx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>slice_edges S cs as = as';\n     slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n    \\<Longrightarrow> slice_edges S cs (as @ asx) = as' @ asx'", "proof(induct as arbitrary:cs as')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs as'.\n       \\<lbrakk>slice_edges S cs [] = as';\n        slice_edges S (upd_cs cs []) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ([] @ asx) = as' @ asx'\n 2. \\<And>a as cs as'.\n       \\<lbrakk>\\<And>cs as'.\n                   \\<lbrakk>slice_edges S cs as = as';\n                    slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S cs (as @ asx) =\n                                     as' @ asx';\n        slice_edges S cs (a # as) = as';\n        slice_edges S (upd_cs cs (a # as)) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ((a # as) @ asx) = as' @ asx'", "case Nil"], ["proof (state)\nthis:\n  slice_edges S cs [] = as'\n  slice_edges S (upd_cs cs []) asx = asx'\n\ngoal (2 subgoals):\n 1. \\<And>cs as'.\n       \\<lbrakk>slice_edges S cs [] = as';\n        slice_edges S (upd_cs cs []) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ([] @ asx) = as' @ asx'\n 2. \\<And>a as cs as'.\n       \\<lbrakk>\\<And>cs as'.\n                   \\<lbrakk>slice_edges S cs as = as';\n                    slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S cs (as @ asx) =\n                                     as' @ asx';\n        slice_edges S cs (a # as) = as';\n        slice_edges S (upd_cs cs (a # as)) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ((a # as) @ asx) = as' @ asx'", "thus ?case"], ["proof (prove)\nusing this:\n  slice_edges S cs [] = as'\n  slice_edges S (upd_cs cs []) asx = asx'\n\ngoal (1 subgoal):\n 1. slice_edges S cs ([] @ asx) = as' @ asx'", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs ([] @ asx) = as' @ asx'\n\ngoal (1 subgoal):\n 1. \\<And>a as cs as'.\n       \\<lbrakk>\\<And>cs as'.\n                   \\<lbrakk>slice_edges S cs as = as';\n                    slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S cs (as @ asx) =\n                                     as' @ asx';\n        slice_edges S cs (a # as) = as';\n        slice_edges S (upd_cs cs (a # as)) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ((a # as) @ asx) = as' @ asx'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as cs as'.\n       \\<lbrakk>\\<And>cs as'.\n                   \\<lbrakk>slice_edges S cs as = as';\n                    slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S cs (as @ asx) =\n                                     as' @ asx';\n        slice_edges S cs (a # as) = as';\n        slice_edges S (upd_cs cs (a # as)) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ((a # as) @ asx) = as' @ asx'", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>slice_edges S ?cs xs = ?as';\n   slice_edges S (upd_cs ?cs xs) asx = asx'\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs (xs @ asx) = ?as' @ asx'\n  slice_edges S cs (x # xs) = as'\n  slice_edges S (upd_cs cs (x # xs)) asx = asx'\n\ngoal (1 subgoal):\n 1. \\<And>a as cs as'.\n       \\<lbrakk>\\<And>cs as'.\n                   \\<lbrakk>slice_edges S cs as = as';\n                    slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S cs (as @ asx) =\n                                     as' @ asx';\n        slice_edges S cs (a # as) = as';\n        slice_edges S (upd_cs cs (a # as)) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ((a # as) @ asx) = as' @ asx'", "note IH = \\<open>\\<And>cs as'. \\<lbrakk>slice_edges S cs xs = as'; \n    slice_edges S (upd_cs cs xs) asx = asx'\\<rbrakk>\n    \\<Longrightarrow> slice_edges S cs (xs @ asx) = as' @ asx'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>slice_edges S ?cs xs = ?as';\n   slice_edges S (upd_cs ?cs xs) asx = asx'\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs (xs @ asx) = ?as' @ asx'\n\ngoal (1 subgoal):\n 1. \\<And>a as cs as'.\n       \\<lbrakk>\\<And>cs as'.\n                   \\<lbrakk>slice_edges S cs as = as';\n                    slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S cs (as @ asx) =\n                                     as' @ asx';\n        slice_edges S cs (a # as) = as';\n        slice_edges S (upd_cs cs (a # as)) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ((a # as) @ asx) = as' @ asx'", "from \\<open>slice_edges S (upd_cs cs (x # xs)) asx = asx'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S (upd_cs cs (x # xs)) asx = asx'", "have \"slice_edges S (upd_cs (upd_cs cs [x]) xs) asx = asx'\""], ["proof (prove)\nusing this:\n  slice_edges S (upd_cs cs (x # xs)) asx = asx'\n\ngoal (1 subgoal):\n 1. slice_edges S (upd_cs (upd_cs cs [x]) xs) asx = asx'", "by(cases \"kind x\")(auto,cases cs,auto)"], ["proof (state)\nthis:\n  slice_edges S (upd_cs (upd_cs cs [x]) xs) asx = asx'\n\ngoal (1 subgoal):\n 1. \\<And>a as cs as'.\n       \\<lbrakk>\\<And>cs as'.\n                   \\<lbrakk>slice_edges S cs as = as';\n                    slice_edges S (upd_cs cs as) asx = asx'\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S cs (as @ asx) =\n                                     as' @ asx';\n        slice_edges S cs (a # as) = as';\n        slice_edges S (upd_cs cs (a # as)) asx = asx'\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs ((a # as) @ asx) = as' @ asx'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "proof(cases \"slice_edge S cs x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n 2. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "case True"], ["proof (state)\nthis:\n  slice_edge S cs x\n\ngoal (2 subgoals):\n 1. slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n 2. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "with \\<open>slice_edges S cs (x # xs) = as'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (x # xs) = as'\n  slice_edge S cs x", "have \"x#slice_edges S (upd_cs cs [x]) xs = as'\""], ["proof (prove)\nusing this:\n  slice_edges S cs (x # xs) = as'\n  slice_edge S cs x\n\ngoal (1 subgoal):\n 1. x # slice_edges S (upd_cs cs [x]) xs = as'", "by simp"], ["proof (state)\nthis:\n  x # slice_edges S (upd_cs cs [x]) xs = as'\n\ngoal (2 subgoals):\n 1. slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n 2. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "then"], ["proof (chain)\npicking this:\n  x # slice_edges S (upd_cs cs [x]) xs = as'", "obtain xs' where \"as' = x#xs'\"\n      and \"slice_edges S (upd_cs cs [x]) xs = xs'\""], ["proof (prove)\nusing this:\n  x # slice_edges S (upd_cs cs [x]) xs = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>as' = x # xs';\n         slice_edges S (upd_cs cs [x]) xs = xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases as') auto"], ["proof (state)\nthis:\n  as' = x # xs'\n  slice_edges S (upd_cs cs [x]) xs = xs'\n\ngoal (2 subgoals):\n 1. slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n 2. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "from IH[OF \\<open>slice_edges S (upd_cs cs [x]) xs = xs'\\<close>\n      \\<open>slice_edges S (upd_cs (upd_cs cs [x]) xs) asx = asx'\\<close>]"], ["proof (chain)\npicking this:\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = xs' @ asx'", "have \"slice_edges S (upd_cs cs [x]) (xs @ asx) = xs' @ asx'\""], ["proof (prove)\nusing this:\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = xs' @ asx'\n\ngoal (1 subgoal):\n 1. slice_edges S (upd_cs cs [x]) (xs @ asx) = xs' @ asx'", "."], ["proof (state)\nthis:\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = xs' @ asx'\n\ngoal (2 subgoals):\n 1. slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n 2. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "with True \\<open>as' = x#xs'\\<close>"], ["proof (chain)\npicking this:\n  slice_edge S cs x\n  as' = x # xs'\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = xs' @ asx'", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_edge S cs x\n  as' = x # xs'\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = xs' @ asx'\n\ngoal (1 subgoal):\n 1. slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "case False"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs x\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "with \\<open>slice_edges S cs (x # xs) = as'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (x # xs) = as'\n  \\<not> slice_edge S cs x", "have \"slice_edges S (upd_cs cs [x]) xs = as'\""], ["proof (prove)\nusing this:\n  slice_edges S cs (x # xs) = as'\n  \\<not> slice_edge S cs x\n\ngoal (1 subgoal):\n 1. slice_edges S (upd_cs cs [x]) xs = as'", "by simp"], ["proof (state)\nthis:\n  slice_edges S (upd_cs cs [x]) xs = as'\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "from IH[OF this \\<open>slice_edges S (upd_cs (upd_cs cs [x]) xs) asx = asx'\\<close>]"], ["proof (chain)\npicking this:\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = as' @ asx'", "have \"slice_edges S (upd_cs cs [x]) (xs @ asx) = as' @ asx'\""], ["proof (prove)\nusing this:\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = as' @ asx'\n\ngoal (1 subgoal):\n 1. slice_edges S (upd_cs cs [x]) (xs @ asx) = as' @ asx'", "."], ["proof (state)\nthis:\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = as' @ asx'\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs x \\<Longrightarrow>\n    slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "with False"], ["proof (chain)\npicking this:\n  \\<not> slice_edge S cs x\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = as' @ asx'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> slice_edge S cs x\n  slice_edges S (upd_cs cs [x]) (xs @ asx) = as' @ asx'\n\ngoal (1 subgoal):\n 1. slice_edges S cs ((x # xs) @ asx) = as' @ asx'", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_edges S cs ((x # xs) @ asx) = as' @ asx'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_edges_Nil_split:\n  \"slice_edges S cs (as@as') = []\n  \\<Longrightarrow> slice_edges S cs as = [] \\<and> slice_edges S (upd_cs cs as) as' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n    slice_edges S cs as = [] \\<and> slice_edges S (upd_cs cs as) as' = []", "apply(induct as arbitrary:cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       slice_edges S cs ([] @ as') = [] \\<Longrightarrow>\n       slice_edges S cs [] = [] \\<and> slice_edges S (upd_cs cs []) as' = []\n 2. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S cs ((a # as) @ as') = []\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         slice_edges S (upd_cs cs (a # as)) as' = []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S cs ((a # as) @ as') = []\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         slice_edges S (upd_cs cs (a # as)) as' = []", "apply(case_tac \"slice_edge S cs a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S cs ((a # as) @ as') = []; slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         slice_edges S (upd_cs cs (a # as)) as' = []\n 2. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S cs ((a # as) @ as') = [];\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         slice_edges S (upd_cs cs (a # as)) as' = []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case kind a of\n          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n            upd_cs (a # cs) []\n          | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n              case cs of [] \\<Rightarrow> upd_cs cs []\n              | c' # cs' \\<Rightarrow> upd_cs cs' []\n          | _ \\<Rightarrow> upd_cs cs [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case kind a of\n                           Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                             upd_cs (a # cs) as\n                           | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n                               case cs of [] \\<Rightarrow> upd_cs cs as\n                               | c' # cs' \\<Rightarrow> upd_cs cs' as\n                           | _ \\<Rightarrow> upd_cs cs as)\n                          as' =\n                         []", "apply(case_tac \"kind a\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a as cs x1.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case kind a of\n          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n            upd_cs (a # cs) []\n          | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n              case cs of [] \\<Rightarrow> upd_cs cs []\n              | c' # cs' \\<Rightarrow> upd_cs cs' []\n          | _ \\<Rightarrow> upd_cs cs [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a; kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case kind a of\n                           Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                             upd_cs (a # cs) as\n                           | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n                               case cs of [] \\<Rightarrow> upd_cs cs as\n                               | c' # cs' \\<Rightarrow> upd_cs cs' as\n                           | _ \\<Rightarrow> upd_cs cs as)\n                          as' =\n                         []\n 2. \\<And>a as cs x2.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case kind a of\n          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n            upd_cs (a # cs) []\n          | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n              case cs of [] \\<Rightarrow> upd_cs cs []\n              | c' # cs' \\<Rightarrow> upd_cs cs' []\n          | _ \\<Rightarrow> upd_cs cs [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case kind a of\n                           Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                             upd_cs (a # cs) as\n                           | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n                               case cs of [] \\<Rightarrow> upd_cs cs as\n                               | c' # cs' \\<Rightarrow> upd_cs cs' as\n                           | _ \\<Rightarrow> upd_cs cs as)\n                          as' =\n                         []\n 3. \\<And>a as cs x31 x32 x33 x34.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case kind a of\n          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n            upd_cs (a # cs) []\n          | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n              case cs of [] \\<Rightarrow> upd_cs cs []\n              | c' # cs' \\<Rightarrow> upd_cs cs' []\n          | _ \\<Rightarrow> upd_cs cs [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a;\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case kind a of\n                           Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                             upd_cs (a # cs) as\n                           | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n                               case cs of [] \\<Rightarrow> upd_cs cs as\n                               | c' # cs' \\<Rightarrow> upd_cs cs' as\n                           | _ \\<Rightarrow> upd_cs cs as)\n                          as' =\n                         []\n 4. \\<And>a as cs x41 x42 x43.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case kind a of\n          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n            upd_cs (a # cs) []\n          | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n              case cs of [] \\<Rightarrow> upd_cs cs []\n              | c' # cs' \\<Rightarrow> upd_cs cs' []\n          | _ \\<Rightarrow> upd_cs cs [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a;\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case kind a of\n                           Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                             upd_cs (a # cs) as\n                           | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n                               case cs of [] \\<Rightarrow> upd_cs cs as\n                               | c' # cs' \\<Rightarrow> upd_cs cs' as\n                           | _ \\<Rightarrow> upd_cs cs as)\n                          as' =\n                         []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as cs x41 x42 x43.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case cs of [] \\<Rightarrow> upd_cs cs []\n          | c' # cs' \\<Rightarrow> upd_cs cs' [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a;\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case cs of [] \\<Rightarrow> upd_cs cs as\n                           | c' # cs' \\<Rightarrow> upd_cs cs' as)\n                          as' =\n                         []", "apply(case_tac cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as cs x41 x42 x43.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case cs of [] \\<Rightarrow> upd_cs cs []\n          | c' # cs' \\<Rightarrow> upd_cs cs' [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a;\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43; cs = []\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case cs of [] \\<Rightarrow> upd_cs cs as\n                           | c' # cs' \\<Rightarrow> upd_cs cs' as)\n                          as' =\n                         []\n 2. \\<And>a as cs x41 x42 x43 aa list.\n       \\<lbrakk>\\<And>cs.\n                   slice_edges S cs (as @ as') = [] \\<Longrightarrow>\n                   slice_edges S cs as = [] \\<and>\n                   slice_edges S (upd_cs cs as) as' = [];\n        slice_edges S\n         (case cs of [] \\<Rightarrow> upd_cs cs []\n          | c' # cs' \\<Rightarrow> upd_cs cs' [])\n         (as @ as') =\n        [];\n        \\<not> slice_edge S cs a;\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43;\n        cs = aa # list\\<rbrakk>\n       \\<Longrightarrow> slice_edges S\n                          (case cs of [] \\<Rightarrow> upd_cs cs as\n                           | c' # cs' \\<Rightarrow> upd_cs cs' as)\n                          as' =\n                         []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma slice_intra_edges_no_nodes_in_slice:\n  \"\\<lbrakk>slice_edges S cs as = []; \\<forall>a \\<in> set as. intra_kind (kind a);\n    \\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>slice_edges S cs as = [];\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     \\<forall>c\\<in>set cs.\n        sourcenode c\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                         nx \\<notin> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>slice_edges S cs [] = [];\n     \\<forall>a\\<in>set []. intra_kind (kind a);\n     \\<forall>c\\<in>set cs.\n        sourcenode c\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes []).\n                         nx \\<notin> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case Nil"], ["proof (state)\nthis:\n  slice_edges S cs [] = []\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>slice_edges S cs [] = [];\n     \\<forall>a\\<in>set []. intra_kind (kind a);\n     \\<forall>c\\<in>set cs.\n        sourcenode c\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes []).\n                         nx \\<notin> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "thus ?case"], ["proof (prove)\nusing this:\n  slice_edges S cs [] = []\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes []).\n       nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes []).\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (Cons a' as')"], ["proof (state)\nthis:\n  \\<lbrakk>slice_edges S cs as' = [];\n   \\<forall>a\\<in>set as'. intra_kind (kind a);\n   \\<forall>c\\<in>set cs.\n      sourcenode c\n      \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as').\n                       nx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  slice_edges S cs (a' # as') = []\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "note IH = \\<open> \\<lbrakk>slice_edges S cs as' = []; \\<forall>a\\<in>set as'. intra_kind (kind a);\n    \\<forall>c\\<in>set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>slice_edges S cs as' = [];\n   \\<forall>a\\<in>set as'. intra_kind (kind a);\n   \\<forall>c\\<in>set cs.\n      sourcenode c\n      \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as').\n                       nx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>\\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)", "have \"intra_kind (kind a')\" and \"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a') &&& \\<forall>a\\<in>set as'. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>slice_edges S cs (a' # as') = []\\<close> \\<open>intra_kind (kind a')\\<close>\n    \\<open>\\<forall>c\\<in>set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a' # as') = []\n  intra_kind (kind a')\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"slice_edges S cs as' = []\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a' # as') = []\n  intra_kind (kind a')\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a'\n    \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> &&&\n    slice_edges S cs as' = []", "by(cases \"slice_edge S cs a'\",auto simp:intra_kind_def slice_edge_def)+"], ["proof (state)\nthis:\n  sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  slice_edges S cs as' = []\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from IH[OF \\<open>slice_edges S cs as' = []\\<close> \\<open>\\<forall>a\\<in>set as'. intra_kind (kind a)\\<close>\n    \\<open>\\<forall>c\\<in>set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes as').\n       nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "."], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>slice_edges S cs as = [];\n                 \\<forall>a\\<in>set as. intra_kind (kind a);\n                 \\<forall>c\\<in>set cs.\n                    sourcenode c\n                    \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes as).\n                                     nx \\<notin> \\<lfloor>HRB_slice\n                     S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        slice_edges S cs (a # as) = [];\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes (a' # as')).\n       nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes (a' # as')).\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_no_slice_edges:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S cs as = [] \\<and> (\\<exists>rs'. tl ms' = targetnodes rs' \\<and>\n  length rs' = length (upd_cs cs as) \\<and> (\\<forall>i<length (upd_cs cs as). \n  call_of_return_node (tl ms'!i) (sourcenode ((upd_cs cs as)!i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n     tl ms = targetnodes rs; length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                      (\\<exists>rs'.\n                          tl ms' = targetnodes rs' \\<and>\n                          length rs' = length (upd_cs cs as) \\<and>\n                          (\\<forall>i<length (upd_cs cs as).\n                              call_of_return_node (tl ms' ! i)\n                               (sourcenode (upd_cs cs as ! i))))", "proof(induct arbitrary:rs cs rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S f rs cs.\n       \\<lbrakk>length ms = length s; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs [] = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs []) \\<and>\n                             (\\<forall>i<length (upd_cs cs []).\n                                 call_of_return_node (tl ms ! i)\n                                  (sourcenode (upd_cs cs [] ! i))))\n 2. \\<And>S f ms s a ms' s' as ms'' s'' rs cs.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "case (silent_moves_Cons S f ms s a ms' s' as ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f rs cs.\n       \\<lbrakk>length ms = length s; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs [] = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs []) \\<and>\n                             (\\<forall>i<length (upd_cs cs []).\n                                 call_of_return_node (tl ms ! i)\n                                  (sourcenode (upd_cs cs [] ! i))))\n 2. \\<And>S f ms s a ms' s' as ms'' s'' rs cs.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close> \\<open>tl ms = targetnodes rs\\<close> \\<open>length rs = length cs\\<close>\n    \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))", "have \"\\<not> slice_edge S cs a\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(rule silent_move_no_slice_edge)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f rs cs.\n       \\<lbrakk>length ms = length s; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs [] = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs []) \\<and>\n                             (\\<forall>i<length (upd_cs cs []).\n                                 call_of_return_node (tl ms ! i)\n                                  (sourcenode (upd_cs cs [] ! i))))\n 2. \\<And>S f ms s a ms' s' as ms'' s'' rs cs.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "with silent_moves_Cons"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  \\<not> slice_edge S cs a", "show ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = [] \\<and>\n    (\\<exists>rs'.\n        tl ms'' = targetnodes rs' \\<and>\n        length rs' = length (upd_cs cs (a # as)) \\<and>\n        (\\<forall>i<length (upd_cs cs (a # as)).\n            call_of_return_node (tl ms'' ! i)\n             (sourcenode (upd_cs cs (a # as) ! i))))", "proof(induct rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "case (silent_move_intra f a s s' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  \\<not> slice_edge S cs a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "note IH = \\<open>\\<And>rs cs. \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n      \\<forall>i<length cs. call_of_return_node (tl ms' ! i) (sourcenode (cs ! i))\\<rbrakk>\n      \\<Longrightarrow> slice_edges S cs as = [] \\<and> (\\<exists>rs'. tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs as) \\<and> (\\<forall>i<length (upd_cs cs as).\n      call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs as ! i))))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>ms' = targetnode a # tl ms\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms' = targetnode a # tl ms\n  tl ms = targetnodes rs", "have \"tl ms' = targetnodes rs\""], ["proof (prove)\nusing this:\n  ms' = targetnode a # tl ms\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. tl ms' = targetnodes rs", "by simp"], ["proof (state)\nthis:\n  tl ms' = targetnodes rs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>ms' = targetnode a # tl ms\\<close> \\<open>tl ms = targetnodes rs\\<close>\n      \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>"], ["proof (chain)\npicking this:\n  ms' = targetnode a # tl ms\n  tl ms = targetnodes rs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))", "have \"\\<forall>i<length cs. call_of_return_node (tl ms' ! i) (sourcenode (cs ! i))\""], ["proof (prove)\nusing this:\n  ms' = targetnode a # tl ms\n  tl ms = targetnodes rs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs.\n       call_of_return_node (tl ms' ! i) (sourcenode (cs ! i))", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms' ! i) (sourcenode (cs ! i))\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from IH[OF \\<open>tl ms' = targetnodes rs\\<close> \\<open>length rs = length cs\\<close> this]"], ["proof (chain)\npicking this:\n  slice_edges S cs as = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs as) \\<and>\n      (\\<forall>i<length (upd_cs cs as).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs as ! i))))", "have \"slice_edges S cs as = []\" \n      and \"\\<exists>rs'. tl ms'' = targetnodes rs' \\<and> length rs' = length (upd_cs cs as) \\<and>\n      (\\<forall>i<length (upd_cs cs as). \n      call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs as ! i)))\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs as) \\<and>\n      (\\<forall>i<length (upd_cs cs as).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs as ! i))))\n\ngoal (1 subgoal):\n 1. slice_edges S cs as = [] &&&\n    \\<exists>rs'.\n       tl ms'' = targetnodes rs' \\<and>\n       length rs' = length (upd_cs cs as) \\<and>\n       (\\<forall>i<length (upd_cs cs as).\n           call_of_return_node (tl ms'' ! i)\n            (sourcenode (upd_cs cs as ! i)))", "by simp_all"], ["proof (state)\nthis:\n  slice_edges S cs as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs cs as) \\<and>\n     (\\<forall>i<length (upd_cs cs as).\n         call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs as ! i)))\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "with \\<open>intra_kind (kind a)\\<close> \\<open>\\<not> slice_edge S cs a\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  \\<not> slice_edge S cs a\n  slice_edges S cs as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs cs as) \\<and>\n     (\\<forall>i<length (upd_cs cs as).\n         call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs as ! i)))", "show ?case"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  \\<not> slice_edge S cs a\n  slice_edges S cs as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs cs as) \\<and>\n     (\\<forall>i<length (upd_cs cs as).\n         call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs as ! i)))\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = [] \\<and>\n    (\\<exists>rs'.\n        tl ms'' = targetnodes rs' \\<and>\n        length rs' = length (upd_cs cs (a # as)) \\<and>\n        (\\<forall>i<length (upd_cs cs (a # as)).\n            call_of_return_node (tl ms'' ! i)\n             (sourcenode (upd_cs cs (a # as) ! i))))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs (a # as)) \\<and>\n      (\\<forall>i<length (upd_cs cs (a # as)).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs (a # as) ! i))))\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "case (silent_move_call f a s s' Q r p fs a' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  \\<not> slice_edge S cs a\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "note IH = \\<open>\\<And>rs cs. \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n      \\<forall>i<length cs. call_of_return_node (tl ms' ! i) (sourcenode (cs ! i))\\<rbrakk>\n      \\<Longrightarrow> slice_edges S cs as = [] \\<and> (\\<exists>rs'. tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs as) \\<and> (\\<forall>i<length (upd_cs cs as).\n      call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs as ! i))))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>tl ms = targetnodes rs\\<close> \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  tl ms = targetnodes rs\n  ms' = targetnode a # targetnode a' # tl ms", "have \"tl ms' = targetnodes (a'#rs)\""], ["proof (prove)\nusing this:\n  tl ms = targetnodes rs\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (1 subgoal):\n 1. tl ms' = targetnodes (a' # rs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  tl ms' = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs", "have \"length (a'#rs) = length (a#cs)\""], ["proof (prove)\nusing this:\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. length (a' # rs) = length (a # cs)", "by simp"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"return_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. return_node (targetnode a')", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "with \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  return_node (targetnode a')", "have \"call_of_return_node (targetnode a') (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  return_node (targetnode a')\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode a)", "by(simp add:call_of_return_node_def) blast"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "with \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>\n      \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  ms' = targetnode a # targetnode a' # tl ms\n  call_of_return_node (targetnode a') (sourcenode a)", "have \"\\<forall>i<length (a#cs). \n      call_of_return_node (tl ms' ! i) (sourcenode ((a#cs) ! i))\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  ms' = targetnode a # targetnode a' # tl ms\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a # cs).\n       call_of_return_node (tl ms' ! i) (sourcenode ((a # cs) ! i))", "by auto (case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a # cs).\n     call_of_return_node (tl ms' ! i) (sourcenode ((a # cs) ! i))\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from IH[OF \\<open>tl ms' = targetnodes (a'#rs)\\<close> \\<open>length (a'#rs) = length (a#cs)\\<close> this]"], ["proof (chain)\npicking this:\n  slice_edges S (a # cs) as = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs (a # cs) as) \\<and>\n      (\\<forall>i<length (upd_cs (a # cs) as).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs (a # cs) as ! i))))", "have \"slice_edges S (a # cs) as = []\"\n      and \"\\<exists>rs'. tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs (a # cs) as) \\<and>\n      (\\<forall>i<length (upd_cs (a # cs) as).\n        call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs (a # cs) as ! i)))\""], ["proof (prove)\nusing this:\n  slice_edges S (a # cs) as = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs (a # cs) as) \\<and>\n      (\\<forall>i<length (upd_cs (a # cs) as).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs (a # cs) as ! i))))\n\ngoal (1 subgoal):\n 1. slice_edges S (a # cs) as = [] &&&\n    \\<exists>rs'.\n       tl ms'' = targetnodes rs' \\<and>\n       length rs' = length (upd_cs (a # cs) as) \\<and>\n       (\\<forall>i<length (upd_cs (a # cs) as).\n           call_of_return_node (tl ms'' ! i)\n            (sourcenode (upd_cs (a # cs) as ! i)))", "by simp_all"], ["proof (state)\nthis:\n  slice_edges S (a # cs) as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs (a # cs) as) \\<and>\n     (\\<forall>i<length (upd_cs (a # cs) as).\n         call_of_return_node (tl ms'' ! i)\n          (sourcenode (upd_cs (a # cs) as ! i)))\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "with \\<open>\\<not> slice_edge S cs a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<not> slice_edge S cs a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  slice_edges S (a # cs) as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs (a # cs) as) \\<and>\n     (\\<forall>i<length (upd_cs (a # cs) as).\n         call_of_return_node (tl ms'' ! i)\n          (sourcenode (upd_cs (a # cs) as ! i)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> slice_edge S cs a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  slice_edges S (a # cs) as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs (a # cs) as) \\<and>\n     (\\<forall>i<length (upd_cs (a # cs) as).\n         call_of_return_node (tl ms'' ! i)\n          (sourcenode (upd_cs (a # cs) as ! i)))\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = [] \\<and>\n    (\\<exists>rs'.\n        tl ms'' = targetnodes rs' \\<and>\n        length rs' = length (upd_cs cs (a # as)) \\<and>\n        (\\<forall>i<length (upd_cs cs (a # as)).\n            call_of_return_node (tl ms'' ! i)\n             (sourcenode (upd_cs cs (a # as) ! i))))", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs (a # as)) \\<and>\n      (\\<forall>i<length (upd_cs cs (a # as)).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs (a # as) ! i))))\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "case (silent_move_return f a s s' Q p f' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "note IH = \\<open>\\<And>rs cs. \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n      \\<forall>i<length cs. call_of_return_node (tl ms' ! i) (sourcenode (cs ! i))\\<rbrakk>\n      \\<Longrightarrow> slice_edges S cs as = [] \\<and> (\\<exists>rs'. tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs as) \\<and> (\\<forall>i<length (upd_cs cs as).\n      call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs as ! i))))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>tl ms' = targetnodes ?rs; length ?rs = length ?cs;\n   \\<forall>i<length ?cs.\n      call_of_return_node (tl ms' ! i) (sourcenode (?cs ! i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S ?cs as = [] \\<and>\n                    (\\<exists>rs'.\n                        tl ms'' = targetnodes rs' \\<and>\n                        length rs' = length (upd_cs ?cs as) \\<and>\n                        (\\<forall>i<length (upd_cs ?cs as).\n                            call_of_return_node (tl ms'' ! i)\n                             (sourcenode (upd_cs ?cs as ! i))))\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>length s = Suc (length s')\\<close> \\<open>s' \\<noteq> []\\<close> \\<open>length ms = length s\\<close> \\<open>ms' = tl ms\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length s')\n  s' \\<noteq> []\n  length ms = length s\n  ms' = tl ms", "obtain x xs where [simp]:\"ms' = x#xs\""], ["proof (prove)\nusing this:\n  length s = Suc (length s')\n  s' \\<noteq> []\n  length ms = length s\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms' = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms)(auto,case_tac ms',auto)"], ["proof (state)\nthis:\n  ms' = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>ms' = tl ms\\<close> \\<open>tl ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms' = tl ms\n  tl ms = targetnodes rs", "obtain r' rs' where \"rs = r'#rs'\"\n      and \"x = targetnode r'\" and \"tl ms' = targetnodes rs'\""], ["proof (prove)\nusing this:\n  ms' = tl ms\n  tl ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; x = targetnode r';\n         tl ms' = targetnodes rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rs)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  rs = r' # rs'\n  x = targetnode r'\n  tl ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>length rs = length cs\\<close> \\<open>rs = r'#rs'\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  rs = r' # rs'", "obtain c' cs' where \"cs = c'#cs'\"\n      and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  rs = r' # rs'\n\ngoal (1 subgoal):\n 1. (\\<And>c' cs'.\n        \\<lbrakk>cs = c' # cs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cs) auto"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>\n      \\<open>cs = c'#cs'\\<close> \\<open>ms' = tl ms\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  cs = c' # cs'\n  ms' = tl ms", "have \"\\<forall>i<length cs'. call_of_return_node (tl ms' ! i) (sourcenode (cs' ! i))\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n  cs = c' # cs'\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs'.\n       call_of_return_node (tl ms' ! i) (sourcenode (cs' ! i))", "by auto(erule_tac x=\"Suc i\" in allE,cases \"tl ms\",auto)"], ["proof (state)\nthis:\n  \\<forall>i<length cs'.\n     call_of_return_node (tl ms' ! i) (sourcenode (cs' ! i))\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "from IH[OF \\<open>tl ms' = targetnodes rs'\\<close> \\<open>length rs' = length cs'\\<close> this]"], ["proof (chain)\npicking this:\n  slice_edges S cs' as = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs' as) \\<and>\n      (\\<forall>i<length (upd_cs cs' as).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs' as ! i))))", "have \"slice_edges S cs' as = []\" and \"\\<exists>rs'. tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs' as) \\<and> (\\<forall>i<length (upd_cs cs' as).\n      call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs' as ! i)))\""], ["proof (prove)\nusing this:\n  slice_edges S cs' as = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs' as) \\<and>\n      (\\<forall>i<length (upd_cs cs' as).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs' as ! i))))\n\ngoal (1 subgoal):\n 1. slice_edges S cs' as = [] &&&\n    \\<exists>rs'.\n       tl ms'' = targetnodes rs' \\<and>\n       length rs' = length (upd_cs cs' as) \\<and>\n       (\\<forall>i<length (upd_cs cs' as).\n           call_of_return_node (tl ms'' ! i)\n            (sourcenode (upd_cs cs' as ! i)))", "by simp_all"], ["proof (state)\nthis:\n  slice_edges S cs' as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs cs' as) \\<and>\n     (\\<forall>i<length (upd_cs cs' as).\n         call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs' as ! i)))\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<And>rs cs.\n           \\<lbrakk>tl ms' = targetnodes rs; length rs = length cs;\n            \\<forall>i<length cs.\n               call_of_return_node (tl ms' ! i)\n                (sourcenode (cs ! i))\\<rbrakk>\n           \\<Longrightarrow> slice_edges S cs as = [] \\<and>\n                             (\\<exists>rs'.\n                                 tl ms'' = targetnodes rs' \\<and>\n                                 length rs' = length (upd_cs cs as) \\<and>\n                                 (\\<forall>i<length (upd_cs cs as).\n                                     call_of_return_node (tl ms'' ! i)\n(sourcenode (upd_cs cs as ! i))));\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i));\n        \\<not> slice_edge S cs a\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (a # as) = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms'' = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs (a # as)) \\<and>\n                             (\\<forall>i<length (upd_cs cs (a # as)).\n                                 call_of_return_node (tl ms'' ! i)\n                                  (sourcenode (upd_cs cs (a # as) ! i))))", "with \\<open>\\<not> slice_edge S cs a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> slice_edge S cs a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'\n  slice_edges S cs' as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs cs' as) \\<and>\n     (\\<forall>i<length (upd_cs cs' as).\n         call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs' as ! i)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> slice_edge S cs a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = c' # cs'\n  slice_edges S cs' as = []\n  \\<exists>rs'.\n     tl ms'' = targetnodes rs' \\<and>\n     length rs' = length (upd_cs cs' as) \\<and>\n     (\\<forall>i<length (upd_cs cs' as).\n         call_of_return_node (tl ms'' ! i) (sourcenode (upd_cs cs' as ! i)))\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = [] \\<and>\n    (\\<exists>rs'.\n        tl ms'' = targetnodes rs' \\<and>\n        length rs' = length (upd_cs cs (a # as)) \\<and>\n        (\\<forall>i<length (upd_cs cs (a # as)).\n            call_of_return_node (tl ms'' ! i)\n             (sourcenode (upd_cs cs (a # as) ! i))))", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs (a # as)) \\<and>\n      (\\<forall>i<length (upd_cs cs (a # as)).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs (a # as) ! i))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = [] \\<and>\n  (\\<exists>rs'.\n      tl ms'' = targetnodes rs' \\<and>\n      length rs' = length (upd_cs cs (a # as)) \\<and>\n      (\\<forall>i<length (upd_cs cs (a # as)).\n          call_of_return_node (tl ms'' ! i)\n           (sourcenode (upd_cs cs (a # as) ! i))))\n\ngoal (1 subgoal):\n 1. \\<And>ms s S f rs cs.\n       \\<lbrakk>length ms = length s; tl ms = targetnodes rs;\n        length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs [] = [] \\<and>\n                         (\\<exists>rs'.\n                             tl ms = targetnodes rs' \\<and>\n                             length rs' = length (upd_cs cs []) \\<and>\n                             (\\<forall>i<length (upd_cs cs []).\n                                 call_of_return_node (tl ms ! i)\n                                  (sourcenode (upd_cs cs [] ! i))))", "qed fastforce"], ["", "lemma observable_moves_singular_slice_edge:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s'); tl ms = targetnodes rs; length rs = length cs;\n    \\<forall>i<length cs. call_of_return_node (tl ms!i) (sourcenode (cs!i))\\<rbrakk>\n  \\<Longrightarrow> slice_edges S cs as = [last as]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n     tl ms = targetnodes rs; length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> slice_edges S cs as = [last as]", "proof(induct rule:observable_moves.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'');\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (as @ [a]) = [last (as @ [a])]", "case (observable_moves_snoc S f ms s as ms' s' a ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'');\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (as @ [a]) = [last (as @ [a])]", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close> \\<open>tl ms = targetnodes rs\\<close> \\<open>length rs = length cs\\<close>\n    \\<open>\\<forall>i<length cs. call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))", "obtain rs' where \"slice_edges S cs as = []\" \n    and \"tl ms' = targetnodes rs'\" and \"length rs' = length (upd_cs cs as)\"\n    and \"\\<forall>i<length (upd_cs cs as). \n    call_of_return_node (tl ms'!i) (sourcenode ((upd_cs cs as)!i))\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  tl ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>rs'.\n        \\<lbrakk>slice_edges S cs as = []; tl ms' = targetnodes rs';\n         length rs' = length (upd_cs cs as);\n         \\<forall>i<length (upd_cs cs as).\n            call_of_return_node (tl ms' ! i)\n             (sourcenode (upd_cs cs as ! i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:silent_moves_no_slice_edges)"], ["proof (state)\nthis:\n  slice_edges S cs as = []\n  tl ms' = targetnodes rs'\n  length rs' = length (upd_cs cs as)\n  \\<forall>i<length (upd_cs cs as).\n     call_of_return_node (tl ms' ! i) (sourcenode (upd_cs cs as ! i))\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'');\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (as @ [a]) = [last (as @ [a])]", "from \\<open>S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<close> this"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\n  slice_edges S cs as = []\n  tl ms' = targetnodes rs'\n  length rs' = length (upd_cs cs as)\n  \\<forall>i<length (upd_cs cs as).\n     call_of_return_node (tl ms' ! i) (sourcenode (upd_cs cs as ! i))", "have \"slice_edge S (upd_cs cs as) a\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\n  slice_edges S cs as = []\n  tl ms' = targetnodes rs'\n  length rs' = length (upd_cs cs as)\n  \\<forall>i<length (upd_cs cs as).\n     call_of_return_node (tl ms' ! i) (sourcenode (upd_cs cs as ! i))\n\ngoal (1 subgoal):\n 1. slice_edge S (upd_cs cs as) a", "by -(rule observable_move_slice_edge)"], ["proof (state)\nthis:\n  slice_edge S (upd_cs cs as) a\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'');\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (as @ [a]) = [last (as @ [a])]", "with \\<open>slice_edges S cs as = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs as = []\n  slice_edge S (upd_cs cs as) a", "have \"slice_edges S cs (as @ [a]) = []@[a]\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = []\n  slice_edge S (upd_cs cs as) a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (as @ [a]) = [] @ [a]", "by(fastforce intro:slice_edges_Append)"], ["proof (state)\nthis:\n  slice_edges S cs (as @ [a]) = [] @ [a]\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'');\n        tl ms = targetnodes rs; length rs = length cs;\n        \\<forall>i<length cs.\n           call_of_return_node (tl ms ! i) (sourcenode (cs ! i))\\<rbrakk>\n       \\<Longrightarrow> slice_edges S cs (as @ [a]) = [last (as @ [a])]", "thus ?case"], ["proof (prove)\nusing this:\n  slice_edges S cs (as @ [a]) = [] @ [a]\n\ngoal (1 subgoal):\n 1. slice_edges S cs (as @ [a]) = [last (as @ [a])]", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (as @ [a]) = [last (as @ [a])]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_nonempty_nodestack_False:\n  assumes \"S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and \"ms' \\<noteq> []\" and \"CFG_node m' \\<in> sum_SDG_slice1 nx\" and \"nx \\<in> S\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from assms(1-4)"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  ms' \\<noteq> []\n  CFG_node m' \\<in> sum_SDG_slice1 nx", "have \"slice_edges S [] as \\<noteq> []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  ms' \\<noteq> []\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> []", "proof(induct ms' arbitrary:as m' s')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "case (Cons mx msx)"], ["proof (state)\nthis:\n  \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =?as\\<Rightarrow>\\<^sub>\\<tau> (?m' #\n                                    msx,?s');\n   valid_node m; msx \\<noteq> [];\n   CFG_node ?m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n  \\<Longrightarrow> slice_edges S [] ?as \\<noteq> []\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          mx # msx,s')\n  valid_node m\n  mx # msx \\<noteq> []\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "note IH = \\<open>\\<And>as m' s'. \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx,s'); valid_node m; \n      msx \\<noteq> []; CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n      \\<Longrightarrow> slice_edges S [] as \\<noteq> []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =?as\\<Rightarrow>\\<^sub>\\<tau> (?m' #\n                                    msx,?s');\n   valid_node m; msx \\<noteq> [];\n   CFG_node ?m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n  \\<Longrightarrow> slice_edges S [] ?as \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "from \\<open>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close> \\<open>valid_node m\\<close>\n      \\<open>CFG_node m' \\<in> sum_SDG_slice1 nx\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          mx # msx,s')\n  valid_node m\n  CFG_node m' \\<in> sum_SDG_slice1 nx", "obtain as' a as'' where \"as = as'@a#as''\" and \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"call_of_return_node mx (sourcenode a)\" \n      and \"CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\"\n      and \"targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          mx # msx,s')\n  valid_node m\n  CFG_node m' \\<in> sum_SDG_slice1 nx\n\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>as = as' @ a # as'';\n         \\<exists>Q r p fs.\n            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         call_of_return_node mx (sourcenode a);\n         CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx;\n         targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:silent_moves_called_node_in_slice1_hd_nodestack_in_slice1\n      [of _ _ _ _ _ _ _ _ _ \"[]\" \"[]\"] simp:targetnodes_def valid_return_list_def)"], ["proof (state)\nthis:\n  as = as' @ a # as''\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  call_of_return_node mx (sourcenode a)\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "from \\<open>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close> \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          mx # msx,s')\n  as = as' @ a # as''", "obtain xs x where \"S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\"\n      and \"S,kind \\<turnstile> (xs,x) =a#as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          mx # msx,s')\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. (\\<And>xs x.\n        \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x);\n         S,kind \\<turnstile> (xs,x) =a #\n                                     as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               mx # msx,s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves_split)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\n  S,kind \\<turnstile> (xs,x) =a #\n                              as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "from \\<open>S,kind \\<turnstile> (xs,x) =a#as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (xs,x) =a #\n                              as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')", "obtain ys y where \"S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\"\n      and \"S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (xs,x) =a #\n                              as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n\ngoal (1 subgoal):\n 1. (\\<And>ys y.\n        \\<lbrakk>S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y);\n         S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               mx # msx,s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\n  S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "from \\<open>S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\\<close> \\<open>\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain xs' a' where \"xs = sourcenode a#xs'\" \n      and \"ys = targetnode a#targetnode a'#xs'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y)\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>xs' a'.\n        \\<lbrakk>xs = sourcenode a # xs';\n         ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs' a'.\n                \\<lbrakk>xs = sourcenode a # xs';\n                 ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     S,kind \\<turnstile> (xs,x) -a\\<rightarrow>\\<^sub>\\<tau> (ys,y);\n     \\<exists>Q r p fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule silent_move.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f aa s s' ms Sa ms'.\n       \\<lbrakk>\\<And>xs' a'.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; xs = ms; x = s; a = aa; ys = ms'; y = s';\n        pred (f aa) s; transfer (f aa) s = s'; valid_edge aa;\n        intra_kind (kind aa);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode aa;\n        ms' = targetnode aa # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>f aa s s' Q r p fs a' ms Sa ms'.\n       \\<lbrakk>\\<And>xs' a'.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; xs = ms; x = s; a = aa; ys = ms'; y = s';\n        pred (f aa) s; transfer (f aa) s = s'; valid_edge aa;\n        kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges aa;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode aa;\n        ms' = targetnode aa # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>f aa s s' Q p f' ms Sa ms'.\n       \\<lbrakk>\\<And>xs' a'.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    ys = targetnode a # targetnode a' # xs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        S = Sa; kind = f; xs = ms; x = s; a = aa; ys = ms'; y = s';\n        pred (f aa) s; transfer (f aa) s = s'; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode aa;\n        hd (tl ms) = targetnode aa; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:intra_kind_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs a' m m'.\n       \\<lbrakk>\\<And>xs' a'a.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    targetnode a' = targetnode a'a\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ys = targetnode a # targetnode a' # tl xs;\n        pred (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a; Ball (set (tl xs)) return_node;\n        length xs = length x;\n        length (transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x) =\n        Suc (length x);\n        hd xs = sourcenode a;\n        y = transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x;\n        m \\<in> set (tl xs); call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>Q r p fs a'.\n       \\<lbrakk>\\<And>xs' a'a.\n                   \\<lbrakk>xs = sourcenode a # xs';\n                    targetnode a' = targetnode a'a\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ys = targetnode a # targetnode a' # tl xs;\n        pred (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a; Ball (set (tl xs)) return_node;\n        length xs = length x;\n        length (transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x) =\n        Suc (length x);\n        hd xs = sourcenode a;\n        y = transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) x;\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases xs,auto)+"], ["proof (state)\nthis:\n  xs = sourcenode a # xs'\n  ys = targetnode a # targetnode a' # xs'\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "from \\<open>S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' # mx # msx,s')\\<close> \n      \\<open>ys = targetnode a#targetnode a'#xs'\\<close> \\<open>targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n  ys = targetnode a # targetnode a' # xs'\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "have \"mx = targetnode a'\" and \"xs' = msx\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ys,y) =as''\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        mx # msx,s')\n  ys = targetnode a # targetnode a' # xs'\n  targetnode a -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (1 subgoal):\n 1. mx = targetnode a' &&& xs' = msx", "by(auto dest:silent_moves_same_level_path)"], ["proof (state)\nthis:\n  mx = targetnode a'\n  xs' = msx\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "with \\<open>xs = sourcenode a#xs'\\<close> \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\\<close>"], ["proof (chain)\npicking this:\n  xs = sourcenode a # xs'\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\n  mx = targetnode a'\n  xs' = msx", "have \"S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode a#msx,x)\""], ["proof (prove)\nusing this:\n  xs = sourcenode a # xs'\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (xs,x)\n  mx = targetnode a'\n  xs' = msx\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                              a #\n                             msx,x)", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                            a #\n                           msx,x)\n\ngoal (2 subgoals):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. \\<And>a ms' as m' s'.\n       \\<lbrakk>\\<And>as m' s'.\n                   \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n              ms',s');\n                    valid_node m; ms' \\<noteq> [];\n                    CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n                   \\<Longrightarrow> slice_edges S [] as \\<noteq> [];\n        S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                a # ms',s');\n        valid_node m; a # ms' \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> []", "proof(cases \"msx = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "case True"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "from \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode a#msx,x)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                            a #\n                           msx,x)", "obtain rs' where \"msx = targetnodes rs' \\<and> length rs' = length (upd_cs [] as')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode\n                            a #\n                           msx,x)\n\ngoal (1 subgoal):\n 1. (\\<And>rs'.\n        msx = targetnodes rs' \\<and>\n        length rs' = length (upd_cs [] as') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:silent_moves_no_slice_edges[where cs=\"[]\" and rs=\"[]\"]\n                    simp:targetnodes_def)"], ["proof (state)\nthis:\n  msx = targetnodes rs' \\<and> length rs' = length (upd_cs [] as')\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "with True"], ["proof (chain)\npicking this:\n  msx = []\n  msx = targetnodes rs' \\<and> length rs' = length (upd_cs [] as')", "have \"upd_cs [] as' = []\""], ["proof (prove)\nusing this:\n  msx = []\n  msx = targetnodes rs' \\<and> length rs' = length (upd_cs [] as')\n\ngoal (1 subgoal):\n 1. upd_cs [] as' = []", "by(cases rs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  upd_cs [] as' = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "with \\<open>CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<close> \\<open>nx \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n  upd_cs [] as' = []", "have \"slice_edge S (upd_cs [] as') a\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n  upd_cs [] as' = []\n\ngoal (1 subgoal):\n 1. slice_edge S (upd_cs [] as') a", "by(cases \"kind a\",auto intro:combSlice_refl \n          simp:slice_edge_def SDG_to_CFG_set_def HRB_slice_def)"], ["proof (state)\nthis:\n  slice_edge S (upd_cs [] as') a\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "hence \"slice_edges S (upd_cs [] as') (a#as'') \\<noteq> []\""], ["proof (prove)\nusing this:\n  slice_edge S (upd_cs [] as') a\n\ngoal (1 subgoal):\n 1. slice_edges S (upd_cs [] as') (a # as'') \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  slice_edges S (upd_cs [] as') (a # as'') \\<noteq> []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []\n 2. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "with \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''\n  slice_edges S (upd_cs [] as') (a # as'') \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n  slice_edges S (upd_cs [] as') (a # as'') \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> []", "by(fastforce dest:slice_edges_Nil_split)"], ["proof (state)\nthis:\n  slice_edges S [] as \\<noteq> []\n\ngoal (1 subgoal):\n 1. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "case False"], ["proof (state)\nthis:\n  msx \\<noteq> []\n\ngoal (1 subgoal):\n 1. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "from IH[OF \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (sourcenode a#msx,x)\\<close> \n        \\<open>valid_node m\\<close> this \\<open>CFG_node (sourcenode a) \\<in> sum_SDG_slice1 nx\\<close>]"], ["proof (chain)\npicking this:\n  slice_edges S [] as' \\<noteq> []", "have \"slice_edges S [] as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  slice_edges S [] as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as' \\<noteq> []", "."], ["proof (state)\nthis:\n  slice_edges S [] as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. msx \\<noteq> [] \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "with \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''\n  slice_edges S [] as' \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n  slice_edges S [] as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> []", "by(fastforce dest:slice_edges_Nil_split)"], ["proof (state)\nthis:\n  slice_edges S [] as \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_edges S [] as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>as m' s'.\n       \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> ([m'],s');\n        valid_node m; [] \\<noteq> [];\n        CFG_node m' \\<in> sum_SDG_slice1 nx\\<rbrakk>\n       \\<Longrightarrow> slice_edges S [] as \\<noteq> []", "qed simp"], ["proof (state)\nthis:\n  slice_edges S [] as \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  slice_edges S [] as \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "from \\<open>S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "have \"slice_edges S [] as = []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (1 subgoal):\n 1. slice_edges S [] as = []", "by(fastforce dest!:silent_moves_no_slice_edges[where cs=\"[]\" and rs=\"[]\"] \n                simp:targetnodes_def)"], ["proof (state)\nthis:\n  slice_edges S [] as = []\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  slice_edges S [] as \\<noteq> []\n  slice_edges S [] as = []", "show False"], ["proof (prove)\nusing this:\n  slice_edges S [] as \\<noteq> []\n  slice_edges S [] as = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfers_intra_slice_kinds_slice_edges:\n  \"\\<lbrakk>\\<forall>a \\<in> set as. intra_kind (kind a); \\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> transfers (slice_kinds S (slice_edges S cs as)) s =\n  transfers (slice_kinds S as) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n     \\<forall>c\\<in>set cs.\n        sourcenode c\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> transfers (slice_kinds S (slice_edges S cs as)) s =\n                      transfers (slice_kinds S as) s", "proof(induct as arbitrary:s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers (slice_kinds S (slice_edges S cs [])) s =\n                         transfers (slice_kinds S []) s\n 2. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n                    \\<forall>c\\<in>set cs.\n                       sourcenode c\n                       \\<in> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                   \\<Longrightarrow> transfers\n(slice_kinds S (slice_edges S cs as)) s =\n                                     transfers (slice_kinds S as) s;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers\n                          (slice_kinds S (slice_edges S cs (a # as))) s =\n                         transfers (slice_kinds S (a # as)) s", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers (slice_kinds S (slice_edges S cs [])) s =\n                         transfers (slice_kinds S []) s\n 2. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n                    \\<forall>c\\<in>set cs.\n                       sourcenode c\n                       \\<in> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                   \\<Longrightarrow> transfers\n(slice_kinds S (slice_edges S cs as)) s =\n                                     transfers (slice_kinds S as) s;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers\n                          (slice_kinds S (slice_edges S cs (a # as))) s =\n                         transfers (slice_kinds S (a # as)) s", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs [])) s =\n    transfers (slice_kinds S []) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs [])) s =\n  transfers (slice_kinds S []) s\n\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n                    \\<forall>c\\<in>set cs.\n                       sourcenode c\n                       \\<in> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                   \\<Longrightarrow> transfers\n(slice_kinds S (slice_edges S cs as)) s =\n                                     transfers (slice_kinds S as) s;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers\n                          (slice_kinds S (slice_edges S cs (a # as))) s =\n                         transfers (slice_kinds S (a # as)) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n                    \\<forall>c\\<in>set cs.\n                       sourcenode c\n                       \\<in> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                   \\<Longrightarrow> transfers\n(slice_kinds S (slice_edges S cs as)) s =\n                                     transfers (slice_kinds S as) s;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers\n                          (slice_kinds S (slice_edges S cs (a # as))) s =\n                         transfers (slice_kinds S (a # as)) s", "case (Cons a' as')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>set as'. intra_kind (kind a);\n   \\<forall>c\\<in>set cs.\n      sourcenode c\n      \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> transfers (slice_kinds S (slice_edges S cs as')) ?s =\n                    transfers (slice_kinds S as') ?s\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n                    \\<forall>c\\<in>set cs.\n                       sourcenode c\n                       \\<in> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                   \\<Longrightarrow> transfers\n(slice_kinds S (slice_edges S cs as)) s =\n                                     transfers (slice_kinds S as) s;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers\n                          (slice_kinds S (slice_edges S cs (a # as))) s =\n                         transfers (slice_kinds S (a # as)) s", "note IH = \\<open>\\<And>s. \\<lbrakk>\\<forall>a\\<in>set as'. intra_kind (kind a);\n    \\<forall>c\\<in>set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk> \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs as')) s =\n    transfers (slice_kinds S as') s\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>set as'. intra_kind (kind a);\n   \\<forall>c\\<in>set cs.\n      sourcenode c\n      \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> transfers (slice_kinds S (slice_edges S cs as')) ?s =\n                    transfers (slice_kinds S as') ?s\n\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n                    \\<forall>c\\<in>set cs.\n                       sourcenode c\n                       \\<in> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                   \\<Longrightarrow> transfers\n(slice_kinds S (slice_edges S cs as)) s =\n                                     transfers (slice_kinds S as) s;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers\n                          (slice_kinds S (slice_edges S cs (a # as))) s =\n                         transfers (slice_kinds S (a # as)) s", "from \\<open>\\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)", "have \"intra_kind (kind a')\" and \"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a') &&& \\<forall>a\\<in>set as'. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n                    \\<forall>c\\<in>set cs.\n                       sourcenode c\n                       \\<in> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n                   \\<Longrightarrow> transfers\n(slice_kinds S (slice_edges S cs as)) s =\n                                     transfers (slice_kinds S as) s;\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> transfers\n                          (slice_kinds S (slice_edges S cs (a # as))) s =\n                         transfers (slice_kinds S (a # as)) s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "proof(cases \"slice_edge S cs a'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "case True"], ["proof (state)\nthis:\n  slice_edge S cs a'\n\ngoal (2 subgoals):\n 1. slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "with \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  slice_edge S cs a'", "have eq:\"transfers (slice_kinds S (slice_edges S cs (a'#as'))) s\n            = transfers (slice_kinds S (slice_edges S cs as')) \n                (transfer (slice_kind S a') s)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  slice_edge S cs a'\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (slice_edges S cs as'))\n     (transfer (slice_kind S a') s)", "by(cases \"kind a'\")(auto simp:slice_kinds_def intra_kind_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S cs as'))\n   (transfer (slice_kind S a') s)\n\ngoal (2 subgoals):\n 1. slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "have \"transfers (slice_kinds S (a'#as')) s\n        = transfers (slice_kinds S as') (transfer (slice_kind S a') s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (a' # as')) s =\n    transfers (slice_kinds S as') (transfer (slice_kind S a') s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (a' # as')) s =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n\ngoal (2 subgoals):\n 1. slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "with eq IH[OF \\<open>\\<forall>a\\<in>set as'. intra_kind (kind a)\\<close> \n      \\<open>\\<forall>c\\<in>set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>,\n      of \"transfer (slice_kind S a') s\"]"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S cs as'))\n   (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (slice_edges S cs as'))\n   (transfer (slice_kind S a') s) =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (a' # as')) s =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)", "show ?thesis"], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S cs as'))\n   (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (slice_edges S cs as'))\n   (transfer (slice_kind S a') s) =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (a' # as')) s =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "by simp"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (a' # as')) s\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "case False"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a'\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "with \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  \\<not> slice_edge S cs a'", "have eq:\"transfers (slice_kinds S (slice_edges S cs (a'#as'))) s\n            = transfers (slice_kinds S (slice_edges S cs as')) s\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  \\<not> slice_edge S cs a'\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (slice_edges S cs as')) s", "by(cases \"kind a'\")(auto simp:slice_kinds_def intra_kind_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S cs as')) s\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "from False \\<open>intra_kind (kind a')\\<close> \\<open>\\<forall>c\\<in>set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<not> slice_edge S cs a'\n  intra_kind (kind a')\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<not> slice_edge S cs a'\n  intra_kind (kind a')\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce simp:slice_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "with \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"transfer (slice_kind S a') s = s\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  sourcenode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a') s = s", "by(cases s)(auto,cases \"kind a'\",\n        auto simp:slice_kind_def Let_def intra_kind_def)"], ["proof (state)\nthis:\n  transfer (slice_kind S a') s = s\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "hence \"transfers (slice_kinds S (a'#as')) s\n         = transfers (slice_kinds S as') s\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a') s = s\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a' \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "with eq IH[OF \\<open>\\<forall>a\\<in>set as'. intra_kind (kind a)\\<close> \n      \\<open>\\<forall>c\\<in>set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>,of s]"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S cs as')) s\n  transfers (slice_kinds S (slice_edges S cs as')) s =\n  transfers (slice_kinds S as') s\n  transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s", "show ?thesis"], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S cs as')) s\n  transfers (slice_kinds S (slice_edges S cs as')) s =\n  transfers (slice_kinds S as') s\n  transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "by simp"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (a' # as')) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs (a' # as'))) s =\n  transfers (slice_kinds S (a' # as')) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_sliced_intra_path_preds:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"slice_edges S cs as = []\" \n  and \"m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  obtains as' where \"m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"preds (slice_kinds S as') (cf#cfs)\"\n  and \"slice_edges S cs as' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>m -as'\\<rightarrow>\\<^sub>\\<iota>* m';\n         preds (slice_kinds S as') (cf # cfs);\n         slice_edges S cs as' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'", "have \"m -as\\<rightarrow>* m'\" and \"\\<forall>a \\<in> set as. intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* m' &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* m'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "from \\<open>slice_edges S cs as = []\\<close> \\<open>\\<forall>a \\<in> set as. intra_kind(kind a)\\<close>\n    \\<open>\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs as = []\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = []\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes as).\n       nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule slice_intra_edges_no_nodes_in_slice)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes as).\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "with \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set (sourcenodes as).\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set (sourcenodes as).\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:obs_intra_elem)"], ["proof (state)\nthis:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "hence \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}", "by(rule obs_intra_singleton_element)"], ["proof (state)\nthis:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "from \\<open>m -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>* m'", "have \"valid_node m\" and \"valid_node m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. valid_node m &&& valid_node m'", "by(fastforce dest:path_valid_node)+"], ["proof (state)\nthis:\n  valid_node m\n  valid_node m'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'", "obtain x where \"distance m m' x\" and \"x \\<le> length as\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance m m' x; x \\<le> length as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule every_path_distance)"], ["proof (state)\nthis:\n  distance m m' x\n  x \\<le> length as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "from \\<open>distance m m' x\\<close> \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\\<close>"], ["proof (chain)\npicking this:\n  distance m m' x\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}", "show \"\\<exists>as'. m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and> preds (slice_kinds S as') (cf#cfs) \\<and> \n              slice_edges S cs as' = []\""], ["proof (prove)\nusing this:\n  distance m m' x\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "proof(induct x arbitrary:m rule:nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>distance m m' 0;\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "case zero"], ["proof (state)\nthis:\n  distance m m' 0\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>distance m m' 0;\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from \\<open>distance m m' 0\\<close>"], ["proof (chain)\npicking this:\n  distance m m' 0", "have \"m = m'\""], ["proof (prove)\nusing this:\n  distance m m' 0\n\ngoal (1 subgoal):\n 1. m = m'", "by(fastforce elim:distance.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  m = m'\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>distance m m' 0;\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>valid_node m'\\<close>"], ["proof (chain)\npicking this:\n  valid_node m'\n  m = m'", "show ?case"], ["proof (prove)\nusing this:\n  valid_node m'\n  m = m'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "by(rule_tac x=\"[]\" in exI,\n        auto intro:empty_path simp:slice_kinds_def intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n     preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>distance ?m m' x;\n   obs_intra ?m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n   {m'}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       ?m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                       preds (slice_kinds S as') (cf # cfs) \\<and>\n                       slice_edges S cs as' = []\n  distance m m' (Suc x)\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "note IH = \\<open>\\<And>m. \\<lbrakk>distance m m' x; obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\\<rbrakk>\n      \\<Longrightarrow> \\<exists>as'. m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and> preds (slice_kinds S as') (cf # cfs) \\<and>\n               slice_edges S cs as' = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>distance ?m m' x;\n   obs_intra ?m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n   {m'}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       ?m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                       preds (slice_kinds S as') (cf # cfs) \\<and>\n                       slice_edges S cs as' = []\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from \\<open>distance m m' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance m m' (Suc x)", "obtain a \n      where \"valid_edge a\" and \"m = sourcenode a\" and \"intra_kind(kind a)\"\n      and \"distance (targetnode a) m' x\"\n      and target:\"targetnode a = (SOME nx. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n      distance (targetnode a') m' x \\<and>\n      valid_edge a' \\<and> intra_kind(kind a') \\<and> targetnode a' = nx)\""], ["proof (prove)\nusing this:\n  distance m m' (Suc x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; m = sourcenode a; intra_kind (kind a);\n         distance (targetnode a) m' x;\n         targetnode a =\n         (SOME nx.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m' x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = nx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance_successor_distance)"], ["proof (state)\nthis:\n  valid_edge a\n  m = sourcenode a\n  intra_kind (kind a)\n  distance (targetnode a) m' x\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "have \"m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "assume \"m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from \\<open>valid_edge a\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  m = sourcenode a", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  valid_edge a\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. valid_node m", "by simp"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_node m", "have \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\""], ["proof (prove)\nusing this:\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_node m\n\ngoal (1 subgoal):\n 1. obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "by -(rule n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "have \"m = m'\""], ["proof (prove)\nusing this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (1 subgoal):\n 1. m = m'", "by simp"], ["proof (state)\nthis:\n  m = m'\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m = m'", "have \"m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  valid_node m\n  m = m'\n\ngoal (1 subgoal):\n 1. m -[]\\<rightarrow>\\<^sub>\\<iota>* m'", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>distance m m' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance m m' (Suc x)\n  m -[]\\<rightarrow>\\<^sub>\\<iota>* m'", "show False"], ["proof (prove)\nusing this:\n  distance m m' (Suc x)\n  m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:distance.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from \\<open>distance (targetnode a) m' x\\<close> \\<open>m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  distance (targetnode a) m' x\n  m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain mx where \"mx \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  distance (targetnode a) m' x\n  m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>mx.\n        mx \\<in> obs_intra (targetnode a)\n                  \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:distance.cases path_ex_obs_intra)"], ["proof (state)\nthis:\n  mx \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from \\<open>valid_edge a\\<close> \\<open>intra_kind(kind a)\\<close> \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<subseteq> \n      obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n    \\<subseteq> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(rule edge_obs_intra_subset,auto)"], ["proof (state)\nthis:\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>mx \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close>\n      \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\\<close>"], ["proof (chain)\npicking this:\n  mx \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m' \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  mx \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m' \\<in> obs_intra (targetnode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by auto"], ["proof (state)\nthis:\n  m' \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "hence \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {m'}", "by(rule obs_intra_singleton_element)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {m'}\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from IH[OF \\<open>distance (targetnode a) m' x\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n     preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "obtain as where \"targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"preds (slice_kinds S as) (cf#cfs)\"\n      and \"slice_edges S cs as = []\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n     preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* m';\n         preds (slice_kinds S as) (cf # cfs);\n         slice_edges S cs as = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  preds (slice_kinds S as) (cf # cfs)\n  slice_edges S cs as = []\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from \\<open>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind(kind a)\\<close> \n      \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  valid_edge a\n  intra_kind (kind a)\n  m = sourcenode a", "have \"m -a#as\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  valid_edge a\n  intra_kind (kind a)\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>\\<^sub>\\<iota>* m'", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from \\<open>\\<forall>c \\<in> set cs. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>m = sourcenode a\\<close> \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  intra_kind (kind a)", "have \"\\<not> slice_edge S cs a\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set cs.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(fastforce simp:slice_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>slice_edges S cs as = []\\<close> \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs as = []\n  intra_kind (kind a)\n  \\<not> slice_edge S cs a", "have \"slice_edges S cs (a#as) = []\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = []\n  intra_kind (kind a)\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = []\n\ngoal (1 subgoal):\n 1. \\<And>nat m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distance m m' nat;\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {m'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n  preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = [];\n        distance m m' (Suc nat);\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "from \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "show ?case"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "proof(cases \"kind a\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "case (UpdateEdge f)"], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  kind a = \\<Up>f", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by(fastforce intro:slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "hence \"transfer (slice_kind S a) (cf#cfs) = (cf#cfs)\" \n        and \"pred (slice_kind S a) (cf#cfs)\""], ["proof (prove)\nusing this:\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) (cf # cfs) = cf # cfs &&&\n    pred (slice_kind S a) (cf # cfs)", "by simp_all"], ["proof (state)\nthis:\n  transfer (slice_kind S a) (cf # cfs) = cf # cfs\n  pred (slice_kind S a) (cf # cfs)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>preds (slice_kinds S as) (cf#cfs)\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as) (cf # cfs)\n  transfer (slice_kind S a) (cf # cfs) = cf # cfs\n  pred (slice_kind S a) (cf # cfs)", "have \"preds (slice_kinds S (a#as)) (cf#cfs)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as) (cf # cfs)\n  transfer (slice_kind S a) (cf # cfs) = cf # cfs\n  pred (slice_kind S a) (cf # cfs)\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S (a # as)) (cf # cfs)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S (a # as)) (cf # cfs)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>m -a#as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>slice_edges S cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S cs (a # as) = []\n  preds (slice_kinds S (a # as)) (cf # cfs)", "show ?thesis"], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S cs (a # as) = []\n  preds (slice_kinds S (a # as)) (cf # cfs)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n     preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "case (PredicateEdge Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close> \\<open>distance m m' (Suc x)\\<close>  \n        \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\\<close> \\<open>distance (targetnode a) m' x\\<close>\n        target"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  distance m m' (Suc x)\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n  distance (targetnode a) m' x\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)\n  kind a = (Q)\\<^sub>\\<surd>", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  distance m m' (Suc x)\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n  distance (targetnode a) m' x\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "hence \"transfer (slice_kind S a) (cf#cfs) = (cf#cfs)\" \n        and \"pred (slice_kind S a) (cf#cfs)\""], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) (cf # cfs) = cf # cfs &&&\n    pred (slice_kind S a) (cf # cfs)", "by simp_all"], ["proof (state)\nthis:\n  transfer (slice_kind S a) (cf # cfs) = cf # cfs\n  pred (slice_kind S a) (cf # cfs)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>preds (slice_kinds S as) (cf#cfs)\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as) (cf # cfs)\n  transfer (slice_kind S a) (cf # cfs) = cf # cfs\n  pred (slice_kind S a) (cf # cfs)", "have \"preds (slice_kinds S (a#as)) (cf#cfs)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as) (cf # cfs)\n  transfer (slice_kind S a) (cf # cfs) = cf # cfs\n  pred (slice_kind S a) (cf # cfs)\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S (a # as)) (cf # cfs)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S (a # as)) (cf # cfs)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "with \\<open>m -a#as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>slice_edges S cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S cs (a # as) = []\n  preds (slice_kinds S (a # as)) (cf # cfs)", "show ?thesis"], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S cs (a # as) = []\n  preds (slice_kinds S (a # as)) (cf # cfs)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n       preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n     preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []\n 2. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n                            preds (slice_kinds S as') (cf # cfs) \\<and>\n                            slice_edges S cs as' = []", "qed (auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n     preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     m -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<and>\n     preds (slice_kinds S as') (cf # cfs) \\<and> slice_edges S cs as' = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slp_to_intra_path_with_slice_edges:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" and \"slice_edges S cs as = []\"\n  obtains as' where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"slice_edges S cs as' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<iota>* n';\n         slice_edges S cs as' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "from \\<open>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "have \"n -as\\<rightarrow>* n'\" and \"same_level_path as\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* n' &&& same_level_path as", "by(simp_all add:slp_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  same_level_path as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "from \\<open>same_level_path as\\<close>"], ["proof (chain)\npicking this:\n  same_level_path as", "have \"same_level_path_aux [] as\" and \"upd_cs [] as = []\""], ["proof (prove)\nusing this:\n  same_level_path as\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as &&& upd_cs [] as = []", "by(simp_all add:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "from \\<open>n -as\\<rightarrow>* n'\\<close> \\<open>same_level_path_aux [] as\\<close> \\<open>upd_cs [] as = []\\<close> \n    \\<open>slice_edges S cs as = []\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  same_level_path_aux [] as\n  upd_cs [] as = []\n  slice_edges S cs as = []", "show \"\\<exists>as'. n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  same_level_path_aux [] as\n  upd_cs [] as = []\n  slice_edges S cs as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "proof(induct as arbitrary:n cs rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n cs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>* n' \\<longrightarrow>\n                       same_level_path_aux [] ys \\<longrightarrow>\n                       upd_cs [] ys = [] \\<longrightarrow>\n                       (\\<forall>xa.\n                           slice_edges S xa ys = [] \\<longrightarrow>\n                           (\\<exists>as'.\n                               x -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                               slice_edges S xa as' = [])));\n        n -xs\\<rightarrow>* n'; same_level_path_aux [] xs;\n        upd_cs [] xs = []; slice_edges S cs xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            slice_edges S cs as' = []", "fix as n cs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n cs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>* n' \\<longrightarrow>\n                       same_level_path_aux [] ys \\<longrightarrow>\n                       upd_cs [] ys = [] \\<longrightarrow>\n                       (\\<forall>xa.\n                           slice_edges S xa ys = [] \\<longrightarrow>\n                           (\\<exists>as'.\n                               x -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                               slice_edges S xa as' = [])));\n        n -xs\\<rightarrow>* n'; same_level_path_aux [] xs;\n        upd_cs [] xs = []; slice_edges S cs xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            slice_edges S cs as' = []", "assume IH:\"\\<forall>as''. length as'' < length as \\<longrightarrow>\n      (\\<forall>n''. n'' -as''\\<rightarrow>* n' \\<longrightarrow> same_level_path_aux [] as'' \\<longrightarrow>\n           upd_cs [] as'' = [] \\<longrightarrow> (\\<forall>cs'. slice_edges S cs' as'' = [] \\<longrightarrow>\n           (\\<exists>as'. n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs' as' = [])))\"\n      and \"n -as\\<rightarrow>* n'\" and \"same_level_path_aux [] as\" and \"upd_cs [] as = []\"\n      and \"slice_edges S cs as = []\""], ["proof (state)\nthis:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<forall>cs'.\n             slice_edges S cs' as'' = [] \\<longrightarrow>\n             (\\<exists>as'.\n                 n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                 slice_edges S cs' as' = [])))\n  n -as\\<rightarrow>* n'\n  same_level_path_aux [] as\n  upd_cs [] as = []\n  slice_edges S cs as = []\n\ngoal (1 subgoal):\n 1. \\<And>xs n cs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>* n' \\<longrightarrow>\n                       same_level_path_aux [] ys \\<longrightarrow>\n                       upd_cs [] ys = [] \\<longrightarrow>\n                       (\\<forall>xa.\n                           slice_edges S xa ys = [] \\<longrightarrow>\n                           (\\<exists>as'.\n                               x -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                               slice_edges S xa as' = [])));\n        n -xs\\<rightarrow>* n'; same_level_path_aux [] xs;\n        upd_cs [] xs = []; slice_edges S cs xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            slice_edges S cs as' = []", "show \"\\<exists>as'. n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "proof(cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "case (Cons a' as')"], ["proof (state)\nthis:\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with \\<open>n -as\\<rightarrow>* n'\\<close> Cons"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = a' # as'\n  as = a' # as'", "have \"n = sourcenode a'\" and \"valid_edge a'\" \n        and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = a' # as'\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with Cons \\<open>same_level_path_aux [] as\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  same_level_path_aux [] as\n  intra_kind (kind a')", "have \"same_level_path_aux [] as'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  same_level_path_aux [] as\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] as'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux [] as'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from Intra Cons \\<open>upd_cs [] as = []\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  as = a' # as'\n  upd_cs [] as = []", "have \"upd_cs [] as' = []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  as = a' # as'\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. upd_cs [] as' = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs [] as' = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "moreover"], ["proof (state)\nthis:\n  upd_cs [] as' = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>slice_edges S cs as = []\\<close> Cons Intra"], ["proof (chain)\npicking this:\n  slice_edges S cs as = []\n  as = a' # as'\n  intra_kind (kind a')", "have \"slice_edges S cs as' = []\" and \"\\<not> slice_edge S cs a'\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = []\n  as = a' # as'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. slice_edges S cs as' = [] &&& \\<not> slice_edge S cs a'", "by(cases \"slice_edge S cs a'\",auto simp:intra_kind_def)+"], ["proof (state)\nthis:\n  slice_edges S cs as' = []\n  \\<not> slice_edge S cs a'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "ultimately"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = []\n  slice_edges S cs as' = []\n  \\<not> slice_edge S cs a'", "obtain as'' where \"targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\"\n          and \"slice_edges S cs as'' = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = []\n  slice_edges S cs as' = []\n  \\<not> slice_edge S cs a'\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n         slice_edges S cs as'' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using IH Cons \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>"], ["proof (prove)\nusing this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = []\n  slice_edges S cs as' = []\n  \\<not> slice_edge S cs a'\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<forall>cs'.\n             slice_edges S cs' as'' = [] \\<longrightarrow>\n             (\\<exists>as'.\n                 n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                 slice_edges S cs' as' = [])))\n  as = a' # as'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n         slice_edges S cs as'' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule_tac x=\"as'\" in allE) auto"], ["proof (state)\nthis:\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  slice_edges S cs as'' = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>n = sourcenode a'\\<close> \\<open>valid_edge a'\\<close> Intra \\<open>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n = sourcenode a'\n  valid_edge a'\n  intra_kind (kind a')\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -a'#as''\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  n = sourcenode a'\n  valid_edge a'\n  intra_kind (kind a')\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "moreover"], ["proof (state)\nthis:\n  n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>slice_edges S cs as'' = []\\<close> \\<open>\\<not> slice_edge S cs a'\\<close> Intra"], ["proof (chain)\npicking this:\n  slice_edges S cs as'' = []\n  \\<not> slice_edge S cs a'\n  intra_kind (kind a')", "have \"slice_edges S cs (a'#as'') = []\""], ["proof (prove)\nusing this:\n  slice_edges S cs as'' = []\n  \\<not> slice_edge S cs a'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a' # as'') = []", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a' # as'') = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "ultimately"], ["proof (chain)\npicking this:\n  n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  slice_edges S cs (a' # as'') = []", "show ?thesis"], ["proof (prove)\nusing this:\n  n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  slice_edges S cs (a' # as'') = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "case (Call Q r p f)"], ["proof (state)\nthis:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with Cons \\<open>same_level_path_aux [] as\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f", "have \"same_level_path_aux [a'] as'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. same_level_path_aux [a'] as'", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [a'] as'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from Call Cons \\<open>upd_cs [] as = []\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  as = a' # as'\n  upd_cs [] as = []", "have \"upd_cs [a'] as' = []\""], ["proof (prove)\nusing this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  as = a' # as'\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. upd_cs [a'] as' = []", "by simp"], ["proof (state)\nthis:\n  upd_cs [a'] as' = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "hence \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  upd_cs [a'] as' = []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with \\<open>upd_cs [a'] as' = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [a'] as' = []\n  as' \\<noteq> []", "obtain xs ys where \"as' = xs@ys\" and \"xs \\<noteq> []\"\n        and \"upd_cs [a'] xs = []\" and \"upd_cs [] ys = []\"\n        and \"\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs [a'] xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  upd_cs [a'] as' = []\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as' = xs @ ys; xs \\<noteq> []; upd_cs [a'] xs = [];\n         upd_cs [] ys = [];\n         \\<forall>xs' ys'.\n            xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n            upd_cs [a'] xs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule upd_cs_empty_split,auto)"], ["proof (state)\nthis:\n  as' = xs @ ys\n  xs \\<noteq> []\n  upd_cs [a'] xs = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs [a'] xs' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>same_level_path_aux [a'] as'\\<close> \\<open>as' = xs@ys\\<close> \\<open>upd_cs [a'] xs = []\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [a'] as'\n  as' = xs @ ys\n  upd_cs [a'] xs = []", "have \"same_level_path_aux [a'] xs\"  and \"same_level_path_aux [] ys\""], ["proof (prove)\nusing this:\n  same_level_path_aux [a'] as'\n  as' = xs @ ys\n  upd_cs [a'] xs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [a'] xs &&& same_level_path_aux [] ys", "by(rule slpa_split)+"], ["proof (state)\nthis:\n  same_level_path_aux [a'] xs\n  same_level_path_aux [] ys\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with \\<open>upd_cs [a'] xs = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [a'] xs = []\n  same_level_path_aux [a'] xs\n  same_level_path_aux [] ys", "have \"upd_cs ([a']@cs) xs = []@cs\""], ["proof (prove)\nusing this:\n  upd_cs [a'] xs = []\n  same_level_path_aux [a'] xs\n  same_level_path_aux [] ys\n\ngoal (1 subgoal):\n 1. upd_cs ([a'] @ cs) xs = [] @ cs", "by(fastforce intro:same_level_path_upd_cs_callstack_Append)"], ["proof (state)\nthis:\n  upd_cs ([a'] @ cs) xs = [] @ cs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>slice_edges S cs as = []\\<close> Cons Call"], ["proof (chain)\npicking this:\n  slice_edges S cs as = []\n  as = a' # as'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f", "have \"slice_edges S (a'#cs) as' = []\" and \"\\<not> slice_edge S cs a'\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = []\n  as = a' # as'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. slice_edges S (a' # cs) as' = [] &&& \\<not> slice_edge S cs a'", "by(cases \"slice_edge S cs a'\",auto)+"], ["proof (state)\nthis:\n  slice_edges S (a' # cs) as' = []\n  \\<not> slice_edge S cs a'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>slice_edges S (a'#cs) as' = []\\<close> \\<open>as' = xs@ys\\<close> \n          \\<open>upd_cs ([a']@cs) xs = []@cs\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S (a' # cs) as' = []\n  as' = xs @ ys\n  upd_cs ([a'] @ cs) xs = [] @ cs", "have \"slice_edges S cs ys = []\""], ["proof (prove)\nusing this:\n  slice_edges S (a' # cs) as' = []\n  as' = xs @ ys\n  upd_cs ([a'] @ cs) xs = [] @ cs\n\ngoal (1 subgoal):\n 1. slice_edges S cs ys = []", "by(fastforce dest:slice_edges_Nil_split)"], ["proof (state)\nthis:\n  slice_edges S cs ys = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>same_level_path_aux [a'] xs\\<close> \\<open>upd_cs [a'] xs = []\\<close>\n          \\<open>\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs [a'] xs' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [a'] xs\n  upd_cs [a'] xs = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs [a'] xs' \\<noteq> []", "have \"last xs \\<in> get_return_edges (last [a'])\""], ["proof (prove)\nusing this:\n  same_level_path_aux [a'] xs\n  upd_cs [a'] xs = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs [a'] xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last xs \\<in> get_return_edges (last [a'])", "by(fastforce intro!:slpa_get_return_edges)"], ["proof (state)\nthis:\n  last xs \\<in> get_return_edges (last [a'])\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with \\<open>valid_edge a'\\<close> Call"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  last xs \\<in> get_return_edges (last [a'])", "obtain a where \"valid_edge a\" and \"sourcenode a = sourcenode a'\"\n          and \"targetnode a = targetnode (last xs)\" and \"kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  last xs \\<in> get_return_edges (last [a'])\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = sourcenode a';\n         targetnode a = targetnode (last xs);\n         kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode (last xs)\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>targetnode a = targetnode (last xs)\\<close> \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = targetnode (last xs)\n  xs \\<noteq> []", "have \"targetnode a = targetnode (last (a'#xs))\""], ["proof (prove)\nusing this:\n  targetnode a = targetnode (last xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. targetnode a = targetnode (last (a' # xs))", "by simp"], ["proof (state)\nthis:\n  targetnode a = targetnode (last (a' # xs))\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>as' = xs@ys\\<close> \\<open>xs \\<noteq> []\\<close> Cons"], ["proof (chain)\npicking this:\n  as' = xs @ ys\n  xs \\<noteq> []\n  as = a' # as'", "have \"length ys < length as\""], ["proof (prove)\nusing this:\n  as' = xs @ ys\n  xs \\<noteq> []\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. length ys < length as", "by simp"], ["proof (state)\nthis:\n  length ys < length as\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close> \\<open>as' = xs@ys\\<close> \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -as'\\<rightarrow>* n'\n  as' = xs @ ys\n  xs \\<noteq> []", "have \"targetnode (last (a'#xs)) -ys\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  targetnode a' -as'\\<rightarrow>* n'\n  as' = xs @ ys\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. targetnode (last (a' # xs)) -ys\\<rightarrow>* n'", "by(cases xs rule:rev_cases,auto dest:path_split)"], ["proof (state)\nthis:\n  targetnode (last (a' # xs)) -ys\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with IH \\<open>length ys < length as\\<close> \\<open>same_level_path_aux [] ys\\<close>\n          \\<open>upd_cs [] ys = []\\<close> \\<open>slice_edges S cs ys = []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<forall>cs'.\n             slice_edges S cs' as'' = [] \\<longrightarrow>\n             (\\<exists>as'.\n                 n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                 slice_edges S cs' as' = [])))\n  length ys < length as\n  same_level_path_aux [] ys\n  upd_cs [] ys = []\n  slice_edges S cs ys = []\n  targetnode (last (a' # xs)) -ys\\<rightarrow>* n'", "obtain as'' where \"targetnode (last (a'#xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\"\n          and \"slice_edges S cs as'' = []\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<forall>cs'.\n             slice_edges S cs' as'' = [] \\<longrightarrow>\n             (\\<exists>as'.\n                 n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                 slice_edges S cs' as' = [])))\n  length ys < length as\n  same_level_path_aux [] ys\n  upd_cs [] ys = []\n  slice_edges S cs ys = []\n  targetnode (last (a' # xs)) -ys\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>targetnode\n                  (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n         slice_edges S cs as'' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"ys\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (last\n                            (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 slice_edges S cs as'' = []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     slice_edges S cs ys = [];\n     targetnode (last (a' # xs)) -ys\\<rightarrow>* n';\n     length ys < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -ys\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] ys \\<longrightarrow>\n         upd_cs [] ys = [] \\<longrightarrow>\n         (\\<forall>cs'.\n             slice_edges S cs' ys = [] \\<longrightarrow>\n             (\\<exists>as'.\n                 n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                 slice_edges S cs' as' = [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (if xs = [] then a'\n                           else last\n                                 xs) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 slice_edges S cs as'' = []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     slice_edges S cs ys = [];\n     targetnode (if xs = [] then a' else last xs) -ys\\<rightarrow>* n';\n     \\<forall>n''.\n        n'' -ys\\<rightarrow>* n' \\<longrightarrow>\n        (\\<forall>cs'.\n            slice_edges S cs' ys = [] \\<longrightarrow>\n            (\\<exists>as'.\n                n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                slice_edges S cs' as' = []))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"targetnode (last (a'#xs))\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (if xs = [] then a'\n                           else last\n                                 xs) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 slice_edges S cs as'' = []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     slice_edges S cs ys = [];\n     targetnode (if xs = [] then a' else last xs) -ys\\<rightarrow>* n';\n     targetnode (last (a' # xs)) -ys\\<rightarrow>* n' \\<longrightarrow>\n     (\\<forall>cs'.\n         slice_edges S cs' ys = [] \\<longrightarrow>\n         (\\<exists>as'.\n             targetnode\n              (last (a' # xs)) -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n             slice_edges S cs' as' = []))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (if xs = [] then a'\n                           else last\n                                 xs) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 slice_edges S cs as'' = []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     slice_edges S cs ys = [];\n     targetnode (if xs = [] then a' else last xs) -ys\\<rightarrow>* n';\n     \\<forall>cs'.\n        slice_edges S cs' ys = [] \\<longrightarrow>\n        (\\<exists>as'.\n            targetnode\n             (if xs = [] then a'\n              else last xs) -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n            slice_edges S cs' as' = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"cs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (if xs = [] then a'\n                           else last\n                                 xs) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 slice_edges S cs as'' = []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     slice_edges S cs ys = [];\n     targetnode (if xs = [] then a' else last xs) -ys\\<rightarrow>* n';\n     slice_edges S cs ys = [] \\<longrightarrow>\n     (\\<exists>as'.\n         targetnode\n          (if xs = [] then a'\n           else last xs) -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n         slice_edges S cs as' = [])\\<rbrakk>\n    \\<Longrightarrow> thesis", "by clarsimp"], ["proof (state)\nthis:\n  targetnode (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  slice_edges S cs as'' = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>sourcenode a = sourcenode a'\\<close> \\<open>n = sourcenode a'\\<close>\n          \\<open>targetnode a = targetnode (last (a'#xs))\\<close> \\<open>valid_edge a\\<close>\n          \\<open>kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close> \\<open>targetnode (last (a'#xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  n = sourcenode a'\n  targetnode a = targetnode (last (a' # xs))\n  valid_edge a\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  targetnode (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -a#as''\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  n = sourcenode a'\n  targetnode a = targetnode (last (a' # xs))\n  valid_edge a\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  targetnode (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'", "by(fastforce intro:Cons_path simp:intra_path_def intra_kind_def)"], ["proof (state)\nthis:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "moreover"], ["proof (state)\nthis:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "from \\<open>kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close> \\<open>slice_edges S cs as'' = []\\<close>\n          \\<open>\\<not> slice_edge S cs a'\\<close> \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  slice_edges S cs as'' = []\n  \\<not> slice_edge S cs a'\n  sourcenode a = sourcenode a'", "have \"slice_edges S cs (a#as'') = []\""], ["proof (prove)\nusing this:\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  slice_edges S cs as'' = []\n  \\<not> slice_edge S cs a'\n  sourcenode a = sourcenode a'\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as'') = []", "by(cases \"kind a'\")(auto simp:slice_edge_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a # as'') = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "ultimately"], ["proof (chain)\npicking this:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  slice_edges S cs (a # as'') = []", "show ?thesis"], ["proof (prove)\nusing this:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  slice_edges S cs (a # as'') = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "with Cons \\<open>same_level_path_aux [] as\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          slice_edges S cs as' = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       slice_edges S cs as' = []", "by simp"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> slice_edges S cs as' = []\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>* (ms',s')\\<close> : the reflexive transitive \n  closure of \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close>\\<close>"], ["", "inductive trans_observable_moves :: \n  \"'node SDG_node set \\<Rightarrow> ('edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind) \\<Rightarrow> 'node list \\<Rightarrow> \n   (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> 'edge list \\<Rightarrow> 'node list \\<Rightarrow> \n  (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> bool\"\n(\"_,_ \\<turnstile> '(_,_') =_\\<Rightarrow>* '(_,_')\" [51,50,0,0,50,0,0] 51) \n\nwhere tom_Nil:\n  \"length ms = length s \\<Longrightarrow> S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>* (ms,s)\"\n\n| tom_Cons:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s'); S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =(last as)#as'\\<Rightarrow>* (ms'',s'')\""], ["", "lemma tom_split_snoc:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>* (ms',s')\" and \"as \\<noteq> []\"\n  obtains asx asx' ms'' s'' where \"as = asx@[last asx']\" \n  and \"S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'')\" and \"S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asx asx' ms'' s''.\n        \\<lbrakk>as = asx @ [last asx'];\n         S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'');\n         S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>asx asx' ms'' s''.\n       as = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and>\n       S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms',s')", "from assms"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>* (ms',s')\n  as \\<noteq> []", "show \"\\<exists>asx asx' ms'' s''. as = asx @ [last asx'] \\<and>\n    S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and> S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>* (ms',s')\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>asx asx' ms'' s''.\n       as = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and>\n       S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms',s')", "proof(induct rule:trans_observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>asx asx' ms'' s''.\n                            [] = asx @ [last asx'] \\<and>\n                            S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms,s)\n 2. \\<And>S f ms s as ms' s' as' ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        as' \\<noteq> [] \\<Longrightarrow>\n        \\<exists>asx asx' ms''a s''a.\n           as' = asx @ [last asx'] \\<and>\n           S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n           S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'');\n        last as # as' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>asx asx' ms''a s''a.\n                            last as # as' = asx @ [last asx'] \\<and>\n                            S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n                            S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "case (tom_Cons S f ms s as ms' s' as' ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n  S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\n  as' \\<noteq> [] \\<Longrightarrow>\n  \\<exists>asx asx' ms''a s''a.\n     as' = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n     S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n  last as # as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>asx asx' ms'' s''.\n                            [] = asx @ [last asx'] \\<and>\n                            S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms,s)\n 2. \\<And>S f ms s as ms' s' as' ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        as' \\<noteq> [] \\<Longrightarrow>\n        \\<exists>asx asx' ms''a s''a.\n           as' = asx @ [last asx'] \\<and>\n           S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n           S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'');\n        last as # as' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>asx asx' ms''a s''a.\n                            last as # as' = asx @ [last asx'] \\<and>\n                            S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n                            S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "note IH = \\<open>as' \\<noteq> [] \\<Longrightarrow> \\<exists>asx asx' msx sx. as' = asx @ [last asx'] \\<and>\n      S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (msx,sx) \\<and> S,f \\<turnstile> (msx,sx) =asx'\\<Rightarrow> (ms'',s'')\\<close>"], ["proof (state)\nthis:\n  as' \\<noteq> [] \\<Longrightarrow>\n  \\<exists>asx asx' msx sx.\n     as' = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (msx,sx) \\<and>\n     S,f \\<turnstile> (msx,sx) =asx'\\<Rightarrow> (ms'',s'')\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>asx asx' ms'' s''.\n                            [] = asx @ [last asx'] \\<and>\n                            S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms,s)\n 2. \\<And>S f ms s as ms' s' as' ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        as' \\<noteq> [] \\<Longrightarrow>\n        \\<exists>asx asx' ms''a s''a.\n           as' = asx @ [last asx'] \\<and>\n           S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n           S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'');\n        last as # as' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>asx asx' ms''a s''a.\n                            last as # as' = asx @ [last asx'] \\<and>\n                            S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n                            S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "with \\<open>S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\n  as' = []", "have [simp]:\"ms'' = ms'\" \"s'' = s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\n  as' = []\n\ngoal (1 subgoal):\n 1. ms'' = ms' &&& s'' = s'", "by(auto elim:trans_observable_moves.cases)"], ["proof (state)\nthis:\n  ms'' = ms'\n  s'' = s'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')", "have \"length ms = length s\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s", "by(rule observable_moves_equal_length)"], ["proof (state)\nthis:\n  length ms = length s\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "hence \"S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>* (ms,s)\""], ["proof (prove)\nusing this:\n  length ms = length s\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>* (ms,s)", "by(rule tom_Nil)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>* (ms,s)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "with \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close> True"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n  as' = []\n  S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>* (ms,s)", "show ?thesis"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n  as' = []\n  S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>* (ms,s)\n\ngoal (1 subgoal):\n 1. \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>asx asx' ms''a s''a.\n     last as # as' = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n     S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>asx asx' msx sx.\n     as' = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (msx,sx) \\<and>\n     S,f \\<turnstile> (msx,sx) =asx'\\<Rightarrow> (ms'',s'')", "obtain xs xs' msx sx where \"as' = xs @ [last xs']\"\n        and \"S,f \\<turnstile> (ms',s') =xs\\<Rightarrow>* (msx,sx)\" \n        and \"S,f \\<turnstile> (msx,sx) =xs'\\<Rightarrow> (ms'',s'')\""], ["proof (prove)\nusing this:\n  \\<exists>asx asx' msx sx.\n     as' = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms',s') =asx\\<Rightarrow>* (msx,sx) \\<and>\n     S,f \\<turnstile> (msx,sx) =asx'\\<Rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. (\\<And>xs xs' msx sx.\n        \\<lbrakk>as' = xs @ [last xs'];\n         S,f \\<turnstile> (ms',s') =xs\\<Rightarrow>* (msx,sx);\n         S,f \\<turnstile> (msx,sx) =xs'\\<Rightarrow> (ms'',s'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as' = xs @ [last xs']\n  S,f \\<turnstile> (ms',s') =xs\\<Rightarrow>* (msx,sx)\n  S,f \\<turnstile> (msx,sx) =xs'\\<Rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close> \\<open>S,f \\<turnstile> (ms',s') =xs\\<Rightarrow>* (msx,sx)\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n  S,f \\<turnstile> (ms',s') =xs\\<Rightarrow>* (msx,sx)", "have \"S,f \\<turnstile> (ms,s) =(last as)#xs\\<Rightarrow>* (msx,sx)\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n  S,f \\<turnstile> (ms',s') =xs\\<Rightarrow>* (msx,sx)\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) =last as # xs\\<Rightarrow>* (msx,sx)", "by(rule trans_observable_moves.tom_Cons)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =last as # xs\\<Rightarrow>* (msx,sx)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "with \\<open>S,f \\<turnstile> (msx,sx) =xs'\\<Rightarrow> (ms'',s'')\\<close> \\<open>as' = xs @ [last xs']\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (msx,sx) =xs'\\<Rightarrow> (ms'',s'')\n  as' = xs @ [last xs']\n  S,f \\<turnstile> (ms,s) =last as # xs\\<Rightarrow>* (msx,sx)", "show ?thesis"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (msx,sx) =xs'\\<Rightarrow> (ms'',s'')\n  as' = xs @ [last xs']\n  S,f \\<turnstile> (ms,s) =last as # xs\\<Rightarrow>* (msx,sx)\n\ngoal (1 subgoal):\n 1. \\<exists>asx asx' ms''a s''a.\n       last as # as' = asx @ [last asx'] \\<and>\n       S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n       S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>asx asx' ms''a s''a.\n     last as # as' = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n     S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>asx asx' ms''a s''a.\n     last as # as' = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms''a,s''a) \\<and>\n     S,f \\<turnstile> (ms''a,s''a) =asx'\\<Rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>asx asx' ms'' s''.\n                            [] = asx @ [last asx'] \\<and>\n                            S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms,s)", "qed simp"], ["proof (state)\nthis:\n  \\<exists>asx asx' ms'' s''.\n     as = asx @ [last asx'] \\<and>\n     S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>* (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =asx'\\<Rightarrow> (ms',s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tom_preserves_stacks:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>* (m'#ms',s')\" and \"valid_node m\" \n  and \"valid_call_list cs m\" and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" \n  and \"valid_return_list rs m\" and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  obtains cs' rs' where \"valid_node m'\" and \"valid_call_list cs' m'\"\n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs' rs'.\n        \\<lbrakk>valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and> ms' = targetnodes rs'", "from assms"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow>* (m' # ms',s')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs", "show \"\\<exists>cs' rs'. valid_node m' \\<and> valid_call_list cs' m' \\<and>\n    (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and> valid_return_list rs' m' \\<and>\n    length rs' = length cs' \\<and> ms' = targetnodes rs'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow>* (m' # ms',s')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and> ms' = targetnodes rs'", "proof(induct S f \"m#ms\" s as \"m'#ms'\" s' arbitrary:m ms cs rs\n      rule:trans_observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s S f cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'\n 2. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "case (tom_Nil sx n\\<^sub>c f)"], ["proof (state)\nthis:\n  length (m' # ms') = length sx\n  valid_node m'\n  valid_call_list cs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m'\n  length rs = length cs\n  ms' = targetnodes rs\n\ngoal (2 subgoals):\n 1. \\<And>s S f cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'\n 2. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "thus ?case"], ["proof (prove)\nusing this:\n  length (m' # ms') = length sx\n  valid_node m'\n  valid_call_list cs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m'\n  length rs = length cs\n  ms' = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and> ms' = targetnodes rs'", "apply(rule_tac x=\"cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (m' # ms') = length sx; valid_node m';\n     valid_call_list cs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     valid_return_list rs m'; length rs = length cs;\n     ms' = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         valid_node m' \\<and>\n                         valid_call_list cs m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs \\<and> ms' = targetnodes rs'", "apply(rule_tac x=\"rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (m' # ms') = length sx; valid_node m';\n     valid_call_list cs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     valid_return_list rs m'; length rs = length cs;\n     ms' = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> valid_node m' \\<and>\n                      valid_call_list cs m' \\<and>\n                      (\\<forall>i<length rs.\n                          rs ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                      valid_return_list rs m' \\<and>\n                      length rs = length cs \\<and> ms' = targetnodes rs", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and> ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "case (tom_Cons S f sx as msx' sx' as' sx'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx')\n  S,f \\<turnstile> (msx',sx') =as'\\<Rightarrow>* (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' rs'.\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and> ms' = targetnodes rs'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "note IH = \\<open>\\<And>m ms cs rs. \\<lbrakk>msx' = m # ms; valid_node m; valid_call_list cs m;\n      \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); valid_return_list rs m;\n      length rs = length cs; ms = targetnodes rs\\<rbrakk>\n      \\<Longrightarrow> \\<exists>cs' rs'. valid_node m' \\<and> valid_call_list cs' m' \\<and>\n      (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n      valid_return_list rs' m' \\<and> length rs' = length cs' \\<and>\n      ms' = targetnodes rs'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs;\n   ?ms = targetnodes ?rs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' rs'.\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and> ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "from \\<open>S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx')", "obtain m'' ms'' where \"msx' = m''#ms''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. (\\<And>m'' ms''.\n        msx' = m'' # ms'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases msx')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m'' ms''. msx' = m'' # ms'' \\<Longrightarrow> thesis;\n     S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx');\n     msx' = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m'' ms''. msx' = m'' # ms'' \\<Longrightarrow> thesis;\n        S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx');\n        msx' = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto elim!:observable_moves.cases observable_move.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as aa sa Q p f' msaa.\n       \\<lbrakk>msx' = []; as = as @ [aa];\n        S,f \\<turnstile> (m #\n                          ms,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (msaa,sa);\n        pred (f aa) sa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        length msaa = Suc (length (transfer (f aa) sa));\n        length sa = Suc (length (transfer (f aa) sa));\n        transfer (f aa) sa \\<noteq> []; hd msaa = sourcenode aa;\n        hd [] = targetnode aa; [] = tl msaa;\n        sx' = transfer (f aa) sa\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac \"msaa\") auto"], ["proof (state)\nthis:\n  msx' = m'' # ms''\n\ngoal (1 subgoal):\n 1. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "with \\<open>S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx')\\<close> \\<open>valid_node m\\<close>\n      \\<open>valid_call_list cs m\\<close> \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n      \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close> \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  msx' = m'' # ms''", "obtain cs'' rs'' where \"valid_node m''\" and \"valid_call_list cs'' m''\"\n      and \"\\<forall>i < length rs''. rs''!i \\<in> get_return_edges (cs''!i)\"\n      and \"valid_return_list rs'' m''\" and \"length rs'' = length cs''\" \n      and \"ms'' = targetnodes rs''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,sx) =as\\<Rightarrow> (msx',sx')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  msx' = m'' # ms''\n\ngoal (1 subgoal):\n 1. (\\<And>cs'' rs''.\n        \\<lbrakk>valid_node m''; valid_call_list cs'' m'';\n         \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i);\n         valid_return_list rs'' m''; length rs'' = length cs'';\n         ms'' = targetnodes rs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:observable_moves_preserves_stack)"], ["proof (state)\nthis:\n  valid_node m''\n  valid_call_list cs'' m''\n  \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i)\n  valid_return_list rs'' m''\n  length rs'' = length cs''\n  ms'' = targetnodes rs''\n\ngoal (1 subgoal):\n 1. \\<And>S f s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' rs'.\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        ms = targetnodes rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' rs'.\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs'", "from IH[OF \\<open>msx' = m''#ms''\\<close> this(1-6)]"], ["proof (chain)\npicking this:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and> ms' = targetnodes rs'", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and> ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' rs'.\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and> ms' = targetnodes rs'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and> ms' = targetnodes rs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cs' rs'.\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and> ms' = targetnodes rs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vpa_trans_observable_moves:\n  assumes \"valid_path_aux cs as\" and \"m -as\\<rightarrow>* m'\" and \"preds (kinds as) s\" \n  and \"transfers (kinds as) s = s'\" and \"valid_call_list cs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  and \"valid_return_list rs m\" \n  and \"length rs = length cs\" and \"length s = Suc (length cs)\" \n  obtains ms ms'' s'' ms' as' as''\n  where \"S,kind \\<turnstile> (m#ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'')\"\n  and \"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" \n  and \"ms = targetnodes rs\" and \"length ms = length cs\"\n  and \"\\<forall>i<length cs. call_of_return_node (ms!i) (sourcenode (cs!i))\"\n  and \"slice_edges S cs as = slice_edges S cs as''\" \n  and \"m -as''@as'\\<rightarrow>* m'\" and \"valid_path_aux cs (as''@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ms ms'' s'' as' ms' as''.\n        \\<lbrakk>S,kind \\<turnstile> (m #\nms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'');\n         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                  ms',s');\n         ms = targetnodes rs; length ms = length cs;\n         \\<forall>i<length cs.\n            call_of_return_node (ms ! i) (sourcenode (cs ! i));\n         slice_edges S cs as = slice_edges S cs as'';\n         m -as'' @ as'\\<rightarrow>* m';\n         valid_path_aux cs (as'' @ as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    as\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs as = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from assms"], ["proof (chain)\npicking this:\n  valid_path_aux cs as\n  m -as\\<rightarrow>* m'\n  preds (kinds as) s\n  transfers (kinds as) s = s'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)", "show \"\\<exists>ms ms'' s'' as' ms' as''.\n    S,kind \\<turnstile> (m # ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n    S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and> \n    ms = targetnodes rs \\<and> length ms = length cs \\<and>\n    (\\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n    slice_edges S cs as = slice_edges S cs as'' \\<and>\n    m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\""], ["proof (prove)\nusing this:\n  valid_path_aux cs as\n  m -as\\<rightarrow>* m'\n  preds (kinds as) s\n  transfers (kinds as) s = s'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    as\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs as = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "proof(induct arbitrary:m s rs rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs m s rs.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; preds (kinds []) s;\n        transfers (kinds []) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs []\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs [] =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 5. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "case (vpa_empty cs)"], ["proof (state)\nthis:\n  m -[]\\<rightarrow>* m'\n  preds (kinds []) s\n  transfers (kinds []) s = s'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n\ngoal (5 subgoals):\n 1. \\<And>cs m s rs.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; preds (kinds []) s;\n        transfers (kinds []) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs []\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs [] =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 5. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>m -[]\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -[]\\<rightarrow>* m'", "have [simp]:\"m' = m\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m' = m", "by fastforce"], ["proof (state)\nthis:\n  m' = m\n\ngoal (5 subgoals):\n 1. \\<And>cs m s rs.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; preds (kinds []) s;\n        transfers (kinds []) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs []\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs [] =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 5. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>transfers (kinds []) s = s'\\<close> \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  transfers (kinds []) s = s'\n  length s = Suc (length cs)", "have [simp]:\"s' = s\""], ["proof (prove)\nusing this:\n  transfers (kinds []) s = s'\n  length s = Suc (length cs)\n\ngoal (1 subgoal):\n 1. s' = s", "by(cases cs)(auto simp:kinds_def)"], ["proof (state)\nthis:\n  s' = s\n\ngoal (5 subgoals):\n 1. \\<And>cs m s rs.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; preds (kinds []) s;\n        transfers (kinds []) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs []\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs [] =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 5. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_call_list cs m\\<close> \\<open>valid_return_list rs m\\<close>\n      \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  valid_return_list rs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs", "have \"\\<forall>i<length cs. call_of_return_node (targetnodes rs!i) (sourcenode (cs!i))\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  valid_return_list rs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs.\n       call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i))", "by(rule get_return_edges_call_of_return_nodes)"], ["proof (state)\nthis:\n  \\<forall>i<length cs.\n     call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i))\n\ngoal (5 subgoals):\n 1. \\<And>cs m s rs.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; preds (kinds []) s;\n        transfers (kinds []) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs []\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs [] =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 5. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>length s = Suc (length cs)\\<close> \\<open>m -[]\\<rightarrow>* m'\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)\n  m -[]\\<rightarrow>* m'\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i))", "show ?case"], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n  m -[]\\<rightarrow>* m'\n  length rs = length cs\n  \\<forall>i<length cs.\n     call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    []\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs [] = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"targetnodes rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s = Suc (length cs); m -[]\\<rightarrow>* m';\n     length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (targetnodes rs ! i)\n         (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s) =slice_edges S cs []\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnodes rs = targetnodes rs \\<and>\n                         length (targetnodes rs) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (targetnodes rs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs [] = slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"m#targetnodes rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s = Suc (length cs); m -[]\\<rightarrow>* m';\n     length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (targetnodes rs ! i)\n         (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s) =slice_edges S cs\n                 []\\<Rightarrow>* (m # targetnodes rs,s'') \\<and>\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         targetnodes rs = targetnodes rs \\<and>\n                         length (targetnodes rs) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (targetnodes rs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs [] = slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s = Suc (length cs); m -[]\\<rightarrow>* m';\n     length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (targetnodes rs ! i)\n         (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s) =slice_edges S cs\n                 []\\<Rightarrow>* (m # targetnodes rs,s) \\<and>\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         targetnodes rs = targetnodes rs \\<and>\n                         length (targetnodes rs) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (targetnodes rs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs [] = slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s = Suc (length cs); m -[]\\<rightarrow>* m';\n     length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (targetnodes rs ! i)\n         (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s) =slice_edges S cs\n                 []\\<Rightarrow>* (m # targetnodes rs,s) \\<and>\n                         S,kind \\<turnstile> (m #\n        targetnodes rs,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         targetnodes rs = targetnodes rs \\<and>\n                         length (targetnodes rs) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (targetnodes rs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs [] = slice_edges S cs as'' \\<and>\n                         m -as'' @ []\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ [])", "apply(rule_tac x=\"targetnodes rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s = Suc (length cs); m -[]\\<rightarrow>* m';\n     length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (targetnodes rs ! i)\n         (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s) =slice_edges S cs\n                 []\\<Rightarrow>* (m # targetnodes rs,s) \\<and>\n                         S,kind \\<turnstile> (m #\n        targetnodes\n         rs,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' # targetnodes rs,s') \\<and>\n                         targetnodes rs = targetnodes rs \\<and>\n                         length (targetnodes rs) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (targetnodes rs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs [] = slice_edges S cs as'' \\<and>\n                         m -as'' @ []\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ [])", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length s = Suc (length cs); m -[]\\<rightarrow>* m';\n     length rs = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (targetnodes rs ! i)\n         (sourcenode (cs ! i))\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     targetnodes\n      rs,s) =slice_edges S cs []\\<Rightarrow>* (m # targetnodes rs,s) \\<and>\n                      S,kind \\<turnstile> (m #\n     targetnodes\n      rs,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m' # targetnodes rs,s') \\<and>\n                      targetnodes rs = targetnodes rs \\<and>\n                      length (targetnodes rs) = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node (targetnodes rs ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs [] = slice_edges S cs [] \\<and>\n                      m -[] @ []\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ([] @ [])", "by(fastforce intro:tom_Nil silent_moves_Nil simp:targetnodes_def)"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  []\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs [] = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "case (vpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; preds (kinds as) ?s;\n   transfers (kinds as) ?s = s'; valid_call_list cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs;\n   length ?s = Suc (length cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                       S,kind \\<turnstile> (?m #\n      ms,?s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n          ms',s') \\<and>\n                       ms = targetnodes ?rs \\<and>\n                       length ms = length cs \\<and>\n                       (\\<forall>i<length cs.\n                           call_of_return_node (ms ! i)\n                            (sourcenode (cs ! i))) \\<and>\n                       slice_edges S cs as = slice_edges S cs as'' \\<and>\n                       ?m -as'' @ as'\\<rightarrow>* m' \\<and>\n                       valid_path_aux cs (as'' @ as')\n  m -a # as\\<rightarrow>* m'\n  preds (kinds (a # as)) s\n  transfers (kinds (a # as)) s = s'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "note IH = \\<open>\\<And>m s rs. \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s; transfers (kinds as) s = s';\n      valid_call_list cs m; \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n      valid_return_list rs m; length rs = length cs; length s = Suc (length cs)\\<rbrakk>\n      \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n      S,kind \\<turnstile> (m # ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and> ms = targetnodes rs \\<and>\n      length ms = length cs \\<and>\n      (\\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n      slice_edges S cs as = slice_edges S cs as'' \\<and>\n      m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; preds (kinds as) ?s;\n   transfers (kinds as) ?s = s'; valid_call_list cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs;\n   length ?s = Suc (length cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                       S,kind \\<turnstile> (?m #\n      ms,?s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n          ms',s') \\<and>\n                       ms = targetnodes ?rs \\<and>\n                       length ms = length cs \\<and>\n                       (\\<forall>i<length cs.\n                           call_of_return_node (ms ! i)\n                            (sourcenode (cs ! i))) \\<and>\n                       slice_edges S cs as = slice_edges S cs as'' \\<and>\n                       ?m -as'' @ as'\\<rightarrow>* m' \\<and>\n                       valid_path_aux cs (as'' @ as')\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"m = sourcenode a\" and \"valid_edge a\"\n      and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>preds (kinds (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\"\n      and \"preds (kinds as) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s &&& preds (kinds as) (transfer (kind a) s)", "by(auto simp:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n  preds (kinds as) (transfer (kind a) s)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>transfers (kinds (a # as)) s = s'\\<close>"], ["proof (chain)\npicking this:\n  transfers (kinds (a # as)) s = s'", "have \"transfers (kinds as) (transfer (kind a) s) = s'\""], ["proof (prove)\nusing this:\n  transfers (kinds (a # as)) s = s'\n\ngoal (1 subgoal):\n 1. transfers (kinds as) (transfer (kind a) s) = s'", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  transfers (kinds as) (transfer (kind a) s) = s'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_call_list cs m\\<close> \\<open>m = sourcenode a\\<close>\n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>intra_kind (kind a)\\<close> \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  length s = Suc (length cs)", "have \"length (transfer (kind a) s) = Suc (length cs)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  length s = Suc (length cs)\n\ngoal (1 subgoal):\n 1. length (transfer (kind a) s) = Suc (length cs)", "by(cases s)(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  length (transfer (kind a) s) = Suc (length cs)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_return_list rs m\\<close> \\<open>m = sourcenode a\\<close> \n     \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list rs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list rs (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        m = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        rs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> sourcenode a\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_return_list rs (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \\<open>preds (kinds as) (transfer (kind a) s)\\<close>\n      \\<open>transfers (kinds as) (transfer (kind a) s) = s'\\<close> \n      \\<open>valid_call_list cs (targetnode a)\\<close> \n      \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> this \\<open>length rs = length cs\\<close>\n      \\<open>length (transfer (kind a) s) = Suc (length cs)\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (targetnode a #\n                          ms,transfer (kind a)\n                              s) =slice_edges S cs\n                                   as\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs as = slice_edges S cs as'' \\<and>\n     targetnode a -as'' @ as'\\<rightarrow>* m' \\<and>\n     valid_path_aux cs (as'' @ as')", "obtain ms ms'' s'' as' ms' as'' where \"length ms = length cs\"\n      and \"S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) =slice_edges S cs as\\<Rightarrow>*\n                       (ms'',s'')\" \n      and paths:\"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\"\n      \"ms = targetnodes rs\"\n      \"\\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\"\n      \"slice_edges S cs as = slice_edges S cs as''\"\n      \"targetnode a -as'' @ as'\\<rightarrow>* m'\" \"valid_path_aux cs (as'' @ as')\""], ["proof (prove)\nusing this:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (targetnode a #\n                          ms,transfer (kind a)\n                              s) =slice_edges S cs\n                                   as\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs as = slice_edges S cs as'' \\<and>\n     targetnode a -as'' @ as'\\<rightarrow>* m' \\<and>\n     valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. (\\<And>ms ms'' s'' as' ms' as''.\n        \\<lbrakk>length ms = length cs;\n         S,kind \\<turnstile> (targetnode a #\n                              ms,transfer (kind a)\n                                  s) =slice_edges S cs\n as\\<Rightarrow>* (ms'',s'');\n         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                  ms',s');\n         ms = targetnodes rs;\n         \\<forall>i<length cs.\n            call_of_return_node (ms ! i) (sourcenode (cs ! i));\n         slice_edges S cs as = slice_edges S cs as'';\n         targetnode a -as'' @ as'\\<rightarrow>* m';\n         valid_path_aux cs (as'' @ as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length ms = length cs\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes rs\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  slice_edges S cs as = slice_edges S cs as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux cs (as'' @ as')\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\\<close>\n      \\<open>length ms = length cs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  length ms = length cs", "have \"\\<forall>mx \\<in> set ms. return_node mx\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  length ms = length cs\n\ngoal (1 subgoal):\n 1. Ball (set ms) return_node", "by(auto simp:call_of_return_node_def in_set_conv_nth)"], ["proof (state)\nthis:\n  Ball (set ms) return_node\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m s rs.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            length s = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs \\<and>\n                                (\\<forall>i<length cs.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs ! i))) \\<and>\n                                slice_edges S cs as =\n                                slice_edges S cs as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 4. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "proof(cases \"(\\<forall>m \\<in> set ms. \\<exists>m'. call_of_return_node m m' \\<and> \n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and> m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "case True"], ["proof (state)\nthis:\n  (\\<forall>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>m = sourcenode a\\<close> \\<open>length ms = length cs\\<close> \\<open>intra_kind (kind a)\\<close>\n        \\<open>\\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\\<close>"], ["proof (chain)\npicking this:\n  m = sourcenode a\n  length ms = length cs\n  intra_kind (kind a)\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  (\\<forall>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_edge S cs a\""], ["proof (prove)\nusing this:\n  m = sourcenode a\n  length ms = length cs\n  intra_kind (kind a)\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  (\\<forall>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edge S cs a", "by(fastforce simp:slice_edge_def in_set_conv_nth intra_kind_def)"], ["proof (state)\nthis:\n  slice_edge S cs a\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  slice_edge S cs a", "have \"slice_edges S cs (a#as) = a#slice_edges S cs as\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = a # slice_edges S cs as", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = a # slice_edges S cs as\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from True \\<open>pred (kind a) s\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>\n        \\<open>\\<forall>mx \\<in> set ms. return_node mx\\<close> \\<open>length ms = length cs\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>length s = Suc (length cs)\\<close> \\<open>length (transfer (kind a) s) = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  (\\<forall>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  intra_kind (kind a)\n  Ball (set ms) return_node\n  length ms = length cs\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length cs)", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) -a\\<rightarrow> (targetnode a#ms,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  (\\<forall>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  intra_kind (kind a)\n  Ball (set ms) return_node\n  length ms = length cs\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length cs)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) -a\\<rightarrow> (targetnode a #\n          ms,transfer (kind a) s)", "by(fastforce intro!:observable_move_intra)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow> (targetnode a #\n        ms,transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>length ms = length cs\\<close> \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length ms = length cs\n  length s = Suc (length cs)\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow> (targetnode a #\n        ms,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) =[]@[a]\\<Rightarrow> \n                      (targetnode a#ms,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  length ms = length cs\n  length s = Suc (length cs)\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow> (targetnode a #\n        ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) =[] @\n                                [a]\\<Rightarrow> (targetnode a #\n            ms,transfer (kind a) s)", "by(fastforce intro:observable_moves_snoc silent_moves_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          ms,transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) =slice_edges S cs as\\<Rightarrow>*\n        (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          ms,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) =last [a]#slice_edges S cs as\\<Rightarrow>* (ms'',s'')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) =last [a] #\n                                slice_edges S cs as\\<Rightarrow>* (ms'',s'')", "by(fastforce intro:tom_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last [a] #\n                              slice_edges S cs as\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>slice_edges S cs (a#as) = a#slice_edges S cs as\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = a # slice_edges S cs as\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last [a] #\n                              slice_edges S cs as\\<Rightarrow>* (ms'',s'')", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) =slice_edges S cs (a#as)\\<Rightarrow>* (ms'',s'')\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = a # slice_edges S cs as\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last [a] #\n                              slice_edges S cs as\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) =slice_edges S cs\n                                 (a # as)\\<Rightarrow>* (ms'',s'')", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from \\<open>slice_edges S cs as = slice_edges S cs as''\\<close> \\<open>slice_edge S cs a\\<close>\n        \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs as = slice_edges S cs as''\n  slice_edge S cs a\n  intra_kind (kind a)", "have \"slice_edges S cs (a#as) = slice_edges S cs (a#as'')\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = slice_edges S cs as''\n  slice_edge S cs a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using paths \\<open>m = sourcenode a\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>\n        \\<open>length ms = length cs\\<close> \\<open>slice_edges S cs (a#as) = a#slice_edges S cs as\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes rs\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  slice_edges S cs as = slice_edges S cs as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux cs (as'' @ as')\n  m = sourcenode a\n  valid_edge a\n  intra_kind (kind a)\n  length ms = length cs\n  slice_edges S cs (a # as) = a # slice_edges S cs as\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; valid_edge a;\n     intra_kind (kind a); length ms = length cs;\n     slice_edges S cs (a # as) = a # slice_edges S cs as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; valid_edge a;\n     intra_kind (kind a); length ms = length cs;\n     slice_edges S cs (a # as) = a # slice_edges S cs as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; valid_edge a;\n     intra_kind (kind a); length ms = length cs;\n     slice_edges S cs (a # as) = a # slice_edges S cs as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; valid_edge a;\n     intra_kind (kind a); length ms = length cs;\n     slice_edges S cs (a # as) = a # slice_edges S cs as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; valid_edge a;\n     intra_kind (kind a); length ms = length cs;\n     slice_edges S cs (a # as) = a # slice_edges S cs as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; valid_edge a;\n     intra_kind (kind a); length ms = length cs;\n     slice_edges S cs (a # as) = a # slice_edges S cs as\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n         ms',s') \\<and>\n                      ms = targetnodes rs \\<and>\n                      length ms = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node (ms ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) =\n                      slice_edges S cs (a # as'') \\<and>\n                      m -(a # as'') @ as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ((a # as'') @ as')", "by(auto intro:Cons_path simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "case False"], ["proof (state)\nthis:\n  \\<not> ((\\<forall>m\\<in>set ms.\n              \\<exists>m'.\n                 call_of_return_node m m' \\<and>\n                 m' \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n          m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>\\<forall>mx \\<in> set ms. return_node mx\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms) return_node\n  \\<not> ((\\<forall>m\\<in>set ms.\n              \\<exists>m'.\n                 call_of_return_node m m' \\<and>\n                 m' \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n          m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have disj:\"(\\<exists>m \\<in> set ms. \\<exists>m'. call_of_return_node m m' \\<and> \n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  Ball (set ms) return_node\n  \\<not> ((\\<forall>m\\<in>set ms.\n              \\<exists>m'.\n                 call_of_return_node m m' \\<and>\n                 m' \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n          m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<in>set ms.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n    m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce dest:return_node_call_of_return_node)"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>m = sourcenode a\\<close> \\<open>length ms = length cs\\<close> \\<open>intra_kind (kind a)\\<close>\n        \\<open>\\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\\<close>"], ["proof (chain)\npicking this:\n  m = sourcenode a\n  length ms = length cs\n  intra_kind (kind a)\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  (\\<exists>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<not> slice_edge S cs a\""], ["proof (prove)\nusing this:\n  m = sourcenode a\n  length ms = length cs\n  intra_kind (kind a)\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  (\\<exists>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "by(fastforce simp:slice_edge_def in_set_conv_nth intra_kind_def)"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  \\<not> slice_edge S cs a", "have \"slice_edges S cs (a#as) = slice_edges S cs as\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs as", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs as\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from disj \\<open>pred (kind a) s\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>\n        \\<open>\\<forall>mx \\<in> set ms. return_node mx\\<close> \\<open>length ms = length cs\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>length s = Suc (length cs)\\<close> \\<open>length (transfer (kind a) s) = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  (\\<exists>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  intra_kind (kind a)\n  Ball (set ms) return_node\n  length ms = length cs\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length cs)", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a#ms,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set ms.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  intra_kind (kind a)\n  Ball (set ms) return_node\n  length ms = length cs\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length cs)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                       ms,transfer (kind a) s)", "by(fastforce intro!:silent_move_intra)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set ms.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            m \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) =slice_edges S cs as\\<Rightarrow>*\n                      (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs as\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "proof(rule trans_observable_moves.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "fix msx sx n\\<^sub>c' f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "assume \"targetnode a # ms = msx\"\n          and \"transfer (kind a) s = sx\" and \"slice_edges S cs as = []\"\n          and [simp]:\"ms'' = msx\" \"s'' = sx\" and \"length msx = length sx\""], ["proof (state)\nthis:\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  slice_edges S cs as = []\n  ms'' = msx\n  s'' = sx\n  length msx = length sx\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>slice_edges S cs (a#as) = slice_edges S cs as\\<close> \n          \\<open>slice_edges S cs as = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = slice_edges S cs as\n  slice_edges S cs as = []", "have \"slice_edges S cs (a#as) = []\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = slice_edges S cs as\n  slice_edges S cs as = []\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = []\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>length ms = length cs\\<close> \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length ms = length cs\n  length s = Suc (length cs)\n  slice_edges S cs (a # as) = []", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) =slice_edges S cs (a#as)\\<Rightarrow>*\n                        (sourcenode a#ms,s)\""], ["proof (prove)\nusing this:\n  length ms = length cs\n  length s = Suc (length cs)\n  slice_edges S cs (a # as) = []\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) =slice_edges S cs\n                                 (a #\n                                  as)\\<Rightarrow>* (sourcenode a # ms,s)", "by(fastforce intro:tom_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # ms,s)\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # ms,s)\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>targetnode a # ms = msx\\<close>\n          \\<open>transfer (kind a) s = sx\\<close> \\<open>ms'' = msx\\<close> \\<open>s'' = sx\\<close>\n          \\<open>S,kind \\<turnstile> (sourcenode a#ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a#ms,transfer (kind a) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  ms'' = msx\n  s'' = sx\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) =a#as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  ms'' = msx\n  s'' = sx\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) =a #\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "by(fastforce intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from this \\<open>valid_edge a\\<close> \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n          \\<open>ms = targetnodes rs\\<close> \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close>\n          \\<open>length s = Suc (length cs)\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_edge a\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n  m = sourcenode a", "have \"sourcenode a -a#as'\\<rightarrow>* m'\" and \"valid_path_aux cs (a#as')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_edge a\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* m' &&& valid_path_aux cs (a # as')", "by -(rule silent_moves_vpa_path,(fastforce simp:targetnodes_def)+)+"], ["proof (state)\nthis:\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # ms,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # ms,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using \\<open>m = sourcenode a\\<close> \\<open>length ms = length cs\\<close>\n          \\<open>\\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\\<close>\n          \\<open>slice_edges S cs (a#as) = []\\<close> \\<open>intra_kind (kind a)\\<close>\n          \\<open>S,kind \\<turnstile> (sourcenode a#ms,s) =a#as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>\n          \\<open>ms = targetnodes rs\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # ms,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n  m = sourcenode a\n  length ms = length cs\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  slice_edges S cs (a # as) = []\n  intra_kind (kind a)\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs (a # as) = []; intra_kind (kind a);\n     S,kind \\<turnstile> (sourcenode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"sourcenode a#ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs (a # as) = []; intra_kind (kind a);\n     S,kind \\<turnstile> (sourcenode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # ms,s'') \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        ms,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs (a # as) = []; intra_kind (kind a);\n     S,kind \\<turnstile> (sourcenode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # ms,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs (a # as) = []; intra_kind (kind a);\n     S,kind \\<turnstile> (sourcenode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # ms,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        ms,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ a # as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ a # as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs (a # as) = []; intra_kind (kind a);\n     S,kind \\<turnstile> (sourcenode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # ms,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        ms,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ a # as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ a # as')", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs (a # as) = []; intra_kind (kind a);\n     S,kind \\<turnstile> (sourcenode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     ms,s) =slice_edges S cs\n             (a # as)\\<Rightarrow>* (sourcenode a # ms,s) \\<and>\n                      S,kind \\<turnstile> (sourcenode a #\n     ms,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                      ms = targetnodes rs \\<and>\n                      length ms = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node (ms ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) = slice_edges S cs [] \\<and>\n                      m -[] @ a # as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ([] @ a # as')", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "fix S' f msx sx asx msx' sx' asx' msx'' sx''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "assume [simp]:\"S = S'\" and \"kind = f\" and \"targetnode a # ms = msx\"\n          and \"transfer (kind a) s = sx\" and \"slice_edges S cs as = last asx # asx'\"\n          and \"ms'' = msx''\" and \"s'' = sx''\" \n          and \"S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\"\n          and \"S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\""], ["proof (state)\nthis:\n  S = S'\n  kind = f\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  slice_edges S cs as = last asx # asx'\n  ms'' = msx''\n  s'' = sx''\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>kind = f\\<close>"], ["proof (chain)\npicking this:\n  kind = f", "have [simp]:\"f = kind\""], ["proof (prove)\nusing this:\n  kind = f\n\ngoal (1 subgoal):\n 1. f = kind", "by simp"], ["proof (state)\nthis:\n  f = kind\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (sourcenode a#ms,s) -a\\<rightarrow>\\<^sub>\\<tau> \n          (targetnode a#ms,transfer (kind a) s)\\<close> \\<open>S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\\<close>\n          \\<open>transfer (kind a) s = sx\\<close> \\<open>targetnode a # ms = msx\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  transfer (kind a) s = sx\n  targetnode a # ms = msx", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) =a#asx\\<Rightarrow> (msx',sx')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  transfer (kind a) s = sx\n  targetnode a # ms = msx\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) =a # asx\\<Rightarrow> (msx',sx')", "by(fastforce intro:silent_move_observable_moves)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a # ms,s) =a # asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\\<close> \\<open>ms'' = msx''\\<close> \\<open>s'' = sx''\\<close>"], ["proof (chain)\npicking this:\n  S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n  ms'' = msx''\n  s'' = sx''\n  S,kind \\<turnstile> (sourcenode a # ms,s) =a # asx\\<Rightarrow> (msx',sx')", "have \"S,kind \\<turnstile> (sourcenode a#ms,s) =last (a#asx)#asx'\\<Rightarrow>* (ms'',s'')\""], ["proof (prove)\nusing this:\n  S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n  ms'' = msx''\n  s'' = sx''\n  S,kind \\<turnstile> (sourcenode a # ms,s) =a # asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         ms,s) =last (a # asx) #\n                                asx'\\<Rightarrow>* (ms'',s'')", "by(fastforce intro:trans_observable_moves.tom_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\\<close>"], ["proof (chain)\npicking this:\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')", "have \"asx \\<noteq> []\""], ["proof (prove)\nusing this:\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. asx \\<noteq> []", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>slice_edges S cs (a#as) = slice_edges S cs as\\<close>\n          \\<open>slice_edges S cs as = last asx # asx'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = slice_edges S cs as\n  slice_edges S cs as = last asx # asx'\n  asx \\<noteq> []", "have \"slice_edges S cs (a#as) = last (a#asx)#asx'\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = slice_edges S cs as\n  slice_edges S cs as = last asx # asx'\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = last (a # asx) # asx'", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<not> slice_edge S cs a\\<close> \\<open>slice_edges S cs as = slice_edges S cs as''\\<close>\n          \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> slice_edge S cs a\n  slice_edges S cs as = slice_edges S cs as''\n  intra_kind (kind a)", "have \"slice_edges S cs (a # as) = slice_edges S cs (a # as'')\""], ["proof (prove)\nusing this:\n  \\<not> slice_edge S cs a\n  slice_edges S cs as = slice_edges S cs as''\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using paths \\<open>m = sourcenode a\\<close> \\<open>intra_kind (kind a)\\<close>\n          \\<open>length ms = length cs\\<close> \\<open>ms = targetnodes rs\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes rs\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n  slice_edges S cs as = slice_edges S cs as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux cs (as'' @ as')\n  m = sourcenode a\n  intra_kind (kind a)\n  length ms = length cs\n  ms = targetnodes rs\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; intra_kind (kind a);\n     length ms = length cs; ms = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; intra_kind (kind a);\n     length ms = length cs; ms = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; intra_kind (kind a);\n     length ms = length cs; ms = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; intra_kind (kind a);\n     length ms = length cs; ms = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; intra_kind (kind a);\n     length ms = length cs; ms = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         ms = targetnodes rs \\<and>\n                         length ms = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (ms ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs;\n     \\<forall>i<length cs.\n        call_of_return_node (ms ! i) (sourcenode (cs ! i));\n     slice_edges S cs as = slice_edges S cs as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs (as'' @ as'); m = sourcenode a; intra_kind (kind a);\n     length ms = length cs; ms = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n         ms',s') \\<and>\n                      ms = targetnodes rs \\<and>\n                      length ms = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node (ms ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) =\n                      slice_edges S cs (a # as'') \\<and>\n                      m -(a # as'') @ as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ((a # as'') @ as')", "by(auto intro:Cons_path simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "case (vpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; preds (kinds as) ?s;\n   transfers (kinds as) ?s = s'; valid_call_list (a # cs) ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges ((a # cs) ! i);\n   valid_return_list ?rs ?m; length ?rs = length (a # cs);\n   length ?s = Suc (length (a # cs))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                       S,kind \\<turnstile> (?m #\n      ms,?s) =slice_edges S (a # cs) as\\<Rightarrow>* (ms'',s'') \\<and>\n                       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n          ms',s') \\<and>\n                       ms = targetnodes ?rs \\<and>\n                       length ms = length (a # cs) \\<and>\n                       (\\<forall>i<length (a # cs).\n                           call_of_return_node (ms ! i)\n                            (sourcenode ((a # cs) ! i))) \\<and>\n                       slice_edges S (a # cs) as =\n                       slice_edges S (a # cs) as'' \\<and>\n                       ?m -as'' @ as'\\<rightarrow>* m' \\<and>\n                       valid_path_aux (a # cs) (as'' @ as')\n  m -a # as\\<rightarrow>* m'\n  preds (kinds (a # as)) s\n  transfers (kinds (a # as)) s = s'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "note IH = \\<open>\\<And>m s rs. \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s; transfers (kinds as) s = s';\n      valid_call_list (a # cs) m;\n      \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n      valid_return_list rs m; length rs = length (a # cs);\n      length s = Suc (length (a # cs))\\<rbrakk>\n      \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n      S,kind \\<turnstile> (m # ms,s) =slice_edges S (a # cs) as\\<Rightarrow>* (ms'',s'') \\<and>\n      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and> ms = targetnodes rs \\<and>\n      length ms = length (a # cs) \\<and>\n      (\\<forall>i<length (a # cs). call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))) \\<and>\n      slice_edges S (a # cs) as = slice_edges S (a # cs) as'' \\<and>\n      m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux (a # cs) (as'' @ as')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; preds (kinds as) ?s;\n   transfers (kinds as) ?s = s'; valid_call_list (a # cs) ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges ((a # cs) ! i);\n   valid_return_list ?rs ?m; length ?rs = length (a # cs);\n   length ?s = Suc (length (a # cs))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                       S,kind \\<turnstile> (?m #\n      ms,?s) =slice_edges S (a # cs) as\\<Rightarrow>* (ms'',s'') \\<and>\n                       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n          ms',s') \\<and>\n                       ms = targetnodes ?rs \\<and>\n                       length ms = length (a # cs) \\<and>\n                       (\\<forall>i<length (a # cs).\n                           call_of_return_node (ms ! i)\n                            (sourcenode ((a # cs) ! i))) \\<and>\n                       slice_edges S (a # cs) as =\n                       slice_edges S (a # cs) as'' \\<and>\n                       ?m -as'' @ as'\\<rightarrow>* m' \\<and>\n                       valid_path_aux (a # cs) (as'' @ as')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"m = sourcenode a\" and \"valid_edge a\"\n      and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>preds (kinds (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\"\n      and \"preds (kinds as) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s &&& preds (kinds as) (transfer (kind a) s)", "by(auto simp:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n  preds (kinds as) (transfer (kind a) s)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>transfers (kinds (a # as)) s = s'\\<close>"], ["proof (chain)\npicking this:\n  transfers (kinds (a # as)) s = s'", "have \"transfers (kinds as) (transfer (kind a) s) = s'\""], ["proof (prove)\nusing this:\n  transfers (kinds (a # as)) s = s'\n\ngoal (1 subgoal):\n 1. transfers (kinds as) (transfer (kind a) s) = s'", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  transfers (kinds as) (transfer (kind a) s) = s'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>valid_call_list cs m\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p", "have \"valid_call_list (a # cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  m = sourcenode a\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        a # cs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        a # cs = cs' @ c # cs''; cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a);\n        cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        m = sourcenode a; p = get_proc (targetnode a); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "by(case_tac list)(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain a' where \"a' \\<in> get_return_edges a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        a' \\<in> get_return_edges a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:get_return_edge_call)"], ["proof (state)\nthis:\n  a' \\<in> get_return_edges a\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a", "have \"\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a' # rs).\n       (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>valid_return_list rs m\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n      \\<open>get_proc (sourcenode a') = p\\<close> \\<open>get_proc (targetnode a) = p\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')", "have \"valid_return_list (a'#rs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a') = p\n  get_proc (targetnode a) = p\n  m = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_return_list (a' # rs) (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); a' # rs = cs' @ c # cs'';\n        cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a')\\<^esub>f';\n        get_proc (targetnode a) = get_proc (sourcenode a');\n        m = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        p = get_proc (sourcenode a'); rs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> sourcenode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "by(case_tac list)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs", "have \"length (a'#rs) = length (a#cs)\""], ["proof (prove)\nusing this:\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. length (a' # rs) = length (a # cs)", "by simp"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>length s = Suc (length cs)\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"length (transfer (kind a) s) = Suc (length (a#cs))\""], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. length (transfer (kind a) s) = Suc (length (a # cs))", "by(cases s) auto"], ["proof (state)\nthis:\n  length (transfer (kind a) s) = Suc (length (a # cs))\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \\<open>preds (kinds as) (transfer (kind a) s)\\<close>\n      \\<open>transfers (kinds as) (transfer (kind a) s) = s'\\<close> \n      \\<open>valid_call_list (a # cs) (targetnode a)\\<close> \n      \\<open>\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\\<close>\n      \\<open>valid_return_list (a'#rs) (targetnode a)\\<close> \\<open>length (a'#rs) = length (a#cs)\\<close>\n      \\<open>length (transfer (kind a) s) = Suc (length (a#cs))\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (targetnode a #\n                          ms,transfer (kind a)\n                              s) =slice_edges S (a # cs)\n                                   as\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes (a' # rs) \\<and>\n     length ms = length (a # cs) \\<and>\n     (\\<forall>i<length (a # cs).\n         call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))) \\<and>\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'' \\<and>\n     targetnode a -as'' @ as'\\<rightarrow>* m' \\<and>\n     valid_path_aux (a # cs) (as'' @ as')", "obtain ms ms'' s'' as' ms' as'' where \"length ms = length (a#cs)\"\n      and \"S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) \n                     =slice_edges S (a#cs) as\\<Rightarrow>* (ms'',s'')\" \n      and paths:\"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\"\n      \"ms = targetnodes (a'#rs)\"\n      \"\\<forall>i<length (a#cs). call_of_return_node (ms ! i) (sourcenode ((a#cs) ! i))\"\n      \"slice_edges S (a#cs) as = slice_edges S (a#cs) as''\"\n      \"targetnode a -as'' @ as'\\<rightarrow>* m'\" \"valid_path_aux (a#cs) (as'' @ as')\""], ["proof (prove)\nusing this:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (targetnode a #\n                          ms,transfer (kind a)\n                              s) =slice_edges S (a # cs)\n                                   as\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes (a' # rs) \\<and>\n     length ms = length (a # cs) \\<and>\n     (\\<forall>i<length (a # cs).\n         call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))) \\<and>\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'' \\<and>\n     targetnode a -as'' @ as'\\<rightarrow>* m' \\<and>\n     valid_path_aux (a # cs) (as'' @ as')\n\ngoal (1 subgoal):\n 1. (\\<And>ms ms'' s'' as' ms' as''.\n        \\<lbrakk>length ms = length (a # cs);\n         S,kind \\<turnstile> (targetnode a #\n                              ms,transfer (kind a)\n                                  s) =slice_edges S (a # cs)\n as\\<Rightarrow>* (ms'',s'');\n         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                  ms',s');\n         ms = targetnodes (a' # rs);\n         \\<forall>i<length (a # cs).\n            call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n         slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n         targetnode a -as'' @ as'\\<rightarrow>* m';\n         valid_path_aux (a # cs) (as'' @ as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length ms = length (a # cs)\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S (a # cs)\n                                as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes (a' # rs)\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  slice_edges S (a # cs) as = slice_edges S (a # cs) as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux (a # cs) (as'' @ as')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>ms = targetnodes (a'#rs)\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes (a' # rs)", "obtain x xs where [simp]:\"ms = x#xs\"\n      and \"x = targetnode a'\" and \"xs = targetnodes rs\""], ["proof (prove)\nusing this:\n  ms = targetnodes (a' # rs)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<lbrakk>ms = x # xs; x = targetnode a';\n         xs = targetnodes rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  ms = x # xs\n  x = targetnode a'\n  xs = targetnodes rs\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<forall>i<length (a#cs). call_of_return_node (ms ! i) (sourcenode ((a#cs) ! i))\\<close>\n      \\<open>length ms = length (a#cs)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  length ms = length (a # cs)", "have \"\\<forall>mx \\<in> set xs. return_node mx\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  length ms = length (a # cs)\n\ngoal (1 subgoal):\n 1. Ball (set xs) return_node", "apply(auto simp:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<Suc (length cs).\n                   call_of_return_node ((x # xs) ! i)\n                    (sourcenode ((a # cs) ! i));\n        length xs = length cs; i < length cs\\<rbrakk>\n       \\<Longrightarrow> return_node (xs ! i)", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<Suc (length cs).\n                   call_of_return_node ((x # xs) ! i)\n                    (sourcenode ((a # cs) ! i));\n        length xs = length cs; i < length cs; i = 0\\<rbrakk>\n       \\<Longrightarrow> return_node (xs ! i)\n 2. \\<And>i nat.\n       \\<lbrakk>\\<forall>i<Suc (length cs).\n                   call_of_return_node ((x # xs) ! i)\n                    (sourcenode ((a # cs) ! i));\n        length xs = length cs; i < length cs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> return_node (xs ! i)", "apply(erule_tac x=\"Suc 0\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length xs = length cs; i < length cs; i = 0;\n        Suc 0 < Suc (length cs) \\<longrightarrow>\n        call_of_return_node ((x # xs) ! Suc 0)\n         (sourcenode ((a # cs) ! Suc 0))\\<rbrakk>\n       \\<Longrightarrow> return_node (xs ! i)\n 2. \\<And>i nat.\n       \\<lbrakk>\\<forall>i<Suc (length cs).\n                   call_of_return_node ((x # xs) ! i)\n                    (sourcenode ((a # cs) ! i));\n        length xs = length cs; i < length cs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> return_node (xs ! i)", "by(auto simp:call_of_return_node_def)"], ["proof (state)\nthis:\n  Ball (set xs) return_node\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m s rs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list (a # cs) m;\n            \\<forall>i<length rs.\n               rs ! i \\<in> get_return_edges ((a # cs) ! i);\n            valid_return_list rs m; length rs = length (a # cs);\n            length s = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S (a # cs)\n                       as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length (a # cs) \\<and>\n                                (\\<forall>i<length (a # cs).\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ((a # cs) ! i))) \\<and>\n                                slice_edges S (a # cs) as =\n                                slice_edges S (a # cs) as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux (a # cs) (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 3. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "proof(cases \"(\\<forall>m \\<in> set xs. \\<exists>m'. call_of_return_node m m' \\<and> \n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and> sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "case True"], ["proof (state)\nthis:\n  (\\<forall>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>\\<forall>i<length (a#cs). call_of_return_node (ms ! i) (sourcenode ((a#cs) ! i))\\<close>\n        \\<open>length ms = length (a#cs)\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  length ms = length (a # cs)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (\\<forall>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_edge S cs a\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  length ms = length (a # cs)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (\\<forall>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edge S cs a", "apply(auto simp:slice_edge_def in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<Suc (length cs).\n                   call_of_return_node ((x # xs) ! i)\n                    (sourcenode ((a # cs) ! i));\n        length xs = length cs;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        \\<forall>m\\<in>set xs.\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        i < length cs\\<rbrakk>\n       \\<Longrightarrow> sourcenode (cs ! i)\n                         \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"Suc i\" in allE) auto"], ["proof (state)\nthis:\n  slice_edge S cs a\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  slice_edge S cs a", "have \"slice_edges S cs (a#as) = a#slice_edges S (a#cs) as\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = a # slice_edges S (a # cs) as", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from True \\<open>pred (kind a) s\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n        \\<open>valid_edge a'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>\n        \\<open>\\<forall>mx \\<in> set xs. return_node mx\\<close> \\<open>length ms = length (a#cs)\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>length s = Suc (length cs)\\<close> \n        \\<open>length (transfer (kind a) s) = Suc (length (a#cs))\\<close>"], ["proof (chain)\npicking this:\n  (\\<forall>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  Ball (set xs) return_node\n  length ms = length (a # cs)\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length (a # cs))", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) -a\\<rightarrow> \n        (targetnode a#targetnode a'#xs,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  (\\<forall>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  Ball (set xs) return_node\n  length ms = length (a # cs)\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length (a # cs))\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) -a\\<rightarrow> (targetnode a #\n          targetnode a' # xs,transfer (kind a) s)", "by -(rule_tac a'=\"a'\" in observable_move_call,fastforce+)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow> (targetnode a #\n        targetnode a' # xs,transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>length ms = length (a#cs)\\<close> \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length ms = length (a # cs)\n  length s = Suc (length cs)\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow> (targetnode a #\n        targetnode a' # xs,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) =[]@[a]\\<Rightarrow> \n        (targetnode a#targetnode a'#xs,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  length ms = length (a # cs)\n  length s = Suc (length cs)\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow> (targetnode a #\n        targetnode a' # xs,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) =[] @\n                                [a]\\<Rightarrow> (targetnode a #\n            targetnode a' # xs,transfer (kind a) s)", "by(fastforce intro:observable_moves_snoc silent_moves_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          targetnode a' # xs,transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) \n        =slice_edges S (a#cs) as\\<Rightarrow>* (ms'',s'')\\<close> \\<open>x = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S (a # cs)\n                                as\\<Rightarrow>* (ms'',s'')\n  x = targetnode a'\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          targetnode a' # xs,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) =last [a]#slice_edges S (a#cs) as\\<Rightarrow>* \n        (ms'',s'')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S (a # cs)\n                                as\\<Rightarrow>* (ms'',s'')\n  x = targetnode a'\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          targetnode a' # xs,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) =last [a] #\n                                slice_edges S (a # cs)\n                                 as\\<Rightarrow>* (ms'',s'')", "by -(rule tom_Cons,auto)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last [a] #\n                              slice_edges S (a # cs)\n                               as\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>slice_edges S cs (a#as) = a#slice_edges S (a#cs) as\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last [a] #\n                              slice_edges S (a # cs)\n                               as\\<Rightarrow>* (ms'',s'')", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) =slice_edges S cs (a#as)\\<Rightarrow>* (ms'',s'')\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last [a] #\n                              slice_edges S (a # cs)\n                               as\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) =slice_edges S cs\n                                 (a # as)\\<Rightarrow>* (ms'',s'')", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from \\<open>slice_edges S (a#cs) as = slice_edges S (a#cs) as''\\<close>\n        \\<open>slice_edge S cs a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S (a # cs) as = slice_edges S (a # cs) as''\n  slice_edge S cs a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"slice_edges S cs (a#as) = slice_edges S cs (a#as'')\""], ["proof (prove)\nusing this:\n  slice_edges S (a # cs) as = slice_edges S (a # cs) as''\n  slice_edge S cs a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (2 subgoals):\n 1. (\\<forall>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n    sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using paths \\<open>m = sourcenode a\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n          \\<open>length ms = length (a#cs)\\<close> \\<open>xs = targetnodes rs\\<close>\n          \\<open>slice_edges S cs (a#as) = a#slice_edges S (a#cs) as\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes (a' # rs)\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  slice_edges S (a # cs) as = slice_edges S (a # cs) as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux (a # cs) (as'' @ as')\n  m = sourcenode a\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  length ms = length (a # cs)\n  xs = targetnodes rs\n  slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs;\n     slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs;\n     slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs;\n     slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs;\n     slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs;\n     slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs;\n     slice_edges S cs (a # as) = a # slice_edges S (a # cs) as\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n         ms',s') \\<and>\n                      xs = targetnodes rs \\<and>\n                      length xs = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node (xs ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) =\n                      slice_edges S cs (a # as'') \\<and>\n                      m -(a # as'') @ as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ((a # as'') @ as')", "by(auto intro:Cons_path simp:targetnodes_def)"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "case False"], ["proof (state)\nthis:\n  \\<not> ((\\<forall>m\\<in>set xs.\n              \\<exists>m'.\n                 call_of_return_node m m' \\<and>\n                 m' \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n          sourcenode a\n          \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>\\<forall>mx \\<in> set xs. return_node mx\\<close>"], ["proof (chain)\npicking this:\n  Ball (set xs) return_node\n  \\<not> ((\\<forall>m\\<in>set xs.\n              \\<exists>m'.\n                 call_of_return_node m m' \\<and>\n                 m' \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n          sourcenode a\n          \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have disj:\"(\\<exists>m \\<in> set xs. \\<exists>m'. call_of_return_node m m' \\<and> \n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  Ball (set xs) return_node\n  \\<not> ((\\<forall>m\\<in>set xs.\n              \\<exists>m'.\n                 call_of_return_node m m' \\<and>\n                 m' \\<in> \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n          sourcenode a\n          \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<in>set xs.\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n    sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce dest:return_node_call_of_return_node)"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>\\<forall>i<length (a#cs). call_of_return_node (ms ! i) (sourcenode ((a#cs) ! i))\\<close>\n        \\<open>length ms = length (a#cs)\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  length ms = length (a # cs)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (\\<exists>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<not> slice_edge S cs a\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  length ms = length (a # cs)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (\\<exists>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "apply(auto simp:slice_edge_def in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' i.\n       \\<lbrakk>\\<forall>i<Suc (length cs).\n                   call_of_return_node ((x # xs) ! i)\n                    (sourcenode ((a # cs) ! i));\n        length xs = length cs;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        \\<forall>c\\<in>set cs.\n           sourcenode c\n           \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        call_of_return_node (xs ! i) m';\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        i < length cs\\<rbrakk>\n       \\<Longrightarrow> False", "by(erule_tac x=\"Suc i\" in allE) auto"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<not> slice_edge S cs a", "have \"slice_edges S cs (a#as) = slice_edges S (a#cs) as\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S (a # cs) as", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S (a # cs) as\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from disj \\<open>pred (kind a) s\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n        \\<open>valid_edge a'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>\n        \\<open>\\<forall>mx \\<in> set xs. return_node mx\\<close> \\<open>length ms = length (a#cs)\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>length s = Suc (length cs)\\<close> \n        \\<open>length (transfer (kind a) s) = Suc (length (a#cs))\\<close>"], ["proof (chain)\npicking this:\n  (\\<exists>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  Ball (set xs) return_node\n  length ms = length (a # cs)\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length (a # cs))", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) -a\\<rightarrow>\\<^sub>\\<tau>\n        (targetnode a#targetnode a'#xs,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set xs.\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  Ball (set xs) return_node\n  length ms = length (a # cs)\n  m = sourcenode a\n  length s = Suc (length cs)\n  length (transfer (kind a) s) = Suc (length (a # cs))\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                       targetnode a' # xs,transfer (kind a) s)", "by -(rule_tac a'=\"a'\" in silent_move_call,fastforce+)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     targetnode a' # xs,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>m\\<in>set xs.\n                \\<exists>m'.\n                   call_of_return_node m m' \\<and>\n                   m' \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<and>\n            sourcenode a\n            \\<in> \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) \n        =slice_edges S (a#cs) as\\<Rightarrow>* (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S (a # cs)\n                                as\\<Rightarrow>* (ms'',s'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S (a # cs)\n                                as\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "proof(rule trans_observable_moves.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "fix msx sx S' f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "assume \"targetnode a # ms = msx\"\n          and \"transfer (kind a) s = sx\" and \"slice_edges S (a#cs) as = []\"\n          and [simp]:\"ms'' = msx\" \"s'' = sx\" and \"length msx = length sx\""], ["proof (state)\nthis:\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  slice_edges S (a # cs) as = []\n  ms'' = msx\n  s'' = sx\n  length msx = length sx\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>slice_edges S cs (a#as) = slice_edges S (a#cs) as\\<close> \n          \\<open>slice_edges S (a#cs) as = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = slice_edges S (a # cs) as\n  slice_edges S (a # cs) as = []", "have \"slice_edges S cs (a#as) = []\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = slice_edges S (a # cs) as\n  slice_edges S (a # cs) as = []\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = []\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>length ms = length (a#cs)\\<close> \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length ms = length (a # cs)\n  length s = Suc (length cs)\n  slice_edges S cs (a # as) = []", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) =slice_edges S cs (a#as)\\<Rightarrow>*\n                        (sourcenode a#xs,s)\""], ["proof (prove)\nusing this:\n  length ms = length (a # cs)\n  length s = Suc (length cs)\n  slice_edges S cs (a # as) = []\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) =slice_edges S cs\n                                 (a #\n                                  as)\\<Rightarrow>* (sourcenode a # xs,s)", "by(fastforce intro:tom_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # xs,s)\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # xs,s)\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>targetnode a # ms = msx\\<close>\n          \\<open>transfer (kind a) s = sx\\<close> \\<open>ms'' = msx\\<close> \\<open>s'' = sx\\<close> \\<open>x = targetnode a'\\<close>\n          \\<open>S,kind \\<turnstile> (sourcenode a#xs,s) -a\\<rightarrow>\\<^sub>\\<tau> \n          (targetnode a#targetnode a'#xs,transfer (kind a) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  ms'' = msx\n  s'' = sx\n  x = targetnode a'\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     targetnode a' # xs,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) =a#as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  ms'' = msx\n  s'' = sx\n  x = targetnode a'\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     targetnode a' # xs,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) =a #\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "by(auto intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from this \\<open>valid_edge a\\<close> \n          \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n          \\<open>xs = targetnodes rs\\<close> \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close>\n          \\<open>length s = Suc (length cs)\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_edge a\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  xs = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n  m = sourcenode a", "have \"sourcenode a -a#as'\\<rightarrow>* m'\" and \"valid_path_aux cs (a#as')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_edge a\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  xs = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* m' &&& valid_path_aux cs (a # as')", "by -(rule silent_moves_vpa_path,(fastforce simp:targetnodes_def)+)+"], ["proof (state)\nthis:\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # xs,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # xs,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using \\<open>m = sourcenode a\\<close> \\<open>length ms = length (a#cs)\\<close>\n          \\<open>\\<forall>i<length (a#cs). call_of_return_node (ms ! i) (sourcenode ((a#cs) ! i))\\<close>\n          \\<open>slice_edges S cs (a#as) = []\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n          \\<open>S,kind \\<turnstile> (sourcenode a#xs,s) =a#as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>\n          \\<open>xs = targetnodes rs\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (sourcenode a # xs,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n  m = sourcenode a\n  length ms = length (a # cs)\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  slice_edges S cs (a # as) = []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  xs = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # xs,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length (a # cs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     S,kind \\<turnstile> (sourcenode a #\n                          xs,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     xs = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"sourcenode a#xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # xs,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length (a # cs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     S,kind \\<turnstile> (sourcenode a #\n                          xs,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     xs = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # xs,s'') \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        xs,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # xs,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length (a # cs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     S,kind \\<turnstile> (sourcenode a #\n                          xs,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     xs = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # xs,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        xs,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # xs,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length (a # cs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     S,kind \\<turnstile> (sourcenode a #\n                          xs,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     xs = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # xs,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        xs,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ a # as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ a # as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # xs,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length (a # cs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     S,kind \\<turnstile> (sourcenode a #\n                          xs,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     xs = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs\n                (a # as)\\<Rightarrow>* (sourcenode a # xs,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        xs,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ a # as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ a # as')", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # xs,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length (a # cs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     S,kind \\<turnstile> (sourcenode a #\n                          xs,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     xs = targetnodes rs\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     xs,s) =slice_edges S cs\n             (a # as)\\<Rightarrow>* (sourcenode a # xs,s) \\<and>\n                      S,kind \\<turnstile> (sourcenode a #\n     xs,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                      xs = targetnodes rs \\<and>\n                      length xs = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node (xs ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) = slice_edges S cs [] \\<and>\n                      m -[] @ a # as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ([] @ a # as')", "by auto"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "fix S' f msx sx asx msx' sx' asx' msx'' sx''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "assume [simp]:\"S = S'\" and \"kind = f\" and \"targetnode a # ms = msx\"\n          and \"transfer (kind a) s = sx\" \n          and \"slice_edges S (a#cs) as = last asx # asx'\"\n          and \"ms'' = msx''\" and \"s'' = sx''\" \n          and \"S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\"\n          and \"S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\""], ["proof (state)\nthis:\n  S = S'\n  kind = f\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  slice_edges S (a # cs) as = last asx # asx'\n  ms'' = msx''\n  s'' = sx''\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>kind = f\\<close>"], ["proof (chain)\npicking this:\n  kind = f", "have [simp]:\"f = kind\""], ["proof (prove)\nusing this:\n  kind = f\n\ngoal (1 subgoal):\n 1. f = kind", "by simp"], ["proof (state)\nthis:\n  f = kind\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (sourcenode a#xs,s) -a\\<rightarrow>\\<^sub>\\<tau> \n          (targetnode a#targetnode a'#xs,transfer (kind a) s)\\<close>\n          \\<open>S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\\<close> \\<open>x = targetnode a'\\<close>\n          \\<open>transfer (kind a) s = sx\\<close> \\<open>targetnode a # ms = msx\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     targetnode a' # xs,transfer (kind a) s)\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  x = targetnode a'\n  transfer (kind a) s = sx\n  targetnode a # ms = msx", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) =a#asx\\<Rightarrow> (msx',sx')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     targetnode a' # xs,transfer (kind a) s)\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  x = targetnode a'\n  transfer (kind a) s = sx\n  targetnode a # ms = msx\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) =a # asx\\<Rightarrow> (msx',sx')", "by(auto intro:silent_move_observable_moves)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a # xs,s) =a # asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\\<close> \\<open>ms'' = msx''\\<close> \\<open>s'' = sx''\\<close>"], ["proof (chain)\npicking this:\n  S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n  ms'' = msx''\n  s'' = sx''\n  S,kind \\<turnstile> (sourcenode a # xs,s) =a # asx\\<Rightarrow> (msx',sx')", "have \"S,kind \\<turnstile> (sourcenode a#xs,s) =last (a#asx)#asx'\\<Rightarrow>* (ms'',s'')\""], ["proof (prove)\nusing this:\n  S',f \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n  ms'' = msx''\n  s'' = sx''\n  S,kind \\<turnstile> (sourcenode a # xs,s) =a # asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         xs,s) =last (a # asx) #\n                                asx'\\<Rightarrow>* (ms'',s'')", "by(fastforce intro:trans_observable_moves.tom_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\\<close>"], ["proof (chain)\npicking this:\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')", "have \"asx \\<noteq> []\""], ["proof (prove)\nusing this:\n  S',f \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. asx \\<noteq> []", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>slice_edges S cs (a#as) = slice_edges S (a#cs) as\\<close>\n          \\<open>slice_edges S (a#cs) as = last asx # asx'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = slice_edges S (a # cs) as\n  slice_edges S (a # cs) as = last asx # asx'\n  asx \\<noteq> []", "have \"slice_edges S cs (a#as) = last (a#asx)#asx'\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = slice_edges S (a # cs) as\n  slice_edges S (a # cs) as = last asx # asx'\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = last (a # asx) # asx'", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<not> slice_edge S cs a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n          \\<open>slice_edges S (a#cs) as = slice_edges S (a#cs) as''\\<close>"], ["proof (chain)\npicking this:\n  \\<not> slice_edge S cs a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  slice_edges S (a # cs) as = slice_edges S (a # cs) as''", "have \"slice_edges S cs (a # as) = slice_edges S cs (a # as'')\""], ["proof (prove)\nusing this:\n  \\<not> slice_edge S cs a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  slice_edges S (a # cs) as = slice_edges S (a # cs) as''\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S (a # cs) as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using paths \\<open>m = sourcenode a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n          \\<open>length ms = length (a#cs)\\<close> \\<open>xs = targetnodes rs\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       xs,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes (a' # rs)\n  \\<forall>i<length (a # cs).\n     call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i))\n  slice_edges S (a # cs) as = slice_edges S (a # cs) as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux (a # cs) (as'' @ as')\n  m = sourcenode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  length ms = length (a # cs)\n  xs = targetnodes rs\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         xs = targetnodes rs \\<and>\n                         length xs = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node (xs ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  xs,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes (a' # rs);\n     \\<forall>i<length (a # cs).\n        call_of_return_node (ms ! i) (sourcenode ((a # cs) ! i));\n     slice_edges S (a # cs) as = slice_edges S (a # cs) as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux (a # cs) (as'' @ as'); m = sourcenode a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     length ms = length (a # cs); xs = targetnodes rs; valid_edge a\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     xs,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n         ms',s') \\<and>\n                      xs = targetnodes rs \\<and>\n                      length xs = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node (xs ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) =\n                      slice_edges S cs (a # as'') \\<and>\n                      m -(a # as'') @ as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ((a # as'') @ as')", "by(auto intro:Cons_path simp:targetnodes_def)"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "case (vpa_ReturnEmpty cs a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; preds (kinds as) ?s;\n   transfers (kinds as) ?s = s'; valid_call_list [] ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges ([] ! i);\n   valid_return_list ?rs ?m; length ?rs = length [];\n   length ?s = Suc (length [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                       S,kind \\<turnstile> (?m #\n      ms,?s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n          ms',s') \\<and>\n                       ms = targetnodes ?rs \\<and>\n                       length ms = length [] \\<and>\n                       (\\<forall>i<length [].\n                           call_of_return_node (ms ! i)\n                            (sourcenode ([] ! i))) \\<and>\n                       slice_edges S [] as = slice_edges S [] as'' \\<and>\n                       ?m -as'' @ as'\\<rightarrow>* m' \\<and>\n                       valid_path_aux [] (as'' @ as')\n  m -a # as\\<rightarrow>* m'\n  preds (kinds (a # as)) s\n  transfers (kinds (a # as)) s = s'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>preds (kinds (a # as)) s\\<close> \\<open>length s = Suc (length cs)\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n      \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s\n  length s = Suc (length cs)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []", "have False"], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n  length s = Suc (length cs)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n\ngoal (1 subgoal):\n 1. False", "by(cases s)(auto simp:kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list [] m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n            valid_return_list rs m; length rs = length [];\n            length s = Suc (length [])\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length [] \\<and>\n                                (\\<forall>i<length [].\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode ([] ! i))) \\<and>\n                                slice_edges S [] as =\n                                slice_edges S [] as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux [] (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "by simp"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "case (vpa_ReturnCons cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>?m -as\\<rightarrow>* m'; preds (kinds as) ?s;\n   transfers (kinds as) ?s = s'; valid_call_list cs' ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs' ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs';\n   length ?s = Suc (length cs')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                       S,kind \\<turnstile> (?m #\n      ms,?s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n          ms',s') \\<and>\n                       ms = targetnodes ?rs \\<and>\n                       length ms = length cs' \\<and>\n                       (\\<forall>i<length cs'.\n                           call_of_return_node (ms ! i)\n                            (sourcenode (cs' ! i))) \\<and>\n                       slice_edges S cs' as = slice_edges S cs' as'' \\<and>\n                       ?m -as'' @ as'\\<rightarrow>* m' \\<and>\n                       valid_path_aux cs' (as'' @ as')\n  m -a # as\\<rightarrow>* m'\n  preds (kinds (a # as)) s\n  transfers (kinds (a # as)) s = s'\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "note IH = \\<open>\\<And>m s rs. \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s; transfers (kinds as) s = s';\n      valid_call_list cs' m; \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n      valid_return_list rs m; length rs = length cs'; length s = Suc (length cs')\\<rbrakk>\n      \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n      S,kind \\<turnstile> (m # ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and> ms = targetnodes rs \\<and>\n      length ms = length cs' \\<and>\n      (\\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))) \\<and>\n      slice_edges S cs' as = slice_edges S cs' as'' \\<and>\n      m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs' (as'' @ as')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; preds (kinds as) ?s;\n   transfers (kinds as) ?s = s'; valid_call_list cs' ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs' ! i);\n   valid_return_list ?rs ?m; length ?rs = length cs';\n   length ?s = Suc (length cs')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                       S,kind \\<turnstile> (?m #\n      ms,?s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n          ms',s') \\<and>\n                       ms = targetnodes ?rs \\<and>\n                       length ms = length cs' \\<and>\n                       (\\<forall>i<length cs'.\n                           call_of_return_node (ms ! i)\n                            (sourcenode (cs' ! i))) \\<and>\n                       slice_edges S cs' as = slice_edges S cs' as'' \\<and>\n                       ?m -as'' @ as'\\<rightarrow>* m' \\<and>\n                       valid_path_aux cs' (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"m = sourcenode a\" and \"valid_edge a\"\n      and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>preds (kinds (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\"\n      and \"preds (kinds as) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s &&& preds (kinds as) (transfer (kind a) s)", "by(auto simp:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n  preds (kinds as) (transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>transfers (kinds (a # as)) s = s'\\<close>"], ["proof (chain)\npicking this:\n  transfers (kinds (a # as)) s = s'", "have \"transfers (kinds as) (transfer (kind a) s) = s'\""], ["proof (prove)\nusing this:\n  transfers (kinds (a # as)) s = s'\n\ngoal (1 subgoal):\n 1. transfers (kinds as) (transfer (kind a) s) = s'", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  transfers (kinds as) (transfer (kind a) s) = s'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c'", "by(fastforce simp:valid_call_list_def)"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>\n      \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"valid_call_list cs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode a);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> m\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs')(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>length rs = length cs\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  cs = c' # cs'", "obtain r' rs' \n      where [simp]:\"rs = r'#rs'\" and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rs) auto"], ["proof (state)\nthis:\n  rs = r' # rs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  cs = c' # cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n      and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'", "have [simp]:\"a = r'\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. a = r'", "by -(rule get_return_edges_unique)"], ["proof (state)\nthis:\n  a = r'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>valid_return_list rs m\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  a = r'", "have \"valid_return_list rs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  a = r'\n\ngoal (1 subgoal):\n 1. valid_return_list rs' (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       r' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> m\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        rs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"r' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>rs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               r' # cs' @ c # cs'' =\n               (r' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case r' # cs' of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow>\n        last (targetnodes (r' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>length s = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"length (transfer (kind a) s) = Suc (length cs')\""], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. length (transfer (kind a) s) = Suc (length cs')", "by(cases s)(auto,case_tac list,auto)"], ["proof (state)\nthis:\n  length (transfer (kind a) s) = Suc (length cs')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \\<open>preds (kinds as) (transfer (kind a) s)\\<close>\n      \\<open>transfers (kinds as) (transfer (kind a) s) = s'\\<close>\n      \\<open>valid_call_list cs' (targetnode a)\\<close> \n      \\<open>\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\\<close>\n      \\<open>valid_return_list rs' (targetnode a)\\<close> \\<open>length rs' = length cs'\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (targetnode a #\n                          ms,transfer (kind a)\n                              s) =slice_edges S cs'\n                                   as\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs' \\<and>\n     length ms = length cs' \\<and>\n     (\\<forall>i<length cs'.\n         call_of_return_node (ms ! i) (sourcenode (cs' ! i))) \\<and>\n     slice_edges S cs' as = slice_edges S cs' as'' \\<and>\n     targetnode a -as'' @ as'\\<rightarrow>* m' \\<and>\n     valid_path_aux cs' (as'' @ as')", "obtain ms ms'' s'' as' ms' as'' where \"length ms = length cs'\"\n      and \"S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) \n                     =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\" \n      and paths:\"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\"\n      \"ms = targetnodes rs'\"\n      \"\\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\"\n      \"slice_edges S cs' as = slice_edges S cs' as''\"\n      \"targetnode a -as'' @ as'\\<rightarrow>* m'\" \"valid_path_aux cs' (as'' @ as')\""], ["proof (prove)\nusing this:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (targetnode a #\n                          ms,transfer (kind a)\n                              s) =slice_edges S cs'\n                                   as\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs' \\<and>\n     length ms = length cs' \\<and>\n     (\\<forall>i<length cs'.\n         call_of_return_node (ms ! i) (sourcenode (cs' ! i))) \\<and>\n     slice_edges S cs' as = slice_edges S cs' as'' \\<and>\n     targetnode a -as'' @ as'\\<rightarrow>* m' \\<and>\n     valid_path_aux cs' (as'' @ as')\n\ngoal (1 subgoal):\n 1. (\\<And>ms ms'' s'' as' ms' as''.\n        \\<lbrakk>length ms = length cs';\n         S,kind \\<turnstile> (targetnode a #\n                              ms,transfer (kind a)\n                                  s) =slice_edges S cs'\n as\\<Rightarrow>* (ms'',s'');\n         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                  ms',s');\n         ms = targetnodes rs';\n         \\<forall>i<length cs'.\n            call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n         slice_edges S cs' as = slice_edges S cs' as'';\n         targetnode a -as'' @ as'\\<rightarrow>* m';\n         valid_path_aux cs' (as'' @ as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length ms = length cs'\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes rs'\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  slice_edges S cs' as = slice_edges S cs' as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux cs' (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\\<close>\n      \\<open>length ms = length cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  length ms = length cs'", "have \"\\<forall>mx \\<in> set ms. return_node mx\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  length ms = length cs'\n\ngoal (1 subgoal):\n 1. Ball (set ms) return_node", "by(auto simp:in_set_conv_nth call_of_return_node_def)"], ["proof (state)\nthis:\n  Ball (set ms) return_node\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>valid_edge a\\<close> \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"return_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. return_node (targetnode a)", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>valid_edge c'\\<close> \\<open>valid_edge a\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  valid_edge a\n  a \\<in> get_return_edges c'\n  return_node (targetnode a)", "have \"call_of_return_node (targetnode a) (sourcenode c')\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  valid_edge a\n  a \\<in> get_return_edges c'\n  return_node (targetnode a)\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a) (sourcenode c')", "by(simp add:call_of_return_node_def) blast"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a) (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m s rs.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m s rs.\n           \\<lbrakk>m -as\\<rightarrow>* m'; preds (kinds as) s;\n            transfers (kinds as) s = s'; valid_call_list cs' m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i);\n            valid_return_list rs m; length rs = length cs';\n            length s = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                                S,kind \\<turnstile> (m #\n               ms,s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'') \\<and>\n                                S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                   ms',s') \\<and>\n                                ms = targetnodes rs \\<and>\n                                length ms = length cs' \\<and>\n                                (\\<forall>i<length cs'.\n                                    call_of_return_node (ms ! i)\n                                     (sourcenode (cs' ! i))) \\<and>\n                                slice_edges S cs' as =\n                                slice_edges S cs' as'' \\<and>\n                                m -as'' @ as'\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs' (as'' @ as');\n        m -a # as\\<rightarrow>* m'; preds (kinds (a # as)) s;\n        transfers (kinds (a # as)) s = s'; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs;\n        length s = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "proof(cases \"(\\<forall>m \\<in> set (targetnode a#ms). \\<exists>m'. call_of_return_node m m' \\<and> \n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "case True"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain x where \"call_of_return_node (targetnode a) x\"\n        and \"x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>call_of_return_node (targetnode a) x;\n         x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a) x\n  x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>call_of_return_node (targetnode a) (sourcenode c')\\<close>"], ["proof (chain)\npicking this:\n  call_of_return_node (targetnode a) (sourcenode c')\n  call_of_return_node (targetnode a) x\n  x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode c' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  call_of_return_node (targetnode a) (sourcenode c')\n  call_of_return_node (targetnode a) x\n  x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode c' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  sourcenode c' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with True \\<open>\\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\\<close>\n        \\<open>length ms = length cs'\\<close> \\<open>cs = c' # cs'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  length ms = length cs'\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode c' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_edge S cs a\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  length ms = length cs'\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode c' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edge S cs a", "apply(auto simp:slice_edge_def in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' i.\n       \\<lbrakk>\\<forall>i<length cs'.\n                   call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n        length ms = length cs'; cs = c' # cs';\n        kind r' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        sourcenode c'\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>m\\<in>set ms.\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        call_of_return_node (targetnode r') m';\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        i < length cs'\\<rbrakk>\n       \\<Longrightarrow> sourcenode (cs' ! i)\n                         \\<in> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  slice_edge S cs a\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  slice_edge S cs a", "have \"slice_edges S cs (a#as) = a#slice_edges S cs' as\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = a # slice_edges S cs' as", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = a # slice_edges S cs' as\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from True \\<open>pred (kind a) s\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n        \\<open>\\<forall>mx \\<in> set ms. return_node mx\\<close> \\<open>length ms = length cs'\\<close> \n        \\<open>length s = Suc (length cs)\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>length (transfer (kind a) s) = Suc (length cs')\\<close>\n        \\<open>return_node (targetnode a)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  Ball (set ms) return_node\n  length ms = length cs'\n  length s = Suc (length cs)\n  m = sourcenode a\n  length (transfer (kind a) s) = Suc (length cs')\n  return_node (targetnode a)\n  cs = c' # cs'", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) -a\\<rightarrow> \n        (targetnode a#ms,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  Ball (set ms) return_node\n  length ms = length cs'\n  length s = Suc (length cs)\n  m = sourcenode a\n  length (transfer (kind a) s) = Suc (length cs')\n  return_node (targetnode a)\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) -a\\<rightarrow> (targetnode a #\n          ms,transfer (kind a) s)", "by(auto intro!:observable_move_return)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow> (targetnode a #\n        ms,transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>length ms = length cs'\\<close> \\<open>length s = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length ms = length cs'\n  length s = Suc (length cs)\n  cs = c' # cs'\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow> (targetnode a #\n        ms,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) =[]@[a]\\<Rightarrow>\n        (targetnode a#ms,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  length ms = length cs'\n  length s = Suc (length cs)\n  cs = c' # cs'\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow> (targetnode a #\n        ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) =[] @\n                                [a]\\<Rightarrow> (targetnode a #\n            ms,transfer (kind a) s)", "by(fastforce intro:observable_moves_snoc silent_moves_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          ms,transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) \n                     =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          ms,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) \n        =last [a]#slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =[] @\n                              [a]\\<Rightarrow> (targetnode a #\n          ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) =last [a] #\n                                slice_edges S cs'\n                                 as\\<Rightarrow>* (ms'',s'')", "by -(rule tom_Cons,auto)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last [a] #\n                              slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>slice_edges S cs (a#as) = a#slice_edges S cs' as\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = a # slice_edges S cs' as\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last [a] #\n                              slice_edges S cs' as\\<Rightarrow>* (ms'',s'')", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) =slice_edges S cs (a#as)\\<Rightarrow>* \n        (ms'',s'')\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = a # slice_edges S cs' as\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last [a] #\n                              slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) =slice_edges S cs\n                                 (a # as)\\<Rightarrow>* (ms'',s'')", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from \\<open>slice_edges S cs' as = slice_edges S cs' as''\\<close>\n        \\<open>slice_edge S cs a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs' as = slice_edges S cs' as''\n  slice_edge S cs a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'", "have \"slice_edges S cs (a#as) = slice_edges S cs (a#as'')\""], ["proof (prove)\nusing this:\n  slice_edges S cs' as = slice_edges S cs' as''\n  slice_edge S cs a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n 2. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using paths \\<open>m = sourcenode a\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n          \\<open>length ms = length cs'\\<close> \\<open>ms = targetnodes rs'\\<close> \\<open>cs = c' # cs'\\<close>\n          \\<open>slice_edges S cs (a#as) = a#slice_edges S cs' as\\<close>\n          \\<open>a \\<in> get_return_edges c'\\<close> \n          \\<open>call_of_return_node (targetnode a) (sourcenode c')\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a # as)\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes rs'\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  slice_edges S cs' as = slice_edges S cs' as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux cs' (as'' @ as')\n  m = sourcenode a\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  length ms = length cs'\n  ms = targetnodes rs'\n  cs = c' # cs'\n  slice_edges S cs (a # as) = a # slice_edges S cs' as\n  a \\<in> get_return_edges c'\n  call_of_return_node (targetnode a) (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"targetnode a#ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; cs = c' # cs';\n     slice_edges S cs (a # as) = a # slice_edges S cs' as;\n     a \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; cs = c' # cs';\n     slice_edges S cs (a # as) = a # slice_edges S cs' as;\n     a \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; cs = c' # cs';\n     slice_edges S cs (a # as) = a # slice_edges S cs' as;\n     a \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; cs = c' # cs';\n     slice_edges S cs (a # as) = a # slice_edges S cs' as;\n     a \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; cs = c' # cs';\n     slice_edges S cs (a # as) = a # slice_edges S cs' as;\n     a \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a; valid_edge a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; cs = c' # cs';\n     slice_edges S cs (a # as) = a # slice_edges S cs' as;\n     a \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     targetnode a #\n     ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n         ms',s') \\<and>\n                      targetnode a # ms = targetnodes rs \\<and>\n                      length (targetnode a # ms) = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node ((targetnode a # ms) ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) =\n                      slice_edges S cs (a # as'') \\<and>\n                      m -(a # as'') @ as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ((a # as'') @ as')", "apply(auto intro:Cons_path simp:targetnodes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>S,kind \\<turnstile> (sourcenode r' #\n                                     targetnode r' #\n                                     map targetnode\nrs',s) =r' # slice_edges S cs' as''\\<Rightarrow>* (ms'',s'');\n        slice_edges S (c' # cs') (r' # as) = r' # slice_edges S cs' as'';\n        S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                 ms',s');\n        \\<forall>i<length cs'.\n           call_of_return_node (targetnode (rs' ! i))\n            (sourcenode (cs' ! i));\n        slice_edges S cs' as = slice_edges S cs' as'';\n        targetnode r' -as'' @ as'\\<rightarrow>* m';\n        valid_path_aux cs' (as'' @ as'); m = sourcenode r'; valid_edge r';\n        kind r' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        length rs' = length cs'; ms = map targetnode rs'; cs = c' # cs';\n        slice_edges S (c' # cs') (r' # as'') = r' # slice_edges S cs' as'';\n        r' \\<in> get_return_edges c';\n        call_of_return_node (targetnode r') (sourcenode c');\n        i < Suc (length cs')\\<rbrakk>\n       \\<Longrightarrow> call_of_return_node\n                          ((targetnode r' # map targetnode rs') ! i)\n                          (sourcenode ((c' # cs') ! i))", "by(case_tac i) auto"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n             \\<exists>m'.\n                call_of_return_node m m' \\<and>\n                m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>\\<forall>mx \\<in> set ms. return_node mx\\<close> \\<open>return_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms) return_node\n  return_node (targetnode a)\n  \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n             \\<exists>m'.\n                call_of_return_node m m' \\<and>\n                m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"\\<exists>m \\<in> set (targetnode a # ms). \\<exists>m'. call_of_return_node m m' \\<and> \n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  Ball (set ms) return_node\n  return_node (targetnode a)\n  \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n             \\<exists>m'.\n                call_of_return_node m m' \\<and>\n                m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (targetnode a # ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce dest:return_node_call_of_return_node)"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>\\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\\<close>\n        \\<open>length ms = length cs'\\<close> \\<open>cs = c' # cs'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n        \\<open>call_of_return_node (targetnode a) (sourcenode c')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  length ms = length cs'\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  call_of_return_node (targetnode a) (sourcenode c')\n  \\<exists>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<not> slice_edge S cs a\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  length ms = length cs'\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  call_of_return_node (targetnode a) (sourcenode c')\n  \\<exists>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> slice_edge S cs a", "apply(auto simp:slice_edge_def in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' i.\n       \\<lbrakk>\\<forall>i<length cs'.\n                   call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n        length ms = length cs'; cs = c' # cs';\n        kind r' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        call_of_return_node (targetnode r') (sourcenode c');\n        sourcenode c'\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        call_of_return_node (ms ! i) m';\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        i < length cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>set cs'.\n                            sourcenode c\n                            \\<notin> \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(erule_tac x=\"i\" in allE) auto"], ["proof (state)\nthis:\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  \\<not> slice_edge S cs a", "have \"slice_edges S cs (a#as) = slice_edges S cs' as\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  \\<not> slice_edge S cs a\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs' as", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs' as\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from \\<open>pred (kind a) s\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n        \\<open>\\<forall>mx \\<in> set ms. return_node mx\\<close> \\<open>length ms = length cs'\\<close> \n        \\<open>length s = Suc (length cs)\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>length (transfer (kind a) s) = Suc (length cs')\\<close>\n        \\<open>return_node (targetnode a)\\<close> \\<open>cs = c' # cs'\\<close>\n        \\<open>\\<exists>m \\<in> set (targetnode a # ms). \\<exists>m'. call_of_return_node m m' \\<and> \n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  pred (kind a) s\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  Ball (set ms) return_node\n  length ms = length cs'\n  length s = Suc (length cs)\n  m = sourcenode a\n  length (transfer (kind a) s) = Suc (length cs')\n  return_node (targetnode a)\n  cs = c' # cs'\n  \\<exists>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) -a\\<rightarrow>\\<^sub>\\<tau>\n        (targetnode a#ms,transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  pred (kind a) s\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  Ball (set ms) return_node\n  length ms = length cs'\n  length s = Suc (length cs)\n  m = sourcenode a\n  length (transfer (kind a) s) = Suc (length cs')\n  return_node (targetnode a)\n  cs = c' # cs'\n  \\<exists>m\\<in>set (targetnode a # ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                       ms,transfer (kind a) s)", "by(auto intro!:silent_move_return)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m\\<in>set (targetnode a # ms).\n               \\<exists>m'.\n                  call_of_return_node m m' \\<and>\n                  m' \\<in> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (targetnode a # ms,transfer (kind a) s) \n                     =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (targetnode a #\n                       ms,transfer (kind a)\n                           s) =slice_edges S cs' as\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "proof(rule trans_observable_moves.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "fix msx sx S' f'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "assume \"targetnode a # ms = msx\"\n          and \"transfer (kind a) s = sx\" and \"slice_edges S cs' as = []\"\n          and [simp]:\"ms'' = msx\" \"s'' = sx\" and \"length msx = length sx\""], ["proof (state)\nthis:\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  slice_edges S cs' as = []\n  ms'' = msx\n  s'' = sx\n  length msx = length sx\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>slice_edges S cs (a#as) = slice_edges S cs' as\\<close> \n          \\<open>slice_edges S cs' as = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = slice_edges S cs' as\n  slice_edges S cs' as = []", "have \"slice_edges S cs (a#as) = []\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = slice_edges S cs' as\n  slice_edges S cs' as = []\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = []\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>length ms = length cs'\\<close> \\<open>length s = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length ms = length cs'\n  length s = Suc (length cs)\n  cs = c' # cs'\n  slice_edges S cs (a # as) = []", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) =slice_edges S cs (a#as)\\<Rightarrow>*\n                        (sourcenode a#targetnode a#ms,s)\""], ["proof (prove)\nusing this:\n  length ms = length cs'\n  length s = Suc (length cs)\n  cs = c' # cs'\n  slice_edges S cs (a # as) = []\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) =slice_edges S cs\n                                 (a #\n                                  as)\\<Rightarrow>* (sourcenode a #\n               targetnode a # ms,s)", "by(fastforce intro:tom_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a #\n                                as)\\<Rightarrow>* (sourcenode a #\n             targetnode a # ms,s)\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a #\n                                as)\\<Rightarrow>* (sourcenode a #\n             targetnode a # ms,s)\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close> \\<open>targetnode a # ms = msx\\<close>\n          \\<open>transfer (kind a) s = sx\\<close> \\<open>ms'' = msx\\<close> \\<open>s'' = sx\\<close>\n          \\<open>S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) -a\\<rightarrow>\\<^sub>\\<tau> \n          (targetnode a#ms,transfer (kind a) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  ms'' = msx\n  s'' = sx\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) =a#as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  ms'' = msx\n  s'' = sx\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) =a #\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')", "by(auto intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from this \\<open>valid_edge a\\<close> \n          \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n          \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close>\n          \\<open>length s = Suc (length cs)\\<close> \\<open>m = sourcenode a\\<close>\n          \\<open>ms = targetnodes rs'\\<close> \\<open>rs = r'#rs'\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_edge a\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n  m = sourcenode a\n  ms = targetnodes rs'\n  rs = r' # rs'\n  cs = c' # cs'", "have \"sourcenode a -a#as'\\<rightarrow>* m'\" and \"valid_path_aux cs (a#as')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_edge a\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  length s = Suc (length cs)\n  m = sourcenode a\n  ms = targetnodes rs'\n  rs = r' # rs'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* m' &&& valid_path_aux cs (a # as')", "by -(rule silent_moves_vpa_path,(fastforce simp:targetnodes_def)+)+"], ["proof (state)\nthis:\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n\ngoal (2 subgoals):\n 1. \\<And>msa s Sa f.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = []; ms'' = msa;\n        s'' = s; length msa = length s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')\n 2. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a #\n                                as)\\<Rightarrow>* (sourcenode a #\n             targetnode a # ms,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a #\n                                as)\\<Rightarrow>* (sourcenode a #\n             targetnode a # ms,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using \\<open>m = sourcenode a\\<close> \\<open>length ms = length cs'\\<close>\n          \\<open>\\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\\<close>\n          \\<open>slice_edges S cs (a#as) = []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n          \\<open>S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) =a#as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\\<close>\n          \\<open>ms = targetnodes rs'\\<close> \\<open>rs = r'#rs'\\<close> \\<open>cs = c' # cs'\\<close>\n          \\<open>call_of_return_node (targetnode a) (sourcenode c')\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =slice_edges S cs\n                               (a #\n                                as)\\<Rightarrow>* (sourcenode a #\n             targetnode a # ms,s)\n  sourcenode a -a # as'\\<rightarrow>* m'\n  valid_path_aux cs (a # as')\n  m = sourcenode a\n  length ms = length cs'\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  slice_edges S cs (a # as) = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  ms = targetnodes rs'\n  rs = r' # rs'\n  cs = c' # cs'\n  call_of_return_node (targetnode a) (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"targetnode a#ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # targetnode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     S,kind \\<turnstile> (sourcenode a #\n                          targetnode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs'; rs = r' # rs'; cs = c' # cs';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"sourcenode a#targetnode a#ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # targetnode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     S,kind \\<turnstile> (sourcenode a #\n                          targetnode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs'; rs = r' # rs'; cs = c' # cs';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs\n                (a #\n                 as)\\<Rightarrow>* (sourcenode a #\n                                    targetnode a # ms,s'') \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        targetnode a #\n        ms,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # targetnode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     S,kind \\<turnstile> (sourcenode a #\n                          targetnode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs'; rs = r' # rs'; cs = c' # cs';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs\n                (a #\n                 as)\\<Rightarrow>* (sourcenode a #\n                                    targetnode a # ms,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        targetnode a #\n        ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # targetnode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     S,kind \\<turnstile> (sourcenode a #\n                          targetnode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs'; rs = r' # rs'; cs = c' # cs';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs\n                (a #\n                 as)\\<Rightarrow>* (sourcenode a #\n                                    targetnode a # ms,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        targetnode a #\n        ms,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ a # as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ a # as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # targetnode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     S,kind \\<turnstile> (sourcenode a #\n                          targetnode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs'; rs = r' # rs'; cs = c' # cs';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs\n                (a #\n                 as)\\<Rightarrow>* (sourcenode a #\n                                    targetnode a # ms,s) \\<and>\n                         S,kind \\<turnstile> (sourcenode a #\n        targetnode a #\n        ms,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ a # as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ a # as')", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =slice_edges S cs\n    (a # as)\\<Rightarrow>* (sourcenode a # targetnode a # ms,s);\n     sourcenode a -a # as'\\<rightarrow>* m'; valid_path_aux cs (a # as');\n     m = sourcenode a; length ms = length cs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs (a # as) = [];\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     S,kind \\<turnstile> (sourcenode a #\n                          targetnode a #\n                          ms,s) =a #\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          ms',s');\n     ms = targetnodes rs'; rs = r' # rs'; cs = c' # cs';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     targetnode a #\n     ms,s) =slice_edges S cs\n             (a #\n              as)\\<Rightarrow>* (sourcenode a # targetnode a # ms,s) \\<and>\n                      S,kind \\<turnstile> (sourcenode a #\n     targetnode a #\n     ms,s) =a # as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n                      targetnode a # ms = targetnodes rs \\<and>\n                      length (targetnode a # ms) = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node ((targetnode a # ms) ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) = slice_edges S cs [] \\<and>\n                      m -[] @ a # as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ([] @ a # as')", "apply(auto simp:targetnodes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>S,kind \\<turnstile> (sourcenode r' #\n                                     targetnode r' #\n                                     map targetnode\nrs',s) =[]\\<Rightarrow>* (sourcenode r' #\n                          targetnode r' # map targetnode rs',s);\n        sourcenode r' -r' # as'\\<rightarrow>* m'; m = sourcenode r';\n        length rs' = length cs';\n        \\<forall>i<length cs'.\n           call_of_return_node (targetnode (rs' ! i))\n            (sourcenode (cs' ! i));\n        slice_edges S (c' # cs') (r' # as) = [];\n        kind r' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        S,kind \\<turnstile> (sourcenode r' #\n                             targetnode r' #\n                             map targetnode\n                              rs',s) =r' #\nas'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s');\n        ms = map targetnode rs'; cs = c' # cs';\n        call_of_return_node (targetnode r') (sourcenode c');\n        r' \\<in> get_return_edges c'; valid_path_aux cs' as';\n        i < Suc (length cs')\\<rbrakk>\n       \\<Longrightarrow> call_of_return_node\n                          ((targetnode r' # map targetnode rs') ! i)\n                          (sourcenode ((c' # cs') ! i))", "by(case_tac i) auto"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "fix S' f' msx sx asx msx' sx' asx' msx'' sx''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "assume [simp]:\"S = S'\" and \"kind = f'\" and \"targetnode a # ms = msx\"\n          and \"transfer (kind a) s = sx\" \n          and \"slice_edges S cs' as = last asx # asx'\"\n          and \"ms'' = msx''\" and \"s'' = sx''\" \n          and \"S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\"\n          and \"S',f' \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\""], ["proof (state)\nthis:\n  S = S'\n  kind = f'\n  targetnode a # ms = msx\n  transfer (kind a) s = sx\n  slice_edges S cs' as = last asx # asx'\n  ms'' = msx''\n  s'' = sx''\n  S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  S',f' \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>kind = f'\\<close>"], ["proof (chain)\npicking this:\n  kind = f'", "have [simp]:\"f' = kind\""], ["proof (prove)\nusing this:\n  kind = f'\n\ngoal (1 subgoal):\n 1. f' = kind", "by simp"], ["proof (state)\nthis:\n  f' = kind\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) -a\\<rightarrow>\\<^sub>\\<tau> \n          (targetnode a#ms,transfer (kind a) s)\\<close>\n          \\<open>S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\\<close>\n          \\<open>transfer (kind a) s = sx\\<close> \\<open>targetnode a # ms = msx\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n  S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  transfer (kind a) s = sx\n  targetnode a # ms = msx", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) =a#asx\\<Rightarrow> (msx',sx')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     ms,transfer (kind a) s)\n  S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n  transfer (kind a) s = sx\n  targetnode a # ms = msx\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) =a # asx\\<Rightarrow> (msx',sx')", "by(auto intro:silent_move_observable_moves)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a # ms,s) =a # asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>S',f' \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\\<close> \\<open>ms'' = msx''\\<close> \\<open>s'' = sx''\\<close>"], ["proof (chain)\npicking this:\n  S',f' \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n  ms'' = msx''\n  s'' = sx''\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a # ms,s) =a # asx\\<Rightarrow> (msx',sx')", "have \"S,kind \\<turnstile> (sourcenode a#targetnode a#ms,s) =last (a#asx)#asx'\\<Rightarrow>* \n          (ms'',s'')\""], ["proof (prove)\nusing this:\n  S',f' \\<turnstile> (msx',sx') =asx'\\<Rightarrow>* (msx'',sx'')\n  ms'' = msx''\n  s'' = sx''\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a # ms,s) =a # asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (sourcenode a #\n                         targetnode a #\n                         ms,s) =last (a # asx) #\n                                asx'\\<Rightarrow>* (ms'',s'')", "by(fastforce intro:trans_observable_moves.tom_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\\<close>"], ["proof (chain)\npicking this:\n  S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')", "have \"asx \\<noteq> []\""], ["proof (prove)\nusing this:\n  S',f' \\<turnstile> (msx,sx) =asx\\<Rightarrow> (msx',sx')\n\ngoal (1 subgoal):\n 1. asx \\<noteq> []", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "with \\<open>slice_edges S cs (a#as) = slice_edges S cs' as\\<close>\n          \\<open>slice_edges S cs' as = last asx # asx'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs (a # as) = slice_edges S cs' as\n  slice_edges S cs' as = last asx # asx'\n  asx \\<noteq> []", "have \"slice_edges S cs (a#as) = last (a#asx)#asx'\""], ["proof (prove)\nusing this:\n  slice_edges S cs (a # as) = slice_edges S cs' as\n  slice_edges S cs' as = last asx # asx'\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = last (a # asx) # asx'", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "moreover"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "from \\<open>\\<not> slice_edge S cs a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n          \\<open>slice_edges S cs' as = slice_edges S cs' as''\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> slice_edge S cs a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  slice_edges S cs' as = slice_edges S cs' as''\n  cs = c' # cs'", "have \"slice_edges S cs (a # as) = slice_edges S cs (a # as'')\""], ["proof (prove)\nusing this:\n  \\<not> slice_edge S cs a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  slice_edges S cs' as = slice_edges S cs' as''\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<And>Sa f msa s as ms' s'a as' ms''a s''a.\n       \\<lbrakk>S = Sa; kind = f; targetnode a # ms = msa;\n        transfer (kind a) s = s; slice_edges S cs' as = last as # as';\n        ms'' = ms''a; s'' = s''a;\n        Sa,f \\<turnstile> (msa,s) =as\\<Rightarrow> (ms',s'a);\n        Sa,f \\<turnstile> (ms',s'a) =as'\\<Rightarrow>* (ms''a,s''a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms ms'' s'' as' ms' as''.\n                            S,kind \\<turnstile> (m #\n           ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                            S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n               ms',s') \\<and>\n                            ms = targetnodes rs \\<and>\n                            length ms = length cs \\<and>\n                            (\\<forall>i<length cs.\n                                call_of_return_node (ms ! i)\n                                 (sourcenode (cs ! i))) \\<and>\n                            slice_edges S cs (a # as) =\n                            slice_edges S cs as'' \\<and>\n                            m -as'' @ as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs (as'' @ as')", "ultimately"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "using paths \\<open>m = sourcenode a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n          \\<open>length ms = length cs'\\<close> \\<open>ms = targetnodes rs'\\<close> \\<open>valid_edge a\\<close>\n          \\<open>rs = r'#rs'\\<close> \\<open>cs = c' # cs'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>\n          \\<open>call_of_return_node (targetnode a) (sourcenode c')\\<close>"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (sourcenode a #\n                       targetnode a #\n                       ms,s) =last (a # asx) # asx'\\<Rightarrow>* (ms'',s'')\n  slice_edges S cs (a # as) = last (a # asx) # asx'\n  slice_edges S cs (a # as) = slice_edges S cs (a # as'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',s')\n  ms = targetnodes rs'\n  \\<forall>i<length cs'. call_of_return_node (ms ! i) (sourcenode (cs' ! i))\n  slice_edges S cs' as = slice_edges S cs' as''\n  targetnode a -as'' @ as'\\<rightarrow>* m'\n  valid_path_aux cs' (as'' @ as')\n  m = sourcenode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  length ms = length cs'\n  ms = targetnodes rs'\n  valid_edge a\n  rs = r' # rs'\n  cs = c' # cs'\n  r' \\<in> get_return_edges c'\n  call_of_return_node (targetnode a) (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<exists>ms ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> (m #\n                            ms,s) =slice_edges S cs\n                                    (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       ms = targetnodes rs \\<and>\n       length ms = length cs \\<and>\n       (\\<forall>i<length cs.\n           call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n       slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n       m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"targetnode a#ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; valid_edge a; rs = r' # rs'; cs = c' # cs';\n     r' \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms'' s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; valid_edge a; rs = r' # rs'; cs = c' # cs';\n     r' \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"s''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; valid_edge a; rs = r' # rs'; cs = c' # cs';\n     r' \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; valid_edge a; rs = r' # rs'; cs = c' # cs';\n     r' \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ms' as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"ms'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; valid_edge a; rs = r' # rs'; cs = c' # cs';\n     r' \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (m #\n        targetnode a #\n        ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n            ms',s') \\<and>\n                         targetnode a # ms = targetnodes rs \\<and>\n                         length (targetnode a # ms) = length cs \\<and>\n                         (\\<forall>i<length cs.\n                             call_of_return_node ((targetnode a # ms) ! i)\n                              (sourcenode (cs ! i))) \\<and>\n                         slice_edges S cs (a # as) =\n                         slice_edges S cs as'' \\<and>\n                         m -as'' @ as'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as'' @ as')", "apply(rule_tac x=\"a#as''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (sourcenode a #\n                                  targetnode a #\n                                  ms,s) =last (a # asx) #\n   asx'\\<Rightarrow>* (ms'',s'');\n     slice_edges S cs (a # as) = last (a # asx) # asx';\n     slice_edges S cs (a # as) = slice_edges S cs (a # as'');\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     ms = targetnodes rs';\n     \\<forall>i<length cs'.\n        call_of_return_node (ms ! i) (sourcenode (cs' ! i));\n     slice_edges S cs' as = slice_edges S cs' as'';\n     targetnode a -as'' @ as'\\<rightarrow>* m';\n     valid_path_aux cs' (as'' @ as'); m = sourcenode a;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; length ms = length cs';\n     ms = targetnodes rs'; valid_edge a; rs = r' # rs'; cs = c' # cs';\n     r' \\<in> get_return_edges c';\n     call_of_return_node (targetnode a) (sourcenode c')\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (m #\n     targetnode a #\n     ms,s) =slice_edges S cs (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n                      S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n         ms',s') \\<and>\n                      targetnode a # ms = targetnodes rs \\<and>\n                      length (targetnode a # ms) = length cs \\<and>\n                      (\\<forall>i<length cs.\n                          call_of_return_node ((targetnode a # ms) ! i)\n                           (sourcenode (cs ! i))) \\<and>\n                      slice_edges S cs (a # as) =\n                      slice_edges S cs (a # as'') \\<and>\n                      m -(a # as'') @ as'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs ((a # as'') @ as')", "apply(auto intro:Cons_path simp:targetnodes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>S',kind \\<turnstile> (sourcenode r' #\ntargetnode r' #\nmap targetnode\n rs',s) =slice_edges S' (c' # cs') (r' # as'')\\<Rightarrow>* (ms'',s'');\n        slice_edges S' (c' # cs') (r' # as) =\n        slice_edges S' (c' # cs') (r' # as'');\n        (if asx = [] then r' else last asx) # asx' =\n        slice_edges S' (c' # cs') (r' # as'');\n        S',kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                  ms',s');\n        \\<forall>i<length cs'.\n           call_of_return_node (targetnode (rs' ! i))\n            (sourcenode (cs' ! i));\n        slice_edges S' cs' as = slice_edges S' cs' as'';\n        targetnode r' -as'' @ as'\\<rightarrow>* m';\n        valid_path_aux cs' (as'' @ as'); m = sourcenode r';\n        kind r' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        length rs' = length cs'; ms = map targetnode rs'; valid_edge r';\n        cs = c' # cs'; r' \\<in> get_return_edges c';\n        call_of_return_node (targetnode r') (sourcenode c');\n        i < Suc (length cs')\\<rbrakk>\n       \\<Longrightarrow> call_of_return_node\n                          ((targetnode r' # map targetnode rs') ! i)\n                          (sourcenode ((c' # cs') ! i))", "by(case_tac i) auto"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  (a # as)\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs (a # as) = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> (m #\n                          ms,s) =slice_edges S cs\n                                  as\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     ms = targetnodes rs \\<and>\n     length ms = length cs \\<and>\n     (\\<forall>i<length cs.\n         call_of_return_node (ms ! i) (sourcenode (cs ! i))) \\<and>\n     slice_edges S cs as = slice_edges S cs as'' \\<and>\n     m -as'' @ as'\\<rightarrow>* m' \\<and> valid_path_aux cs (as'' @ as')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_path_trans_observable_moves:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\" and \"preds (kinds as) [cf]\" \n  and \"transfers (kinds as) [cf] = s'\"\n  obtains ms'' s'' ms' as' as'' \n  where \"S,kind \\<turnstile> ([m],[cf]) =slice_edges S [] as\\<Rightarrow>* (ms'',s'')\"\n  and \"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\"\n  and \"slice_edges S [] as = slice_edges S [] as''\"\n  and \"m -as''@as'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ms'' s'' as' ms' as''.\n        \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n            as\\<Rightarrow>* (ms'',s'');\n         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                  ms',s');\n         slice_edges S [] as = slice_edges S [] as'';\n         m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n  as\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       slice_edges S [] as = slice_edges S [] as'' \\<and>\n       m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'", "have \"valid_path_aux [] as\" and \"m -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (1 subgoal):\n 1. valid_path_aux [] as &&& m -as\\<rightarrow>* m'", "by(simp_all add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  valid_path_aux [] as\n  m -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<exists>ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n  as\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       slice_edges S [] as = slice_edges S [] as'' \\<and>\n       m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from this \\<open>preds (kinds as) [cf]\\<close> \\<open>transfers (kinds as) [cf] = s'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux [] as\n  m -as\\<rightarrow>* m'\n  preds (kinds as) [cf]\n  transfers (kinds as) [cf] = s'", "show \"\\<exists>ms'' s'' as' ms' as''. \n    S,kind \\<turnstile> ([m],[cf]) =slice_edges S [] as\\<Rightarrow>* (ms'',s'') \\<and>\n    S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s') \\<and>\n    slice_edges S [] as = slice_edges S [] as'' \\<and> m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\nusing this:\n  valid_path_aux [] as\n  m -as\\<rightarrow>* m'\n  preds (kinds as) [cf]\n  transfers (kinds as) [cf] = s'\n\ngoal (1 subgoal):\n 1. \\<exists>ms'' s'' as' ms' as''.\n       S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n  as\\<Rightarrow>* (ms'',s'') \\<and>\n       S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                ms',s') \\<and>\n       slice_edges S [] as = slice_edges S [] as'' \\<and>\n       m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'", "by -(erule vpa_trans_observable_moves[of _ _ _ _ _ _ \"[]\" S],\n      auto simp:valid_call_list_def valid_return_list_def vp_def valid_path_def)"], ["proof (state)\nthis:\n  \\<exists>ms'' s'' as' ms' as''.\n     S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\nas\\<Rightarrow>* (ms'',s'') \\<and>\n     S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s') \\<and>\n     slice_edges S [] as = slice_edges S [] as'' \\<and>\n     m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WS_weak_sim_trans:\n  assumes \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  and \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\" and \"as \\<noteq> []\"\n  shows \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)) \\<in> WS S \\<and> \n         S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers\n (slice_kinds S as) s\\<^sub>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers\n (slice_kinds S as) s\\<^sub>2)", "obtain f where \"f = kind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. f = kind \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  f = kind\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers\n (slice_kinds S as) s\\<^sub>2)", "with \\<open>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\n  f = kind", "have \"S,f \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\n  f = kind\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers\n (slice_kinds S as) s\\<^sub>2)", "from \\<open>S,f \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\\<close> \\<open>((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close> \n    \\<open>as \\<noteq> []\\<close> \\<open>f = kind\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  as \\<noteq> []\n  f = kind", "show ?thesis"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (ms\\<^sub>1',s\\<^sub>1')\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  as \\<noteq> []\n  f = kind\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers\n (slice_kinds S as) s\\<^sub>2)", "proof(induct arbitrary:ms\\<^sub>2 s\\<^sub>2 rule:trans_observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S f ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>length ms = length s;\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S; [] \\<noteq> [];\n        f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms, s), ms,\n                          transfers (slice_kinds S []) s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (ms,transfers\n             (slice_kinds S []) s\\<^sub>2)\n 2. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "case tom_Nil"], ["proof (state)\nthis:\n  length ms_ = length s_\n  ((ms_, s_), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S_\n  [] \\<noteq> []\n  f_ = kind\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>length ms = length s;\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S; [] \\<noteq> [];\n        f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms, s), ms,\n                          transfers (slice_kinds S []) s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (ms,transfers\n             (slice_kinds S []) s\\<^sub>2)\n 2. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  length ms_ = length s_\n  ((ms_, s_), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S_\n  [] \\<noteq> []\n  f_ = kind\n\ngoal (1 subgoal):\n 1. ((ms_, s_), ms_, transfers (slice_kinds S_ []) s\\<^sub>2)\n    \\<in> WS S_ \\<and>\n    S_,slice_kind\n        S_ \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (ms_,transfers\n                                 (slice_kinds S_ []) s\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  ((ms_, s_), ms_, transfers (slice_kinds S_ []) s\\<^sub>2)\n  \\<in> WS S_ \\<and>\n  S_,slice_kind\n      S_ \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (ms_,transfers\n                               (slice_kinds S_ []) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "case (tom_Cons S f ms s as ms' s' as' ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n  S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\n  \\<lbrakk>((ms', s'), ?ms\\<^sub>2, ?s\\<^sub>2) \\<in> WS S; as' \\<noteq> [];\n   f = kind\\<rbrakk>\n  \\<Longrightarrow> ((ms'', s''), ms'',\n                     transfers (slice_kinds S as') ?s\\<^sub>2)\n                    \\<in> WS S \\<and>\n                    S,slice_kind\n                       S \\<turnstile> (?ms\\<^sub>2,?s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n             (slice_kinds S as') ?s\\<^sub>2)\n  ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  last as # as' \\<noteq> []\n  f = kind\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "note IH = \\<open>\\<And>ms\\<^sub>2 s\\<^sub>2. \\<lbrakk>((ms',s'),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S; as' \\<noteq> []; f = kind\\<rbrakk>\n      \\<Longrightarrow> ((ms'',s''),(ms'',transfers (slice_kinds S as') s\\<^sub>2)) \\<in> WS S \\<and>\n      S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers (slice_kinds S as') s\\<^sub>2)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>((ms', s'), ?ms\\<^sub>2, ?s\\<^sub>2) \\<in> WS S; as' \\<noteq> [];\n   f = kind\\<rbrakk>\n  \\<Longrightarrow> ((ms'', s''), ms'',\n                     transfers (slice_kinds S as') ?s\\<^sub>2)\n                    \\<in> WS S \\<and>\n                    S,slice_kind\n                       S \\<turnstile> (?ms\\<^sub>2,?s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n             (slice_kinds S as') ?s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')", "have \"s' \\<noteq> []\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n\ngoal (1 subgoal):\n 1. s' \\<noteq> []", "by(fastforce elim:observable_moves.cases observable_move.cases)"], ["proof (state)\nthis:\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')", "obtain asx ax msx sx where \"S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\"\n      and \"S,f \\<turnstile> (msx,sx) -ax\\<rightarrow> (ms',s')\" and \"as = asx@[ax]\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>asx msx sx ax.\n        \\<lbrakk>S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx);\n         S,f \\<turnstile> (msx,sx) -ax\\<rightarrow> (ms',s');\n         as = asx @ [ax]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,f \\<turnstile> (msx,sx) -ax\\<rightarrow> (ms',s')\n  as = asx @ [ax]\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "from \\<open>S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\\<close> \\<open>((ms,s),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close> \\<open>f = kind\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  f = kind", "have \"((msx,sx),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (msx,sx)\n  ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  f = kind\n\ngoal (1 subgoal):\n 1. ((msx, sx), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by(fastforce intro:WS_silent_moves)"], ["proof (state)\nthis:\n  ((msx, sx), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "from \\<open>((msx,sx),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close> \\<open>S,f \\<turnstile> (msx,sx) -ax\\<rightarrow> (ms',s')\\<close> \\<open>s' \\<noteq> []\\<close>\n      \\<open>f = kind\\<close>"], ["proof (chain)\npicking this:\n  ((msx, sx), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  S,f \\<turnstile> (msx,sx) -ax\\<rightarrow> (ms',s')\n  s' \\<noteq> []\n  f = kind", "obtain asx' where \"((ms',s'),(ms',transfer (slice_kind S ax) s\\<^sub>2)) \\<in> WS S\"\n      and \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx'@[ax]\\<Rightarrow> \n      (ms',transfer (slice_kind S ax) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ((msx, sx), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  S,f \\<turnstile> (msx,sx) -ax\\<rightarrow> (ms',s')\n  s' \\<noteq> []\n  f = kind\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>((ms', s'), ms', transfer (slice_kind S ax) s\\<^sub>2)\n                 \\<in> WS S;\n         S,slice_kind\n            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx' @\n             [ax]\\<Rightarrow> (ms',transfer (slice_kind S ax)\n                                     s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:WS_observable_move)"], ["proof (state)\nthis:\n  ((ms', s'), ms', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx' @\n      [ax]\\<Rightarrow> (ms',transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' as' ms'' s'' ms\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n        S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'');\n        \\<And>ms\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((ms'', s''), ms'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                    (slice_kinds S as') s\\<^sub>2);\n        ((ms, s), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((ms'', s''), ms'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n                             as'\\<Rightarrow>* (ms'',transfers\n                (slice_kinds S (last as # as')) s\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "with \\<open>S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\n  as' = []", "have \"ms' = ms'' \\<and> s' = s''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms',s') =as'\\<Rightarrow>* (ms'',s'')\n  as' = []\n\ngoal (1 subgoal):\n 1. ms' = ms'' \\<and> s' = s''", "by(fastforce elim:trans_observable_moves.cases dest:observable_move_notempty)"], ["proof (state)\nthis:\n  ms' = ms'' \\<and> s' = s''\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "from \\<open>((ms',s'),(ms',transfer (slice_kind S ax) s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  ((ms', s'), ms', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S", "have \"length ms' = length (transfer (slice_kind S ax) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ((ms', s'), ms', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. length ms' = length (transfer (slice_kind S ax) s\\<^sub>2)", "by(fastforce elim:WS.cases)"], ["proof (state)\nthis:\n  length ms' = length (transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx'@[ax]\\<Rightarrow> \n        (ms',transfer (slice_kind S ax) s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx' @\n      [ax]\\<Rightarrow> (ms',transfer (slice_kind S ax) s\\<^sub>2)\n  length ms' = length (transfer (slice_kind S ax) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =(last (asx'@[ax]))#[]\\<Rightarrow>* \n        (ms',transfer (slice_kind S ax) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx' @\n      [ax]\\<Rightarrow> (ms',transfer (slice_kind S ax) s\\<^sub>2)\n  length ms' = length (transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[last\n          (asx' @\n           [ax])]\\<Rightarrow>* (ms',transfer (slice_kind S ax) s\\<^sub>2)", "by(fastforce intro:trans_observable_moves.intros)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[last\n        (asx' @\n         [ax])]\\<Rightarrow>* (ms',transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "with \\<open>((ms',s'),(ms',transfer (slice_kind S ax) s\\<^sub>2)) \\<in> WS S\\<close> \\<open>as = asx@[ax]\\<close>\n        \\<open>ms' = ms'' \\<and> s' = s''\\<close> True"], ["proof (chain)\npicking this:\n  ((ms', s'), ms', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S\n  as = asx @ [ax]\n  ms' = ms'' \\<and> s' = s''\n  as' = []\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[last\n        (asx' @\n         [ax])]\\<Rightarrow>* (ms',transfer (slice_kind S ax) s\\<^sub>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((ms', s'), ms', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S\n  as = asx @ [ax]\n  ms' = ms'' \\<and> s' = s''\n  as' = []\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =[last\n        (asx' @\n         [ax])]\\<Rightarrow>* (ms',transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n      as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "from IH[OF \\<open>((ms',s'),(ms',transfer (slice_kind S ax) s\\<^sub>2)) \\<in> WS S\\<close> this \n        \\<open>f = kind\\<close>]"], ["proof (chain)\npicking this:\n  ((ms'', s''), ms'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (ms',transfer (slice_kind S ax)\n                          s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                         (slice_kinds S as')\n                         (transfer (slice_kind S ax) s\\<^sub>2))", "have \"((ms'',s''),(ms'',transfers (slice_kinds S as') \n        (transfer (slice_kind S ax) s\\<^sub>2))) \\<in> WS S\"\n        and \"S,slice_kind S \\<turnstile> (ms',transfer (slice_kind S ax) s\\<^sub>2) =as'\\<Rightarrow>* \n        (ms'',transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\""], ["proof (prove)\nusing this:\n  ((ms'', s''), ms'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (ms',transfer (slice_kind S ax)\n                          s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                         (slice_kinds S as')\n                         (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. ((ms'', s''), ms'',\n     transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n    \\<in> WS S &&&\n    S,slice_kind\n       S \\<turnstile> (ms',transfer (slice_kind S ax)\n                            s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                           (slice_kinds S as')\n                           (transfer (slice_kind S ax) s\\<^sub>2))", "by simp_all"], ["proof (state)\nthis:\n  ((ms'', s''), ms'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (ms',transfer (slice_kind S ax)\n                          s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                         (slice_kinds S as')\n                         (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx'@[ax]\\<Rightarrow> \n                               (ms',transfer (slice_kind S ax) s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx' @\n      [ax]\\<Rightarrow> (ms',transfer (slice_kind S ax) s\\<^sub>2)\n  ((ms'', s''), ms'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (ms',transfer (slice_kind S ax)\n                          s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                         (slice_kinds S as')\n                         (transfer (slice_kind S ax) s\\<^sub>2))", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =(last (asx'@[ax]))#as'\\<Rightarrow>* \n        (ms'',transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =asx' @\n      [ax]\\<Rightarrow> (ms',transfer (slice_kind S ax) s\\<^sub>2)\n  ((ms'', s''), ms'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (ms',transfer (slice_kind S ax)\n                          s\\<^sub>2) =as'\\<Rightarrow>* (ms'',transfers\n                         (slice_kinds S as')\n                         (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S as')\n                                 (transfer (slice_kind S ax) s\\<^sub>2))", "by(fastforce intro:trans_observable_moves.tom_Cons)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n      as'\\<Rightarrow>* (ms'',transfers (slice_kinds S as')\n                               (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "with \\<open>((ms'',s''),(ms'',transfers (slice_kinds S as') \n        (transfer (slice_kind S ax) s\\<^sub>2))) \\<in> WS S\\<close> False \\<open>as = asx@[ax]\\<close>"], ["proof (chain)\npicking this:\n  ((ms'', s''), ms'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  as' \\<noteq> []\n  as = asx @ [ax]\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n      as'\\<Rightarrow>* (ms'',transfers (slice_kinds S as')\n                               (transfer (slice_kind S ax) s\\<^sub>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((ms'', s''), ms'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  as' \\<noteq> []\n  as = asx @ [ax]\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n      as'\\<Rightarrow>* (ms'',transfers (slice_kinds S as')\n                               (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n        as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                                 s\\<^sub>2)", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n      as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((ms'', s''), ms'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =last as #\n      as'\\<Rightarrow>* (ms'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfers (slice_kinds S as) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (ms\\<^sub>1',transfers\n                                     (slice_kinds S as) s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stacks_rewrite:\n  assumes \"valid_call_list cs m\" and \"valid_return_list rs m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  shows \"\\<forall>i<length cs. call_of_return_node (ms!i) (sourcenode (cs!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length cs \\<longrightarrow>\n       call_of_return_node (ms ! i) (sourcenode (cs ! i))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length cs \\<longrightarrow>\n       call_of_return_node (ms ! i) (sourcenode (cs ! i))", "show \"i < length cs \\<longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cs \\<longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "assume \"i < length cs\""], ["proof (state)\nthis:\n  i < length cs\n\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "with \\<open>\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n  i < length cs", "have \"rs!i \\<in> get_return_edges (cs!i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n  i < length cs\n\ngoal (1 subgoal):\n 1. rs ! i \\<in> get_return_edges (cs ! i)", "by fastforce"], ["proof (state)\nthis:\n  rs ! i \\<in> get_return_edges (cs ! i)\n\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "from \\<open>valid_return_list rs m\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m", "have \"\\<forall>r \\<in> set rs. valid_edge r\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs. valid_edge r", "by(rule valid_return_list_valid_edges)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs. valid_edge r\n\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "with \\<open>i < length cs\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  i < length cs\n  length rs = length cs\n  \\<forall>r\\<in>set rs. valid_edge r", "have \"valid_edge (rs!i)\""], ["proof (prove)\nusing this:\n  i < length cs\n  length rs = length cs\n  \\<forall>r\\<in>set rs. valid_edge r\n\ngoal (1 subgoal):\n 1. valid_edge (rs ! i)", "by(simp add:all_set_conv_all_nth)"], ["proof (state)\nthis:\n  valid_edge (rs ! i)\n\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "from \\<open>valid_call_list cs m\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m", "have \"\\<forall>c \\<in> set cs. valid_edge c\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs. valid_edge c", "by(rule valid_call_list_valid_edges)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set cs. valid_edge c\n\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "with \\<open>i < length cs\\<close>"], ["proof (chain)\npicking this:\n  i < length cs\n  \\<forall>c\\<in>set cs. valid_edge c", "have \"valid_edge (cs!i)\""], ["proof (prove)\nusing this:\n  i < length cs\n  \\<forall>c\\<in>set cs. valid_edge c\n\ngoal (1 subgoal):\n 1. valid_edge (cs ! i)", "by(simp add:all_set_conv_all_nth)"], ["proof (state)\nthis:\n  valid_edge (cs ! i)\n\ngoal (1 subgoal):\n 1. i < length cs \\<Longrightarrow>\n    call_of_return_node (ms ! i) (sourcenode (cs ! i))", "with \\<open>valid_edge (rs!i)\\<close> \\<open>rs!i \\<in> get_return_edges (cs!i)\\<close> \\<open>ms = targetnodes rs\\<close>\n      \\<open>i < length cs\\<close> \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge (rs ! i)\n  rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  i < length cs\n  length rs = length cs\n  valid_edge (cs ! i)", "show \"call_of_return_node (ms ! i) (sourcenode (cs ! i))\""], ["proof (prove)\nusing this:\n  valid_edge (rs ! i)\n  rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  i < length cs\n  length rs = length cs\n  valid_edge (cs ! i)\n\ngoal (1 subgoal):\n 1. call_of_return_node (ms ! i) (sourcenode (cs ! i))", "by(fastforce simp:call_of_return_node_def return_node_def targetnodes_def)"], ["proof (state)\nthis:\n  call_of_return_node (ms ! i) (sourcenode (cs ! i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length cs \\<longrightarrow>\n  call_of_return_node (ms ! i) (sourcenode (cs ! i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_tom_preds_vp:\n  assumes \"S,slice_kind S \\<turnstile> (m#ms,s) =as\\<Rightarrow>* (m'#ms',s')\" and \"valid_node m\"\n  and \"valid_call_list cs m\" and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\"\n  and \"valid_return_list rs m\" and \"length rs = length cs\" and \"ms = targetnodes rs\"\n  and \"\\<forall>mx \\<in> set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  obtains as' cs' rs' where \"preds (slice_kinds S as') s\" \n  and \"slice_edges S cs as' = as\" and \"m -as'\\<rightarrow>* m'\" and \"valid_path_aux cs as'\" \n  and \"upd_cs cs as' = cs'\" and \"valid_node m'\" and \"valid_call_list cs' m'\" \n  and \"\\<forall>i < length rs'. rs'!i \\<in> get_return_edges (cs'!i)\"\n  and \"valid_return_list rs' m'\" and \"length rs' = length cs'\" \n  and \"ms' = targetnodes rs'\" and \"transfers (slice_kinds S as') s \\<noteq> []\"\n  and \"transfers (slice_kinds S (slice_edges S cs as')) s =\n    transfers (slice_kinds S as') s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' cs' rs'.\n        \\<lbrakk>preds (slice_kinds S as') s; slice_edges S cs as' = as;\n         m -as'\\<rightarrow>* m'; valid_path_aux cs as';\n         upd_cs cs as' = cs'; valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs'; transfers (slice_kinds S as') s \\<noteq> [];\n         transfers (slice_kinds S (slice_edges S cs as')) s =\n         transfers (slice_kinds S as') s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' cs' rs'.\n       preds (slice_kinds S as') s \\<and>\n       slice_edges S cs as' = as \\<and>\n       m -as'\\<rightarrow>* m' \\<and>\n       valid_path_aux cs as' \\<and>\n       upd_cs cs as' = cs' \\<and>\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and>\n       transfers (slice_kinds S as') s \\<noteq> [] \\<and>\n       transfers (slice_kinds S (slice_edges S cs as')) s =\n       transfers (slice_kinds S as') s", "from assms"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow>* (m' # ms',s')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show \"\\<exists>as' cs' rs'. preds (slice_kinds S as') s \\<and>\n    slice_edges S cs as' = as \\<and> m -as'\\<rightarrow>* m' \\<and> valid_path_aux cs as' \\<and>\n    upd_cs cs as' = cs' \\<and> valid_node m' \\<and> valid_call_list cs' m' \\<and>\n    (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and> valid_return_list rs' m' \\<and>\n    length rs' = length cs' \\<and> ms' = targetnodes rs' \\<and> \n    transfers (slice_kinds S as') s \\<noteq> [] \\<and> \n    transfers (slice_kinds S (slice_edges S cs as')) s =\n    transfers (slice_kinds S as') s\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow>* (m' # ms',s')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>as' cs' rs'.\n       preds (slice_kinds S as') s \\<and>\n       slice_edges S cs as' = as \\<and>\n       m -as'\\<rightarrow>* m' \\<and>\n       valid_path_aux cs as' \\<and>\n       upd_cs cs as' = cs' \\<and>\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and>\n       transfers (slice_kinds S as') s \\<noteq> [] \\<and>\n       transfers (slice_kinds S (slice_edges S cs as')) s =\n       transfers (slice_kinds S as') s", "proof(induct S \"slice_kind S\" \"m#ms\" s as \"m'#ms'\" s'\n    arbitrary:m ms cs rs rule:trans_observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "case (tom_Nil s n\\<^sub>c)"], ["proof (state)\nthis:\n  length (m' # ms') = length s\n  valid_node m'\n  valid_call_list cs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m'\n  length rs = length cs\n  ms' = targetnodes rs\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>length (m' # ms') = length s\\<close>"], ["proof (chain)\npicking this:\n  length (m' # ms') = length s", "have \"s \\<noteq> []\""], ["proof (prove)\nusing this:\n  length (m' # ms') = length s\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "by(cases s) auto"], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "have \"preds (slice_kinds S []) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preds (slice_kinds S []) s", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S []) s\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S []) s\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "have \"slice_edges S cs [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_edges S cs [] = []", "by simp"], ["proof (state)\nthis:\n  slice_edges S cs [] = []\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  slice_edges S cs [] = []\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>valid_node m'\\<close>"], ["proof (chain)\npicking this:\n  valid_node m'", "have \"m' -[]\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_node m'\n\ngoal (1 subgoal):\n 1. m' -[]\\<rightarrow>* m'", "by(fastforce intro:empty_path)"], ["proof (state)\nthis:\n  m' -[]\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  m' -[]\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "have \"valid_path_aux cs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux cs []", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs []\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  valid_path_aux cs []\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "have \"upd_cs cs [] = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs [] = cs", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [] = cs\n\ngoal (2 subgoals):\n 1. \\<And>s S cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        valid_call_list cs m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m'; length rs = length cs;\n        ms' = targetnodes rs;\n        \\<forall>mx\\<in>set ms'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' cs' rs'.\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S cs as' = [] \\<and>\n                            m' -as'\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as' \\<and>\n                            upd_cs cs as' = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as') s \\<noteq>\n                            [] \\<and>\n                            transfers (slice_kinds S (slice_edges S cs as'))\n                             s =\n                            transfers (slice_kinds S as') s\n 2. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "ultimately"], ["proof (chain)\npicking this:\n  preds (slice_kinds S []) s\n  slice_edges S cs [] = []\n  m' -[]\\<rightarrow>* m'\n  valid_path_aux cs []\n  upd_cs cs [] = cs", "show ?case"], ["proof (prove)\nusing this:\n  preds (slice_kinds S []) s\n  slice_edges S cs [] = []\n  m' -[]\\<rightarrow>* m'\n  valid_path_aux cs []\n  upd_cs cs [] = cs\n\ngoal (1 subgoal):\n 1. \\<exists>as' cs' rs'.\n       preds (slice_kinds n\\<^sub>c as') s \\<and>\n       slice_edges n\\<^sub>c cs as' = [] \\<and>\n       m' -as'\\<rightarrow>* m' \\<and>\n       valid_path_aux cs as' \\<and>\n       upd_cs cs as' = cs' \\<and>\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and>\n       transfers (slice_kinds n\\<^sub>c as') s \\<noteq> [] \\<and>\n       transfers (slice_kinds n\\<^sub>c (slice_edges n\\<^sub>c cs as')) s =\n       transfers (slice_kinds n\\<^sub>c as') s", "using \\<open>valid_call_list cs m'\\<close> \\<open>valid_return_list rs m'\\<close> \n      \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>length rs = length cs\\<close>\n      \\<open>ms' = targetnodes rs\\<close> \\<open>s \\<noteq> []\\<close> \\<open>valid_node m'\\<close>"], ["proof (prove)\nusing this:\n  preds (slice_kinds S []) s\n  slice_edges S cs [] = []\n  m' -[]\\<rightarrow>* m'\n  valid_path_aux cs []\n  upd_cs cs [] = cs\n  valid_call_list cs m'\n  valid_return_list rs m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n  ms' = targetnodes rs\n  s \\<noteq> []\n  valid_node m'\n\ngoal (1 subgoal):\n 1. \\<exists>as' cs' rs'.\n       preds (slice_kinds n\\<^sub>c as') s \\<and>\n       slice_edges n\\<^sub>c cs as' = [] \\<and>\n       m' -as'\\<rightarrow>* m' \\<and>\n       valid_path_aux cs as' \\<and>\n       upd_cs cs as' = cs' \\<and>\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and>\n       transfers (slice_kinds n\\<^sub>c as') s \\<noteq> [] \\<and>\n       transfers (slice_kinds n\\<^sub>c (slice_edges n\\<^sub>c cs as')) s =\n       transfers (slice_kinds n\\<^sub>c as') s", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preds (slice_kinds S []) s; slice_edges S cs [] = [];\n     m' -[]\\<rightarrow>* m'; valid_path_aux cs []; upd_cs cs [] = cs;\n     valid_call_list cs m'; valid_return_list rs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs; ms' = targetnodes rs; s \\<noteq> [];\n     valid_node m'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>cs' rs'.\n                         preds (slice_kinds n\\<^sub>c []) s \\<and>\n                         slice_edges n\\<^sub>c cs [] = [] \\<and>\n                         m' -[]\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs [] \\<and>\n                         upd_cs cs [] = cs' \\<and>\n                         valid_node m' \\<and>\n                         valid_call_list cs' m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges (cs' ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs' \\<and>\n                         ms' = targetnodes rs' \\<and>\n                         transfers (slice_kinds n\\<^sub>c []) s \\<noteq>\n                         [] \\<and>\n                         transfers\n                          (slice_kinds n\\<^sub>c\n                            (slice_edges n\\<^sub>c cs []))\n                          s =\n                         transfers (slice_kinds n\\<^sub>c []) s", "apply(rule_tac x=\"cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preds (slice_kinds S []) s; slice_edges S cs [] = [];\n     m' -[]\\<rightarrow>* m'; valid_path_aux cs []; upd_cs cs [] = cs;\n     valid_call_list cs m'; valid_return_list rs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs; ms' = targetnodes rs; s \\<noteq> [];\n     valid_node m'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         preds (slice_kinds n\\<^sub>c []) s \\<and>\n                         slice_edges n\\<^sub>c cs [] = [] \\<and>\n                         m' -[]\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs [] \\<and>\n                         upd_cs cs [] = cs \\<and>\n                         valid_node m' \\<and>\n                         valid_call_list cs m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs \\<and>\n                         ms' = targetnodes rs' \\<and>\n                         transfers (slice_kinds n\\<^sub>c []) s \\<noteq>\n                         [] \\<and>\n                         transfers\n                          (slice_kinds n\\<^sub>c\n                            (slice_edges n\\<^sub>c cs []))\n                          s =\n                         transfers (slice_kinds n\\<^sub>c []) s", "apply(rule_tac x=\"rs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preds (slice_kinds S []) s; slice_edges S cs [] = [];\n     m' -[]\\<rightarrow>* m'; valid_path_aux cs []; upd_cs cs [] = cs;\n     valid_call_list cs m'; valid_return_list rs m';\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs; ms' = targetnodes rs; s \\<noteq> [];\n     valid_node m'\\<rbrakk>\n    \\<Longrightarrow> preds (slice_kinds n\\<^sub>c []) s \\<and>\n                      slice_edges n\\<^sub>c cs [] = [] \\<and>\n                      m' -[]\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs [] \\<and>\n                      upd_cs cs [] = cs \\<and>\n                      valid_node m' \\<and>\n                      valid_call_list cs m' \\<and>\n                      (\\<forall>i<length rs.\n                          rs ! i \\<in> get_return_edges (cs ! i)) \\<and>\n                      valid_return_list rs m' \\<and>\n                      length rs = length cs \\<and>\n                      ms' = targetnodes rs \\<and>\n                      transfers (slice_kinds n\\<^sub>c []) s \\<noteq>\n                      [] \\<and>\n                      transfers\n                       (slice_kinds n\\<^sub>c (slice_edges n\\<^sub>c cs []))\n                       s =\n                      transfers (slice_kinds n\\<^sub>c []) s", "by(clarsimp simp:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<exists>as' cs' rs'.\n     preds (slice_kinds n\\<^sub>c as') s \\<and>\n     slice_edges n\\<^sub>c cs as' = [] \\<and>\n     m' -as'\\<rightarrow>* m' \\<and>\n     valid_path_aux cs as' \\<and>\n     upd_cs cs as' = cs' \\<and>\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and>\n     transfers (slice_kinds n\\<^sub>c as') s \\<noteq> [] \\<and>\n     transfers (slice_kinds n\\<^sub>c (slice_edges n\\<^sub>c cs as')) s =\n     transfers (slice_kinds n\\<^sub>c as') s\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "case (tom_Cons S s as msx' s' as' sx'')"], ["proof (state)\nthis:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  S,slice_kind S \\<turnstile> (msx',s') =as'\\<Rightarrow>* (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs; ?ms = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                       preds (slice_kinds S as'a) s' \\<and>\n                       slice_edges S ?cs as'a = as' \\<and>\n                       ?m -as'a\\<rightarrow>* m' \\<and>\n                       valid_path_aux ?cs as'a \\<and>\n                       upd_cs ?cs as'a = cs' \\<and>\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and>\n                       ms' = targetnodes rs' \\<and>\n                       transfers (slice_kinds S as'a) s' \\<noteq> [] \\<and>\n                       transfers (slice_kinds S (slice_edges S ?cs as'a))\n                        s' =\n                       transfers (slice_kinds S as'a) s'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "note IH = \\<open>\\<And>m ms cs rs. \\<lbrakk>msx' = m # ms; valid_node m; valid_call_list cs m;\n      \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); valid_return_list rs m;\n      length rs = length cs; ms = targetnodes rs; \n      \\<forall>mx\\<in>set ms. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n      \\<Longrightarrow> \\<exists>as'' cs' rs'. preds (slice_kinds S as'') s' \\<and>\n      slice_edges S cs as'' = as' \\<and> m -as''\\<rightarrow>* m' \\<and> valid_path_aux cs as'' \\<and>\n      upd_cs cs as'' = cs' \\<and> valid_node m' \\<and> valid_call_list cs' m' \\<and>\n      (\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n      valid_return_list rs' m' \\<and> length rs' = length cs' \\<and> ms' = targetnodes rs' \\<and>\n      transfers (slice_kinds S as'') s' \\<noteq> [] \\<and> \n      transfers (slice_kinds S (slice_edges S cs as'')) s' =\n      transfers (slice_kinds S as'') s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs; ?ms = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'' cs' rs'.\n                       preds (slice_kinds S as'') s' \\<and>\n                       slice_edges S ?cs as'' = as' \\<and>\n                       ?m -as''\\<rightarrow>* m' \\<and>\n                       valid_path_aux ?cs as'' \\<and>\n                       upd_cs ?cs as'' = cs' \\<and>\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and>\n                       ms' = targetnodes rs' \\<and>\n                       transfers (slice_kinds S as'') s' \\<noteq> [] \\<and>\n                       transfers (slice_kinds S (slice_edges S ?cs as''))\n                        s' =\n                       transfers (slice_kinds S as'') s'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "note callstack = \\<open>\\<forall>mx\\<in>set ms.\n      \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')", "obtain asx ax xs s'' where \"as = asx@[ax]\" \n      and \"S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\" \n      and \"S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax xs s''.\n        \\<lbrakk>as = asx @ [ax];\n         S,slice_kind\n            S \\<turnstile> (m #\n                            ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'');\n         S,slice_kind\n            S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  as = asx @ [ax]\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')", "obtain xs' ms'' where [simp]:\"xs = sourcenode ax#xs'\" \"msx' = targetnode ax#ms''\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n\ngoal (1 subgoal):\n 1. (\\<And>xs' ms''.\n        \\<lbrakk>xs = sourcenode ax # xs';\n         msx' = targetnode ax # ms''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) (auto elim!:observable_move.cases, cases msx', auto)"], ["proof (state)\nthis:\n  xs = sourcenode ax # xs'\n  msx' = targetnode ax # ms''\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\\<close> tom_Cons"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  S,slice_kind S \\<turnstile> (msx',s') =as'\\<Rightarrow>* (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs; ?ms = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                       preds (slice_kinds S as'a) s' \\<and>\n                       slice_edges S ?cs as'a = as' \\<and>\n                       ?m -as'a\\<rightarrow>* m' \\<and>\n                       valid_path_aux ?cs as'a \\<and>\n                       upd_cs ?cs as'a = cs' \\<and>\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and>\n                       ms' = targetnodes rs' \\<and>\n                       transfers (slice_kinds S as'a) s' \\<noteq> [] \\<and>\n                       transfers (slice_kinds S (slice_edges S ?cs as'a))\n                        s' =\n                       transfers (slice_kinds S as'a) s'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain cs'' rs'' where results:\"valid_node (targetnode ax)\"\n      \"valid_call_list cs'' (targetnode ax)\"\n      \"\\<forall>i < length rs''. rs''!i \\<in> get_return_edges (cs''!i)\"\n      \"valid_return_list rs'' (targetnode ax)\" \"length rs'' = length cs''\" \n      \"ms'' = targetnodes rs''\" and \"upd_cs cs as = cs''\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  S,slice_kind S \\<turnstile> (msx',s') =as'\\<Rightarrow>* (m' # ms',sx'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m; valid_call_list ?cs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   valid_return_list ?rs ?m; length ?rs = length ?cs; ?ms = targetnodes ?rs;\n   \\<forall>mx\\<in>set ?ms.\n      \\<exists>mx'.\n         call_of_return_node mx mx' \\<and>\n         mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                       preds (slice_kinds S as'a) s' \\<and>\n                       slice_edges S ?cs as'a = as' \\<and>\n                       ?m -as'a\\<rightarrow>* m' \\<and>\n                       valid_path_aux ?cs as'a \\<and>\n                       upd_cs ?cs as'a = cs' \\<and>\n                       valid_node m' \\<and>\n                       valid_call_list cs' m' \\<and>\n                       (\\<forall>i<length rs'.\n                           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                       valid_return_list rs' m' \\<and>\n                       length rs' = length cs' \\<and>\n                       ms' = targetnodes rs' \\<and>\n                       transfers (slice_kinds S as'a) s' \\<noteq> [] \\<and>\n                       transfers (slice_kinds S (slice_edges S ?cs as'a))\n                        s' =\n                       transfers (slice_kinds S as'a) s'\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>cs'' rs''.\n        \\<lbrakk>valid_node (targetnode ax);\n         valid_call_list cs'' (targetnode ax);\n         \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i);\n         valid_return_list rs'' (targetnode ax); length rs'' = length cs'';\n         ms'' = targetnodes rs''; upd_cs cs as = cs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:observable_moves_preserves_stack)"], ["proof (state)\nthis:\n  valid_node (targetnode ax)\n  valid_call_list cs'' (targetnode ax)\n  \\<forall>i<length rs''. rs'' ! i \\<in> get_return_edges (cs'' ! i)\n  valid_return_list rs'' (targetnode ax)\n  length rs'' = length cs''\n  ms'' = targetnodes rs''\n  upd_cs cs as = cs''\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\\<close> callstack"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<forall>a \\<in> set asx. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set asx. intra_kind (kind a)", "by simp(rule silent_moves_slice_intra_path)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  \\<forall>a\\<in>set asx. intra_kind (kind a)", "have [simp]:\"xs' = ms\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. xs' = ms", "by(fastforce dest:silent_moves_intra_path)"], ["proof (state)\nthis:\n  xs' = ms\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')", "have \"\\<forall>mx \\<in> set ms''. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set ms''.\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce dest:observable_set_stack_in_slice)"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms''.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from IH[OF \\<open>msx' = targetnode ax#ms''\\<close> results this]"], ["proof (chain)\npicking this:\n  \\<exists>as'' cs' rs'.\n     preds (slice_kinds S as'') s' \\<and>\n     slice_edges S cs'' as'' = as' \\<and>\n     targetnode ax -as''\\<rightarrow>* m' \\<and>\n     valid_path_aux cs'' as'' \\<and>\n     upd_cs cs'' as'' = cs' \\<and>\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and>\n     transfers (slice_kinds S as'') s' \\<noteq> [] \\<and>\n     transfers (slice_kinds S (slice_edges S cs'' as'')) s' =\n     transfers (slice_kinds S as'') s'", "obtain asx' cs' rs' where \"preds (slice_kinds S asx') s'\" \n      and \"slice_edges S cs'' asx' = as'\" and \"targetnode ax -asx'\\<rightarrow>* m'\"\n      and \"valid_path_aux cs'' asx'\" and \"upd_cs cs'' asx' = cs'\"\n      and \"valid_node m'\" and \"valid_call_list cs' m'\" \n      and \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n      and \"valid_return_list rs' m'\" and \"length rs' = length cs'\"\n      and \"ms' = targetnodes rs'\" and \"transfers (slice_kinds S asx') s' \\<noteq> []\"\n      and trans_eq:\"transfers (slice_kinds S (slice_edges S cs'' asx')) s' =\n      transfers (slice_kinds S asx') s'\""], ["proof (prove)\nusing this:\n  \\<exists>as'' cs' rs'.\n     preds (slice_kinds S as'') s' \\<and>\n     slice_edges S cs'' as'' = as' \\<and>\n     targetnode ax -as''\\<rightarrow>* m' \\<and>\n     valid_path_aux cs'' as'' \\<and>\n     upd_cs cs'' as'' = cs' \\<and>\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and>\n     transfers (slice_kinds S as'') s' \\<noteq> [] \\<and>\n     transfers (slice_kinds S (slice_edges S cs'' as'')) s' =\n     transfers (slice_kinds S as'') s'\n\ngoal (1 subgoal):\n 1. (\\<And>asx' cs' rs'.\n        \\<lbrakk>preds (slice_kinds S asx') s';\n         slice_edges S cs'' asx' = as';\n         targetnode ax -asx'\\<rightarrow>* m'; valid_path_aux cs'' asx';\n         upd_cs cs'' asx' = cs'; valid_node m'; valid_call_list cs' m';\n         \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n         valid_return_list rs' m'; length rs' = length cs';\n         ms' = targetnodes rs';\n         transfers (slice_kinds S asx') s' \\<noteq> [];\n         transfers (slice_kinds S (slice_edges S cs'' asx')) s' =\n         transfers (slice_kinds S asx') s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  preds (slice_kinds S asx') s'\n  slice_edges S cs'' asx' = as'\n  targetnode ax -asx'\\<rightarrow>* m'\n  valid_path_aux cs'' asx'\n  upd_cs cs'' asx' = cs'\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n  transfers (slice_kinds S asx') s' \\<noteq> []\n  transfers (slice_kinds S (slice_edges S cs'' asx')) s' =\n  transfers (slice_kinds S asx') s'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')", "have \"preds (slice_kinds S asx) s\" and \"transfers (slice_kinds S asx) s = s''\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx) s &&& transfers (slice_kinds S asx) s = s''", "by(auto intro:silent_moves_preds_transfers simp:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) s\n  transfers (slice_kinds S asx) s = s''\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')", "have \"pred (slice_kind S ax) s''\" and \"transfer (slice_kind S ax) s'' = s'\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n\ngoal (1 subgoal):\n 1. pred (slice_kind S ax) s'' &&& transfer (slice_kind S ax) s'' = s'", "by(auto elim:observable_move.cases)"], ["proof (state)\nthis:\n  pred (slice_kind S ax) s''\n  transfer (slice_kind S ax) s'' = s'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>preds (slice_kinds S asx) s\\<close> \\<open>as = asx@[ax]\\<close>\n      \\<open>transfers (slice_kinds S asx) s = s''\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S asx) s\n  as = asx @ [ax]\n  transfers (slice_kinds S asx) s = s''\n  pred (slice_kind S ax) s''\n  transfer (slice_kind S ax) s'' = s'", "have \"preds (slice_kinds S as) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S asx) s\n  as = asx @ [ax]\n  transfers (slice_kinds S asx) s = s''\n  pred (slice_kind S ax) s''\n  transfer (slice_kind S ax) s'' = s'\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S as) s", "by(simp add:preds_split slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S as) s\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>transfers (slice_kinds S asx) s = s''\\<close> \n      \\<open>transfer (slice_kind S ax) s'' = s'\\<close> \\<open>as = asx@[ax]\\<close>"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S asx) s = s''\n  transfer (slice_kind S ax) s'' = s'\n  as = asx @ [ax]", "have \"transfers (slice_kinds S as) s = s'\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S asx) s = s''\n  transfer (slice_kind S ax) s'' = s'\n  as = asx @ [ax]\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S as) s = s'", "by(simp add:transfers_split slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S as) s = s'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>preds (slice_kinds S asx') s'\\<close> \\<open>preds (slice_kinds S as) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S asx') s'\n  preds (slice_kinds S as) s\n  transfers (slice_kinds S as) s = s'", "have \"preds (slice_kinds S (as@asx')) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S asx') s'\n  preds (slice_kinds S as) s\n  transfers (slice_kinds S as) s = s'\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S (as @ asx')) s", "by(simp add:preds_split slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S (as @ asx')) s\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S (as @ asx')) s\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>valid_call_list cs m\\<close> \\<open>valid_return_list rs m\\<close>\n      \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>length rs = length cs\\<close>\n      \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  valid_return_list rs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n  ms = targetnodes rs", "have \"\\<forall>i<length cs. call_of_return_node (ms!i) (sourcenode (cs!i))\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  valid_return_list rs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))", "by(rule stacks_rewrite)"], ["proof (state)\nthis:\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\\<close> \\<open>ms = targetnodes rs\\<close>\n      \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))", "have \"slice_edges S cs as = [last as]\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length cs. call_of_return_node (ms ! i) (sourcenode (cs ! i))\n\ngoal (1 subgoal):\n 1. slice_edges S cs as = [last as]", "by(fastforce elim:observable_moves_singular_slice_edge)"], ["proof (state)\nthis:\n  slice_edges S cs as = [last as]\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>slice_edges S cs'' asx' = as'\\<close> \\<open>upd_cs cs as = cs''\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs'' asx' = as'\n  upd_cs cs as = cs''\n  slice_edges S cs as = [last as]", "have \"slice_edges S cs (as@asx') = [last as]@as'\""], ["proof (prove)\nusing this:\n  slice_edges S cs'' asx' = as'\n  upd_cs cs as = cs''\n  slice_edges S cs as = [last as]\n\ngoal (1 subgoal):\n 1. slice_edges S cs (as @ asx') = [last as] @ as'", "by(fastforce intro:slice_edges_Append)"], ["proof (state)\nthis:\n  slice_edges S cs (as @ asx') = [last as] @ as'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  slice_edges S cs (as @ asx') = [last as] @ as'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\\<close> \\<open>valid_node m\\<close>\n      \\<open>valid_call_list cs m\\<close> \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n      \\<open>valid_return_list rs m\\<close> \\<open>length rs = length cs\\<close> \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs", "have \"m -asx\\<rightarrow>* sourcenode ax\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  valid_node m\n  valid_call_list cs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_return_list rs m\n  length rs = length cs\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. m -asx\\<rightarrow>* sourcenode ax", "by(fastforce intro:silent_moves_vpa_path)"], ["proof (state)\nthis:\n  m -asx\\<rightarrow>* sourcenode ax\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')", "have \"valid_edge ax\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n\ngoal (1 subgoal):\n 1. valid_edge ax", "by(fastforce elim:observable_move.cases)"], ["proof (state)\nthis:\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "hence \"sourcenode ax -[ax]\\<rightarrow>* targetnode ax\""], ["proof (prove)\nusing this:\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. sourcenode ax -[ax]\\<rightarrow>* targetnode ax", "by(rule path_edge)"], ["proof (state)\nthis:\n  sourcenode ax -[ax]\\<rightarrow>* targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>m -asx\\<rightarrow>* sourcenode ax\\<close> \\<open>as = asx@[ax]\\<close>"], ["proof (chain)\npicking this:\n  m -asx\\<rightarrow>* sourcenode ax\n  as = asx @ [ax]\n  sourcenode ax -[ax]\\<rightarrow>* targetnode ax", "have \"m -as\\<rightarrow>* targetnode ax\""], ["proof (prove)\nusing this:\n  m -asx\\<rightarrow>* sourcenode ax\n  as = asx @ [ax]\n  sourcenode ax -[ax]\\<rightarrow>* targetnode ax\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* targetnode ax", "by(fastforce intro:path_Append)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>targetnode ax -asx'\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx'\\<rightarrow>* m'\n  m -as\\<rightarrow>* targetnode ax", "have \"m -as@asx'\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  targetnode ax -asx'\\<rightarrow>* m'\n  m -as\\<rightarrow>* targetnode ax\n\ngoal (1 subgoal):\n 1. m -as @ asx'\\<rightarrow>* m'", "by -(rule path_Append)"], ["proof (state)\nthis:\n  m -as @ asx'\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  m -as @ asx'\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>\\<forall>a \\<in> set asx. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set asx. intra_kind (kind a)", "have \"valid_path_aux cs asx\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. valid_path_aux cs asx", "by(rule valid_path_aux_intra_path)"], ["proof (state)\nthis:\n  valid_path_aux cs asx\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>\\<forall>a \\<in> set asx. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set asx. intra_kind (kind a)", "have \"upd_cs cs asx = cs\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs cs asx = cs", "by(rule upd_cs_intra_path)"], ["proof (state)\nthis:\n  upd_cs cs asx = cs\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>m -asx\\<rightarrow>* sourcenode ax\\<close> \\<open>\\<forall>a \\<in> set asx. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  m -asx\\<rightarrow>* sourcenode ax\n  \\<forall>a\\<in>set asx. intra_kind (kind a)", "have \"get_proc m = get_proc (sourcenode ax)\""], ["proof (prove)\nusing this:\n  m -asx\\<rightarrow>* sourcenode ax\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc m = get_proc (sourcenode ax)", "by(fastforce intro:intra_path_get_procs simp:intra_path_def)"], ["proof (state)\nthis:\n  get_proc m = get_proc (sourcenode ax)\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>valid_return_list rs m\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  get_proc m = get_proc (sourcenode ax)", "have \"valid_return_list rs (sourcenode ax)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  get_proc m = get_proc (sourcenode ax)\n\ngoal (1 subgoal):\n 1. valid_return_list rs (sourcenode ax)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> m\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        get_proc m = get_proc (sourcenode ax); rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode ax\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc m = get_proc (sourcenode ax); rs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode ax\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>get_proc m = get_proc (sourcenode ax); rs = cs' @ c # cs'';\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> m\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> m\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode ax\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_return_list rs (sourcenode ax)\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\\<close> \\<open>valid_edge ax\\<close> \n      \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \\<open>ms = targetnodes rs\\<close>\n      \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n  valid_edge ax\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  length rs = length cs\n  valid_return_list rs (sourcenode ax)", "have \"valid_path_aux cs [ax]\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n  valid_edge ax\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  length rs = length cs\n  valid_return_list rs (sourcenode ax)\n\ngoal (1 subgoal):\n 1. valid_path_aux cs [ax]", "by(auto intro!:observable_move_vpa_path simp del:valid_path_aux.simps)"], ["proof (state)\nthis:\n  valid_path_aux cs [ax]\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>valid_path_aux cs asx\\<close> \\<open>upd_cs cs asx = cs\\<close> \\<open>as = asx@[ax]\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux cs asx\n  upd_cs cs asx = cs\n  as = asx @ [ax]\n  valid_path_aux cs [ax]", "have \"valid_path_aux cs as\""], ["proof (prove)\nusing this:\n  valid_path_aux cs asx\n  upd_cs cs asx = cs\n  as = asx @ [ax]\n  valid_path_aux cs [ax]\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as", "by(fastforce intro:valid_path_aux_Append)"], ["proof (state)\nthis:\n  valid_path_aux cs as\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>upd_cs cs as = cs''\\<close> \\<open>valid_path_aux cs'' asx'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs as = cs''\n  valid_path_aux cs'' asx'\n  valid_path_aux cs as", "have \"valid_path_aux cs (as@asx')\""], ["proof (prove)\nusing this:\n  upd_cs cs as = cs''\n  valid_path_aux cs'' asx'\n  valid_path_aux cs as\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (as @ asx')", "by(fastforce intro:valid_path_aux_Append)"], ["proof (state)\nthis:\n  valid_path_aux cs (as @ asx')\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  valid_path_aux cs (as @ asx')\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>upd_cs cs as = cs''\\<close> \\<open>upd_cs cs'' asx' = cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs as = cs''\n  upd_cs cs'' asx' = cs'", "have \"upd_cs cs (as@asx') = cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs as = cs''\n  upd_cs cs'' asx' = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs (as @ asx') = cs'", "by(rule upd_cs_Append)"], ["proof (state)\nthis:\n  upd_cs cs (as @ asx') = cs'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  upd_cs cs (as @ asx') = cs'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>transfers (slice_kinds S as) s = s'\\<close> \n      \\<open>transfers (slice_kinds S asx') s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S as) s = s'\n  transfers (slice_kinds S asx') s' \\<noteq> []", "have \"transfers (slice_kinds S (as@asx')) s \\<noteq> []\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S as) s = s'\n  transfers (slice_kinds S asx') s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (as @ asx')) s \\<noteq> []", "by(simp add:slice_kinds_def transfers_split)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (as @ asx')) s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "moreover"], ["proof (state)\nthis:\n  transfers (slice_kinds S (as @ asx')) s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')", "have \"transfers (map (slice_kind S) as) s = s'\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n\ngoal (1 subgoal):\n 1. transfers (map (slice_kind S) as) s = s'", "by simp(rule observable_moves_preds_transfers)"], ["proof (state)\nthis:\n  transfers (map (slice_kind S) as) s = s'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\\<close> \\<open>ms = targetnodes rs\\<close>\n      \\<open>length rs = length cs\\<close> \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n      \\<open>valid_call_list cs m\\<close> \\<open>valid_return_list rs m\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_call_list cs m\n  valid_return_list rs m", "have \"slice_edges S cs as = [last as]\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (msx',s')\n  ms = targetnodes rs\n  length rs = length cs\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  valid_call_list cs m\n  valid_return_list rs m\n\ngoal (1 subgoal):\n 1. slice_edges S cs as = [last as]", "by(fastforce intro!:observable_moves_singular_slice_edge\n      [OF _ _ _ stacks_rewrite])"], ["proof (state)\nthis:\n  slice_edges S cs as = [last as]\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>S,slice_kind S \\<turnstile> (m#ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\\<close> callstack"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"s = s''\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (xs,s'')\n  \\<forall>mx\\<in>set ms.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. s = s''", "by(fastforce intro:silent_moves_slice_keeps_state)"], ["proof (state)\nthis:\n  s = s''\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n  s = s''", "have \"transfer (slice_kind S ax) s = s'\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (xs,s'') -ax\\<rightarrow> (msx',s')\n  s = s''\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S ax) s = s'", "by(fastforce elim:observable_move.cases)"], ["proof (state)\nthis:\n  transfer (slice_kind S ax) s = s'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with \\<open>slice_edges S cs as = [last as]\\<close> \\<open>as = asx@[ax]\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S cs as = [last as]\n  as = asx @ [ax]\n  transfer (slice_kind S ax) s = s'", "have \"s' = transfers (slice_kinds S (slice_edges S cs as)) s\""], ["proof (prove)\nusing this:\n  slice_edges S cs as = [last as]\n  as = asx @ [ax]\n  transfer (slice_kind S ax) s = s'\n\ngoal (1 subgoal):\n 1. s' = transfers (slice_kinds S (slice_edges S cs as)) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  s' = transfers (slice_kinds S (slice_edges S cs as)) s\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>upd_cs cs as = cs''\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs as = cs''", "have \"slice_edges S cs (as @ asx') =\n      (slice_edges S cs as)@(slice_edges S cs'' asx')\""], ["proof (prove)\nusing this:\n  upd_cs cs as = cs''\n\ngoal (1 subgoal):\n 1. slice_edges S cs (as @ asx') =\n    slice_edges S cs as @ slice_edges S cs'' asx'", "by(fastforce intro:slice_edges_Append)"], ["proof (state)\nthis:\n  slice_edges S cs (as @ asx') =\n  slice_edges S cs as @ slice_edges S cs'' asx'\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "hence trans_eq':\"transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n      transfers (slice_kinds S (slice_edges S cs'' asx'))\n        (transfers (slice_kinds S (slice_edges S cs as)) s)\""], ["proof (prove)\nusing this:\n  slice_edges S cs (as @ asx') =\n  slice_edges S cs as @ slice_edges S cs'' asx'\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n    transfers (slice_kinds S (slice_edges S cs'' asx'))\n     (transfers (slice_kinds S (slice_edges S cs as)) s)", "by(simp add:slice_kinds_def transfers_split)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n  transfers (slice_kinds S (slice_edges S cs'' asx'))\n   (transfers (slice_kinds S (slice_edges S cs as)) s)\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "from \\<open>s' = transfers (slice_kinds S (slice_edges S cs as)) s\\<close>\n      \\<open>transfers (map (slice_kind S) as) s = s'\\<close>"], ["proof (chain)\npicking this:\n  s' = transfers (slice_kinds S (slice_edges S cs as)) s\n  transfers (map (slice_kind S) as) s = s'", "have \"transfers (map (slice_kind S) (slice_edges S cs as)) s =\n      transfers (map (slice_kind S) as) s\""], ["proof (prove)\nusing this:\n  s' = transfers (slice_kinds S (slice_edges S cs as)) s\n  transfers (map (slice_kind S) as) s = s'\n\ngoal (1 subgoal):\n 1. transfers (map (slice_kind S) (slice_edges S cs as)) s =\n    transfers (map (slice_kind S) as) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (map (slice_kind S) (slice_edges S cs as)) s =\n  transfers (map (slice_kind S) as) s\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "with trans_eq trans_eq'\n      \\<open>s' = transfers (slice_kinds S (slice_edges S cs as)) s\\<close>"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S cs'' asx')) s' =\n  transfers (slice_kinds S asx') s'\n  transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n  transfers (slice_kinds S (slice_edges S cs'' asx'))\n   (transfers (slice_kinds S (slice_edges S cs as)) s)\n  s' = transfers (slice_kinds S (slice_edges S cs as)) s\n  transfers (map (slice_kind S) (slice_edges S cs as)) s =\n  transfers (map (slice_kind S) as) s", "have \"transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n       transfers (slice_kinds S (as @ asx')) s\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S cs'' asx')) s' =\n  transfers (slice_kinds S asx') s'\n  transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n  transfers (slice_kinds S (slice_edges S cs'' asx'))\n   (transfers (slice_kinds S (slice_edges S cs as)) s)\n  s' = transfers (slice_kinds S (slice_edges S cs as)) s\n  transfers (map (slice_kind S) (slice_edges S cs as)) s =\n  transfers (map (slice_kind S) as) s\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n    transfers (slice_kinds S (as @ asx')) s", "by(simp add:slice_kinds_def transfers_split)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n  transfers (slice_kinds S (as @ asx')) s\n\ngoal (1 subgoal):\n 1. \\<And>S s as ms'a s' as' s'' m ms cs rs.\n       \\<lbrakk>S,slice_kind\n                   S \\<turnstile> (m # ms,s) =as\\<Rightarrow> (ms'a,s');\n        S,slice_kind\n           S \\<turnstile> (ms'a,s') =as'\\<Rightarrow>* (m' # ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m; valid_call_list cs m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            valid_return_list rs m; length rs = length cs;\n            ms = targetnodes rs;\n            \\<forall>mx\\<in>set ms.\n               \\<exists>mx'.\n                  call_of_return_node mx mx' \\<and>\n                  mx'\n                  \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                                preds (slice_kinds S as'a) s' \\<and>\n                                slice_edges S cs as'a = as' \\<and>\n                                m -as'a\\<rightarrow>* m' \\<and>\n                                valid_path_aux cs as'a \\<and>\n                                upd_cs cs as'a = cs' \\<and>\n                                valid_node m' \\<and>\n                                valid_call_list cs' m' \\<and>\n                                (\\<forall>i<length rs'.\n                                    rs' ! i\n                                    \\<in> get_return_edges (cs' ! i)) \\<and>\n                                valid_return_list rs' m' \\<and>\n                                length rs' = length cs' \\<and>\n                                ms' = targetnodes rs' \\<and>\n                                transfers (slice_kinds S as'a) s' \\<noteq>\n                                [] \\<and>\n                                transfers\n                                 (slice_kinds S (slice_edges S cs as'a))\n                                 s' =\n                                transfers (slice_kinds S as'a) s';\n        valid_node m; valid_call_list cs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        valid_return_list rs m; length rs = length cs; ms = targetnodes rs;\n        \\<forall>mx\\<in>set ms.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx'\n              \\<in> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a cs' rs'.\n                            preds (slice_kinds S as'a) s \\<and>\n                            slice_edges S cs as'a = last as # as' \\<and>\n                            m -as'a\\<rightarrow>* m' \\<and>\n                            valid_path_aux cs as'a \\<and>\n                            upd_cs cs as'a = cs' \\<and>\n                            valid_node m' \\<and>\n                            valid_call_list cs' m' \\<and>\n                            (\\<forall>i<length rs'.\n                                rs' ! i\n                                \\<in> get_return_edges (cs' ! i)) \\<and>\n                            valid_return_list rs' m' \\<and>\n                            length rs' = length cs' \\<and>\n                            ms' = targetnodes rs' \\<and>\n                            transfers (slice_kinds S as'a) s \\<noteq>\n                            [] \\<and>\n                            transfers\n                             (slice_kinds S (slice_edges S cs as'a)) s =\n                            transfers (slice_kinds S as'a) s", "ultimately"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (as @ asx')) s\n  slice_edges S cs (as @ asx') = [last as] @ as'\n  m -as @ asx'\\<rightarrow>* m'\n  valid_path_aux cs (as @ asx')\n  upd_cs cs (as @ asx') = cs'\n  transfers (slice_kinds S (as @ asx')) s \\<noteq> []\n  transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n  transfers (slice_kinds S (as @ asx')) s", "show ?case"], ["proof (prove)\nusing this:\n  preds (slice_kinds S (as @ asx')) s\n  slice_edges S cs (as @ asx') = [last as] @ as'\n  m -as @ asx'\\<rightarrow>* m'\n  valid_path_aux cs (as @ asx')\n  upd_cs cs (as @ asx') = cs'\n  transfers (slice_kinds S (as @ asx')) s \\<noteq> []\n  transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n  transfers (slice_kinds S (as @ asx')) s\n\ngoal (1 subgoal):\n 1. \\<exists>as'a cs' rs'.\n       preds (slice_kinds S as'a) s \\<and>\n       slice_edges S cs as'a = last as # as' \\<and>\n       m -as'a\\<rightarrow>* m' \\<and>\n       valid_path_aux cs as'a \\<and>\n       upd_cs cs as'a = cs' \\<and>\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and>\n       transfers (slice_kinds S as'a) s \\<noteq> [] \\<and>\n       transfers (slice_kinds S (slice_edges S cs as'a)) s =\n       transfers (slice_kinds S as'a) s", "using \\<open>valid_node m'\\<close> \\<open>valid_call_list cs' m'\\<close> \n        \\<open>\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\\<close> \n        \\<open>valid_return_list rs' m'\\<close> \\<open>length rs' = length cs'\\<close> \\<open>ms' = targetnodes rs'\\<close>"], ["proof (prove)\nusing this:\n  preds (slice_kinds S (as @ asx')) s\n  slice_edges S cs (as @ asx') = [last as] @ as'\n  m -as @ asx'\\<rightarrow>* m'\n  valid_path_aux cs (as @ asx')\n  upd_cs cs (as @ asx') = cs'\n  transfers (slice_kinds S (as @ asx')) s \\<noteq> []\n  transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n  transfers (slice_kinds S (as @ asx')) s\n  valid_node m'\n  valid_call_list cs' m'\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  valid_return_list rs' m'\n  length rs' = length cs'\n  ms' = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<exists>as'a cs' rs'.\n       preds (slice_kinds S as'a) s \\<and>\n       slice_edges S cs as'a = last as # as' \\<and>\n       m -as'a\\<rightarrow>* m' \\<and>\n       valid_path_aux cs as'a \\<and>\n       upd_cs cs as'a = cs' \\<and>\n       valid_node m' \\<and>\n       valid_call_list cs' m' \\<and>\n       (\\<forall>i<length rs'.\n           rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n       valid_return_list rs' m' \\<and>\n       length rs' = length cs' \\<and>\n       ms' = targetnodes rs' \\<and>\n       transfers (slice_kinds S as'a) s \\<noteq> [] \\<and>\n       transfers (slice_kinds S (slice_edges S cs as'a)) s =\n       transfers (slice_kinds S as'a) s", "apply(rule_tac x=\"as@asx'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preds (slice_kinds S (as @ asx')) s;\n     slice_edges S cs (as @ asx') = [last as] @ as';\n     m -as @ asx'\\<rightarrow>* m'; valid_path_aux cs (as @ asx');\n     upd_cs cs (as @ asx') = cs';\n     transfers (slice_kinds S (as @ asx')) s \\<noteq> [];\n     transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n     transfers (slice_kinds S (as @ asx')) s;\n     valid_node m'; valid_call_list cs' m';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     valid_return_list rs' m'; length rs' = length cs';\n     ms' = targetnodes rs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>cs' rs'.\n                         preds (slice_kinds S (as @ asx')) s \\<and>\n                         slice_edges S cs (as @ asx') = last as # as' \\<and>\n                         m -as @ asx'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as @ asx') \\<and>\n                         upd_cs cs (as @ asx') = cs' \\<and>\n                         valid_node m' \\<and>\n                         valid_call_list cs' m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges (cs' ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs' \\<and>\n                         ms' = targetnodes rs' \\<and>\n                         transfers (slice_kinds S (as @ asx')) s \\<noteq>\n                         [] \\<and>\n                         transfers\n                          (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n                         transfers (slice_kinds S (as @ asx')) s", "apply(rule_tac x=\"cs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preds (slice_kinds S (as @ asx')) s;\n     slice_edges S cs (as @ asx') = [last as] @ as';\n     m -as @ asx'\\<rightarrow>* m'; valid_path_aux cs (as @ asx');\n     upd_cs cs (as @ asx') = cs';\n     transfers (slice_kinds S (as @ asx')) s \\<noteq> [];\n     transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n     transfers (slice_kinds S (as @ asx')) s;\n     valid_node m'; valid_call_list cs' m';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     valid_return_list rs' m'; length rs' = length cs';\n     ms' = targetnodes rs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs'.\n                         preds (slice_kinds S (as @ asx')) s \\<and>\n                         slice_edges S cs (as @ asx') = last as # as' \\<and>\n                         m -as @ asx'\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (as @ asx') \\<and>\n                         upd_cs cs (as @ asx') = cs' \\<and>\n                         valid_node m' \\<and>\n                         valid_call_list cs' m' \\<and>\n                         (\\<forall>i<length rs'.\n                             rs' ! i\n                             \\<in> get_return_edges (cs' ! i)) \\<and>\n                         valid_return_list rs' m' \\<and>\n                         length rs' = length cs' \\<and>\n                         ms' = targetnodes rs' \\<and>\n                         transfers (slice_kinds S (as @ asx')) s \\<noteq>\n                         [] \\<and>\n                         transfers\n                          (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n                         transfers (slice_kinds S (as @ asx')) s", "apply(rule_tac x=\"rs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preds (slice_kinds S (as @ asx')) s;\n     slice_edges S cs (as @ asx') = [last as] @ as';\n     m -as @ asx'\\<rightarrow>* m'; valid_path_aux cs (as @ asx');\n     upd_cs cs (as @ asx') = cs';\n     transfers (slice_kinds S (as @ asx')) s \\<noteq> [];\n     transfers (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n     transfers (slice_kinds S (as @ asx')) s;\n     valid_node m'; valid_call_list cs' m';\n     \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i);\n     valid_return_list rs' m'; length rs' = length cs';\n     ms' = targetnodes rs'\\<rbrakk>\n    \\<Longrightarrow> preds (slice_kinds S (as @ asx')) s \\<and>\n                      slice_edges S cs (as @ asx') = last as # as' \\<and>\n                      m -as @ asx'\\<rightarrow>* m' \\<and>\n                      valid_path_aux cs (as @ asx') \\<and>\n                      upd_cs cs (as @ asx') = cs' \\<and>\n                      valid_node m' \\<and>\n                      valid_call_list cs' m' \\<and>\n                      (\\<forall>i<length rs'.\n                          rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n                      valid_return_list rs' m' \\<and>\n                      length rs' = length cs' \\<and>\n                      ms' = targetnodes rs' \\<and>\n                      transfers (slice_kinds S (as @ asx')) s \\<noteq>\n                      [] \\<and>\n                      transfers\n                       (slice_kinds S (slice_edges S cs (as @ asx'))) s =\n                      transfers (slice_kinds S (as @ asx')) s", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>as'a cs' rs'.\n     preds (slice_kinds S as'a) s \\<and>\n     slice_edges S cs as'a = last as # as' \\<and>\n     m -as'a\\<rightarrow>* m' \\<and>\n     valid_path_aux cs as'a \\<and>\n     upd_cs cs as'a = cs' \\<and>\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and>\n     transfers (slice_kinds S as'a) s \\<noteq> [] \\<and>\n     transfers (slice_kinds S (slice_edges S cs as'a)) s =\n     transfers (slice_kinds S as'a) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as' cs' rs'.\n     preds (slice_kinds S as') s \\<and>\n     slice_edges S cs as' = as \\<and>\n     m -as'\\<rightarrow>* m' \\<and>\n     valid_path_aux cs as' \\<and>\n     upd_cs cs as' = cs' \\<and>\n     valid_node m' \\<and>\n     valid_call_list cs' m' \\<and>\n     (\\<forall>i<length rs'.\n         rs' ! i \\<in> get_return_edges (cs' ! i)) \\<and>\n     valid_return_list rs' m' \\<and>\n     length rs' = length cs' \\<and>\n     ms' = targetnodes rs' \\<and>\n     transfers (slice_kinds S as') s \\<noteq> [] \\<and>\n     transfers (slice_kinds S (slice_edges S cs as')) s =\n     transfers (slice_kinds S as') s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The fundamental property of static interprocedural slicing\\<close>"], ["", "theorem fundamental_property_of_static_slicing:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\" and \"preds (kinds as) [cf]\" and \"CFG_node m' \\<in> S\"\n  obtains as' where \"preds (slice_kinds S as') [cf]\"\n  and \"\\<forall>V \\<in> Use m'. state_val (transfers (slice_kinds S as') [cf]) V = \n                    state_val (transfers (kinds as) [cf]) V\"\n  and \"slice_edges S [] as = slice_edges S [] as'\"\n  and \"transfers (kinds as) [cf] \\<noteq> []\" and \"m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>preds (slice_kinds S as') [cf];\n         \\<forall>V\\<in>Use m'.\n            state_val (transfers (slice_kinds S as') [cf]) V =\n            state_val (transfers (kinds as) [cf]) V;\n         slice_edges S [] as = slice_edges S [] as';\n         transfers (kinds as) [cf] \\<noteq> [];\n         m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* m'\\<close> \\<open>preds (kinds as) [cf]\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n  preds (kinds as) [cf]", "obtain ms'' s'' ms' as' as''\n    where \"S,kind \\<turnstile> ([m],[cf]) =slice_edges S [] as\\<Rightarrow>* \n                              (ms'',s'')\"\n    and \"S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\"\n    and \"slice_edges S [] as = slice_edges S [] as''\"\n    and \"m -as''@as'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n  preds (kinds as) [cf]\n\ngoal (1 subgoal):\n 1. (\\<And>ms'' s'' as' ms' as''.\n        \\<lbrakk>S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n            as\\<Rightarrow>* (ms'',s'');\n         S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                                  ms',transfers (kinds as) [cf]);\n         slice_edges S [] as = slice_edges S [] as'';\n         m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:valid_path_trans_observable_moves[of _ _ _ _ _ \"S\"])"], ["proof (state)\nthis:\n  S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n                                   as\\<Rightarrow>* (ms'',s'')\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  slice_edges S [] as = slice_edges S [] as''\n  m -as'' @ as'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'", "have \"valid_node m\" and \"valid_node m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (1 subgoal):\n 1. valid_node m &&& valid_node m'", "by(auto intro:path_valid_node simp:vp_def)"], ["proof (state)\nthis:\n  valid_node m\n  valid_node m'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  CFG_node m' \\<in> S\n  valid_node m\n  valid_node m'", "have \"CFG_node m' \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  CFG_node m' \\<in> S\n  valid_node m\n  valid_node m'\n\ngoal (1 subgoal):\n 1. CFG_node m' \\<in> HRB_slice S", "by -(rule HRB_slice_refl)"], ["proof (state)\nthis:\n  CFG_node m' \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>valid_node m\\<close> \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  CFG_node m' \\<in> S", "have \"(([m],[cf]),([m],[cf])) \\<in> WS S\""], ["proof (prove)\nusing this:\n  valid_node m\n  CFG_node m' \\<in> S\n\ngoal (1 subgoal):\n 1. (([m], [cf]), [m], [cf]) \\<in> WS S", "by(fastforce intro:WSI)"], ["proof (state)\nthis:\n  (([m], [cf]), [m], [cf]) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "{"], ["proof (state)\nthis:\n  (([m], [cf]), [m], [cf]) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "assume \"V \\<in> Use m'\""], ["proof (state)\nthis:\n  V \\<in> Use m'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>valid_node m'\\<close>"], ["proof (chain)\npicking this:\n  valid_node m'\n  V \\<in> Use m'", "have \"V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node m')\""], ["proof (prove)\nusing this:\n  valid_node m'\n  V \\<in> Use m'\n\ngoal (1 subgoal):\n 1. V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node m'", "by(fastforce intro:CFG_Use_SDG_Use)"], ["proof (state)\nthis:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node m'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "moreover"], ["proof (state)\nthis:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node m'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>valid_node m'\\<close>"], ["proof (chain)\npicking this:\n  valid_node m'", "have \"parent_node (CFG_node m') -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m')\""], ["proof (prove)\nusing this:\n  valid_node m'\n\ngoal (1 subgoal):\n 1. parent_node\n     (CFG_node m') -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m')", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   (CFG_node m') -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "ultimately"], ["proof (chain)\npicking this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node m'\n  parent_node\n   (CFG_node m') -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m')", "have \"V \\<in> rv S (CFG_node m')\""], ["proof (prove)\nusing this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node m'\n  parent_node\n   (CFG_node m') -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m')\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node m')", "using \\<open>CFG_node m' \\<in> HRB_slice S\\<close> \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node m'\n  parent_node\n   (CFG_node m') -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m')\n  CFG_node m' \\<in> HRB_slice S\n  CFG_node m' \\<in> S\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node m')", "by(fastforce intro:rvI simp:sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node m')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "}"], ["proof (state)\nthis:\n  ?V2 \\<in> Use m' \\<Longrightarrow> ?V2 \\<in> rv S (CFG_node m')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "hence \"\\<forall>V \\<in> Use m'. V \\<in> rv S (CFG_node m')\""], ["proof (prove)\nusing this:\n  ?V2 \\<in> Use m' \\<Longrightarrow> ?V2 \\<in> rv S (CFG_node m')\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use m'. V \\<in> rv S (CFG_node m')", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use m'. V \\<in> rv S (CFG_node m')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "show \"\\<exists>as'. preds (slice_kinds S as') [cf] \\<and>\n    (\\<forall>V\\<in>Use m'. state_val (transfers (slice_kinds S as') [cf]) V =\n    state_val (transfers (kinds as) [cf]) V) \\<and> \n    slice_edges S [] as = slice_edges S [] as' \\<and>\n     transfers (kinds as) [cf] \\<noteq> [] \\<and> m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "proof(cases \"slice_edges S [] as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "case True"], ["proof (state)\nthis:\n  slice_edges S [] as = []\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "hence \"preds (slice_kinds S []) [cf]\" \n      and \"slice_edges S [] [] = slice_edges S [] as\""], ["proof (prove)\nusing this:\n  slice_edges S [] as = []\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S []) [cf] &&&\n    slice_edges S [] [] = slice_edges S [] as", "by(simp_all add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S []) [cf]\n  slice_edges S [] [] = slice_edges S [] as\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>S,kind \\<turnstile> ([m],[cf]) =slice_edges S [] as\\<Rightarrow>* (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n                                   as\\<Rightarrow>* (ms'',s'')\n  preds (slice_kinds S []) [cf]\n  slice_edges S [] [] = slice_edges S [] as", "have [simp]:\"ms'' = [m]\" \"s'' = [cf]\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n                                   as\\<Rightarrow>* (ms'',s'')\n  preds (slice_kinds S []) [cf]\n  slice_edges S [] [] = slice_edges S [] as\n\ngoal (1 subgoal):\n 1. ms'' = [m] &&& s'' = [cf]", "by(auto elim:trans_observable_moves.cases)"], ["proof (state)\nthis:\n  ms'' = [m]\n  s'' = [cf]\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  ms'' = [m]\n  s'' = [cf]", "have \"S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  ms'' = [m]\n  s'' = [cf]\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             ms',transfers (kinds as) [cf])", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])", "have \"m -as'\\<rightarrow>* m'\" and \"valid_path_aux [] as'\""], ["proof (prove)\nusing this:\n  valid_node m\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n\ngoal (1 subgoal):\n 1. m -as'\\<rightarrow>* m' &&& valid_path_aux [] as'", "by(auto intro:silent_moves_vpa_path[of _ _ _ _ _ _ _ _ _ \"[]\"]\n               simp:targetnodes_def valid_return_list_def)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>* m'\n  valid_path_aux [] as'\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "hence \"m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* m'\n  valid_path_aux [] as'\n\ngoal (1 subgoal):\n 1. m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "by(simp add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])", "have \"slice_edges S [] as' = []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n\ngoal (1 subgoal):\n 1. slice_edges S [] as' = []", "by(fastforce dest:silent_moves_no_slice_edges[where cs=\"[]\" and rs=\"[]\"]\n                  simp:targetnodes_def)"], ["proof (state)\nthis:\n  slice_edges S [] as' = []\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>\n      \\<open>valid_node m\\<close> \\<open>valid_node m'\\<close> \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node m\n  valid_node m'\n  CFG_node m' \\<in> S", "have returns:\"\\<forall>mx \\<in> set ms'. \n      \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node m\n  valid_node m'\n  CFG_node m' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set ms'.\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(erule silent_moves_called_node_in_slice1_nodestack_in_slice1\n        [of _ _ _ _ _ _ _ _ _ \"[]\" \"[]\"],\n        auto intro:refl_slice1 simp:targetnodes_def valid_return_list_def)"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>\n      \\<open>(([m],[cf]),([m],[cf])) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  (([m], [cf]), [m], [cf]) \\<in> WS S", "have WS:\"((m'#ms',transfers (kinds as) [cf]),([m],[cf])) \\<in> WS S\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  (([m], [cf]), [m], [cf]) \\<in> WS S\n\ngoal (1 subgoal):\n 1. ((m' # ms', transfers (kinds as) [cf]), [m], [cf]) \\<in> WS S", "by(rule WS_silent_moves)"], ["proof (state)\nthis:\n  ((m' # ms', transfers (kinds as) [cf]), [m], [cf]) \\<in> WS S\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "hence \"transfers (kinds as) [cf] \\<noteq> []\""], ["proof (prove)\nusing this:\n  ((m' # ms', transfers (kinds as) [cf]), [m], [cf]) \\<in> WS S\n\ngoal (1 subgoal):\n 1. transfers (kinds as) [cf] \\<noteq> []", "by(auto elim!:WS.cases)"], ["proof (state)\nthis:\n  transfers (kinds as) [cf] \\<noteq> []\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with WS returns \\<open>transfers (kinds as) [cf] \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ((m' # ms', transfers (kinds as) [cf]), [m], [cf]) \\<in> WS S\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  transfers (kinds as) [cf] \\<noteq> []\n  transfers (kinds as) [cf] \\<noteq> []", "have \"\\<forall>V \\<in> rv S (CFG_node m'). \n      state_val (transfers (kinds as) [cf]) V = fst cf V\""], ["proof (prove)\nusing this:\n  ((m' # ms', transfers (kinds as) [cf]), [m], [cf]) \\<in> WS S\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  transfers (kinds as) [cf] \\<noteq> []\n  transfers (kinds as) [cf] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node m').\n       state_val (transfers (kinds as) [cf]) V = fst cf V", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((m' # ms', transfers (kinds as) [cf]), [m], [cf]) \\<in> WS S;\n     \\<forall>mx\\<in>set ms'.\n        \\<exists>mx'.\n           call_of_return_node mx mx' \\<and>\n           mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     transfers (kinds as) [cf] \\<noteq> [];\n     transfers (kinds as) [cf] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>rv S (CFG_node m').\n                         state_val (transfers (kinds as) [cf]) V = fst cf V", "apply(erule WS.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ms ms'a s s' msx mx.\n       \\<lbrakk>\\<forall>mx\\<in>set ms'.\n                   \\<exists>mx'.\n                      call_of_return_node mx mx' \\<and>\n                      mx'\n                      \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        transfers (kinds as) [cf] \\<noteq> [];\n        transfers (kinds as) [cf] \\<noteq> []; m' # ms' = ms;\n        transfers (kinds as) [cf] = s; [m] = ms'a; [cf] = s';\n        Ball (set ms) valid_node; Ball (set ms'a) valid_node;\n        length ms = length s; length ms'a = length s'; s \\<noteq> [];\n        s' \\<noteq> []; ms = msx @ mx # tl ms'a;\n        get_proc mx = get_proc (hd ms'a);\n        \\<forall>m\\<in>set (tl ms'a).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>i<length ms'a. snd (s ! (length msx + i)) = snd (s' ! i);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms'a.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms'a) ! i)).\n              fst (s ! (length msx + i)) V = fst (s' ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms'a \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>rv S (CFG_node m').\n                            state_val (transfers (kinds as) [cf]) V =\n                            fst cf V", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msx mx V.\n       \\<lbrakk>\\<forall>mx\\<in>set ms'.\n                   \\<exists>mx'.\n                      call_of_return_node mx mx' \\<and>\n                      mx'\n                      \\<in> \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        m' # ms' = msx @ [mx]; valid_node m;\n        Suc (length msx) = length (transfers (kinds as) [cf]);\n        transfers (kinds as) [cf] \\<noteq> []; get_proc mx = get_proc m;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        snd (transfers (kinds as) [cf] ! length msx) = snd cf;\n        Ball (set (tl (msx @ [mx]))) return_node;\n        \\<forall>V\\<in>rv S (CFG_node mx).\n           fst (transfers (kinds as) [cf] ! length msx) V = fst cf V;\n        obs (msx @ [mx]) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        (let S' = obs_intra m\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n         in if S' = {}\n            then obs [] \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n            else (\\<lambda>nx. [nx]) ` S');\n        V \\<in> rv S (CFG_node m'); valid_node mx;\n        Ball (set msx) valid_node\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds as) [cf]) V = fst cf V", "by(case_tac msx)(auto simp:hd_conv_nth)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node m').\n     state_val (transfers (kinds as) [cf]) V = fst cf V\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>\\<forall>V \\<in> Use m'. V \\<in> rv S (CFG_node m')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use m'. V \\<in> rv S (CFG_node m')\n  \\<forall>V\\<in>rv S (CFG_node m').\n     state_val (transfers (kinds as) [cf]) V = fst cf V", "have Uses:\"\\<forall>V \\<in> Use m'. state_val (transfers (kinds as) [cf]) V = fst cf V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use m'. V \\<in> rv S (CFG_node m')\n  \\<forall>V\\<in>rv S (CFG_node m').\n     state_val (transfers (kinds as) [cf]) V = fst cf V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use m'.\n       state_val (transfers (kinds as) [cf]) V = fst cf V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use m'. state_val (transfers (kinds as) [cf]) V = fst cf V\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "have [simp]:\"ms' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms' = []", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. ms' \\<noteq> [] \\<Longrightarrow> False", "assume \"ms' \\<noteq> []\""], ["proof (state)\nthis:\n  ms' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms' \\<noteq> [] \\<Longrightarrow> False", "with \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>\n        \\<open>valid_node m\\<close> \\<open>valid_node m'\\<close> \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node m\n  valid_node m'\n  CFG_node m' \\<in> S\n  ms' \\<noteq> []", "show False"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node m\n  valid_node m'\n  CFG_node m' \\<in> S\n  ms' \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:silent_moves_nonempty_nodestack_False intro:refl_slice1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ms' = []\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  ms' = []", "have \"S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> ([m'],transfers (kinds as) [cf])\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  ms' = []\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> ([m'],transfers\n                                   (kinds as) [cf])", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> ([m'],transfers\n                                 (kinds as) [cf])\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> ([m'],transfers\n                                 (kinds as) [cf])", "have \"m -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\""], ["proof (prove)\nusing this:\n  valid_node m\n  S,kind \\<turnstile> ([m],[cf]) =as'\\<Rightarrow>\\<^sub>\\<tau> ([m'],transfers\n                                 (kinds as) [cf])\n\ngoal (1 subgoal):\n 1. m -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "by(fastforce dest:silent_moves_slp)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from this \\<open>slice_edges S [] as' = []\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  slice_edges S [] as' = []", "obtain asx where \"m -asx\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"slice_edges S [] asx = []\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  slice_edges S [] as' = []\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>m -asx\\<rightarrow>\\<^sub>\\<iota>* m';\n         slice_edges S [] asx = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule slp_to_intra_path_with_slice_edges)"], ["proof (state)\nthis:\n  m -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S [] asx = []\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>CFG_node m' \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  CFG_node m' \\<in> HRB_slice S\n  m -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S [] asx = []", "obtain asx' where \"m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\" \n      and \"preds (slice_kinds S asx') [cf]\"\n      and \"slice_edges S [] asx' = []\""], ["proof (prove)\nusing this:\n  CFG_node m' \\<in> HRB_slice S\n  m -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S [] asx = []\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>m -asx'\\<rightarrow>\\<^sub>\\<iota>* m';\n         preds (slice_kinds S asx') [cf];\n         slice_edges S [] asx' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule exists_sliced_intra_path_preds,auto simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  preds (slice_kinds S asx') [cf]\n  slice_edges S [] asx' = []\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'", "have \"m -asx'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\nusing this:\n  m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m -asx'\\<rightarrow>\\<^sub>\\<surd>* m'", "by(rule intra_path_vp)"], ["proof (state)\nthis:\n  m -asx'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from Uses \\<open>slice_edges S [] asx' = []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use m'. state_val (transfers (kinds as) [cf]) V = fst cf V\n  slice_edges S [] asx' = []", "have \"hd (transfers (slice_kinds S \n      (slice_edges S [] asx')) [cf]) = cf\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use m'. state_val (transfers (kinds as) [cf]) V = fst cf V\n  slice_edges S [] asx' = []\n\ngoal (1 subgoal):\n 1. hd (transfers (slice_kinds S (slice_edges S [] asx')) [cf]) = cf", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  hd (transfers (slice_kinds S (slice_edges S [] asx')) [cf]) = cf\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  CFG_node m' \\<in> S", "have \"transfers (slice_kinds S (slice_edges S [] asx')) [cf] = \n      transfers (slice_kinds S asx') [cf]\""], ["proof (prove)\nusing this:\n  m -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  CFG_node m' \\<in> S\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S [] asx')) [cf] =\n    transfers (slice_kinds S asx') [cf]", "by(fastforce intro:transfers_intra_slice_kinds_slice_edges simp:intra_path_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S [] asx')) [cf] =\n  transfers (slice_kinds S asx') [cf]\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>hd (transfers (slice_kinds S (slice_edges S [] asx')) [cf]) = cf\\<close>"], ["proof (chain)\npicking this:\n  hd (transfers (slice_kinds S (slice_edges S [] asx')) [cf]) = cf\n  transfers (slice_kinds S (slice_edges S [] asx')) [cf] =\n  transfers (slice_kinds S asx') [cf]", "have \"hd (transfers (slice_kinds S asx') [cf]) = cf\""], ["proof (prove)\nusing this:\n  hd (transfers (slice_kinds S (slice_edges S [] asx')) [cf]) = cf\n  transfers (slice_kinds S (slice_edges S [] asx')) [cf] =\n  transfers (slice_kinds S asx') [cf]\n\ngoal (1 subgoal):\n 1. hd (transfers (slice_kinds S asx') [cf]) = cf", "by simp"], ["proof (state)\nthis:\n  hd (transfers (slice_kinds S asx') [cf]) = cf\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with Uses"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use m'. state_val (transfers (kinds as) [cf]) V = fst cf V\n  hd (transfers (slice_kinds S asx') [cf]) = cf", "have \"\\<forall>V\\<in>Use m'. state_val (transfers (slice_kinds S asx') [cf]) V =\n      state_val (transfers (kinds as) [cf]) V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use m'. state_val (transfers (kinds as) [cf]) V = fst cf V\n  hd (transfers (slice_kinds S asx') [cf]) = cf\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use m'.\n       state_val (transfers (slice_kinds S asx') [cf]) V =\n       state_val (transfers (kinds as) [cf]) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds S asx') [cf]) V =\n     state_val (transfers (kinds as) [cf]) V\n\ngoal (2 subgoals):\n 1. slice_edges S [] as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n 2. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>m -asx'\\<rightarrow>\\<^sub>\\<surd>* m'\\<close> \\<open>preds (slice_kinds S asx') [cf]\\<close>\n      \\<open>slice_edges S [] asx' = []\\<close> \\<open>transfers (kinds as) [cf] \\<noteq> []\\<close> True"], ["proof (chain)\npicking this:\n  m -asx'\\<rightarrow>\\<^sub>\\<surd>* m'\n  preds (slice_kinds S asx') [cf]\n  slice_edges S [] asx' = []\n  transfers (kinds as) [cf] \\<noteq> []\n  slice_edges S [] as = []\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds S asx') [cf]) V =\n     state_val (transfers (kinds as) [cf]) V", "show ?thesis"], ["proof (prove)\nusing this:\n  m -asx'\\<rightarrow>\\<^sub>\\<surd>* m'\n  preds (slice_kinds S asx') [cf]\n  slice_edges S [] asx' = []\n  transfers (kinds as) [cf] \\<noteq> []\n  slice_edges S [] as = []\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds S asx') [cf]) V =\n     state_val (transfers (kinds as) [cf]) V\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (slice_kinds S as') [cf] \\<and>\n     (\\<forall>V\\<in>Use m'.\n         state_val (transfers (slice_kinds S as') [cf]) V =\n         state_val (transfers (kinds as) [cf]) V) \\<and>\n     slice_edges S [] as = slice_edges S [] as' \\<and>\n     transfers (kinds as) [cf] \\<noteq> [] \\<and>\n     m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "case False"], ["proof (state)\nthis:\n  slice_edges S [] as \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>(([m],[cf]),([m],[cf])) \\<in> WS S\\<close>\n      \\<open>S,kind \\<turnstile> ([m],[cf]) =slice_edges S [] as\\<Rightarrow>* (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  (([m], [cf]), [m], [cf]) \\<in> WS S\n  S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n                                   as\\<Rightarrow>* (ms'',s'')\n  slice_edges S [] as \\<noteq> []", "have WS:\"((ms'',s''),(ms'',transfers (slice_kinds S (slice_edges S [] as)) [cf]))\n      \\<in> WS S\"\n      and tom:\"S,slice_kind S \\<turnstile> ([m],[cf]) =slice_edges S [] as\\<Rightarrow>* \n      (ms'',transfers (slice_kinds S (slice_edges S [] as)) [cf])\""], ["proof (prove)\nusing this:\n  (([m], [cf]), [m], [cf]) \\<in> WS S\n  S,kind \\<turnstile> ([m],[cf]) =slice_edges S []\n                                   as\\<Rightarrow>* (ms'',s'')\n  slice_edges S [] as \\<noteq> []\n\ngoal (1 subgoal):\n 1. ((ms'', s''), ms'',\n     transfers (slice_kinds S (slice_edges S [] as)) [cf])\n    \\<in> WS S &&&\n    S,slice_kind\n       S \\<turnstile> ([m],[cf]) =slice_edges S []\n                                   as\\<Rightarrow>* (ms'',transfers\n                     (slice_kinds S (slice_edges S [] as)) [cf])", "by(fastforce dest:WS_weak_sim_trans)+"], ["proof (state)\nthis:\n  ((ms'', s''), ms'', transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> ([m],[cf]) =slice_edges S []\n                                 as\\<Rightarrow>* (ms'',transfers\n                   (slice_kinds S (slice_edges S [] as)) [cf])\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from WS"], ["proof (chain)\npicking this:\n  ((ms'', s''), ms'', transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S", "obtain mx msx where [simp]:\"ms'' = mx#msx\" and \"valid_node mx\""], ["proof (prove)\nusing this:\n  ((ms'', s''), ms'', transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. (\\<And>mx msx.\n        \\<lbrakk>ms'' = mx # msx; valid_node mx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule WS.cases,cases ms'',auto)"], ["proof (state)\nthis:\n  ms'' = mx # msx\n  valid_node mx\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close> WS"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  ((ms'', s''), ms'', transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S", "have WS':\"((m'#ms',transfers (kinds as) [cf]),\n      (mx#msx,transfers (slice_kinds S (slice_edges S [] as)) [cf])) \\<in> WS S\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  ((ms'', s''), ms'', transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. ((m' # ms', transfers (kinds as) [cf]), mx # msx,\n     transfers (slice_kinds S (slice_edges S [] as)) [cf])\n    \\<in> WS S", "by simp(rule WS_silent_moves)"], ["proof (state)\nthis:\n  ((m' # ms', transfers (kinds as) [cf]), mx # msx,\n   transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from tom \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> ([m],[cf]) =slice_edges S []\n                                 as\\<Rightarrow>* (ms'',transfers\n                   (slice_kinds S (slice_edges S [] as)) [cf])\n  valid_node m", "obtain asx csx rsx where \"preds (slice_kinds S asx) [cf]\"\n      and \"slice_edges S [] asx = slice_edges S [] as\"\n      and \"m -asx\\<rightarrow>\\<^sub>\\<surd>* mx\" and \"transfers (slice_kinds S asx) [cf] \\<noteq> []\"\n      and \"upd_cs [] asx = csx\" and stack:\"valid_node mx\" \"valid_call_list csx mx\" \n      \"\\<forall>i < length rsx. rsx!i \\<in> get_return_edges (csx!i)\"\n      \"valid_return_list rsx mx\" \"length rsx = length csx\" \n      \"msx = targetnodes rsx\"\n      and trans_eq:\"transfers (slice_kinds S \n      (slice_edges S [] asx)) [cf] = \n      transfers (slice_kinds S asx) [cf]\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> ([m],[cf]) =slice_edges S []\n                                 as\\<Rightarrow>* (ms'',transfers\n                   (slice_kinds S (slice_edges S [] as)) [cf])\n  valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>asx csx rsx.\n        \\<lbrakk>preds (slice_kinds S asx) [cf];\n         slice_edges S [] asx = slice_edges S [] as;\n         m -asx\\<rightarrow>\\<^sub>\\<surd>* mx;\n         transfers (slice_kinds S asx) [cf] \\<noteq> [];\n         upd_cs [] asx = csx; valid_node mx; valid_call_list csx mx;\n         \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i);\n         valid_return_list rsx mx; length rsx = length csx;\n         msx = targetnodes rsx;\n         transfers (slice_kinds S (slice_edges S [] asx)) [cf] =\n         transfers (slice_kinds S asx) [cf]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:slice_tom_preds_vp[of _ _ _ _ _ _ _ _ \"[]\" \"[]\"]\n              simp:valid_call_list_def valid_return_list_def targetnodes_def \n                   vp_def valid_path_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) [cf]\n  slice_edges S [] asx = slice_edges S [] as\n  m -asx\\<rightarrow>\\<^sub>\\<surd>* mx\n  transfers (slice_kinds S asx) [cf] \\<noteq> []\n  upd_cs [] asx = csx\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx\n  transfers (slice_kinds S (slice_edges S [] asx)) [cf] =\n  transfers (slice_kinds S asx) [cf]\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>transfers (slice_kinds S asx) [cf] \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S asx) [cf] \\<noteq> []", "obtain cf' cfs' where eq:\"transfers (slice_kinds S asx) [cf] = \n      cf'#cfs'\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S asx) [cf] \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        transfers (slice_kinds S asx) [cf] = cf' # cfs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"transfers (slice_kinds S asx) [cf]\") auto"], ["proof (state)\nthis:\n  transfers (slice_kinds S asx) [cf] = cf' # cfs'\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from WS'"], ["proof (chain)\npicking this:\n  ((m' # ms', transfers (kinds as) [cf]), mx # msx,\n   transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S", "have callstack:\"\\<forall>mx \\<in> set msx. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  ((m' # ms', transfers (kinds as) [cf]), mx # msx,\n   transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set msx.\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce elim:WS.cases)"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>\n      \\<open>valid_node m'\\<close> stack \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node m'\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx\n  CFG_node m' \\<in> S\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have callstack':\"\\<forall>mx \\<in> set ms'. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node m'\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx\n  CFG_node m' \\<in> S\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>mx\\<in>set ms'.\n       \\<exists>mx'.\n          call_of_return_node mx mx' \\<and>\n          mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp(erule silent_moves_called_node_in_slice1_nodestack_in_slice1\n        [of _ _ _ _ _ _ _ _ _ rsx csx],auto intro:refl_slice1)"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>\n      stack callstack"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"mx -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\" and \"msx = ms'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. mx -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m' &&& msx = ms'", "by(auto dest!:silent_moves_slp)"], ["proof (state)\nthis:\n  mx -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  msx = ms'\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',transfers (kinds as) [cf])\\<close>\n      stack"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx", "have \"slice_edges S csx as' = []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           ms',transfers (kinds as) [cf])\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx\n\ngoal (1 subgoal):\n 1. slice_edges S csx as' = []", "by(auto dest:silent_moves_no_slice_edges[OF _ _ _ stacks_rewrite])"], ["proof (state)\nthis:\n  slice_edges S csx as' = []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>mx -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  mx -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  slice_edges S csx as' = []", "obtain asx'' where \"mx -asx''\\<rightarrow>\\<^sub>\\<iota>* m'\"\n      and \"slice_edges S csx asx'' = []\""], ["proof (prove)\nusing this:\n  mx -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n  slice_edges S csx as' = []\n\ngoal (1 subgoal):\n 1. (\\<And>asx''.\n        \\<lbrakk>mx -asx''\\<rightarrow>\\<^sub>\\<iota>* m';\n         slice_edges S csx asx'' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule slp_to_intra_path_with_slice_edges)"], ["proof (state)\nthis:\n  mx -asx''\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S csx asx'' = []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from stack"], ["proof (chain)\npicking this:\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx", "have \"\\<forall>i<length csx. call_of_return_node (msx!i) (sourcenode (csx!i))\""], ["proof (prove)\nusing this:\n  valid_node mx\n  valid_call_list csx mx\n  \\<forall>i<length rsx. rsx ! i \\<in> get_return_edges (csx ! i)\n  valid_return_list rsx mx\n  length rsx = length csx\n  msx = targetnodes rsx\n\ngoal (1 subgoal):\n 1. \\<forall>i<length csx.\n       call_of_return_node (msx ! i) (sourcenode (csx ! i))", "by -(rule stacks_rewrite)"], ["proof (state)\nthis:\n  \\<forall>i<length csx.\n     call_of_return_node (msx ! i) (sourcenode (csx ! i))\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with callstack \\<open>msx = targetnodes rsx\\<close> \\<open>length rsx = length csx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = targetnodes rsx\n  length rsx = length csx\n  \\<forall>i<length csx.\n     call_of_return_node (msx ! i) (sourcenode (csx ! i))", "have \"\\<forall>c\\<in>set csx. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>mx\\<in>set msx.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = targetnodes rsx\n  length rsx = length csx\n  \\<forall>i<length csx.\n     call_of_return_node (msx ! i) (sourcenode (csx ! i))\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set csx.\n       sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(auto simp:all_set_conv_all_nth targetnodes_def)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set csx.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>mx -asx''\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>slice_edges S csx asx'' = []\\<close> \\<open>valid_node m'\\<close>\n      eq \\<open>CFG_node m' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  mx -asx''\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S csx asx'' = []\n  valid_node m'\n  transfers (slice_kinds S asx) [cf] = cf' # cfs'\n  CFG_node m' \\<in> S\n  \\<forall>c\\<in>set csx.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain asx' where \"mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\"\n      and \"preds (slice_kinds S asx') (cf'#cfs')\"\n      and \"slice_edges S csx asx' = []\""], ["proof (prove)\nusing this:\n  mx -asx''\\<rightarrow>\\<^sub>\\<iota>* m'\n  slice_edges S csx asx'' = []\n  valid_node m'\n  transfers (slice_kinds S asx) [cf] = cf' # cfs'\n  CFG_node m' \\<in> S\n  \\<forall>c\\<in>set csx.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m';\n         preds (slice_kinds S asx') (cf' # cfs');\n         slice_edges S csx asx' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule exists_sliced_intra_path_preds,\n        auto intro:HRB_slice_refl simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  preds (slice_kinds S asx') (cf' # cfs')\n  slice_edges S csx asx' = []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with eq"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S asx) [cf] = cf' # cfs'\n  mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  preds (slice_kinds S asx') (cf' # cfs')\n  slice_edges S csx asx' = []", "have \"preds (slice_kinds S asx') \n      (transfers (slice_kinds S asx) [cf])\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S asx) [cf] = cf' # cfs'\n  mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  preds (slice_kinds S asx') (cf' # cfs')\n  slice_edges S csx asx' = []\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])", "by simp"], ["proof (state)\nthis:\n  preds (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>preds (slice_kinds S asx) [cf]\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S asx) [cf]\n  preds (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])", "have \"preds (slice_kinds S (asx@asx')) [cf]\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S asx) [cf]\n  preds (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S (asx @ asx')) [cf]", "by(simp add:slice_kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (slice_kinds S (asx @ asx')) [cf]\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>m -asx\\<rightarrow>\\<^sub>\\<surd>* mx\\<close> \\<open>mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -asx\\<rightarrow>\\<^sub>\\<surd>* mx\n  mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'", "have \"m -asx@asx'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\nusing this:\n  m -asx\\<rightarrow>\\<^sub>\\<surd>* mx\n  mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m -asx @ asx'\\<rightarrow>\\<^sub>\\<surd>* m'", "by(fastforce elim:vp_slp_Append intra_path_slp)"], ["proof (state)\nthis:\n  m -asx @ asx'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>upd_cs [] asx = csx\\<close> \\<open>slice_edges S csx asx' = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [] asx = csx\n  slice_edges S csx asx' = []", "have \"slice_edges S [] (asx@asx') = \n      (slice_edges S [] asx)@[]\""], ["proof (prove)\nusing this:\n  upd_cs [] asx = csx\n  slice_edges S csx asx' = []\n\ngoal (1 subgoal):\n 1. slice_edges S [] (asx @ asx') = slice_edges S [] asx @ []", "by(fastforce intro:slice_edges_Append)"], ["proof (state)\nthis:\n  slice_edges S [] (asx @ asx') = slice_edges S [] asx @ []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>\\<forall>c\\<in>set csx. sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  \\<forall>c\\<in>set csx.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have trans_eq':\"transfers (slice_kinds S (slice_edges S csx asx')) \n          (transfers (slice_kinds S asx) [cf]) =\n      transfers (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])\""], ["proof (prove)\nusing this:\n  mx -asx'\\<rightarrow>\\<^sub>\\<iota>* m'\n  \\<forall>c\\<in>set csx.\n     sourcenode c \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S csx asx'))\n     (transfers (slice_kinds S asx) [cf]) =\n    transfers (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])", "by(fastforce intro:transfers_intra_slice_kinds_slice_edges simp:intra_path_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S asx) [cf]) =\n  transfers (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>upd_cs [] asx = csx\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [] asx = csx", "have \"slice_edges S [] (asx@asx') = \n      (slice_edges S [] asx)@(slice_edges S csx asx')\""], ["proof (prove)\nusing this:\n  upd_cs [] asx = csx\n\ngoal (1 subgoal):\n 1. slice_edges S [] (asx @ asx') =\n    slice_edges S [] asx @ slice_edges S csx asx'", "by(fastforce intro:slice_edges_Append)"], ["proof (state)\nthis:\n  slice_edges S [] (asx @ asx') =\n  slice_edges S [] asx @ slice_edges S csx asx'\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "hence \"transfers (slice_kinds S (slice_edges S [] (asx@asx'))) [cf] =\n      transfers (slice_kinds S (slice_edges S csx asx'))\n        (transfers (slice_kinds S (slice_edges S [] asx)) [cf])\""], ["proof (prove)\nusing this:\n  slice_edges S [] (asx @ asx') =\n  slice_edges S [] asx @ slice_edges S csx asx'\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n    transfers (slice_kinds S (slice_edges S csx asx'))\n     (transfers (slice_kinds S (slice_edges S [] asx)) [cf])", "by(simp add:slice_kinds_def transfers_split)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S (slice_edges S [] asx)) [cf])\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with trans_eq"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S [] asx)) [cf] =\n  transfers (slice_kinds S asx) [cf]\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S (slice_edges S [] asx)) [cf])", "have \"transfers (slice_kinds S (slice_edges S [] (asx@asx'))) [cf] =\n      transfers (slice_kinds S (slice_edges S csx asx'))\n        (transfers (slice_kinds S asx) [cf])\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S [] asx)) [cf] =\n  transfers (slice_kinds S asx) [cf]\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S (slice_edges S [] asx)) [cf])\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n    transfers (slice_kinds S (slice_edges S csx asx'))\n     (transfers (slice_kinds S asx) [cf])", "by simp"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S asx) [cf])\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with trans_eq'"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S asx) [cf]) =\n  transfers (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S asx) [cf])", "have trans_eq'':\n      \"transfers (slice_kinds S (slice_edges S [] (asx@asx'))) [cf] =\n      transfers (slice_kinds S (asx@asx')) [cf]\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S asx) [cf]) =\n  transfers (slice_kinds S asx') (transfers (slice_kinds S asx) [cf])\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (slice_edges S csx asx'))\n   (transfers (slice_kinds S asx) [cf])\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n    transfers (slice_kinds S (asx @ asx')) [cf]", "by(simp add:slice_kinds_def transfers_split)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (asx @ asx')) [cf]\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from WS'"], ["proof (chain)\npicking this:\n  ((m' # ms', transfers (kinds as) [cf]), mx # msx,\n   transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S", "obtain x xs where \"m'#ms' = xs@x#msx\"\n      and \"xs \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node x mx' \\<and> \n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\"\n      and rest:\"\\<forall>i < length (mx#msx). \\<forall>V \\<in> rv S (CFG_node ((x#msx)!i)). \n      (fst ((transfers (kinds as) [cf])!(length xs + i))) V = \n      (fst ((transfers (slice_kinds S \n      (slice_edges S [] as)) [cf])!i)) V\"\n      \"transfers (kinds as) [cf] \\<noteq> []\"\n      \"transfers (slice_kinds S \n      (slice_edges S [] as)) [cf] \\<noteq> []\""], ["proof (prove)\nusing this:\n  ((m' # ms', transfers (kinds as) [cf]), mx # msx,\n   transfers (slice_kinds S (slice_edges S [] as)) [cf])\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. (\\<And>xs x.\n        \\<lbrakk>m' # ms' = xs @ x # msx;\n         xs \\<noteq> [] \\<longrightarrow>\n         (\\<exists>mx'.\n             call_of_return_node x mx' \\<and>\n             mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n         \\<forall>i<length (mx # msx).\n            \\<forall>V\\<in>rv S (CFG_node ((x # msx) ! i)).\n               fst (transfers (kinds as) [cf] ! (length xs + i)) V =\n               fst (transfers (slice_kinds S (slice_edges S [] as)) [cf] !\n                    i)\n                V;\n         transfers (kinds as) [cf] \\<noteq> [];\n         transfers (slice_kinds S (slice_edges S [] as)) [cf] \\<noteq>\n         []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:WS.cases)"], ["proof (state)\nthis:\n  m' # ms' = xs @ x # msx\n  xs \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node x mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>i<length (mx # msx).\n     \\<forall>V\\<in>rv S (CFG_node ((x # msx) ! i)).\n        fst (transfers (kinds as) [cf] ! (length xs + i)) V =\n        fst (transfers (slice_kinds S (slice_edges S [] as)) [cf] ! i) V\n  transfers (kinds as) [cf] \\<noteq> []\n  transfers (slice_kinds S (slice_edges S [] as)) [cf] \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from \\<open>m'#ms' = xs@x#msx\\<close> \\<open>xs \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node x mx' \\<and> \n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close> callstack'"], ["proof (chain)\npicking this:\n  m' # ms' = xs @ x # msx\n  xs \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node x mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have [simp]:\"xs = []\" \"x = m'\" \"ms' = msx\""], ["proof (prove)\nusing this:\n  m' # ms' = xs @ x # msx\n  xs \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node x mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>mx\\<in>set ms'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. xs = [] &&& x = m' &&& ms' = msx", "by(cases xs,auto)+"], ["proof (state)\nthis:\n  xs = []\n  x = m'\n  ms' = msx\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "from rest"], ["proof (chain)\npicking this:\n  \\<forall>i<length (mx # msx).\n     \\<forall>V\\<in>rv S (CFG_node ((x # msx) ! i)).\n        fst (transfers (kinds as) [cf] ! (length xs + i)) V =\n        fst (transfers (slice_kinds S (slice_edges S [] as)) [cf] ! i) V\n  transfers (kinds as) [cf] \\<noteq> []\n  transfers (slice_kinds S (slice_edges S [] as)) [cf] \\<noteq> []", "have \"\\<forall>V \\<in> rv S (CFG_node m').\n      state_val (transfers (kinds as) [cf]) V = \n      state_val (transfers (slice_kinds S (slice_edges S [] as)) [cf]) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (mx # msx).\n     \\<forall>V\\<in>rv S (CFG_node ((x # msx) ! i)).\n        fst (transfers (kinds as) [cf] ! (length xs + i)) V =\n        fst (transfers (slice_kinds S (slice_edges S [] as)) [cf] ! i) V\n  transfers (kinds as) [cf] \\<noteq> []\n  transfers (slice_kinds S (slice_edges S [] as)) [cf] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node m').\n       state_val (transfers (kinds as) [cf]) V =\n       state_val (transfers (slice_kinds S (slice_edges S [] as)) [cf]) V", "by(fastforce dest:hd_conv_nth)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node m').\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (slice_edges S [] as)) [cf]) V\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>\\<forall>V \\<in> Use m'. V \\<in> rv S (CFG_node m')\\<close> \n      \\<open>slice_edges S [] asx = slice_edges S [] as\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use m'. V \\<in> rv S (CFG_node m')\n  slice_edges S [] asx = slice_edges S [] as\n  \\<forall>V\\<in>rv S (CFG_node m').\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (slice_edges S [] as)) [cf]) V", "have \"\\<forall>V \\<in> Use m'. state_val (transfers (kinds as) [cf]) V = \n      state_val (transfers (slice_kinds S (slice_edges S [] asx)) [cf]) V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use m'. V \\<in> rv S (CFG_node m')\n  slice_edges S [] asx = slice_edges S [] as\n  \\<forall>V\\<in>rv S (CFG_node m').\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (slice_edges S [] as)) [cf]) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use m'.\n       state_val (transfers (kinds as) [cf]) V =\n       state_val (transfers (slice_kinds S (slice_edges S [] asx)) [cf]) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (slice_edges S [] asx)) [cf]) V\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>slice_edges S [] (asx@asx') = (slice_edges S [] asx)@[]\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S [] (asx @ asx') = slice_edges S [] asx @ []\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (slice_edges S [] asx)) [cf]) V", "have \"\\<forall>V \\<in> Use m'. state_val (transfers (kinds as) [cf]) V = \n      state_val (transfers (slice_kinds S (slice_edges S [] (asx@asx'))) [cf]) V\""], ["proof (prove)\nusing this:\n  slice_edges S [] (asx @ asx') = slice_edges S [] asx @ []\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (slice_edges S [] asx)) [cf]) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use m'.\n       state_val (transfers (kinds as) [cf]) V =\n       state_val\n        (transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf]) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val\n      (transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf]) V\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with trans_eq''"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (asx @ asx')) [cf]\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val\n      (transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf]) V", "have \"\\<forall>V \\<in> Use m'. state_val (transfers (kinds as) [cf]) V = \n      state_val (transfers (slice_kinds S (asx@asx')) [cf]) V\""], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf] =\n  transfers (slice_kinds S (asx @ asx')) [cf]\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val\n      (transfers (slice_kinds S (slice_edges S [] (asx @ asx'))) [cf]) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use m'.\n       state_val (transfers (kinds as) [cf]) V =\n       state_val (transfers (slice_kinds S (asx @ asx')) [cf]) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (asx @ asx')) [cf]) V\n\ngoal (1 subgoal):\n 1. slice_edges S [] as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "with \\<open>preds (slice_kinds S (asx@asx')) [cf]\\<close>\n      \\<open>m -asx@asx'\\<rightarrow>\\<^sub>\\<surd>* m'\\<close> \\<open>slice_edges S [] (asx@asx') = \n      (slice_edges S [] asx)@[]\\<close> \\<open>transfers (kinds as) [cf] \\<noteq> []\\<close>\n      \\<open>slice_edges S [] asx = slice_edges S [] as\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (asx @ asx')) [cf]\n  m -asx @ asx'\\<rightarrow>\\<^sub>\\<surd>* m'\n  slice_edges S [] (asx @ asx') = slice_edges S [] asx @ []\n  transfers (kinds as) [cf] \\<noteq> []\n  slice_edges S [] asx = slice_edges S [] as\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (asx @ asx')) [cf]) V", "show ?thesis"], ["proof (prove)\nusing this:\n  preds (slice_kinds S (asx @ asx')) [cf]\n  m -asx @ asx'\\<rightarrow>\\<^sub>\\<surd>* m'\n  slice_edges S [] (asx @ asx') = slice_edges S [] asx @ []\n  transfers (kinds as) [cf] \\<noteq> []\n  slice_edges S [] asx = slice_edges S [] as\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (kinds as) [cf]) V =\n     state_val (transfers (slice_kinds S (asx @ asx')) [cf]) V\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') [cf] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val (transfers (slice_kinds S as') [cf]) V =\n           state_val (transfers (kinds as) [cf]) V) \\<and>\n       slice_edges S [] as = slice_edges S [] as' \\<and>\n       transfers (kinds as) [cf] \\<noteq> [] \\<and>\n       m -as'\\<rightarrow>\\<^sub>\\<surd>* m'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (slice_kinds S as') [cf] \\<and>\n     (\\<forall>V\\<in>Use m'.\n         state_val (transfers (slice_kinds S as') [cf]) V =\n         state_val (transfers (kinds as) [cf]) V) \\<and>\n     slice_edges S [] as = slice_edges S [] as' \\<and>\n     transfers (kinds as) [cf] \\<noteq> [] \\<and>\n     m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (slice_kinds S as') [cf] \\<and>\n     (\\<forall>V\\<in>Use m'.\n         state_val (transfers (slice_kinds S as') [cf]) V =\n         state_val (transfers (kinds as) [cf]) V) \\<and>\n     slice_edges S [] as = slice_edges S [] as' \\<and>\n     transfers (kinds as) [cf] \\<noteq> [] \\<and>\n     m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The fundamental property of static interprocedural slicing related to the semantics\\<close>"], ["", "locale SemanticsProperty = SDG sourcenode targetnode kind valid_edge Entry \n    get_proc get_return_edges procs Main Exit Def Use ParamDefs ParamUses +\n  CFG_semantics_wf sourcenode targetnode kind valid_edge Entry \n    get_proc get_return_edges procs Main sem identifies\n  for sourcenode :: \"'edge \\<Rightarrow> 'node\" and targetnode :: \"'edge \\<Rightarrow> 'node\"\n  and kind :: \"'edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind\" \n  and valid_edge :: \"'edge \\<Rightarrow> bool\"\n  and Entry :: \"'node\" (\"'('_Entry'_')\")  and get_proc :: \"'node \\<Rightarrow> 'pname\"\n  and get_return_edges :: \"'edge \\<Rightarrow> 'edge set\"\n  and procs :: \"('pname \\<times> 'var list \\<times> 'var list) list\" and Main :: \"'pname\"\n  and Exit::\"'node\"  (\"'('_Exit'_')\") \n  and Def :: \"'node \\<Rightarrow> 'var set\" and Use :: \"'node \\<Rightarrow> 'var set\"\n  and ParamDefs :: \"'node \\<Rightarrow> 'var list\" and ParamUses :: \"'node \\<Rightarrow> 'var set list\"\n  and sem :: \"'com \\<Rightarrow> ('var \\<rightharpoonup> 'val) list \\<Rightarrow> 'com \\<Rightarrow> ('var \\<rightharpoonup> 'val) list \\<Rightarrow> bool\" \n    (\"((1\\<langle>_,/_\\<rangle>) \\<Rightarrow>/ (1\\<langle>_,/_\\<rangle>))\" [0,0,0,0] 81)\n  and identifies :: \"'node \\<Rightarrow> 'com \\<Rightarrow> bool\" (\"_ \\<triangleq> _\" [51,0] 80)\nbegin"], ["", "theorem fundamental_property_of_path_slicing_semantically:\n  assumes \"m \\<triangleq> c\" and \"\\<langle>c,[cf]\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\"\n  obtains m' as cfs' where \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\" and \"m' \\<triangleq> c'\"\n  and \"preds (slice_kinds {CFG_node m'} as) [(cf,undefined)]\"\n  and \"\\<forall>V \\<in> Use m'. \n  state_val (transfers (slice_kinds {CFG_node m'} as) [(cf,undefined)]) V = \n  state_val cfs' V\" and \"map fst cfs' = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as m' cfs'.\n        \\<lbrakk>m -as\\<rightarrow>\\<^sub>\\<surd>* m'; m' \\<triangleq> c';\n         preds (slice_kinds {CFG_node m'} as) [(cf, undefined)];\n         \\<forall>V\\<in>Use m'.\n            state_val\n             (transfers (slice_kinds {CFG_node m'} as) [(cf, undefined)])\n             V =\n            state_val cfs' V;\n         map fst cfs' = s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as m' cfs'.\n       m -as\\<rightarrow>\\<^sub>\\<surd>* m' \\<and>\n       m' \\<triangleq> c' \\<and>\n       preds (slice_kinds {CFG_node m'} as) [(cf, undefined)] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val\n            (transfers (slice_kinds {CFG_node m'} as) [(cf, undefined)]) V =\n           state_val cfs' V) \\<and>\n       map fst cfs' = s'", "from \\<open>m \\<triangleq> c\\<close> \\<open>\\<langle>c,[cf]\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  m \\<triangleq> c\n  \\<langle>c,[cf]\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>", "obtain m' as cfs' where \"m -as\\<rightarrow>\\<^sub>\\<surd>* m'\"\n    and \"transfers (kinds as) [(cf,undefined)] = cfs'\"\n    and \"preds (kinds as) [(cf,undefined)]\" and \"m' \\<triangleq> c'\" and \"map fst cfs' = s'\""], ["proof (prove)\nusing this:\n  m \\<triangleq> c\n  \\<langle>c,[cf]\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>as m' cfs'.\n        \\<lbrakk>m -as\\<rightarrow>\\<^sub>\\<surd>* m';\n         transfers (kinds as) [(cf, undefined)] = cfs';\n         preds (kinds as) [(cf, undefined)]; m' \\<triangleq> c';\n         map fst cfs' = s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:fundamental_property)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n  transfers (kinds as) [(cf, undefined)] = cfs'\n  preds (kinds as) [(cf, undefined)]\n  m' \\<triangleq> c'\n  map fst cfs' = s'\n\ngoal (1 subgoal):\n 1. \\<exists>as m' cfs'.\n       m -as\\<rightarrow>\\<^sub>\\<surd>* m' \\<and>\n       m' \\<triangleq> c' \\<and>\n       preds (slice_kinds {CFG_node m'} as) [(cf, undefined)] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val\n            (transfers (slice_kinds {CFG_node m'} as) [(cf, undefined)]) V =\n           state_val cfs' V) \\<and>\n       map fst cfs' = s'", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* m'\\<close> \\<open>preds (kinds as) [(cf,undefined)]\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n  preds (kinds as) [(cf, undefined)]", "obtain as'\n    where \"preds (slice_kinds {CFG_node m'} as') [(cf,undefined)]\"\n    and vals:\"\\<forall>V \\<in> Use m'. state_val (transfers (slice_kinds {CFG_node m'} as') \n    [(cf,undefined)]) V = state_val (transfers (kinds as) [(cf,undefined)]) V\"\n    and \"m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* m'\n  preds (kinds as) [(cf, undefined)]\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>preds (slice_kinds {CFG_node m'} as') [(cf, undefined)];\n         \\<forall>V\\<in>Use m'.\n            state_val\n             (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)])\n             V =\n            state_val (transfers (kinds as) [(cf, undefined)]) V;\n         m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule fundamental_property_of_static_slicing,auto)"], ["proof (state)\nthis:\n  preds (slice_kinds {CFG_node m'} as') [(cf, undefined)]\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)])\n      V =\n     state_val (transfers (kinds as) [(cf, undefined)]) V\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n\ngoal (1 subgoal):\n 1. \\<exists>as m' cfs'.\n       m -as\\<rightarrow>\\<^sub>\\<surd>* m' \\<and>\n       m' \\<triangleq> c' \\<and>\n       preds (slice_kinds {CFG_node m'} as) [(cf, undefined)] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val\n            (transfers (slice_kinds {CFG_node m'} as) [(cf, undefined)]) V =\n           state_val cfs' V) \\<and>\n       map fst cfs' = s'", "from \\<open>transfers (kinds as) [(cf,undefined)] = cfs'\\<close> vals"], ["proof (chain)\npicking this:\n  transfers (kinds as) [(cf, undefined)] = cfs'\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)])\n      V =\n     state_val (transfers (kinds as) [(cf, undefined)]) V", "have \"\\<forall>V \\<in> Use m'. \n    state_val (transfers (slice_kinds {CFG_node m'} as') [(cf,undefined)]) V = \n    state_val cfs' V\""], ["proof (prove)\nusing this:\n  transfers (kinds as) [(cf, undefined)] = cfs'\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)])\n      V =\n     state_val (transfers (kinds as) [(cf, undefined)]) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use m'.\n       state_val\n        (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)]) V =\n       state_val cfs' V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)])\n      V =\n     state_val cfs' V\n\ngoal (1 subgoal):\n 1. \\<exists>as m' cfs'.\n       m -as\\<rightarrow>\\<^sub>\\<surd>* m' \\<and>\n       m' \\<triangleq> c' \\<and>\n       preds (slice_kinds {CFG_node m'} as) [(cf, undefined)] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val\n            (transfers (slice_kinds {CFG_node m'} as) [(cf, undefined)]) V =\n           state_val cfs' V) \\<and>\n       map fst cfs' = s'", "with \\<open>preds (slice_kinds {CFG_node m'} as') [(cf,undefined)]\\<close> \\<open>m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\\<close> \n    \\<open>m' \\<triangleq> c'\\<close> \\<open>map fst cfs' = s'\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds {CFG_node m'} as') [(cf, undefined)]\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n  m' \\<triangleq> c'\n  map fst cfs' = s'\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)])\n      V =\n     state_val cfs' V", "show \"\\<exists>as m' cfs'. m -as\\<rightarrow>\\<^sub>\\<surd>* m' \\<and> m' \\<triangleq> c' \\<and>\n    preds (slice_kinds {CFG_node m'} as) [(cf, undefined)] \\<and>\n    (\\<forall>V\\<in>Use m'. state_val (transfers (slice_kinds {CFG_node m'} as)\n    [(cf, undefined)]) V = state_val cfs' V) \\<and> map fst cfs' = s'\""], ["proof (prove)\nusing this:\n  preds (slice_kinds {CFG_node m'} as') [(cf, undefined)]\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* m'\n  m' \\<triangleq> c'\n  map fst cfs' = s'\n  \\<forall>V\\<in>Use m'.\n     state_val (transfers (slice_kinds {CFG_node m'} as') [(cf, undefined)])\n      V =\n     state_val cfs' V\n\ngoal (1 subgoal):\n 1. \\<exists>as m' cfs'.\n       m -as\\<rightarrow>\\<^sub>\\<surd>* m' \\<and>\n       m' \\<triangleq> c' \\<and>\n       preds (slice_kinds {CFG_node m'} as) [(cf, undefined)] \\<and>\n       (\\<forall>V\\<in>Use m'.\n           state_val\n            (transfers (slice_kinds {CFG_node m'} as) [(cf, undefined)]) V =\n           state_val cfs' V) \\<and>\n       map fst cfs' = s'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as m' cfs'.\n     m -as\\<rightarrow>\\<^sub>\\<surd>* m' \\<and>\n     m' \\<triangleq> c' \\<and>\n     preds (slice_kinds {CFG_node m'} as) [(cf, undefined)] \\<and>\n     (\\<forall>V\\<in>Use m'.\n         state_val\n          (transfers (slice_kinds {CFG_node m'} as) [(cf, undefined)]) V =\n         state_val cfs' V) \\<and>\n     map fst cfs' = s'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}