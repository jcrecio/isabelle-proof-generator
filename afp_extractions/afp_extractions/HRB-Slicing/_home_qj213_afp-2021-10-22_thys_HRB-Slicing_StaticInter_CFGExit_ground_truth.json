{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/CFGExit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma Entry_noteq_Exit [dest]:\n  assumes eq:\"(_Entry_) = (_Exit_)\" shows \"False\"", "lemma Exit_noteq_Entry [dest]:\"(_Exit_) = (_Entry_) \\<Longrightarrow> False\"", "lemma [simp]: \"valid_node (_Entry_)\"", "lemma [simp]: \"valid_node (_Exit_)\"", "lemma method_exit_cases:\n  \"\\<lbrakk>method_exit n; n = (_Exit_) \\<Longrightarrow> P;\n    \\<And>a Q f p. \\<lbrakk>n = sourcenode a; valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma method_exit_inner_path:\n  assumes \"method_exit n\" and \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" shows \"as = []\"", "lemma inner_is_valid:\n  \"inner_node n \\<Longrightarrow> valid_node n\"", "lemma [dest]:\n  \"inner_node (_Entry_) \\<Longrightarrow> False\"", "lemma [dest]:\n  \"inner_node (_Exit_) \\<Longrightarrow> False\"", "lemma [simp]:\"\\<lbrakk>valid_edge a; targetnode a \\<noteq> (_Exit_)\\<rbrakk> \n  \\<Longrightarrow> inner_node (targetnode a)\"", "lemma [simp]:\"\\<lbrakk>valid_edge a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> inner_node (sourcenode a)\"", "lemma valid_node_cases [consumes 1, case_names \"Entry\" \"Exit\" \"inner\"]:\n  \"\\<lbrakk>valid_node n; n = (_Entry_) \\<Longrightarrow> Q; n = (_Exit_) \\<Longrightarrow> Q;\n    inner_node n \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma path_Exit_source:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; n = (_Exit_)\\<rbrakk> \\<Longrightarrow> n' = (_Exit_) \\<and> as = []\"", "lemma [dest]:\"(_Exit_) -as\\<rightarrow>* n' \\<Longrightarrow> n' = (_Exit_) \\<and> as = []\"", "lemma Exit_no_sourcenode[dest]:\n  assumes isin:\"(_Exit_) \\<in> set (sourcenodes as)\" and path:\"n -as\\<rightarrow>* n'\"\n  shows False", "lemma vpa_no_slpa:\n  \"\\<lbrakk>valid_path_aux cs as; n -as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> (\\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q r fs. valid_edge a \\<and> kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\"", "lemma valid_Exit_path_cases:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" and \"as \\<noteq> []\"\n  shows \"(\\<exists>a' as'. as = a'#as' \\<and> intra_kind(kind a')) \\<or>\n         (\\<exists>a' as' Q p f. as = a'#as' \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n         (\\<exists>as' as'' n'. as = as'@as'' \\<and> as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\"", "lemma valid_Exit_path_descending_path:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\"\n  obtains as' where \"n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n  and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\"\n  and \"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\"", "lemma valid_Exit_path_intra_path:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n  obtains as' pex where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\" \n  and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\""], "translations": [["", "lemma Entry_noteq_Exit [dest]:\n  assumes eq:\"(_Entry_) = (_Exit_)\" shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a where \"sourcenode a = (_Entry_)\" \n    and \"valid_edge a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>sourcenode a = (_Entry_); valid_edge a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "with eq"], ["proof (chain)\npicking this:\n  (_Entry_) = (_Exit_)\n  sourcenode a = (_Entry_)\n  valid_edge a", "show False"], ["proof (prove)\nusing this:\n  (_Entry_) = (_Exit_)\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by simp(erule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_noteq_Entry [dest]:\"(_Exit_) = (_Entry_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_Exit_) = (_Entry_) \\<Longrightarrow> False", "by(rule Entry_noteq_Exit[OF sym],simp)"], ["", "lemma [simp]: \"valid_node (_Entry_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a where \"sourcenode a = (_Entry_)\" \n    and \"valid_edge a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>sourcenode a = (_Entry_); valid_edge a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (_Entry_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Entry_)", "by(fastforce simp:valid_node_def)"], ["proof (state)\nthis:\n  valid_node (_Entry_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"valid_node (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a where \"targetnode a = (_Exit_)\"\n    and \"valid_edge a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>targetnode a = (_Exit_); valid_edge a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (_Exit_)", "by(fastforce simp:valid_node_def)"], ["proof (state)\nthis:\n  valid_node (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Definition of \\<open>method_exit\\<close>\\<close>"], ["", "definition method_exit :: \"'node \\<Rightarrow> bool\"\n  where \"method_exit n \\<equiv> n = (_Exit_) \\<or> \n  (\\<exists>a Q p f. n = sourcenode a \\<and> valid_edge a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["", "lemma method_exit_cases:\n  \"\\<lbrakk>method_exit n; n = (_Exit_) \\<Longrightarrow> P;\n    \\<And>a Q f p. \\<lbrakk>n = sourcenode a; valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>method_exit n; n = (_Exit_) \\<Longrightarrow> P;\n     \\<And>a Q f p.\n        \\<lbrakk>n = sourcenode a; valid_edge a;\n         kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by(fastforce simp:method_exit_def)"], ["", "lemma method_exit_inner_path:\n  assumes \"method_exit n\" and \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" shows \"as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as = []", "using \\<open>method_exit n\\<close>"], ["proof (prove)\nusing this:\n  method_exit n\n\ngoal (1 subgoal):\n 1. as = []", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = (_Exit_) \\<Longrightarrow> as = []\n 2. \\<And>a Q f p.\n       \\<lbrakk>n = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> as = []", "assume \"n = (_Exit_)\""], ["proof (state)\nthis:\n  n = (_Exit_)\n\ngoal (2 subgoals):\n 1. n = (_Exit_) \\<Longrightarrow> as = []\n 2. \\<And>a Q f p.\n       \\<lbrakk>n = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> as = []", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. as = []", "proof(cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "case (Cons a' as')"], ["proof (state)\nthis:\n  as = a' # as'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = a' # as'", "have \"n = sourcenode a'\" and \"valid_edge a'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&& valid_edge a'", "by(auto elim:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "with \\<open>n = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n = (_Exit_)\n  n = sourcenode a'\n  valid_edge a'", "have \"sourcenode a' = (_Exit_)\""], ["proof (prove)\nusing this:\n  n = (_Exit_)\n  n = sourcenode a'\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. sourcenode a' = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a' = (_Exit_)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. as = []", "by simp"], ["proof (state)\nthis:\n  as = []\n\ngoal (1 subgoal):\n 1. as = [] \\<Longrightarrow> as = []", "qed simp"], ["proof (state)\nthis:\n  as = []\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> as = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> as = []", "fix a Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> as = []", "assume \"n = sourcenode a\" and \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  n = sourcenode a\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> as = []", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. as = []", "proof(cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "case (Cons a' as')"], ["proof (state)\nthis:\n  as = a' # as'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = a' # as'", "have \"n = sourcenode a'\" and \"valid_edge a'\" \n      and \"intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&& valid_edge a' &&& intra_kind (kind a')", "by(auto elim:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n  intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>valid_edge a'\\<close> \\<open>n = sourcenode a\\<close> \n      \\<open>n = sourcenode a'\\<close> \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a'\n  n = sourcenode a\n  n = sourcenode a'\n  intra_kind (kind a')", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a'\n  n = sourcenode a\n  n = sourcenode a'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> as = []\n 2. \\<And>a list. as = a # list \\<Longrightarrow> as = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. as = []", "by simp"], ["proof (state)\nthis:\n  as = []\n\ngoal (1 subgoal):\n 1. as = [] \\<Longrightarrow> as = []", "qed simp"], ["proof (state)\nthis:\n  as = []\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Definition of \\<open>inner_node\\<close>\\<close>"], ["", "definition inner_node :: \"'node \\<Rightarrow> bool\"\n  where inner_node_def: \n  \"inner_node n \\<equiv> valid_node n \\<and> n \\<noteq> (_Entry_) \\<and> n \\<noteq> (_Exit_)\""], ["", "lemma inner_is_valid:\n  \"inner_node n \\<Longrightarrow> valid_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_node n \\<Longrightarrow> valid_node n", "by(simp add:inner_node_def valid_node_def)"], ["", "lemma [dest]:\n  \"inner_node (_Entry_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_node (_Entry_) \\<Longrightarrow> False", "by(simp add:inner_node_def)"], ["", "lemma [dest]:\n  \"inner_node (_Exit_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_node (_Exit_) \\<Longrightarrow> False", "by(simp add:inner_node_def)"], ["", "lemma [simp]:\"\\<lbrakk>valid_edge a; targetnode a \\<noteq> (_Exit_)\\<rbrakk> \n  \\<Longrightarrow> inner_node (targetnode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge a; targetnode a \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> inner_node (targetnode a)", "by(simp add:inner_node_def,rule ccontr,simp,erule Entry_target)"], ["", "lemma [simp]:\"\\<lbrakk>valid_edge a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n  \\<Longrightarrow> inner_node (sourcenode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> inner_node (sourcenode a)", "by(simp add:inner_node_def,rule ccontr,simp,erule Exit_source)"], ["", "lemma valid_node_cases [consumes 1, case_names \"Entry\" \"Exit\" \"inner\"]:\n  \"\\<lbrakk>valid_node n; n = (_Entry_) \\<Longrightarrow> Q; n = (_Exit_) \\<Longrightarrow> Q;\n    inner_node n \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node n; n = (_Entry_) \\<Longrightarrow> Q;\n     n = (_Exit_) \\<Longrightarrow> Q;\n     inner_node n \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "apply(auto simp:valid_node_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>sourcenode a = (_Entry_) \\<Longrightarrow> Q;\n        sourcenode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (sourcenode a) \\<Longrightarrow> Q; valid_edge a;\n        n = sourcenode a\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a\\<rbrakk>\n       \\<Longrightarrow> Q", "apply(case_tac \"sourcenode a = (_Entry_)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>sourcenode a = (_Entry_) \\<Longrightarrow> Q;\n        sourcenode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (sourcenode a) \\<Longrightarrow> Q; valid_edge a;\n        n = sourcenode a; sourcenode a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>a.\n       \\<lbrakk>sourcenode a = (_Entry_) \\<Longrightarrow> Q;\n        sourcenode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (sourcenode a) \\<Longrightarrow> Q; valid_edge a;\n        n = sourcenode a; sourcenode a \\<noteq> (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> Q\n 3. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a\\<rbrakk>\n       \\<Longrightarrow> Q", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a\\<rbrakk>\n       \\<Longrightarrow> Q", "apply(case_tac \"targetnode a = (_Exit_)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a; targetnode a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>a.\n       \\<lbrakk>targetnode a = (_Entry_) \\<Longrightarrow> Q;\n        targetnode a = (_Exit_) \\<Longrightarrow> Q;\n        inner_node (targetnode a) \\<Longrightarrow> Q; valid_edge a;\n        n = targetnode a; targetnode a \\<noteq> (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> Q", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Lemmas on paths with \\<open>(_Exit_)\\<close>\\<close>"], ["", "lemma path_Exit_source:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; n = (_Exit_)\\<rbrakk> \\<Longrightarrow> n' = (_Exit_) \\<and> as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n'; n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n' = (_Exit_) \\<and> as = []", "proof(induct rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_) \\<and> [] = []\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_) \\<and> as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_) \\<and> a # as = []", "case (Cons_path n'' as n' a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_) \\<and> as = []\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_) \\<and> [] = []\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_) \\<and> as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_) \\<and> a # as = []", "from \\<open>n = (_Exit_)\\<close> \\<open>sourcenode a = n\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  n = (_Exit_)\n  sourcenode a = n\n  valid_edge a", "have False"], ["proof (prove)\nusing this:\n  n = (_Exit_)\n  sourcenode a = n\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by -(rule Exit_source,simp_all)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_) \\<and> [] = []\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        n'' = (_Exit_) \\<Longrightarrow> n' = (_Exit_) \\<and> as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n' = (_Exit_) \\<and> a # as = []", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n' = (_Exit_) \\<and> a # as = []", "by simp"], ["proof (state)\nthis:\n  n' = (_Exit_) \\<and> a # as = []\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_) \\<and> [] = []", "qed simp"], ["", "lemma [dest]:\"(_Exit_) -as\\<rightarrow>* n' \\<Longrightarrow> n' = (_Exit_) \\<and> as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_Exit_) -as\\<rightarrow>* n' \\<Longrightarrow>\n    n' = (_Exit_) \\<and> as = []", "by(fastforce elim!:path_Exit_source)"], ["", "lemma Exit_no_sourcenode[dest]:\n  assumes isin:\"(_Exit_) \\<in> set (sourcenodes as)\" and path:\"n -as\\<rightarrow>* n'\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from isin"], ["proof (chain)\npicking this:\n  (_Exit_) \\<in> set (sourcenodes as)", "obtain ns' ns'' where \"sourcenodes as = ns'@(_Exit_)#ns''\""], ["proof (prove)\nusing this:\n  (_Exit_) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        sourcenodes as = ns' @ (_Exit_) # ns'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:split_list simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes as = ns' @ (_Exit_) # ns''\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  sourcenodes as = ns' @ (_Exit_) # ns''", "obtain as' as'' a where \"as = as'@a#as''\"\n    and source:\"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  sourcenodes as = ns' @ (_Exit_) # ns''\n\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>as = as' @ a # as''; sourcenode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  as = as' @ a # as''\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "with path"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = as' @ a # as''\n  sourcenode a = (_Exit_)", "have \"valid_edge a\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = as' @ a # as''\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. valid_edge a", "by(fastforce dest:path_split)"], ["proof (state)\nthis:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "with source"], ["proof (chain)\npicking this:\n  sourcenode a = (_Exit_)\n  valid_edge a", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (_Exit_)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by -(erule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vpa_no_slpa:\n  \"\\<lbrakk>valid_path_aux cs as; n -as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> (\\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q r fs. valid_edge a \\<and> kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_aux cs as; n -as\\<rightarrow>* n';\n     valid_call_list cs n; cs \\<noteq> [];\n     \\<forall>xs ys.\n        as = xs @ ys \\<longrightarrow>\n        \\<not> same_level_path_aux cs xs \\<or>\n        upd_cs cs xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a Q r fs.\n                         valid_edge a \\<and>\n                         kind a =\n                         Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "proof(induct arbitrary:n rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_call_list cs n;\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 5. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "case (vpa_empty cs)"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n  valid_call_list cs n\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     [] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_call_list cs n;\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 5. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>valid_call_list cs n\\<close> \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs \\<noteq> []", "obtain Q r fs where \"valid_edge (hd cs)\"\n    and \"kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>Q r fs.\n        \\<lbrakk>valid_edge (hd cs);\n         kind (hd cs) =\n         Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(unfold valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r p fs.\n            kind c = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes cs')));\n     cs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(drule hd_Cons_tl[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r p fs.\n            kind c = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes cs')));\n     cs = hd cs # tl cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>c cs''.\n        cs = [] @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r p fs.\n            kind c = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"hd cs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>cs''.\n        cs = [] @ hd cs # cs'' \\<longrightarrow>\n        valid_edge (hd cs) \\<and>\n        (\\<exists>Q r p fs.\n            kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge (hd cs)\n  kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\n\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_call_list cs n;\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 5. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>n -[]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -[]\\<rightarrow>* n'", "have \"n = n'\""], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = n'", "by fastforce"], ["proof (state)\nthis:\n  n = n'\n\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_call_list cs n;\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 5. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "with \\<open>valid_edge (hd cs)\\<close> \\<open>kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge (hd cs)\n  kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\n  n = n'", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge (hd cs)\n  kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "by blast"], ["proof (state)\nthis:\n  \\<exists>a Q r fs.\n     valid_edge a \\<and>\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "case (vpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  \\<lbrakk>?n -as\\<rightarrow>* n'; valid_call_list cs ?n; cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_aux cs xs \\<or>\n      upd_cs cs xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q r fs.\n                       valid_edge a \\<and>\n                       kind a =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "note IH = \\<open>\\<And>n. \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' Q' r' fs'. valid_edge a' \\<and> kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as\\<rightarrow>* n'; valid_call_list cs ?n; cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_aux cs xs \\<or>\n      upd_cs cs xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a' Q' r' fs'.\n                       valid_edge a' \\<and>\n                       kind a' =\n                       Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "note all = \\<open>\\<forall>xs ys. a#as = xs@ys \n    \\<longrightarrow> \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"sourcenode a = n\" and \"valid_edge a\" \n    and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a = n &&& valid_edge a &&& targetnode a -as\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = n\n  valid_edge a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>valid_call_list cs n\\<close> \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs \\<noteq> []", "obtain Q r fs where \"valid_edge (hd cs)\"\n    and \"kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>Q r fs.\n        \\<lbrakk>valid_edge (hd cs);\n         kind (hd cs) =\n         Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(unfold valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r p fs.\n            kind c = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes cs')));\n     cs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(drule hd_Cons_tl[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r p fs.\n            kind c = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes cs')));\n     cs = hd cs # tl cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>c cs''.\n        cs = [] @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r p fs.\n            kind c = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"hd cs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r fs.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>cs''.\n        cs = [] @ hd cs # cs'' \\<longrightarrow>\n        valid_edge (hd cs) \\<and>\n        (\\<exists>Q r p fs.\n            kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n\n              | a # list \\<Rightarrow> last (sourcenodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge (hd cs)\n  kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "with \\<open>kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\n  sourcenode a = n\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind (hd cs) = Q:r\\<hookrightarrow>\\<^bsub>get_proc n\\<^esub>fs\n  sourcenode a = n\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. kind (hd cs) =\n    Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind (hd cs) =\n  Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>valid_call_list cs n\\<close> \\<open>sourcenode a = n\\<close>\n    \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  sourcenode a = n\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  sourcenode a = n\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode a) = get_proc (targetnode a); n = sourcenode a;\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        n = sourcenode a; cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        n = sourcenode a; cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from all \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  intra_kind (kind a)", "have \"\\<forall>xs ys. as = xs@ys \\<longrightarrow> \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>xsa.\n                   (\\<exists>ysa. a # xs @ ys = xsa @ ysa) \\<longrightarrow>\n                   same_level_path_aux cs xsa \\<longrightarrow>\n                   upd_cs cs xsa \\<noteq> [];\n        intra_kind (kind a); as = xs @ ys; same_level_path_aux cs xs;\n        upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"a#xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>intra_kind (kind a); as = xs @ ys;\n        same_level_path_aux cs xs; upd_cs cs xs = [];\n        (\\<exists>ysa. a # xs @ ys = (a # xs) @ ysa) \\<longrightarrow>\n        same_level_path_aux cs (a # xs) \\<longrightarrow>\n        upd_cs cs (a # xs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs n;\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs xs \\<or>\n               upd_cs cs xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>valid_call_list cs (targetnode a)\\<close>\n    \\<open>cs \\<noteq> []\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>a' Q' r' fs'.\n     valid_edge a' \\<and>\n     kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a' Q' r' fs'.\n     valid_edge a' \\<and>\n     kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "."], ["proof (state)\nthis:\n  \\<exists>a Q r fs.\n     valid_edge a \\<and>\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "case (vpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  \\<lbrakk>?n -as\\<rightarrow>* n'; valid_call_list (a # cs) ?n;\n   a # cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_aux (a # cs) xs \\<or>\n      upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q r fs.\n                       valid_edge a \\<and>\n                       kind a =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "note IH = \\<open>\\<And>n. \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a#cs) n; a#cs \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> \\<not> same_level_path_aux (a#cs) xs \\<or> upd_cs (a#cs) xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' Q' r' fs'. valid_edge a' \\<and> kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as\\<rightarrow>* n'; valid_call_list (a # cs) ?n;\n   a # cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_aux (a # cs) xs \\<or>\n      upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a' Q' r' fs'.\n                       valid_edge a' \\<and>\n                       kind a' =\n                       Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "note all = \\<open>\\<forall>xs ys.\n    a#as = xs@ys \\<longrightarrow> \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"sourcenode a = n\" and \"valid_edge a\" \n    and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a = n &&& valid_edge a &&& targetnode a -as\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = n\n  valid_edge a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  get_proc (targetnode a) = p", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "with \\<open>valid_call_list cs n\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  valid_edge a\n  sourcenode a = n\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs", "have \"valid_call_list (a#cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  valid_edge a\n  sourcenode a = n\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        n = sourcenode a; a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        n = sourcenode a; a # cs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        n = sourcenode a; a # cs = cs' @ c # cs''; cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        n = sourcenode a; cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        n = sourcenode a; cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        n = sourcenode a; cs = list @ c # cs'';\n        (\\<exists>cs''a.\n            list @ c # cs'' = list @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> sourcenode a\n    | a # lista \\<Rightarrow> last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "by(auto split:list.split simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from all \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<forall>xs ys. as = xs@ys \n    \\<longrightarrow> \\<not> same_level_path_aux (a#cs) xs \\<or> upd_cs (a#cs) xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_aux (a # cs) xs \\<or>\n       upd_cs (a # cs) xs \\<noteq> []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>xsa.\n                   (\\<exists>ysa. a # xs @ ys = xsa @ ysa) \\<longrightarrow>\n                   same_level_path_aux cs xsa \\<longrightarrow>\n                   upd_cs cs xsa \\<noteq> [];\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; as = xs @ ys;\n        same_level_path_aux (a # cs) xs; upd_cs (a # cs) xs = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"a#xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        as = xs @ ys; same_level_path_aux (a # cs) xs;\n        upd_cs (a # cs) xs = [];\n        (\\<exists>ysa. a # xs @ ys = (a # xs) @ ysa) \\<longrightarrow>\n        same_level_path_aux cs (a # xs) \\<longrightarrow>\n        upd_cs cs (a # xs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux (a # cs) xs \\<or>\n     upd_cs (a # cs) xs \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux (a # cs) xs \\<or>\n               upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>valid_call_list (a#cs) (targetnode a)\\<close>\n    _ this]"], ["proof (chain)\npicking this:\n  a # cs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>a' Q' r' fs'.\n     valid_edge a' \\<and>\n     kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'", "show ?case"], ["proof (prove)\nusing this:\n  a # cs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>a' Q' r' fs'.\n     valid_edge a' \\<and>\n     kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  \\<exists>a Q r fs.\n     valid_edge a \\<and>\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "case (vpa_ReturnEmpty cs a as Q p fx)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n  cs = []\n  valid_path_aux [] as\n  \\<lbrakk>?n -as\\<rightarrow>* n'; valid_call_list [] ?n; [] \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_aux [] xs \\<or>\n      upd_cs [] xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q r fs.\n                       valid_edge a \\<and>\n                       kind a =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>cs \\<noteq> []\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  cs \\<noteq> []\n  cs = []", "have False"], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  cs = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list [] n;\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [] xs \\<or>\n               upd_cs [] xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  \\<exists>a Q r fs.\n     valid_edge a \\<and>\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "case (vpa_ReturnCons cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>?n -as\\<rightarrow>* n'; valid_call_list cs' ?n; cs' \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_aux cs' xs \\<or>\n      upd_cs cs' xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q r fs.\n                       valid_edge a \\<and>\n                       kind a =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "note IH = \\<open>\\<And>n. \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n; cs' \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> \\<not> same_level_path_aux cs' xs \\<or> upd_cs cs' xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' Q' r' fs'. valid_edge a' \\<and> kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as\\<rightarrow>* n'; valid_call_list cs' ?n; cs' \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_aux cs' xs \\<or>\n      upd_cs cs' xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a' Q' r' fs'.\n                       valid_edge a' \\<and>\n                       kind a' =\n                       Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "note all = \\<open>\\<forall>xs ys. a#as = xs@ys \n    \\<longrightarrow> \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"sourcenode a = n\" and \"valid_edge a\" \n    and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a = n &&& valid_edge a &&& targetnode a -as\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = n\n  valid_edge a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "from \\<open>valid_call_list cs n\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs = c' # cs'", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c'", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cs'a c.\n                (\\<exists>cs''.\n                    c' # cs' = cs'a @ c # cs'') \\<longrightarrow>\n                valid_edge c \\<and>\n                (\\<exists>Q r fs.\n                    kind c =\n                    Q:r\\<hookrightarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> n\n            | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n     cs = c' # cs'\\<rbrakk>\n    \\<Longrightarrow> valid_edge c'", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cs = c' # cs';\n     \\<forall>c.\n        (\\<exists>cs''. c' # cs' = [] @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case [] of [] \\<Rightarrow> n\n    | a # list \\<Rightarrow> last (sourcenodes []))\\<^esub>fs)\\<rbrakk>\n    \\<Longrightarrow> valid_edge c'", "by auto"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_call_list cs' n;\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux cs' xs \\<or>\n               upd_cs cs' xs \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q r fs.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                       n'\\<^esub>fs;\n        n -a # as\\<rightarrow>* n'; valid_call_list cs n; cs \\<noteq> [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_aux cs xs \\<or>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q r fs.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   n'\\<^esub>fs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "proof(cases \"cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "case True"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "with all \\<open>cs = c'#cs'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges c'\n  cs' = []", "have False"], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges c'\n  cs' = []\n\ngoal (1 subgoal):\n 1. False", "by(erule_tac x=\"[a]\" in allE,fastforce)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  \\<exists>a Q r fs.\n     valid_edge a \\<and>\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "case False"], ["proof (state)\nthis:\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "with \\<open>valid_call_list cs n\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs = c' # cs'\n  cs' \\<noteq> []", "have \"valid_call_list cs' (sourcenode c')\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs = c' # cs'\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (sourcenode c')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> n\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs''; cs' = cs'a @ c # cs'';\n        valid_edge c \\<longrightarrow>\n        (\\<forall>Q r fs.\n            kind c \\<noteq>\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs'a of [] \\<Rightarrow> sourcenode c'\n    | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> n\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        valid_edge c \\<longrightarrow>\n        (\\<forall>Q r fs.\n            kind c \\<noteq>\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode c'\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"c'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge c \\<longrightarrow>\n                (\\<forall>Q r fs.\n                    kind c \\<noteq>\n                    Q:r\\<hookrightarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode c'\n            | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> n\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp:sourcenodes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c Q r fs.\n       \\<lbrakk>get_proc\n                 (if cs' = [] then sourcenode c'\n                  else last (map sourcenode cs')) \\<noteq>\n                get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode c'\n                  | a # list \\<Rightarrow> last (sourcenodes cs'));\n        valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (if cs' = [] then sourcenode c'\nelse last (map sourcenode cs'))\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c Q r fs.\n       \\<lbrakk>get_proc\n                 (if cs' = [] then sourcenode c'\n                  else last (map sourcenode cs')) \\<noteq>\n                get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode c'\n                  | a # list \\<Rightarrow> last (sourcenodes cs'));\n        valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (if cs' = [] then sourcenode c'\nelse last (map sourcenode cs'))\\<^esub>fs;\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>cs' c Q r fs a list.\n       \\<lbrakk>get_proc\n                 (if cs' = [] then sourcenode c'\n                  else last (map sourcenode cs')) \\<noteq>\n                get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode c'\n                  | a # list \\<Rightarrow> last (sourcenodes cs'));\n        valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (if cs' = [] then sourcenode c'\nelse last (map sourcenode cs'))\\<^esub>fs;\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c Q r fs a list.\n       \\<lbrakk>get_proc\n                 (if list = [] then sourcenode a\n                  else last (map sourcenode list)) \\<noteq>\n                get_proc (last (sourcenodes (a # list)));\n        valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (if list = [] then sourcenode a\nelse last (map sourcenode list))\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c Q r fs a list.\n       \\<lbrakk>get_proc\n                 (if list = [] then sourcenode a\n                  else last (map sourcenode list)) \\<noteq>\n                get_proc (last (sourcenodes (a # list)));\n        valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (if list = [] then sourcenode a\nelse last (map sourcenode list))\\<^esub>fs;\n        list = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c Q r fs a list aa lista.\n       \\<lbrakk>get_proc\n                 (if list = [] then sourcenode a\n                  else last (map sourcenode list)) \\<noteq>\n                get_proc (last (sourcenodes (a # list)));\n        valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (if list = [] then sourcenode a\nelse last (map sourcenode list))\\<^esub>fs;\n        list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp:sourcenodes_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_call_list cs' (sourcenode c')\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "with \\<open>valid_call_list cs' (sourcenode c')\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs' (sourcenode c')\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"valid_call_list cs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs' (sourcenode c')\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> sourcenode c'\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs'a of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'a))\\<^esub>fs", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode c'\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode c'\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode c'\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "from all \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'", "have \"\\<forall>xs ys. as = xs@ys \\<longrightarrow> \\<not> same_level_path_aux cs' xs \\<or> upd_cs cs' xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs xs \\<or> upd_cs cs xs \\<noteq> []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_aux cs' xs \\<or> upd_cs cs' xs \\<noteq> []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>xsa.\n                   (\\<exists>ysa. a # xs @ ys = xsa @ ysa) \\<longrightarrow>\n                   same_level_path_aux (c' # cs') xsa \\<longrightarrow>\n                   upd_cs (c' # cs') xsa \\<noteq> [];\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        a \\<in> get_return_edges c'; as = xs @ ys;\n        same_level_path_aux cs' xs; upd_cs cs' xs = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"a#xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        a \\<in> get_return_edges c'; as = xs @ ys;\n        same_level_path_aux cs' xs; upd_cs cs' xs = [];\n        (\\<exists>ysa. a # xs @ ys = (a # xs) @ ysa) \\<longrightarrow>\n        same_level_path_aux (c' # cs') (a # xs) \\<longrightarrow>\n        upd_cs (c' # cs') (a # xs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux cs' xs \\<or> upd_cs cs' xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>valid_call_list cs' (targetnode a)\\<close>\n      False this]"], ["proof (chain)\npicking this:\n  \\<exists>a' Q' r' fs'.\n     valid_edge a' \\<and>\n     kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a' Q' r' fs'.\n     valid_edge a' \\<and>\n     kind a' = Q':r'\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q r fs.\n       valid_edge a \\<and>\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs", "."], ["proof (state)\nthis:\n  \\<exists>a Q r fs.\n     valid_edge a \\<and>\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a Q r fs.\n     valid_edge a \\<and>\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>get_proc n'\\<^esub>fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Exit_path_cases:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" and \"as \\<noteq> []\"\n  shows \"(\\<exists>a' as'. as = a'#as' \\<and> intra_kind(kind a')) \\<or>\n         (\\<exists>a' as' Q p f. as = a'#as' \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n         (\\<exists>as' as'' n'. as = as'@as'' \\<and> as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "from \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []", "obtain a' as' where \"as = a'#as'\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'. as = a' # as' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases as) auto"], ["proof (state)\nthis:\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "thus ?thesis"], ["proof (prove)\nusing this:\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>as = a' # as'; intra_kind (kind a')\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a' as'.\n                          as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n                      (\\<exists>a' as' Q p f.\n                          as = a' # as' \\<and>\n                          kind a' =\n                          Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                      (\\<exists>as' as'' n'.\n                          as = as' @ as'' \\<and>\n                          as' \\<noteq> [] \\<and>\n                          n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 3. \\<And>Q p f.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as = a' # as'; intra_kind (kind a')\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a' as'.\n                          as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n                      (\\<exists>a' as' Q p f.\n                          as = a' # as' \\<and>\n                          kind a' =\n                          Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                      (\\<exists>as' as'' n'.\n                          as = as' @ as'' \\<and>\n                          as' \\<noteq> [] \\<and>\n                          n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 3. \\<And>Q p f.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "with \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  intra_kind (kind a')", "show ?thesis"], ["proof (prove)\nusing this:\n  as = a' # as'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q p f.\n      as = a' # as' \\<and>\n      kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<And>Q p f.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<And>Q p f.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "case Return"], ["proof (state)\nthis:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<And>Q p f.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "with \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_", "show ?thesis"], ["proof (prove)\nusing this:\n  as = a' # as'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q p f.\n      as = a' # as' \\<and>\n      kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "case (Call Q r p f)"], ["proof (state)\nthis:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"n -as\\<rightarrow>* (_Exit_)\" and \"valid_path_aux [] as\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* (_Exit_) &&& valid_path_aux [] as", "by(simp_all add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* (_Exit_)\n  valid_path_aux [] as\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "from \\<open>n -as\\<rightarrow>* (_Exit_)\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* (_Exit_)\n  as = a' # as'", "have \"sourcenode a' = n\" and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* (_Exit_)\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. sourcenode a' = n &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* (_Exit_)", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a' = n\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "from \\<open>valid_path_aux [] as\\<close> \\<open>as = a'#as'\\<close> Call"], ["proof (chain)\npicking this:\n  valid_path_aux [] as\n  as = a' # as'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f", "have \"valid_path_aux [a'] as'\""], ["proof (prove)\nusing this:\n  valid_path_aux [] as\n  as = a' # as'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. valid_path_aux [a'] as'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux [a'] as'\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "from \\<open>valid_edge a'\\<close> Call"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f", "have \"valid_call_list [a'] (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. valid_call_list [a'] (targetnode a')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f;\n        [a'] = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f;\n        [a'] = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>valid_edge a';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f;\n        [a'] = cs' @ c # cs''; cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(auto intro:get_proc_call[THEN sym])"], ["proof (state)\nthis:\n  valid_call_list [a'] (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = a' # as';\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q p f.\n                             as = a' # as' \\<and>\n                             kind a' =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as' \\<noteq> [] \\<and>\n                             n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "proof(cases \"\\<forall>xs ys. as' = xs@ys \\<longrightarrow> \n        (\\<not> same_level_path_aux [a'] xs \\<or> upd_cs [a'] xs \\<noteq> [])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_aux [a'] xs \\<or>\n       upd_cs [a'] xs \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "case True"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as' = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux [a'] xs \\<or> upd_cs [a'] xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_aux [a'] xs \\<or>\n       upd_cs [a'] xs \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "with \\<open>valid_path_aux [a'] as'\\<close> \\<open>targetnode a' -as'\\<rightarrow>* (_Exit_)\\<close>\n        \\<open>valid_call_list [a'] (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux [a'] as'\n  targetnode a' -as'\\<rightarrow>* (_Exit_)\n  valid_call_list [a'] (targetnode a')\n  \\<forall>xs ys.\n     as' = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux [a'] xs \\<or> upd_cs [a'] xs \\<noteq> []", "obtain ax Qx rx fsx where \"valid_edge ax\" and \"kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (_Exit_)\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  valid_path_aux [a'] as'\n  targetnode a' -as'\\<rightarrow>* (_Exit_)\n  valid_call_list [a'] (targetnode a')\n  \\<forall>xs ys.\n     as' = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_aux [a'] xs \\<or> upd_cs [a'] xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ax Qx rx fsx.\n        \\<lbrakk>valid_edge ax;\n         kind ax =\n         Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (_Exit_)\\<^esub>fsx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:vpa_no_slpa)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (_Exit_)\\<^esub>fsx\n\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_aux [a'] xs \\<or>\n       upd_cs [a'] xs \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "hence False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (_Exit_)\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_call_target simp:get_proc_Exit)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_aux [a'] xs \\<or>\n       upd_cs [a'] xs \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q p f.\n      as = a' # as' \\<and>\n      kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>xs ys.\n             as' = xs @ ys \\<longrightarrow>\n             \\<not> same_level_path_aux [a'] xs \\<or>\n             upd_cs [a'] xs \\<noteq> [])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>xs ys.\n             as' = xs @ ys \\<longrightarrow>\n             \\<not> same_level_path_aux [a'] xs \\<or>\n             upd_cs [a'] xs \\<noteq> [])", "obtain xs ys where \"as' = xs@ys\" and \"same_level_path_aux [a'] xs\"\n        and \"upd_cs [a'] xs = []\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>xs ys.\n             as' = xs @ ys \\<longrightarrow>\n             \\<not> same_level_path_aux [a'] xs \\<or>\n             upd_cs [a'] xs \\<noteq> [])\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as' = xs @ ys; same_level_path_aux [a'] xs;\n         upd_cs [a'] xs = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as' = xs @ ys\n  same_level_path_aux [a'] xs\n  upd_cs [a'] xs = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "with Call"], ["proof (chain)\npicking this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  as' = xs @ ys\n  same_level_path_aux [a'] xs\n  upd_cs [a'] xs = []", "have \"same_level_path (a'#xs)\""], ["proof (prove)\nusing this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  as' = xs @ ys\n  same_level_path_aux [a'] xs\n  upd_cs [a'] xs = []\n\ngoal (1 subgoal):\n 1. same_level_path (a' # xs)", "by(simp add:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path (a' # xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "from \\<open>upd_cs [a'] xs = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [a'] xs = []", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  upd_cs [a'] xs = []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "with \\<open>targetnode a' -as'\\<rightarrow>* (_Exit_)\\<close> \\<open>as' = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -as'\\<rightarrow>* (_Exit_)\n  as' = xs @ ys\n  xs \\<noteq> []", "have \"targetnode a' -xs\\<rightarrow>* last(targetnodes xs)\""], ["proof (prove)\nusing this:\n  targetnode a' -as'\\<rightarrow>* (_Exit_)\n  as' = xs @ ys\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. targetnode a' -xs\\<rightarrow>* last (targetnodes xs)", "apply(cases xs rule:rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>targetnode a' -as'\\<rightarrow>* (_Exit_); as' = xs @ ys;\n     xs \\<noteq> []; xs = []\\<rbrakk>\n    \\<Longrightarrow> targetnode a' -xs\\<rightarrow>* last (targetnodes xs)\n 2. \\<And>ysa y.\n       \\<lbrakk>targetnode a' -as'\\<rightarrow>* (_Exit_); as' = xs @ ys;\n        xs \\<noteq> []; xs = ysa @ [y]\\<rbrakk>\n       \\<Longrightarrow> targetnode\n                          a' -xs\\<rightarrow>* last (targetnodes xs)", "by(auto intro:path_Append path_split path_edge simp:targetnodes_def)"], ["proof (state)\nthis:\n  targetnode a' -xs\\<rightarrow>* last (targetnodes xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "with \\<open>sourcenode a' = n\\<close> \\<open>valid_edge a'\\<close> \\<open>same_level_path (a'#xs)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = n\n  valid_edge a'\n  same_level_path (a' # xs)\n  targetnode a' -xs\\<rightarrow>* last (targetnodes xs)", "have \"n -a'#xs\\<rightarrow>\\<^bsub>sl\\<^esub>* last(targetnodes xs)\""], ["proof (prove)\nusing this:\n  sourcenode a' = n\n  valid_edge a'\n  same_level_path (a' # xs)\n  targetnode a' -xs\\<rightarrow>* last (targetnodes xs)\n\ngoal (1 subgoal):\n 1. n -a' # xs\\<rightarrow>\\<^bsub>sl\\<^esub>* last (targetnodes xs)", "by(fastforce intro:Cons_path simp:slp_def)"], ["proof (state)\nthis:\n  n -a' # xs\\<rightarrow>\\<^bsub>sl\\<^esub>* last (targetnodes xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "with \\<open>as = a'#as'\\<close> \\<open>as' = xs@ys\\<close> Call"], ["proof (chain)\npicking this:\n  as = a' # as'\n  as' = xs @ ys\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  n -a' # xs\\<rightarrow>\\<^bsub>sl\\<^esub>* last (targetnodes xs)", "have \"\\<exists>as' as'' n'. as = as'@as'' \\<and> as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  as' = xs @ ys\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  n -a' # xs\\<rightarrow>\\<^bsub>sl\\<^esub>* last (targetnodes xs)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "by(rule_tac x=\"a'#xs\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_aux [a'] xs \\<or>\n               upd_cs [a'] xs \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q p f.\n        as = a' # as' \\<and>\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q p f.\n      as = a' # as' \\<and>\n      kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q p f.\n      as = a' # as' \\<and>\n      kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q p f.\n      as = a' # as' \\<and>\n      kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Exit_path_descending_path:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\"\n  obtains as' where \"n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n  and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\"\n  and \"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n         set (sourcenodes as') \\<subseteq> set (sourcenodes as);\n         \\<forall>a'\\<in>set as'.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q f p.\n                kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "show \"\\<exists>as'. n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and> set(sourcenodes as') \\<subseteq> set(sourcenodes as)\\<and>\n              (\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "proof(induct as arbitrary:n rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n                       (\\<exists>as'.\n                           x -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys) \\<and>\n                           (\\<forall>a'\\<in>set as'.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q f p.\n                                   kind a' =\n                                   Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))));\n        n -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs) \\<and>\n                            (\\<forall>a'\\<in>set as'.\n                                intra_kind (kind a') \\<or>\n                                (\\<exists>Q f p.\n                                    kind a' =\n                                    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "fix as n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n                       (\\<exists>as'.\n                           x -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys) \\<and>\n                           (\\<forall>a'\\<in>set as'.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q f p.\n                                   kind a' =\n                                   Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))));\n        n -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs) \\<and>\n                            (\\<forall>a'\\<in>set as'.\n                                intra_kind (kind a') \\<or>\n                                (\\<exists>Q f p.\n                                    kind a' =\n                                    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "assume IH:\"\\<forall>as''. length as'' < length as \\<longrightarrow>\n      (\\<forall>n'. n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       (\\<exists>as'. n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and> set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n              (\\<forall>a'\\<in>set as'. intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\"\n      and \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (state)\nthis:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n                       (\\<exists>as'.\n                           x -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys) \\<and>\n                           (\\<forall>a'\\<in>set as'.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q f p.\n                                   kind a' =\n                                   Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))));\n        n -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs) \\<and>\n                            (\\<forall>a'\\<in>set as'.\n                                intra_kind (kind a') \\<or>\n                                (\\<exists>Q f p.\n                                    kind a' =\n                                    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "show \"\\<exists>as'. n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and> set(sourcenodes as') \\<subseteq> set(sourcenodes as)\\<and>\n              (\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "by(fastforce simp:sourcenodes_def vp_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as \\<noteq> []", "have \"((\\<exists>a' as'. as = a'#as' \\<and> intra_kind(kind a')) \\<or>\n         (\\<exists>a' as' Q p f. as = a'#as' \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)) \\<or>\n         (\\<exists>as' as'' n'. as = as'@as'' \\<and> as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. ((\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n     (\\<exists>a' as' Q p f.\n         as = a' # as' \\<and>\n         kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')", "by(auto dest!:valid_Exit_path_cases)"], ["proof (state)\nthis:\n  ((\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n   (\\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n   (\\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')) \\<or>\n     (\\<exists>a' as' Q p f.\n         as = a' # as' \\<and>\n         kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as' \\<noteq> [] \\<and>\n        n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "assume \"\\<exists>a' as'. as = a'#as' \\<and> intra_kind(kind a')\""], ["proof (state)\nthis:\n  \\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "then"], ["proof (chain)\npicking this:\n  \\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')", "obtain a' as' where \"as = a'#as'\" and \"intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  \\<exists>a' as'. as = a' # as' \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = a' # as'\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'", "have \"sourcenode a' = n\" and \"valid_edge a'\" \n          and \"targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. sourcenode a' = n &&&\n    valid_edge a' &&&\n    targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "by(auto intro:vp_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a' = n\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>valid_edge a'\\<close> \\<open>intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  intra_kind (kind a')", "have \"sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'", "by(fastforce intro:path_edge intras_same_level_path simp:slp_def)"], ["proof (state)\nthis:\n  sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from IH \\<open>targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'", "obtain xs where \"targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n          and \"set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\"\n          and \"\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n         set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n         \\<forall>a'\\<in>set xs.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q f p.\n                kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>targetnode\n                          a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n                 set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n                 \\<forall>a'\\<in>set xs.\n                    intra_kind (kind a') \\<or>\n                    (\\<exists>Q f p.\n                        kind a' =\n                        Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_); as = a' # as';\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'a.\n             n' -as'a\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as'a) \\<subseteq> set (sourcenodes as') \\<and>\n             (\\<forall>a'\\<in>set as'a.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' =\n                     Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\\<close> \\<open>targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n  targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"sourcenode a' -[a']@xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n  targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. sourcenode a' -[a'] @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "by(rule slp_vp_Append)"], ["proof (state)\nthis:\n  sourcenode a' -[a'] @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "with \\<open>sourcenode a' = n\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = n\n  sourcenode a' -[a'] @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"n -a'#xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  sourcenode a' = n\n  sourcenode a' -[a'] @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "by simp"], ["proof (state)\nthis:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "moreover"], ["proof (state)\nthis:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = a' # as'", "have \"set (sourcenodes (a'#xs)) \\<subseteq> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "moreover"], ["proof (state)\nthis:\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<close> \n          \\<open>intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  intra_kind (kind a')", "have \"\\<forall>a'\\<in>set (a'#xs). intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (a' # xs).\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (a' # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "ultimately"], ["proof (chain)\npicking this:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (a' # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (a' # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "assume \"\\<exists>a' as' Q p f. as = a'#as' \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  \\<exists>a' as' Q p f.\n     as = a' # as' \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "then"], ["proof (chain)\npicking this:\n  \\<exists>a' as' Q p f.\n     as = a' # as' \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain a' as' Q p f where \"as = a'#as'\" and \"kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (prove)\nusing this:\n  \\<exists>a' as' Q p f.\n     as = a' # as' \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>a' as' Q p f.\n        \\<lbrakk>as = a' # as';\n         kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = a' # as'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'", "have \"sourcenode a' = n\" and \"valid_edge a'\" \n          and \"targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. sourcenode a' = n &&&\n    valid_edge a' &&&\n    targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "by(auto intro:vp_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a' = n\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from IH \\<open>targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'", "obtain xs where \"targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n          and \"set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\"\n          and \"\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n         set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n         \\<forall>a'\\<in>set xs.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q f p.\n                kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>targetnode\n                          a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n                 set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n                 \\<forall>a'\\<in>set xs.\n                    intra_kind (kind a') \\<or>\n                    (\\<exists>Q f p.\n                        kind a' =\n                        Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_); as = a' # as';\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'a.\n             n' -as'a\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as'a) \\<subseteq> set (sourcenodes as') \\<and>\n             (\\<forall>a'\\<in>set as'a.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' =\n                     Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>sourcenode a' = n\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n          \\<open>targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = n\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"n -a'#xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  sourcenode a' = n\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "by(fastforce intro:Cons_path simp:vp_def valid_path_def)"], ["proof (state)\nthis:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "moreover"], ["proof (state)\nthis:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = a' # as'", "have \"set (sourcenodes (a'#xs)) \\<subseteq> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "moreover"], ["proof (state)\nthis:\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<close> \n          \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"\\<forall>a'\\<in>set (a'#xs). intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (a' # xs).\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (a' # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q p f.\n       as = a' # as' \\<and>\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "ultimately"], ["proof (chain)\npicking this:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (a' # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -a' # xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes (a' # xs)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (a' # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "assume \"\\<exists>as' as'' n'. as = as'@as'' \\<and> as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\""], ["proof (state)\nthis:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "then"], ["proof (chain)\npicking this:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "obtain as' as'' n' where \"as = as'@as''\" and \"as' \\<noteq> []\"\n          and \"n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\""], ["proof (prove)\nusing this:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as' \\<noteq> [] \\<and> n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as' as'' n'.\n        \\<lbrakk>as = as' @ as''; as' \\<noteq> [];\n         n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as' @ as''\n  as' \\<noteq> []\n  n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close> \\<open>as = as'@as''\\<close> \\<open>as' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = as' @ as''\n  as' \\<noteq> []", "have \"last(targetnodes as') -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = as' @ as''\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (targetnodes as') -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "by(cases as' rule:rev_cases,auto intro:vp_split simp:targetnodes_def)"], ["proof (state)\nthis:\n  last (targetnodes as') -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<close> \\<open>as' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n  as' \\<noteq> []", "have \"last(targetnodes as') = n'\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (targetnodes as') = n'", "by(fastforce intro:path_targetnode simp:slp_def)"], ["proof (state)\nthis:\n  last (targetnodes as') = n'\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>as = as'@as''\\<close> \\<open>as' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ as''\n  as' \\<noteq> []", "have \"length as'' < length as\""], ["proof (prove)\nusing this:\n  as = as' @ as''\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length as'' < length as", "by simp"], ["proof (state)\nthis:\n  length as'' < length as\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "with IH \\<open>last(targetnodes as') -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>\n          \\<open>last(targetnodes as') = n'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\n  last (targetnodes as') -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  last (targetnodes as') = n'\n  length as'' < length as", "obtain xs where \"n' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n          and \"set (sourcenodes xs) \\<subseteq> set (sourcenodes as'')\"\n          and \"\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\n  last (targetnodes as') -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  last (targetnodes as') = n'\n  length as'' < length as\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>n' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n         set (sourcenodes xs) \\<subseteq> set (sourcenodes as'');\n         \\<forall>a'\\<in>set xs.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q f p.\n                kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as''\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>n' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n                 set (sourcenodes xs) \\<subseteq> set (sourcenodes as'');\n                 \\<forall>a'\\<in>set xs.\n                    intra_kind (kind a') \\<or>\n                    (\\<exists>Q f p.\n                        kind a' =\n                        Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     last (targetnodes as') -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n     last (targetnodes as') = n'; length as'' < length as;\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         n' -as''\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n         (\\<exists>as'.\n             n' -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q f p.\n                     kind a' =\n                     Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  n' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as'')\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "obtain ys where \"n -ys\\<rightarrow>\\<^sub>\\<iota>* n'\"\n          and \"set(sourcenodes ys) \\<subseteq> set(sourcenodes as')\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>n -ys\\<rightarrow>\\<^sub>\\<iota>* n';\n         set (sourcenodes ys) \\<subseteq> set (sourcenodes as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule same_level_path_inner_path)"], ["proof (state)\nthis:\n  n -ys\\<rightarrow>\\<^sub>\\<iota>* n'\n  set (sourcenodes ys) \\<subseteq> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>n -ys\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>n' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -ys\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"n -ys@xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  n -ys\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' -xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -ys @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "by(fastforce intro:slp_vp_Append intra_path_slp)"], ["proof (state)\nthis:\n  n -ys @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "moreover"], ["proof (state)\nthis:\n  n -ys @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>set (sourcenodes xs) \\<subseteq> set (sourcenodes as'')\\<close>\n          \\<open>set(sourcenodes ys) \\<subseteq> set(sourcenodes as')\\<close> \\<open>as = as'@as''\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as'')\n  set (sourcenodes ys) \\<subseteq> set (sourcenodes as')\n  as = as' @ as''", "have \"set (sourcenodes (ys@xs)) \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as'')\n  set (sourcenodes ys) \\<subseteq> set (sourcenodes as')\n  as = as' @ as''\n\ngoal (1 subgoal):\n 1. set (sourcenodes (ys @ xs)) \\<subseteq> set (sourcenodes as)", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes (ys @ xs)) \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "moreover"], ["proof (state)\nthis:\n  set (sourcenodes (ys @ xs)) \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "from \\<open>\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<close>\n          \\<open>n -ys\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  n -ys\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"\\<forall>a'\\<in>set (ys@xs). intra_kind (kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  n -ys\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (ys @ xs).\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (ys @ xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as' \\<noteq> [] \\<and>\n       n -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "ultimately"], ["proof (chain)\npicking this:\n  n -ys @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes (ys @ xs)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (ys @ xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -ys @ xs\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes (ys @ xs)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (ys @ xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Exit_path_intra_path:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n  obtains as' pex where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\" \n  and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' pex.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex; method_exit pex;\n         set (sourcenodes as') \\<subseteq> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as' where \"n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" \n    and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\"\n    and all:\"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n         set (sourcenodes as') \\<subseteq> set (sourcenodes as);\n         \\<forall>a'\\<in>set as'.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q f p.\n                kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule valid_Exit_path_descending_path)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "show \"\\<exists>as' pex. n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and> method_exit pex \\<and> \n                  set(sourcenodes as') \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "proof(cases \"\\<exists>a' \\<in> set as'. \\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "case True"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>set as'.\n     \\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'\\<in>set as'.\n     \\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain asx ax asx' where [simp]:\"as' = asx@ax#asx'\" \n      and \"\\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"\\<forall>a' \\<in> set asx. \\<not> (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  \\<exists>a'\\<in>set as'.\n     \\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax asx'.\n        \\<lbrakk>as' = asx @ ax # asx';\n         \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         \\<forall>a'\\<in>set asx.\n            \\<nexists>Q f p.\n               kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule split_list_first_propE)"], ["proof (state)\nthis:\n  as' = asx @ ax # asx'\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<forall>a'\\<in>set asx.\n     \\<nexists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with all"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  as' = asx @ ax # asx'\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<forall>a'\\<in>set asx.\n     \\<nexists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"\\<forall>a' \\<in> set asx. intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  as' = asx @ ax # asx'\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<forall>a'\\<in>set asx.\n     \\<nexists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set asx. intra_kind (kind a')", "by auto"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set asx. intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"n -asx\\<rightarrow>* sourcenode ax\"\n      and \"valid_edge ax\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -asx\\<rightarrow>* sourcenode ax &&& valid_edge ax", "by(auto elim:path_split simp:vp_def)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>* sourcenode ax\n  valid_edge ax\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>n -asx\\<rightarrow>* sourcenode ax\\<close> \\<open>\\<forall>a' \\<in> set asx. intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>* sourcenode ax\n  \\<forall>a'\\<in>set asx. intra_kind (kind a')", "have \"n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>* sourcenode ax\n  \\<forall>a'\\<in>set asx. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "moreover"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>valid_edge ax\\<close> \\<open>\\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"method_exit (sourcenode ax)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode ax)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode ax)\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "moreover"], ["proof (state)\nthis:\n  method_exit (sourcenode ax)\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>set(sourcenodes as') \\<subseteq> set(sourcenodes as)\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "have \"set(sourcenodes asx) \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. set (sourcenodes asx) \\<subseteq> set (sourcenodes as)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes asx) \\<subseteq> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set as'.\n       \\<exists>Q f p.\n          kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "ultimately"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n  method_exit (sourcenode ax)\n  set (sourcenodes asx) \\<subseteq> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n  method_exit (sourcenode ax)\n  set (sourcenodes asx) \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as' pex.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>a'\\<in>set as'.\n             \\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with all \\<open>n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  \\<not> (\\<exists>a'\\<in>set as'.\n             \\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "have \"n -as'\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  \\<not> (\\<exists>a'\\<in>set as'.\n             \\<exists>Q f p. kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)", "by(fastforce simp:vp_def intra_path_def)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "moreover"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "have \"method_exit (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. method_exit (_Exit_)", "by(simp add:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set as'.\n               \\<exists>Q f p.\n                  kind a' =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "ultimately"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n  method_exit (_Exit_)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n  method_exit (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "using \\<open>set(sourcenodes as') \\<subseteq> set(sourcenodes as)\\<close>"], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n  method_exit (_Exit_)\n  set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as' pex.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as' pex.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as' pex.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}