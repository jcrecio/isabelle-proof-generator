{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/CFG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma get_proc_get_return_edge:\n  assumes \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  shows \"get_proc (sourcenode a) = get_proc (targetnode a')\"", "lemma call_intra_edge_False:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"valid_edge a'\" \n  and \"sourcenode a = sourcenode a'\" and \"intra_kind(kind a')\"\n  shows \"kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\"", "lemma formal_in_THE: \n  \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; (p,ins,outs) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs) = ins\"", "lemma formal_out_THE: \n  \"\\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; (p,ins,outs) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE outs. \\<exists>ins. (p,ins,outs) \\<in> set procs) = outs\"", "lemma params_nth: \n  \"i < length fs \\<Longrightarrow> (params fs cf)!i = (fs!i) cf\"", "lemma [simp]:\"length (params fs cf) = length fs\"", "lemma transfers_split:\n  \"(transfers (ets@ets') s) = (transfers ets' (transfers ets s))\"", "lemma preds_split:\n  \"(preds (ets@ets') s) = (preds ets s \\<and> preds ets' (transfers ets s))\"", "lemma [simp]: \"valid_edge a \\<Longrightarrow> valid_node (sourcenode a)\"", "lemma [simp]: \"valid_edge a \\<Longrightarrow> valid_node (targetnode a)\"", "lemma path_valid_node:\n  assumes \"n -as\\<rightarrow>* n'\" shows \"valid_node n\" and \"valid_node n'\"", "lemma empty_path_nodes [dest]:\"n -[]\\<rightarrow>* n' \\<Longrightarrow> n = n'\"", "lemma path_valid_edges:\"n -as\\<rightarrow>* n' \\<Longrightarrow> \\<forall>a \\<in> set as. valid_edge a\"", "lemma path_edge:\"valid_edge a \\<Longrightarrow> sourcenode a -[a]\\<rightarrow>* targetnode a\"", "lemma path_Append:\"\\<lbrakk>n -as\\<rightarrow>* n''; n'' -as'\\<rightarrow>* n'\\<rbrakk> \n  \\<Longrightarrow> n -as@as'\\<rightarrow>* n'\"", "lemma path_split:\n  assumes \"n -as@a#as'\\<rightarrow>* n'\"\n  shows \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\" and \"targetnode a -as'\\<rightarrow>* n'\"", "lemma path_split_Cons:\n  assumes \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = a'#as'\" and \"n = sourcenode a'\"\n  and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>* n'\"", "lemma path_split_snoc:\n  assumes \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>* sourcenode a'\"\n  and \"valid_edge a'\" and \"n' = targetnode a'\"", "lemma path_split_second:\n  assumes \"n -as@a#as'\\<rightarrow>* n'\" shows \"sourcenode a -a#as'\\<rightarrow>* n'\"", "lemma path_Entry_Cons:\n  assumes \"(_Entry_) -as\\<rightarrow>* n'\" and \"n' \\<noteq> (_Entry_)\"\n  obtains n a where \"sourcenode a = (_Entry_)\" and \"targetnode a = n\"\n  and \"n -tl as\\<rightarrow>* n'\" and \"valid_edge a\" and \"a = hd as\"", "lemma path_det:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; n -as\\<rightarrow>* n''\\<rbrakk> \\<Longrightarrow> n' = n''\"", "lemma path_sourcenode:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd (sourcenodes as) = n\"", "lemma path_targetnode:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> last (targetnodes as) = n'\"", "lemma sourcenodes_is_n_Cons_butlast_targetnodes:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  sourcenodes as = n#(butlast (targetnodes as))\"", "lemma targetnodes_is_tl_sourcenodes_App_n':\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n    targetnodes as = (tl (sourcenodes as))@[n']\"", "lemma intra_path_get_procs:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" shows \"get_proc n = get_proc n'\"", "lemma intra_path_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* n''; n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^sub>\\<iota>* n'\"", "lemma get_proc_get_return_edges: \n  assumes \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  shows \"get_proc(targetnode a) = get_proc(sourcenode a')\"", "lemma vpa_induct [consumes 1,case_names vpa_empty vpa_intra vpa_Call vpa_ReturnEmpty\n  vpa_ReturnCons]:\n  assumes major: \"valid_path_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); valid_path_aux cs as; P cs as\\<rbrakk> \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q r p fs. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_path_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q p f. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = []; valid_path_aux [] as; P [] as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q p f c' cs' . \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c'#cs'; valid_path_aux cs' as;\n                              a \\<in> get_return_edges c'; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (a#as)\"\n  shows \"P xs ys\"", "lemma valid_path_aux_intra_path:\n  \"\\<forall>a \\<in> set as. intra_kind(kind a) \\<Longrightarrow> valid_path_aux cs as\"", "lemma valid_path_aux_callstack_prefix:\n  \"valid_path_aux (cs@cs') as \\<Longrightarrow> valid_path_aux cs as\"", "lemma upd_cs_empty [dest]:\n  \"upd_cs cs [] = [] \\<Longrightarrow> cs = []\"", "lemma upd_cs_intra_path:\n  \"\\<forall>a \\<in> set as. intra_kind(kind a) \\<Longrightarrow> upd_cs cs as = cs\"", "lemma upd_cs_Append:\n  \"\\<lbrakk>upd_cs cs as = cs'; upd_cs cs' as' = cs''\\<rbrakk> \\<Longrightarrow> upd_cs cs (as@as') = cs''\"", "lemma upd_cs_empty_split:\n  assumes \"upd_cs cs as = []\" and \"cs \\<noteq> []\" and \"as \\<noteq> []\"\n  obtains xs ys where \"as = xs@ys\" and \"xs \\<noteq> []\" and \"upd_cs cs xs = []\"\n  and \"\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []\"\n  and \"upd_cs [] ys = []\"", "lemma upd_cs_snoc_Return_Cons:\n  assumes \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  shows \"upd_cs cs as = c'#cs' \\<Longrightarrow> upd_cs cs (as@[a]) = cs'\"", "lemma upd_cs_snoc_Call:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"upd_cs cs (as@[a]) = a#(upd_cs cs as)\"", "lemma valid_path_aux_split:\n  assumes \"valid_path_aux cs (as@as')\"\n  shows \"valid_path_aux cs as\" and \"valid_path_aux (upd_cs cs as) as'\"", "lemma valid_path_aux_Append:\n  \"\\<lbrakk>valid_path_aux cs as; valid_path_aux (upd_cs cs as) as'\\<rbrakk>\n  \\<Longrightarrow> valid_path_aux cs (as@as')\"", "lemma vpa_snoc_Call:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"valid_path_aux cs as \\<Longrightarrow> valid_path_aux cs (as@[a])\"", "lemma valid_path_aux_valid_path:\n  \"valid_path_aux cs as \\<Longrightarrow> valid_path as\"", "lemma valid_path_split:\n  assumes \"valid_path (as@as')\" shows \"valid_path as\" and \"valid_path as'\"", "lemma intra_path_vp:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" shows \"n -as\\<rightarrow>\\<^sub>\\<surd>* n'\"", "lemma vp_split_Cons:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = a'#as'\" and \"n = sourcenode a'\"\n  and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\"", "lemma vp_split_snoc:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\"\n  and \"valid_edge a'\" and \"n' = targetnode a'\"", "lemma vp_split:\n  assumes \"n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\"\n  shows \"n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\" and \"valid_edge a\" and \"targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'\"", "lemma vp_split_second:\n  assumes \"n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\" shows \"sourcenode a -a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\"", "lemma vpra_induct [consumes 1,case_names vpra_empty vpra_intra vpra_Return \n  vpra_CallEmpty vpra_CallCons]:\n  assumes major: \"valid_path_rev_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); valid_path_rev_aux cs as; P cs as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q p f. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; valid_path_rev_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q r p fs. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = []; valid_path_rev_aux [] as; \n         P [] as\\<rbrakk> \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q r p fs c' cs'. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = c'#cs'; \n         valid_path_rev_aux cs' as; c' \\<in> get_return_edges a; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (as@[a])\"\n  shows \"P xs ys\"", "lemma vpra_callstack_prefix:\n  \"valid_path_rev_aux (cs@cs') as \\<Longrightarrow> valid_path_rev_aux cs as\"", "lemma upd_rev_cs_empty [dest]:\n  \"upd_rev_cs cs [] = [] \\<Longrightarrow> cs = []\"", "lemma valid_path_rev_aux_split:\n  assumes \"valid_path_rev_aux cs (as@as')\"\n  shows \"valid_path_rev_aux cs as'\" and \"valid_path_rev_aux (upd_rev_cs cs as') as\"", "lemma valid_path_rev_aux_Append:\n  \"\\<lbrakk>valid_path_rev_aux cs as'; valid_path_rev_aux (upd_rev_cs cs as') as\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs (as@as')\"", "lemma vpra_Cons_intra:\n  assumes \"intra_kind(kind a)\"\n  shows \"valid_path_rev_aux cs as \\<Longrightarrow> valid_path_rev_aux cs (a#as)\"", "lemma vpra_Cons_Return:\n  assumes \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  shows \"valid_path_rev_aux cs as \\<Longrightarrow> valid_path_rev_aux cs (a#as)\"", "lemmas append_Cons_rev = append_Cons[THEN sym]", "lemma upd_rev_cs_Cons_intra:\n  assumes \"intra_kind(kind a)\" shows \"upd_rev_cs cs (a#as) = upd_rev_cs cs as\"", "lemma upd_rev_cs_Cons_Return:\n  assumes \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" shows \"upd_rev_cs cs (a#as) = a#(upd_rev_cs cs as)\"", "lemma upd_rev_cs_Cons_Call_Cons:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"upd_rev_cs cs as = c'#cs' \\<Longrightarrow> upd_rev_cs cs (a#as) = cs'\"", "lemma upd_rev_cs_Cons_Call_Cons_Empty:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"upd_rev_cs cs as = [] \\<Longrightarrow> upd_rev_cs cs (a#as) = []\"", "lemma valid_call_list_valid_edges: \n  assumes \"valid_call_list cs n\" shows \"\\<forall>c \\<in> set cs. valid_edge c\"", "lemma valid_return_list_valid_edges: \n  assumes \"valid_return_list rs n\" shows \"\\<forall>r \\<in> set rs. valid_edge r\"", "lemma vpra_empty_valid_call_list_rev:\n  \"valid_call_list cs n \\<Longrightarrow> valid_path_rev_aux [] (rev cs)\"", "lemma vpa_upd_cs_cases:\n  \"\\<lbrakk>valid_path_aux cs as; valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case (upd_cs cs as) of [] \\<Rightarrow> (\\<forall>c \\<in> set cs. \\<exists>a \\<in> set as. a \\<in> get_return_edges c)\n                      | cx#csx \\<Rightarrow> valid_call_list (cx#csx) n'\"", "lemma vpa_valid_call_list_valid_return_list_vpra:\n  \"\\<lbrakk>valid_path_aux cs cs'; valid_call_list cs n; valid_return_list cs' n'\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' (rev cs)\"", "lemma vpa_to_vpra:\n  \"\\<lbrakk>valid_path_aux cs as; valid_path_aux (upd_cs cs as) cs'; \n    n -as\\<rightarrow>* n'; valid_call_list cs n; valid_return_list cs' n''\\<rbrakk> \n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and> valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\"", "lemma vp_to_vpra:\n  \"n -as\\<rightarrow>\\<^sub>\\<surd>* n' \\<Longrightarrow> valid_path_rev_aux [] as\"", "lemma slpa_induct [consumes 1,case_names slpa_empty slpa_intra slpa_Call \n  slpa_Return]:\n  assumes major: \"same_level_path_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); same_level_path_aux cs as; P cs as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q r p fs. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; same_level_path_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q p f c' cs'. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c'#cs'; same_level_path_aux cs' as;\n                             a \\<in> get_return_edges c'; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (a#as)\"\n  shows \"P xs ys\"", "lemma slpa_cases [consumes 4,case_names intra_path return_intra_path]:\n  assumes \"same_level_path_aux cs as\" and \"upd_cs cs as = []\"\n  and \"\\<forall>c \\<in> set cs. valid_edge c\" and \"\\<forall>a \\<in> set as. valid_edge a\"\n  obtains \"\\<forall>a \\<in> set as. intra_kind(kind a)\"\n  | asx a asx' Q p f c' cs' where \"as = asx@a#asx'\" and \"same_level_path_aux cs asx\"\n    and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"upd_cs cs asx = c'#cs'\" and \"upd_cs cs (asx@[a]) = []\" \n    and \"a \\<in> get_return_edges c'\" and \"valid_edge c'\"\n    and \"\\<forall>a \\<in> set asx'. intra_kind(kind a)\"", "lemma same_level_path_aux_valid_path_aux: \n  \"same_level_path_aux cs as \\<Longrightarrow> valid_path_aux cs as\"", "lemma same_level_path_aux_Append:\n  \"\\<lbrakk>same_level_path_aux cs as; same_level_path_aux (upd_cs cs as) as'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs (as@as')\"", "lemma same_level_path_aux_callstack_Append:\n  \"same_level_path_aux cs as \\<Longrightarrow> same_level_path_aux (cs@cs') as\"", "lemma same_level_path_upd_cs_callstack_Append:\n  \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = cs'\\<rbrakk> \n  \\<Longrightarrow> upd_cs (cs@cs'') as = (cs'@cs'')\"", "lemma slpa_split:\n  assumes \"same_level_path_aux cs as\" and \"as = xs@ys\" and \"upd_cs cs xs = []\"\n  shows \"same_level_path_aux cs xs\" and \"same_level_path_aux [] ys\"", "lemma slpa_number_Calls_eq_number_Returns:\n  \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = []; \n    \\<forall>a \\<in> set as. valid_edge a; \\<forall>c \\<in> set cs. valid_edge c\\<rbrakk>\n  \\<Longrightarrow> length [a\\<leftarrow>as@cs. \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs] = \n     length [a\\<leftarrow>as. \\<exists>Q p f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f]\"", "lemma slpa_get_proc:\n  \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = []; n -as\\<rightarrow>* n'; \n    \\<forall>c \\<in> set cs. valid_edge c\\<rbrakk>\n  \\<Longrightarrow> (if cs = [] then get_proc n else get_proc(last(sourcenodes cs))) = get_proc n'\"", "lemma slpa_get_return_edges:\n  \"\\<lbrakk>same_level_path_aux cs as; cs \\<noteq> []; upd_cs cs as = [];\n  \\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last cs)\"", "lemma slpa_callstack_length:\n  assumes \"same_level_path_aux cs as\" and \"length cs = length cfsx\"\n  obtains cfx cfsx' where \"transfers (kinds as) (cfsx@cf#cfs) = cfsx'@cfx#cfs\"\n  and \"transfers (kinds as) (cfsx@cf#cfs') = cfsx'@cfx#cfs'\"\n  and \"length cfsx' = length (upd_cs cs as)\"", "lemma slpa_snoc_intra:\n  \"\\<lbrakk>same_level_path_aux cs as; intra_kind (kind a)\\<rbrakk> \n  \\<Longrightarrow> same_level_path_aux cs (as@[a])\"", "lemma slpa_snoc_Call:\n  \"\\<lbrakk>same_level_path_aux cs as; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs (as@[a])\"", "lemma vpa_Main_slpa:\n  \"\\<lbrakk>valid_path_aux cs as; m -as\\<rightarrow>* m'; as \\<noteq> []; \n    valid_call_list cs m; get_proc m' = Main;\n    get_proc (case cs of [] \\<Rightarrow> m | _ \\<Rightarrow> sourcenode (last cs)) = Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = []\"", "lemma same_level_path_valid_path:\n  \"same_level_path as \\<Longrightarrow> valid_path as\"", "lemma same_level_path_Append:\n  \"\\<lbrakk>same_level_path as; same_level_path as'\\<rbrakk> \\<Longrightarrow> same_level_path (as@as')\"", "lemma same_level_path_number_Calls_eq_number_Returns:\n  \"\\<lbrakk>same_level_path as; \\<forall>a \\<in> set as. valid_edge a\\<rbrakk> \\<Longrightarrow> \n  length [a\\<leftarrow>as. \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs] = length [a\\<leftarrow>as. \\<exists>Q p f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f]\"", "lemma same_level_path_valid_path_Append:\n  \"\\<lbrakk>same_level_path as; valid_path as'\\<rbrakk> \\<Longrightarrow> valid_path (as@as')\"", "lemma valid_path_same_level_path_Append:\n  \"\\<lbrakk>valid_path as; same_level_path as'\\<rbrakk> \\<Longrightarrow> valid_path (as@as')\"", "lemma intras_same_level_path:\n  assumes \"\\<forall>a \\<in> set as. intra_kind(kind a)\" shows \"same_level_path as\"", "lemma slp_vp: \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow> n -as\\<rightarrow>\\<^sub>\\<surd>* n'\"", "lemma intra_path_slp: \"n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<Longrightarrow> n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\"", "lemma slp_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n''; n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\"", "lemma slp_vp_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n''; n'' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^sub>\\<surd>* n'\"", "lemma vp_slp_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<surd>* n''; n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^sub>\\<surd>* n'\"", "lemma slp_get_proc:\n  \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow> get_proc n = get_proc n'\"", "lemma same_level_path_inner_path:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\"\n  obtains as' where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\"", "lemma slp_callstack_length_equal:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" obtains cf' where \"transfers (kinds as) (cf#cfs) = cf'#cfs\"\n  and \"transfers (kinds as) (cf#cfs') = cf'#cfs'\"", "lemma slp_cases [consumes 1,case_names intra_path return_intra_path]:\n  assumes \"m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\"\n  obtains \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\"\n  | as' a as'' Q p f where \"as = as'@a#as''\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  and \"m -as'@[a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\" and \"targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'\"", "lemma slpra_induct [consumes 1,case_names slpra_empty slpra_intra slpra_Return\n  slpra_Call]:\n  assumes major: \"same_level_path_rev_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); same_level_path_rev_aux cs as; P cs as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q p f. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; same_level_path_rev_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q r p fs c' cs'. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = c'#cs'; \n                   same_level_path_rev_aux cs' as; c' \\<in> get_return_edges a; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (as@[a])\"\n  shows \"P xs ys\"", "lemma same_level_path_rev_aux_Append:\n  \"\\<lbrakk>same_level_path_rev_aux cs as'; same_level_path_rev_aux (upd_rev_cs cs as') as\\<rbrakk>\n  \\<Longrightarrow> same_level_path_rev_aux cs (as@as')\"", "lemma slpra_to_slpa:\n  \"\\<lbrakk>same_level_path_rev_aux cs as; upd_rev_cs cs as = []; n -as\\<rightarrow>* n'; \n  valid_return_list cs n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and> same_level_path_aux (upd_cs [] as) cs \\<and>\n     upd_cs (upd_cs [] as) cs = []\"", "lemma path_Entry_target [dest]:\n  assumes \"n -as\\<rightarrow>* (_Entry_)\"\n  shows \"n = (_Entry_)\" and \"as = []\"", "lemma Entry_sourcenode_hd:\n  assumes \"n -as\\<rightarrow>* n'\" and \"(_Entry_) \\<in> set (sourcenodes as)\"\n  shows \"n = (_Entry_)\" and \"(_Entry_) \\<notin> set (sourcenodes (tl as))\"", "lemma Entry_no_inner_return_path: \n  assumes \"(_Entry_) -as@[a]\\<rightarrow>* n\" and \"\\<forall>a \\<in> set as. intra_kind(kind a)\"\n  and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  shows \"False\"", "lemma vpra_no_slpra:\n  \"\\<lbrakk>valid_path_rev_aux cs as; n -as\\<rightarrow>* n'; valid_return_list cs n'; cs \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> (\\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f. valid_edge a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\"", "lemma valid_Entry_path_cases:\n  assumes \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\" and \"as \\<noteq> []\"\n  shows \"(\\<exists>a' as'. as = as'@[a'] \\<and> intra_kind(kind a')) \\<or>\n         (\\<exists>a' as' Q r p fs. as = as'@[a'] \\<and> kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n         (\\<exists>as' as'' n'. as = as'@as'' \\<and> as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\"", "lemma valid_Entry_path_ascending_path:\n  assumes \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\"\n  obtains as' where \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n\" \n  and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\"\n  and \"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], "translations": [["", "lemma get_proc_get_return_edge:\n  assumes \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  shows \"get_proc (sourcenode a) = get_proc (targetnode a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "from assms"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain ax where \"valid_edge ax\" and \"sourcenode a = sourcenode ax\"\n    and \"targetnode a' = targetnode ax\" and \"intra_kind(kind ax)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode a = sourcenode ax;\n         targetnode a' = targetnode ax; intra_kind (kind ax)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:call_return_node_edge simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode a' = targetnode ax\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode a' = targetnode ax\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "by(fastforce intro:get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma call_intra_edge_False:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"valid_edge a'\" \n  and \"sourcenode a = sourcenode a'\" and \"intra_kind(kind a')\"\n  shows \"kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain ax where \"ax \\<in> get_return_edges a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        ax \\<in> get_return_edges a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:get_return_edge_call)"], ["proof (state)\nthis:\n  ax \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  ax \\<in> get_return_edges a", "obtain a'' where \"valid_edge a''\" \n    and \"sourcenode a'' = sourcenode a\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  ax \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = sourcenode a;\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. intra_kind (kind a'')", "by(simp add:intra_kind_def)"], ["proof (state)\nthis:\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with assms \\<open>valid_edge a''\\<close> \\<open>sourcenode a'' = sourcenode a\\<close> \n    \\<open>kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  sourcenode a = sourcenode a'\n  intra_kind (kind a')\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  intra_kind (kind a'')", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  sourcenode a = sourcenode a'\n  intra_kind (kind a')\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by(fastforce dest:call_only_one_intra_edge)"], ["proof (state)\nthis:\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma formal_in_THE: \n  \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; (p,ins,outs) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs) = ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     (p, ins, outs) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> (THE ins.\n                          \\<exists>outs. (p, ins, outs) \\<in> set procs) =\n                      ins", "by(fastforce dest:distinct_fst_isin_same_fst intro:unique_callers)"], ["", "lemma formal_out_THE: \n  \"\\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; (p,ins,outs) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE outs. \\<exists>ins. (p,ins,outs) \\<in> set procs) = outs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     (p, ins, outs) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> (THE outs.\n                          \\<exists>ins. (p, ins, outs) \\<in> set procs) =\n                      outs", "by(fastforce dest:distinct_fst_isin_same_fst intro:unique_callers)"], ["", "subsubsection \\<open>Transfer and predicate functions\\<close>"], ["", "fun params :: \"(('var \\<rightharpoonup> 'val) \\<rightharpoonup> 'val) list \\<Rightarrow> ('var \\<rightharpoonup> 'val) \\<Rightarrow> 'val option list\"\nwhere \"params [] cf = []\"\n  | \"params (f#fs) cf = (f cf)#params fs cf\""], ["", "lemma params_nth: \n  \"i < length fs \\<Longrightarrow> (params fs cf)!i = (fs!i) cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> params fs cf ! i = (fs ! i) cf", "by(induct fs arbitrary:i,auto,case_tac i,auto)"], ["", "lemma [simp]:\"length (params fs cf) = length fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (params fs cf) = length fs", "by(induct fs) auto"], ["", "fun transfer :: \"('var,'val,'ret,'pname) edge_kind \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> \n  (('var \\<rightharpoonup> 'val) \\<times> 'ret) list\"\nwhere \"transfer (\\<Up>f) (cf#cfs)    = (f (fst cf),snd cf)#cfs\"\n  | \"transfer (Q)\\<^sub>\\<surd> (cf#cfs)      = (cf#cfs)\"\n  | \"transfer (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) (cf#cfs) = \n       (let ins = THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs in\n                            (Map.empty(ins [:=] params fs (fst cf)),r)#cf#cfs)\"\n  | \"transfer (Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f )(cf#cfs)    = (case cfs of [] \\<Rightarrow> []\n                                 | cf'#cfs' \\<Rightarrow> (f (fst cf) (fst cf'),snd cf')#cfs')\"\n  | \"transfer et [] = []\""], ["", "fun transfers :: \"('var,'val,'ret,'pname) edge_kind list \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow>\n                  (('var \\<rightharpoonup> 'val) \\<times> 'ret) list\"\nwhere \"transfers [] s   = s\"\n  | \"transfers (et#ets) s = transfers ets (transfer et s)\""], ["", "fun pred :: \"('var,'val,'ret,'pname) edge_kind \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> bool\"\nwhere \"pred (\\<Up>f) (cf#cfs) = True\"\n  | \"pred (Q)\\<^sub>\\<surd> (cf#cfs)   = Q (fst cf)\"\n  | \"pred (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) (cf#cfs) = Q (fst cf,r)\"\n  | \"pred (Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) (cf#cfs) = (Q cf \\<and> cfs \\<noteq> [])\"\n  | \"pred et [] = False\""], ["", "fun preds :: \"('var,'val,'ret,'pname) edge_kind list \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> bool\"\nwhere \"preds [] s   = True\"\n  | \"preds (et#ets) s = (pred et s \\<and> preds ets (transfer et s))\""], ["", "lemma transfers_split:\n  \"(transfers (ets@ets') s) = (transfers ets' (transfers ets s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (ets @ ets') s = transfers ets' (transfers ets s)", "by(induct ets arbitrary:s) auto"], ["", "lemma preds_split:\n  \"(preds (ets@ets') s) = (preds ets s \\<and> preds ets' (transfers ets s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preds (ets @ ets') s = (preds ets s \\<and> preds ets' (transfers ets s))", "by(induct ets arbitrary:s) auto"], ["", "abbreviation state_val :: \"(('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> 'var \\<rightharpoonup> 'val\"\n  where \"state_val s V \\<equiv> (fst (hd s)) V\""], ["", "subsubsection \\<open>\\<open>valid_node\\<close>\\<close>"], ["", "definition valid_node :: \"'node \\<Rightarrow> bool\"\n  where \"valid_node n \\<equiv> \n  (\\<exists>a. valid_edge a \\<and> (n = sourcenode a \\<or> n = targetnode a))\""], ["", "lemma [simp]: \"valid_edge a \\<Longrightarrow> valid_node (sourcenode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge a \\<Longrightarrow> valid_node (sourcenode a)", "by(fastforce simp:valid_node_def)"], ["", "lemma [simp]: \"valid_edge a \\<Longrightarrow> valid_node (targetnode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge a \\<Longrightarrow> valid_node (targetnode a)", "by(fastforce simp:valid_node_def)"], ["", "subsection \\<open>CFG paths\\<close>"], ["", "inductive path :: \"'node \\<Rightarrow> 'edge list \\<Rightarrow> 'node \\<Rightarrow> bool\"\n  (\"_ -_\\<rightarrow>* _\" [51,0,0] 80)\nwhere \n  empty_path:\"valid_node n \\<Longrightarrow> n -[]\\<rightarrow>* n\"\n\n  | Cons_path:\n  \"\\<lbrakk>n'' -as\\<rightarrow>* n'; valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n    \\<Longrightarrow> n -a#as\\<rightarrow>* n'\""], ["", "lemma path_valid_node:\n  assumes \"n -as\\<rightarrow>* n'\" shows \"valid_node n\" and \"valid_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node n &&& valid_node n'", "using \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_node n &&& valid_node n'", "by(induct rule:path.induct,auto)"], ["", "lemma empty_path_nodes [dest]:\"n -[]\\<rightarrow>* n' \\<Longrightarrow> n = n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* n' \\<Longrightarrow> n = n'", "by(fastforce elim:path.cases)"], ["", "lemma path_valid_edges:\"n -as\\<rightarrow>* n' \\<Longrightarrow> \\<forall>a \\<in> set as. valid_edge a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* n' \\<Longrightarrow>\n    \\<forall>a\\<in>set as. valid_edge a", "by(induct rule:path.induct) auto"], ["", "lemma path_edge:\"valid_edge a \\<Longrightarrow> sourcenode a -[a]\\<rightarrow>* targetnode a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge a \\<Longrightarrow>\n    sourcenode a -[a]\\<rightarrow>* targetnode a", "by(fastforce intro:Cons_path empty_path)"], ["", "lemma path_Append:\"\\<lbrakk>n -as\\<rightarrow>* n''; n'' -as'\\<rightarrow>* n'\\<rbrakk> \n  \\<Longrightarrow> n -as@as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n''; n'' -as'\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> n -as @ as'\\<rightarrow>* n'", "by(induct rule:path.induct,auto intro:Cons_path)"], ["", "lemma path_split:\n  assumes \"n -as@a#as'\\<rightarrow>* n'\"\n  shows \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\" and \"targetnode a -as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&&\n    valid_edge a &&& targetnode a -as'\\<rightarrow>* n'", "using \\<open>n -as@a#as'\\<rightarrow>* n'\\<close>"], ["proof (prove)\nusing this:\n  n -as @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&&\n    valid_edge a &&& targetnode a -as'\\<rightarrow>* n'", "proof(induct as arbitrary:n)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       n -[]\\<rightarrow>* sourcenode a\n 2. \\<And>n. n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n 3. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 5. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 6. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       n -[]\\<rightarrow>* sourcenode a\n 2. \\<And>n. n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n 3. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 5. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 6. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case 1"], ["proof (state)\nthis:\n  n -[] @ a # as'\\<rightarrow>* n'\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       n -[]\\<rightarrow>* sourcenode a\n 2. \\<And>n. n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n 3. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 5. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 6. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n -[] @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* sourcenode a", "by(fastforce elim:path.cases intro:empty_path)"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* sourcenode a\n\ngoal (5 subgoals):\n 1. \\<And>n. n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n 2. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 5. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n. n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n 2. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 5. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>n. n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n 2. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 5. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case 2"], ["proof (state)\nthis:\n  n -[] @ a # as'\\<rightarrow>* n'\n\ngoal (5 subgoals):\n 1. \\<And>n. n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n 2. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 5. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n -[] @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_edge a", "by(fastforce elim:path.cases intro:path_edge)"], ["proof (state)\nthis:\n  valid_edge a\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case 3"], ["proof (state)\nthis:\n  n -[] @ a # as'\\<rightarrow>* n'\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       n -[] @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n       targetnode a -as'\\<rightarrow>* n'\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 4. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n -[] @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. targetnode a -as'\\<rightarrow>* n'", "by(fastforce elim:path.cases)"], ["proof (state)\nthis:\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case (Cons ax asx)"], ["proof (state)\nthis:\n  ?n -asx @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n  ?n -asx\\<rightarrow>* sourcenode a\n  ?n -asx @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n  ?n -asx @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "note IH1 = \\<open>\\<And>n. n -asx@a#as'\\<rightarrow>* n' \\<Longrightarrow> n -asx\\<rightarrow>* sourcenode a\\<close>"], ["proof (state)\nthis:\n  ?n -asx @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n  ?n -asx\\<rightarrow>* sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "note IH2 = \\<open>\\<And>n. n -asx@a#as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\\<close>"], ["proof (state)\nthis:\n  ?n -asx @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "note IH3 = \\<open>\\<And>n. n -asx@a#as'\\<rightarrow>* n' \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'\\<close>"], ["proof (state)\nthis:\n  ?n -asx @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "{"], ["proof (state)\nthis:\n  ?n -asx @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case 1"], ["proof (state)\nthis:\n  n -(ax # asx) @ a # as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "hence \"sourcenode ax = n\" and \"targetnode ax -asx@a#as'\\<rightarrow>* n'\" and \"valid_edge ax\""], ["proof (prove)\nusing this:\n  n -(ax # asx) @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode ax = n &&&\n    targetnode ax -asx @ a # as'\\<rightarrow>* n' &&& valid_edge ax", "by(auto elim:path.cases)"], ["proof (state)\nthis:\n  sourcenode ax = n\n  targetnode ax -asx @ a # as'\\<rightarrow>* n'\n  valid_edge ax\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "from IH1[OF \\<open> targetnode ax -asx@a#as'\\<rightarrow>* n'\\<close>]"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>* sourcenode a", "have \"targetnode ax -asx\\<rightarrow>* sourcenode a\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>* sourcenode a\n\ngoal (1 subgoal):\n 1. targetnode ax -asx\\<rightarrow>* sourcenode a", "."], ["proof (state)\nthis:\n  targetnode ax -asx\\<rightarrow>* sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> n -aa # as\\<rightarrow>* sourcenode a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 3. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "with \\<open>sourcenode ax = n\\<close> \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax = n\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* sourcenode a", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode ax = n\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* sourcenode a\n\ngoal (1 subgoal):\n 1. n -ax # asx\\<rightarrow>* sourcenode a", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  n -ax # asx\\<rightarrow>* sourcenode a\n\ngoal (2 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case 2"], ["proof (state)\nthis:\n  n -(ax # asx) @ a # as'\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "hence \"targetnode ax -asx@a#as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -(ax # asx) @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. targetnode ax -asx @ a # as'\\<rightarrow>* n'", "by(auto elim:path.cases)"], ["proof (state)\nthis:\n  targetnode ax -asx @ a # as'\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> valid_edge a\n 2. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_edge a", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_edge a", "."], ["proof (state)\nthis:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "case 3"], ["proof (state)\nthis:\n  n -(ax # asx) @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "hence \"targetnode ax -asx@a#as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -(ax # asx) @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. targetnode ax -asx @ a # as'\\<rightarrow>* n'", "by(auto elim:path.cases)"], ["proof (state)\nthis:\n  targetnode ax -asx @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>aa as n.\n       \\<lbrakk>\\<And>n.\n                   n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n                   n -as\\<rightarrow>* sourcenode a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow> valid_edge a;\n        \\<And>n.\n           n -as @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n           targetnode a -as'\\<rightarrow>* n';\n        n -(aa # as) @ a # as'\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a -as'\\<rightarrow>* n'", "from IH3[OF this]"], ["proof (chain)\npicking this:\n  targetnode a -as'\\<rightarrow>* n'", "show ?case"], ["proof (prove)\nusing this:\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. targetnode a -as'\\<rightarrow>* n'", "."], ["proof (state)\nthis:\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?na2 -(ax # asx) @ a # as'\\<rightarrow>* n' \\<Longrightarrow>\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_split_Cons:\n  assumes \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = a'#as'\" and \"n = sourcenode a'\"\n  and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; n = sourcenode a'; valid_edge a';\n         targetnode a' -as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>* n'", "from \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []", "obtain a' as' where \"as = a'#as'\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'. as = a' # as' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases as) auto"], ["proof (state)\nthis:\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>* n'", "with \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = a' # as'", "have \"n -[]@a'#as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. n -[] @ a' # as'\\<rightarrow>* n'", "by simp"], ["proof (state)\nthis:\n  n -[] @ a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>* n'", "hence \"n -[]\\<rightarrow>* sourcenode a'\" and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -[] @ a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(rule path_split)+"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>* n'", "from \\<open>n -[]\\<rightarrow>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  n -[]\\<rightarrow>* sourcenode a'", "have \"n = sourcenode a'\""], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* sourcenode a'\n\ngoal (1 subgoal):\n 1. n = sourcenode a'", "by fast"], ["proof (state)\nthis:\n  n = sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>* n'", "with \\<open>as = a'#as'\\<close> \\<open>valid_edge a'\\<close> \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n  n = sourcenode a'", "show \"\\<exists>a' as'. as = a'#as' \\<and> n = sourcenode a' \\<and> valid_edge a' \\<and> \n                 targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n  n = sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' as'.\n     as = a' # as' \\<and>\n     n = sourcenode a' \\<and>\n     valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_split_snoc:\n  assumes \"n -as\\<rightarrow>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>* sourcenode a'\"\n  and \"valid_edge a'\" and \"n' = targetnode a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        \\<lbrakk>as = as' @ [a']; n -as'\\<rightarrow>* sourcenode a';\n         valid_edge a'; n' = targetnode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "from \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []", "obtain a' as' where \"as = as'@[a']\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        as = as' @ [a'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases as rule:rev_cases) auto"], ["proof (state)\nthis:\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "with \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = as' @ [a']", "have \"n -as'@a'#[]\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. n -as' @ [a']\\<rightarrow>* n'", "by simp"], ["proof (state)\nthis:\n  n -as' @ [a']\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "hence \"n -as'\\<rightarrow>* sourcenode a'\" and \"valid_edge a'\" and \"targetnode a' -[]\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as' @ [a']\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>* sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -[]\\<rightarrow>* n'", "by(rule path_split)+"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  targetnode a' -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "from \\<open>targetnode a' -[]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -[]\\<rightarrow>* n'", "have \"n' = targetnode a'\""], ["proof (prove)\nusing this:\n  targetnode a' -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n' = targetnode a'", "by fast"], ["proof (state)\nthis:\n  n' = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "with \\<open>as = as'@[a']\\<close> \\<open>valid_edge a'\\<close> \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  valid_edge a'\n  n -as'\\<rightarrow>* sourcenode a'\n  n' = targetnode a'", "show \"\\<exists>as' a'. as = as'@[a'] \\<and> n -as'\\<rightarrow>* sourcenode a' \\<and> valid_edge a' \\<and> \n                 n' = targetnode a'\""], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  valid_edge a'\n  n -as'\\<rightarrow>* sourcenode a'\n  n' = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as' a'.\n     as = as' @ [a'] \\<and>\n     n -as'\\<rightarrow>* sourcenode a' \\<and>\n     valid_edge a' \\<and> n' = targetnode a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_split_second:\n  assumes \"n -as@a#as'\\<rightarrow>* n'\" shows \"sourcenode a -a#as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* n'", "from \\<open>n -as@a#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ a # as'\\<rightarrow>* n'", "have \"valid_edge a\" and \"targetnode a -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as @ a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_edge a &&& targetnode a -as'\\<rightarrow>* n'", "by(auto intro:path_split)"], ["proof (state)\nthis:\n  valid_edge a\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* n'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  sourcenode a -a # as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_Entry_Cons:\n  assumes \"(_Entry_) -as\\<rightarrow>* n'\" and \"n' \\<noteq> (_Entry_)\"\n  obtains n a where \"sourcenode a = (_Entry_)\" and \"targetnode a = n\"\n  and \"n -tl as\\<rightarrow>* n'\" and \"valid_edge a\" and \"a = hd as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n.\n        \\<lbrakk>sourcenode a = (_Entry_); targetnode a = n;\n         n -tl as\\<rightarrow>* n'; valid_edge a; a = hd as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a n.\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = n \\<and>\n       n -tl as\\<rightarrow>* n' \\<and> valid_edge a \\<and> a = hd as", "from \\<open>(_Entry_) -as\\<rightarrow>* n'\\<close> \\<open>n' \\<noteq> (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n'\n  n' \\<noteq> (_Entry_)", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n'\n  n' \\<noteq> (_Entry_)\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "by(cases as,auto elim:path.cases)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>a n.\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = n \\<and>\n       n -tl as\\<rightarrow>* n' \\<and> valid_edge a \\<and> a = hd as", "with \\<open>(_Entry_) -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n'\n  as \\<noteq> []", "obtain a' as' where \"as = a'#as'\" \n    and \"(_Entry_) = sourcenode a'\" and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n'\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; (_Entry_) = sourcenode a'; valid_edge a';\n         targetnode a' -as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule path_split_Cons)"], ["proof (state)\nthis:\n  as = a' # as'\n  (_Entry_) = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>a n.\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = n \\<and>\n       n -tl as\\<rightarrow>* n' \\<and> valid_edge a \\<and> a = hd as", "thus \"\\<exists>a n. sourcenode a = (_Entry_) \\<and> targetnode a = n \\<and> n -tl as\\<rightarrow>* n' \\<and> \n              valid_edge a \\<and> a = hd as\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  (_Entry_) = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>a n.\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = n \\<and>\n       n -tl as\\<rightarrow>* n' \\<and> valid_edge a \\<and> a = hd as", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a n.\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = n \\<and>\n     n -tl as\\<rightarrow>* n' \\<and> valid_edge a \\<and> a = hd as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_det:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; n -as\\<rightarrow>* n''\\<rbrakk> \\<Longrightarrow> n' = n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n'; n -as\\<rightarrow>* n''\\<rbrakk>\n    \\<Longrightarrow> n' = n''", "proof(induct as arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; n -[]\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "case Nil"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n  n -[]\\<rightarrow>* n''\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; n -[]\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "thus ?case"], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n  n -[]\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. n' = n''", "by(auto elim:path.cases)"], ["proof (state)\nthis:\n  n' = n''\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "case (Cons a' as')"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as'\\<rightarrow>* n'; ?n -as'\\<rightarrow>* n''\\<rbrakk>\n  \\<Longrightarrow> n' = n''\n  n -a' # as'\\<rightarrow>* n'\n  n -a' # as'\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "note IH = \\<open>\\<And>n. \\<lbrakk>n -as'\\<rightarrow>* n'; n -as'\\<rightarrow>* n''\\<rbrakk> \\<Longrightarrow> n' = n''\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as'\\<rightarrow>* n'; ?n -as'\\<rightarrow>* n''\\<rbrakk>\n  \\<Longrightarrow> n' = n''\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "from \\<open>n -a'#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n'", "have \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. targetnode a' -as'\\<rightarrow>* n'", "by(fastforce elim:path_split_Cons)"], ["proof (state)\nthis:\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "from \\<open>n -a'#as'\\<rightarrow>* n''\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n''", "have \"targetnode a' -as'\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. targetnode a' -as'\\<rightarrow>* n''", "by(fastforce elim:path_split_Cons)"], ["proof (state)\nthis:\n  targetnode a' -as'\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    n -as\\<rightarrow>* n''\\<rbrakk>\n                   \\<Longrightarrow> n' = n'';\n        n -a # as\\<rightarrow>* n'; n -a # as\\<rightarrow>* n''\\<rbrakk>\n       \\<Longrightarrow> n' = n''", "from IH[OF \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close> this]"], ["proof (chain)\npicking this:\n  n' = n''", "show ?thesis"], ["proof (prove)\nusing this:\n  n' = n''\n\ngoal (1 subgoal):\n 1. n' = n''", "."], ["proof (state)\nthis:\n  n' = n''\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  sourcenodes :: \"'edge list \\<Rightarrow> 'node list\"\n  where \"sourcenodes xs \\<equiv> map sourcenode xs\""], ["", "definition\n  kinds :: \"'edge list \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind list\"\n  where \"kinds xs \\<equiv> map kind xs\""], ["", "definition\n  targetnodes :: \"'edge list \\<Rightarrow> 'node list\"\n  where \"targetnodes xs \\<equiv> map targetnode xs\""], ["", "lemma path_sourcenode:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd (sourcenodes as) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd (sourcenodes as) = n", "by(fastforce elim:path_split_Cons simp:sourcenodes_def)"], ["", "lemma path_targetnode:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> last (targetnodes as) = n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (targetnodes as) = n'", "by(fastforce elim:path_split_snoc simp:targetnodes_def)"], ["", "lemma sourcenodes_is_n_Cons_butlast_targetnodes:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  sourcenodes as = n#(butlast (targetnodes as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> sourcenodes as = n # butlast (targetnodes as)", "proof(induct as arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes [] = n # butlast (targetnodes [])\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> sourcenodes as =\n                                     n # butlast (targetnodes as);\n        n -a # as\\<rightarrow>* n'; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes (a # as) =\n                         n # butlast (targetnodes (a # as))", "case Nil"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes [] = n # butlast (targetnodes [])\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> sourcenodes as =\n                                     n # butlast (targetnodes as);\n        n -a # as\\<rightarrow>* n'; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes (a # as) =\n                         n # butlast (targetnodes (a # as))", "thus ?case"], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. sourcenodes [] = n # butlast (targetnodes [])", "by simp"], ["proof (state)\nthis:\n  sourcenodes [] = n # butlast (targetnodes [])\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> sourcenodes as =\n                                     n # butlast (targetnodes as);\n        n -a # as\\<rightarrow>* n'; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes (a # as) =\n                         n # butlast (targetnodes (a # as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> sourcenodes as =\n                                     n # butlast (targetnodes as);\n        n -a # as\\<rightarrow>* n'; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes (a # as) =\n                         n # butlast (targetnodes (a # as))", "case (Cons a' as')"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as'\\<rightarrow>* n'; as' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> sourcenodes as' = ?n # butlast (targetnodes as')\n  n -a' # as'\\<rightarrow>* n'\n  a' # as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> sourcenodes as =\n                                     n # butlast (targetnodes as);\n        n -a # as\\<rightarrow>* n'; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes (a # as) =\n                         n # butlast (targetnodes (a # as))", "note IH = \\<open>\\<And>n. \\<lbrakk>n -as'\\<rightarrow>* n'; as' \\<noteq> []\\<rbrakk>\n            \\<Longrightarrow> sourcenodes as' = n#(butlast (targetnodes as'))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as'\\<rightarrow>* n'; as' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> sourcenodes as' = ?n # butlast (targetnodes as')\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> sourcenodes as =\n                                     n # butlast (targetnodes as);\n        n -a # as\\<rightarrow>* n'; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes (a # as) =\n                         n # butlast (targetnodes (a # as))", "from \\<open>n -a'#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n'", "have \"n = sourcenode a'\" and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> sourcenodes as =\n                                     n # butlast (targetnodes as);\n        n -a # as\\<rightarrow>* n'; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sourcenodes (a # as) =\n                         n # butlast (targetnodes (a # as))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "with \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -as'\\<rightarrow>* n'\n  as' = []", "have \"targetnode a' = n'\""], ["proof (prove)\nusing this:\n  targetnode a' -as'\\<rightarrow>* n'\n  as' = []\n\ngoal (1 subgoal):\n 1. targetnode a' = n'", "by fast"], ["proof (state)\nthis:\n  targetnode a' = n'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "with True \\<open>n = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  as' = []\n  n = sourcenode a'\n  targetnode a' = n'", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = []\n  n = sourcenode a'\n  targetnode a' = n'\n\ngoal (1 subgoal):\n 1. sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "by(simp add:sourcenodes_def targetnodes_def)"], ["proof (state)\nthis:\n  sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "from IH[OF \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close> this]"], ["proof (chain)\npicking this:\n  sourcenodes as' = targetnode a' # butlast (targetnodes as')", "have \"sourcenodes as' = targetnode a' # butlast (targetnodes as')\""], ["proof (prove)\nusing this:\n  sourcenodes as' = targetnode a' # butlast (targetnodes as')\n\ngoal (1 subgoal):\n 1. sourcenodes as' = targetnode a' # butlast (targetnodes as')", "."], ["proof (state)\nthis:\n  sourcenodes as' = targetnode a' # butlast (targetnodes as')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "with \\<open>n = sourcenode a'\\<close> False"], ["proof (chain)\npicking this:\n  n = sourcenode a'\n  as' \\<noteq> []\n  sourcenodes as' = targetnode a' # butlast (targetnodes as')", "show ?thesis"], ["proof (prove)\nusing this:\n  n = sourcenode a'\n  as' \\<noteq> []\n  sourcenodes as' = targetnode a' # butlast (targetnodes as')\n\ngoal (1 subgoal):\n 1. sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))", "by(simp add:sourcenodes_def targetnodes_def)"], ["proof (state)\nthis:\n  sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenodes (a' # as') = n # butlast (targetnodes (a' # as'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma targetnodes_is_tl_sourcenodes_App_n':\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n    targetnodes as = (tl (sourcenodes as))@[n']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n'; as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> targetnodes as = tl (sourcenodes as) @ [n']", "proof(induct as arbitrary:n' rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes [] = tl (sourcenodes []) @ [n']\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>n -xs\\<rightarrow>* n'; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> targetnodes xs =\n                                     tl (sourcenodes xs) @ [n'];\n        n -xs @ [x]\\<rightarrow>* n'; xs @ [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes (xs @ [x]) =\n                         tl (sourcenodes (xs @ [x])) @ [n']", "case Nil"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes [] = tl (sourcenodes []) @ [n']\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>n -xs\\<rightarrow>* n'; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> targetnodes xs =\n                                     tl (sourcenodes xs) @ [n'];\n        n -xs @ [x]\\<rightarrow>* n'; xs @ [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes (xs @ [x]) =\n                         tl (sourcenodes (xs @ [x])) @ [n']", "thus ?case"], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. targetnodes [] = tl (sourcenodes []) @ [n']", "by simp"], ["proof (state)\nthis:\n  targetnodes [] = tl (sourcenodes []) @ [n']\n\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>n -xs\\<rightarrow>* n'; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> targetnodes xs =\n                                     tl (sourcenodes xs) @ [n'];\n        n -xs @ [x]\\<rightarrow>* n'; xs @ [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes (xs @ [x]) =\n                         tl (sourcenodes (xs @ [x])) @ [n']", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>n -xs\\<rightarrow>* n'; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> targetnodes xs =\n                                     tl (sourcenodes xs) @ [n'];\n        n -xs @ [x]\\<rightarrow>* n'; xs @ [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes (xs @ [x]) =\n                         tl (sourcenodes (xs @ [x])) @ [n']", "case (snoc a' as')"], ["proof (state)\nthis:\n  \\<lbrakk>n -as'\\<rightarrow>* ?n'; as' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> targetnodes as' = tl (sourcenodes as') @ [?n']\n  n -as' @ [a']\\<rightarrow>* n'\n  as' @ [a'] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>n -xs\\<rightarrow>* n'; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> targetnodes xs =\n                                     tl (sourcenodes xs) @ [n'];\n        n -xs @ [x]\\<rightarrow>* n'; xs @ [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes (xs @ [x]) =\n                         tl (sourcenodes (xs @ [x])) @ [n']", "note IH = \\<open>\\<And>n'. \\<lbrakk>n -as'\\<rightarrow>* n'; as' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> targetnodes as' = tl (sourcenodes as') @ [n']\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n -as'\\<rightarrow>* ?n'; as' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> targetnodes as' = tl (sourcenodes as') @ [?n']\n\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>n -xs\\<rightarrow>* n'; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> targetnodes xs =\n                                     tl (sourcenodes xs) @ [n'];\n        n -xs @ [x]\\<rightarrow>* n'; xs @ [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes (xs @ [x]) =\n                         tl (sourcenodes (xs @ [x])) @ [n']", "from \\<open>n -as'@[a']\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as' @ [a']\\<rightarrow>* n'", "have \"n -as'\\<rightarrow>* sourcenode a'\" and \"n' = targetnode a'\""], ["proof (prove)\nusing this:\n  n -as' @ [a']\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>* sourcenode a' &&& n' = targetnode a'", "by(auto elim:path_split_snoc)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* sourcenode a'\n  n' = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>n -xs\\<rightarrow>* n'; xs \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> targetnodes xs =\n                                     tl (sourcenodes xs) @ [n'];\n        n -xs @ [x]\\<rightarrow>* n'; xs @ [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> targetnodes (xs @ [x]) =\n                         tl (sourcenodes (xs @ [x])) @ [n']", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "with \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* sourcenode a'\n  as' = []", "have \"n = sourcenode a'\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* sourcenode a'\n  as' = []\n\ngoal (1 subgoal):\n 1. n = sourcenode a'", "by fast"], ["proof (state)\nthis:\n  n = sourcenode a'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "with True \\<open>n' = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  as' = []\n  n' = targetnode a'\n  n = sourcenode a'", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = []\n  n' = targetnode a'\n  n = sourcenode a'\n\ngoal (1 subgoal):\n 1. targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "by(simp add:sourcenodes_def targetnodes_def)"], ["proof (state)\nthis:\n  targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "from IH[OF \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close> this]"], ["proof (chain)\npicking this:\n  targetnodes as' = tl (sourcenodes as') @ [sourcenode a']", "have \"targetnodes as' = tl (sourcenodes as')@[sourcenode a']\""], ["proof (prove)\nusing this:\n  targetnodes as' = tl (sourcenodes as') @ [sourcenode a']\n\ngoal (1 subgoal):\n 1. targetnodes as' = tl (sourcenodes as') @ [sourcenode a']", "."], ["proof (state)\nthis:\n  targetnodes as' = tl (sourcenodes as') @ [sourcenode a']\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "with \\<open>n' = targetnode a'\\<close> False"], ["proof (chain)\npicking this:\n  n' = targetnode a'\n  as' \\<noteq> []\n  targetnodes as' = tl (sourcenodes as') @ [sourcenode a']", "show ?thesis"], ["proof (prove)\nusing this:\n  n' = targetnode a'\n  as' \\<noteq> []\n  targetnodes as' = tl (sourcenodes as') @ [sourcenode a']\n\ngoal (1 subgoal):\n 1. targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']", "by(simp add:sourcenodes_def targetnodes_def)"], ["proof (state)\nthis:\n  targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnodes (as' @ [a']) = tl (sourcenodes (as' @ [a'])) @ [n']\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Intraprocedural paths\\<close>"], ["", "definition intra_path :: \"'node \\<Rightarrow> 'edge list \\<Rightarrow> 'node \\<Rightarrow> bool\" \n  (\"_ -_\\<rightarrow>\\<^sub>\\<iota>* _\" [51,0,0] 80)\nwhere \"n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<equiv> n -as\\<rightarrow>* n' \\<and> (\\<forall>a \\<in> set as. intra_kind(kind a))\""], ["", "lemma intra_path_get_procs:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" shows \"get_proc n = get_proc n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc n = get_proc n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_proc n = get_proc n'", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -as\\<rightarrow>* n'\" and \"\\<forall>a \\<in> set as. intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* n' &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc n'", "proof(induct as arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n -[]\\<rightarrow>* n';\n        \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "case Nil"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n -[]\\<rightarrow>* n';\n        \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'\n 2. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "thus ?case"], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc n'", "by fastforce"], ["proof (state)\nthis:\n  get_proc n = get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "case (Cons a' as')"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as'\\<rightarrow>* n';\n   \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> get_proc ?n = get_proc n'\n  n -a' # as'\\<rightarrow>* n'\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "note IH = \\<open>\\<And>n. \\<lbrakk>n -as'\\<rightarrow>* n'; \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n      \\<Longrightarrow> get_proc n = get_proc n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?n -as'\\<rightarrow>* n';\n   \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> get_proc ?n = get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "from \\<open>\\<forall>a\\<in>set (a'#as'). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)", "have \"intra_kind(kind a')\" and \"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a') &&& \\<forall>a\\<in>set as'. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "from \\<open>n -a'#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n'", "have \"sourcenode a' = n\" and \"valid_edge a'\"\n      and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a' = n &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto elim:path.cases)"], ["proof (state)\nthis:\n  sourcenode a' = n\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "from IH[OF \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close> \\<open>\\<forall>a\\<in>set as'. intra_kind (kind a)\\<close>]"], ["proof (chain)\npicking this:\n  get_proc (targetnode a') = get_proc n'", "have \"get_proc (targetnode a') = get_proc n'\""], ["proof (prove)\nusing this:\n  get_proc (targetnode a') = get_proc n'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a') = get_proc n'", "."], ["proof (state)\nthis:\n  get_proc (targetnode a') = get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "from \\<open>valid_edge a'\\<close> \\<open>intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  intra_kind (kind a')", "have \"get_proc (sourcenode a') = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = get_proc (targetnode a')", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>a as n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>n -as\\<rightarrow>* n';\n                    \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n                   \\<Longrightarrow> get_proc n = get_proc n';\n        n -a # as\\<rightarrow>* n';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc n = get_proc n'", "with \\<open>sourcenode a' = n\\<close> \\<open>get_proc (targetnode a') = get_proc n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = n\n  get_proc (targetnode a') = get_proc n'\n  get_proc (sourcenode a') = get_proc (targetnode a')", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a' = n\n  get_proc (targetnode a') = get_proc n'\n  get_proc (sourcenode a') = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc n'", "by simp"], ["proof (state)\nthis:\n  get_proc n = get_proc n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  get_proc n = get_proc n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intra_path_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* n''; n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* n'';\n     n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\\<rbrakk>\n    \\<Longrightarrow> n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* n'", "by(fastforce intro:path_Append simp:intra_path_def)"], ["", "lemma get_proc_get_return_edges: \n  assumes \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  shows \"get_proc(targetnode a) = get_proc(sourcenode a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc (sourcenode a')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc (sourcenode a')", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = targetnode a\"\n    and \"targetnode a'' = sourcenode a'\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = targetnode a;\n         targetnode a'' = sourcenode a';\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:intra_proc_additional_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc (sourcenode a')", "from \\<open>valid_edge a''\\<close> \\<open>kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"get_proc(sourcenode a'') = get_proc(targetnode a'')\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a'') = get_proc (targetnode a'')", "by(fastforce intro:get_proc_intra simp:intra_kind_def)"], ["proof (state)\nthis:\n  get_proc (sourcenode a'') = get_proc (targetnode a'')\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc (sourcenode a')", "with \\<open>sourcenode a'' = targetnode a\\<close> \\<open>targetnode a'' = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  get_proc (sourcenode a'') = get_proc (targetnode a'')", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  get_proc (sourcenode a'') = get_proc (targetnode a'')\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc (sourcenode a')", "by simp"], ["proof (state)\nthis:\n  get_proc (targetnode a) = get_proc (sourcenode a')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Valid paths\\<close>"], ["", "declare conj_cong[fundef_cong]"], ["", "fun valid_path_aux :: \"'edge list \\<Rightarrow> 'edge list \\<Rightarrow> bool\"\n  where \"valid_path_aux cs [] \\<longleftrightarrow> True\"\n  | \"valid_path_aux cs (a#as) \\<longleftrightarrow> \n       (case (kind a) of Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow> valid_path_aux (a#cs) as\n                       | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow> case cs of [] \\<Rightarrow> valid_path_aux [] as\n                                     | c'#cs' \\<Rightarrow> a \\<in> get_return_edges c' \\<and>\n                                                 valid_path_aux cs' as\n                       |    _ \\<Rightarrow> valid_path_aux cs as)\""], ["", "lemma vpa_induct [consumes 1,case_names vpa_empty vpa_intra vpa_Call vpa_ReturnEmpty\n  vpa_ReturnCons]:\n  assumes major: \"valid_path_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); valid_path_aux cs as; P cs as\\<rbrakk> \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q r p fs. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_path_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q p f. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = []; valid_path_aux [] as; P [] as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q p f c' cs' . \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c'#cs'; valid_path_aux cs' as;\n                              a \\<in> get_return_edges c'; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (a#as)\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "using major"], ["proof (prove)\nusing this:\n  valid_path_aux xs ys\n\ngoal (1 subgoal):\n 1. P xs ys", "apply(induct ys arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. valid_path_aux xs [] \\<Longrightarrow> P xs []\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs. valid_path_aux xs ys \\<Longrightarrow> P xs ys;\n        valid_path_aux xs (a # ys)\\<rbrakk>\n       \\<Longrightarrow> P xs (a # ys)", "by(auto intro:rules split:edge_kind.split_asm list.split_asm simp:intra_kind_def)"], ["", "lemma valid_path_aux_intra_path:\n  \"\\<forall>a \\<in> set as. intra_kind(kind a) \\<Longrightarrow> valid_path_aux cs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a) \\<Longrightarrow>\n    valid_path_aux cs as", "by(induct as,auto simp:intra_kind_def)"], ["", "lemma valid_path_aux_callstack_prefix:\n  \"valid_path_aux (cs@cs') as \\<Longrightarrow> valid_path_aux cs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux (cs @ cs') as \\<Longrightarrow> valid_path_aux cs as", "proof(induct \"cs@cs'\" as arbitrary:cs cs' rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs cs'. valid_path_aux cs []\n 2. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 4. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 5. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "case vpa_empty"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>cs cs'. valid_path_aux cs []\n 2. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 4. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 5. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux cs []", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs []\n\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 4. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 4. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "case (vpa_intra a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux (cs @ cs') as\n  cs @ cs' = ?cs @ ?cs' \\<Longrightarrow> valid_path_aux ?cs as\n\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 4. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "hence \"valid_path_aux cs as\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_aux (cs @ cs') as\n  cs @ cs' = ?cs @ ?cs' \\<Longrightarrow> valid_path_aux ?cs as\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as\n\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 4. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_aux cs as", "show ?case"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_aux cs as\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a # as)", "by(cases \"kind a\",auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_aux cs (a # as)\n\ngoal (3 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "case (vpa_Call a as Q r p fs cs'' cs')"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs'' @ cs') as\n  a # cs'' @ cs' = ?cs @ ?cs' \\<Longrightarrow> valid_path_aux ?cs as\n\ngoal (3 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "note IH = \\<open>\\<And>xs ys. a#cs''@cs' = xs@ys \\<Longrightarrow> valid_path_aux xs as\\<close>"], ["proof (state)\nthis:\n  a # cs'' @ cs' = ?xs @ ?ys \\<Longrightarrow> valid_path_aux ?xs as\n\ngoal (3 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "have \"a#cs''@cs' = (a#cs'')@cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # cs'' @ cs' = (a # cs'') @ cs'", "by simp"], ["proof (state)\nthis:\n  a # cs'' @ cs' = (a # cs'') @ cs'\n\ngoal (3 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  valid_path_aux (a # cs'') as", "have \"valid_path_aux (a#cs'') as\""], ["proof (prove)\nusing this:\n  valid_path_aux (a # cs'') as\n\ngoal (1 subgoal):\n 1. valid_path_aux (a # cs'') as", "."], ["proof (state)\nthis:\n  valid_path_aux (a # cs'') as\n\ngoal (3 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 3. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs'') as", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs'') as\n\ngoal (1 subgoal):\n 1. valid_path_aux cs'' (a # as)", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs'' (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "case (vpa_ReturnEmpty a as Q p f cs'' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs'' @ cs' = []\n  valid_path_aux [] as\n  [] = ?cs @ ?cs' \\<Longrightarrow> valid_path_aux ?cs as\n\ngoal (2 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "hence \"valid_path_aux cs'' as\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs'' @ cs' = []\n  valid_path_aux [] as\n  [] = ?cs @ ?cs' \\<Longrightarrow> valid_path_aux ?cs as\n\ngoal (1 subgoal):\n 1. valid_path_aux cs'' as", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs'' as\n\ngoal (2 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs @ cs' = [];\n        valid_path_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)\n 2. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs''@cs' = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs'' @ cs' = []\n  valid_path_aux cs'' as", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs'' @ cs' = []\n  valid_path_aux cs'' as\n\ngoal (1 subgoal):\n 1. valid_path_aux cs'' (a # as)", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs'' (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "case (vpa_ReturnCons a as Q p f c' cs' csx csx')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  csx @ csx' = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  cs' = ?cs @ ?cs' \\<Longrightarrow> valid_path_aux ?cs as\n\ngoal (1 subgoal):\n 1. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "note IH = \\<open>\\<And>xs ys. cs' = xs@ys \\<Longrightarrow> valid_path_aux xs as\\<close>"], ["proof (state)\nthis:\n  cs' = ?xs @ ?ys \\<Longrightarrow> valid_path_aux ?xs as\n\ngoal (1 subgoal):\n 1. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "from \\<open>csx@csx' = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  csx @ csx' = c' # cs'", "have \"csx = [] \\<and> csx' = c'#cs' \\<or> (\\<exists>zs. csx = c'#zs \\<and> zs@csx' = cs')\""], ["proof (prove)\nusing this:\n  csx @ csx' = c' # cs'\n\ngoal (1 subgoal):\n 1. csx = [] \\<and> csx' = c' # cs' \\<or>\n    (\\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs')", "by(simp add:append_eq_Cons_conv)"], ["proof (state)\nthis:\n  csx = [] \\<and> csx' = c' # cs' \\<or>\n  (\\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs')\n\ngoal (1 subgoal):\n 1. \\<And>a as Q p f c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs @ cs'a = c' # cs'; valid_path_aux cs' as;\n        a \\<in> get_return_edges c';\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow> valid_path_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs (a # as)", "thus ?case"], ["proof (prove)\nusing this:\n  csx = [] \\<and> csx' = c' # cs' \\<or>\n  (\\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs')\n\ngoal (1 subgoal):\n 1. valid_path_aux csx (a # as)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. csx = [] \\<and> csx' = c' # cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)\n 2. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "assume \"csx = [] \\<and> csx' = c'#cs'\""], ["proof (state)\nthis:\n  csx = [] \\<and> csx' = c' # cs'\n\ngoal (2 subgoals):\n 1. csx = [] \\<and> csx' = c' # cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)\n 2. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "hence \"csx = []\" and \"csx' = c'#cs'\""], ["proof (prove)\nusing this:\n  csx = [] \\<and> csx' = c' # cs'\n\ngoal (1 subgoal):\n 1. csx = [] &&& csx' = c' # cs'", "by simp_all"], ["proof (state)\nthis:\n  csx = []\n  csx' = c' # cs'\n\ngoal (2 subgoals):\n 1. csx = [] \\<and> csx' = c' # cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)\n 2. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "from \\<open>csx' = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  csx' = c' # cs'", "have \"cs' = []@tl csx'\""], ["proof (prove)\nusing this:\n  csx' = c' # cs'\n\ngoal (1 subgoal):\n 1. cs' = [] @ tl csx'", "by simp"], ["proof (state)\nthis:\n  cs' = [] @ tl csx'\n\ngoal (2 subgoals):\n 1. csx = [] \\<and> csx' = c' # cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)\n 2. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  valid_path_aux [] as", "have \"valid_path_aux [] as\""], ["proof (prove)\nusing this:\n  valid_path_aux [] as\n\ngoal (1 subgoal):\n 1. valid_path_aux [] as", "."], ["proof (state)\nthis:\n  valid_path_aux [] as\n\ngoal (2 subgoals):\n 1. csx = [] \\<and> csx' = c' # cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)\n 2. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "with \\<open>csx = []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  csx = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_aux [] as", "show ?thesis"], ["proof (prove)\nusing this:\n  csx = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_aux [] as\n\ngoal (1 subgoal):\n 1. valid_path_aux csx (a # as)", "by simp"], ["proof (state)\nthis:\n  valid_path_aux csx (a # as)\n\ngoal (1 subgoal):\n 1. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "assume \"\\<exists>zs. csx = c'#zs \\<and> zs@csx' = cs'\""], ["proof (state)\nthis:\n  \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs'\n\ngoal (1 subgoal):\n 1. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "then"], ["proof (chain)\npicking this:\n  \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs'", "obtain zs where \"csx = c'#zs\" and \"cs' = zs@csx'\""], ["proof (prove)\nusing this:\n  \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs'\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>csx = c' # zs; cs' = zs @ csx'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  csx = c' # zs\n  cs' = zs @ csx'\n\ngoal (1 subgoal):\n 1. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "from IH[OF \\<open>cs' = zs@csx'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux zs as", "have \"valid_path_aux zs as\""], ["proof (prove)\nusing this:\n  valid_path_aux zs as\n\ngoal (1 subgoal):\n 1. valid_path_aux zs as", "."], ["proof (state)\nthis:\n  valid_path_aux zs as\n\ngoal (1 subgoal):\n 1. \\<exists>zs. csx = c' # zs \\<and> zs @ csx' = cs' \\<Longrightarrow>\n    valid_path_aux csx (a # as)", "with \\<open>csx = c'#zs\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  csx = c' # zs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges c'\n  valid_path_aux zs as", "show ?thesis"], ["proof (prove)\nusing this:\n  csx = c' # zs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges c'\n  valid_path_aux zs as\n\ngoal (1 subgoal):\n 1. valid_path_aux csx (a # as)", "by simp"], ["proof (state)\nthis:\n  valid_path_aux csx (a # as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux csx (a # as)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun upd_cs :: \"'edge list \\<Rightarrow> 'edge list \\<Rightarrow> 'edge list\"\n  where \"upd_cs cs [] = cs\"\n  | \"upd_cs cs (a#as) =\n       (case (kind a) of Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow> upd_cs (a#cs) as\n                       | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow> case cs of [] \\<Rightarrow> upd_cs cs as\n                                      | c'#cs' \\<Rightarrow> upd_cs cs' as\n                       |    _ \\<Rightarrow> upd_cs cs as)\""], ["", "lemma upd_cs_empty [dest]:\n  \"upd_cs cs [] = [] \\<Longrightarrow> cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs [] = [] \\<Longrightarrow> cs = []", "by(cases cs) auto"], ["", "lemma upd_cs_intra_path:\n  \"\\<forall>a \\<in> set as. intra_kind(kind a) \\<Longrightarrow> upd_cs cs as = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a) \\<Longrightarrow>\n    upd_cs cs as = cs", "by(induct as,auto simp:intra_kind_def)"], ["", "lemma upd_cs_Append:\n  \"\\<lbrakk>upd_cs cs as = cs'; upd_cs cs' as' = cs''\\<rbrakk> \\<Longrightarrow> upd_cs cs (as@as') = cs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>upd_cs cs as = cs'; upd_cs cs' as' = cs''\\<rbrakk>\n    \\<Longrightarrow> upd_cs cs (as @ as') = cs''", "by(induct as arbitrary:cs,auto split:edge_kind.split list.split)"], ["", "lemma upd_cs_empty_split:\n  assumes \"upd_cs cs as = []\" and \"cs \\<noteq> []\" and \"as \\<noteq> []\"\n  obtains xs ys where \"as = xs@ys\" and \"xs \\<noteq> []\" and \"upd_cs cs xs = []\"\n  and \"\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []\"\n  and \"upd_cs [] ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as = xs @ ys; xs \\<noteq> []; upd_cs cs xs = [];\n         \\<forall>xs' ys'.\n            xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs' \\<noteq> [];\n         upd_cs [] ys = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       as = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "from \\<open>upd_cs cs as = []\\<close> \\<open>cs \\<noteq> []\\<close> \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs as = []\n  cs \\<noteq> []\n  as \\<noteq> []", "show \"\\<exists>xs ys. as = xs@ys \\<and> xs \\<noteq> [] \\<and> upd_cs cs xs = [] \\<and> \n             (\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []) \\<and> \n             upd_cs [] ys = []\""], ["proof (prove)\nusing this:\n  upd_cs cs as = []\n  cs \\<noteq> []\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       as = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "proof(induct as arbitrary:cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>upd_cs cs [] = []; cs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            [] = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []\n 2. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>upd_cs cs as = []; cs \\<noteq> [];\n                    as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys.\n  as = xs @ ys \\<and>\n  xs \\<noteq> [] \\<and>\n  upd_cs cs xs = [] \\<and>\n  (\\<forall>xs' ys'.\n      xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs' \\<noteq> []) \\<and>\n  upd_cs [] ys = [];\n        upd_cs cs (a # as) = []; cs \\<noteq> []; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # as = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []", "case Nil"], ["proof (state)\nthis:\n  upd_cs cs [] = []\n  cs \\<noteq> []\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>upd_cs cs [] = []; cs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            [] = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []\n 2. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>upd_cs cs as = []; cs \\<noteq> [];\n                    as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys.\n  as = xs @ ys \\<and>\n  xs \\<noteq> [] \\<and>\n  upd_cs cs xs = [] \\<and>\n  (\\<forall>xs' ys'.\n      xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs' \\<noteq> []) \\<and>\n  upd_cs [] ys = [];\n        upd_cs cs (a # as) = []; cs \\<noteq> []; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # as = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []", "thus ?case"], ["proof (prove)\nusing this:\n  upd_cs cs [] = []\n  cs \\<noteq> []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       [] = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "by simp"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     [] = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal (1 subgoal):\n 1. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>upd_cs cs as = []; cs \\<noteq> [];\n                    as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys.\n  as = xs @ ys \\<and>\n  xs \\<noteq> [] \\<and>\n  upd_cs cs xs = [] \\<and>\n  (\\<forall>xs' ys'.\n      xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs' \\<noteq> []) \\<and>\n  upd_cs [] ys = [];\n        upd_cs cs (a # as) = []; cs \\<noteq> []; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # as = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>upd_cs cs as = []; cs \\<noteq> [];\n                    as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys.\n  as = xs @ ys \\<and>\n  xs \\<noteq> [] \\<and>\n  upd_cs cs xs = [] \\<and>\n  (\\<forall>xs' ys'.\n      xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs' \\<noteq> []) \\<and>\n  upd_cs [] ys = [];\n        upd_cs cs (a # as) = []; cs \\<noteq> []; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # as = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []", "case (Cons a' as')"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs ?cs as' = []; ?cs \\<noteq> []; as' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys.\n                       as' = xs @ ys \\<and>\n                       xs \\<noteq> [] \\<and>\n                       upd_cs ?cs xs = [] \\<and>\n                       (\\<forall>xs' ys'.\n                           xs = xs' @ ys' \\<and>\n                           ys' \\<noteq> [] \\<longrightarrow>\n                           upd_cs ?cs xs' \\<noteq> []) \\<and>\n                       upd_cs [] ys = []\n  upd_cs cs (a' # as') = []\n  cs \\<noteq> []\n  a' # as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>upd_cs cs as = []; cs \\<noteq> [];\n                    as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys.\n  as = xs @ ys \\<and>\n  xs \\<noteq> [] \\<and>\n  upd_cs cs xs = [] \\<and>\n  (\\<forall>xs' ys'.\n      xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs' \\<noteq> []) \\<and>\n  upd_cs [] ys = [];\n        upd_cs cs (a # as) = []; cs \\<noteq> []; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # as = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []", "note IH = \\<open>\\<And>cs. \\<lbrakk>upd_cs cs as' = []; cs \\<noteq> []; as' \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> \\<exists>xs ys. as' = xs@ys \\<and> xs \\<noteq> [] \\<and> upd_cs cs xs = [] \\<and>\n                 (\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []) \\<and> \n                 upd_cs [] ys = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs ?cs as' = []; ?cs \\<noteq> []; as' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys.\n                       as' = xs @ ys \\<and>\n                       xs \\<noteq> [] \\<and>\n                       upd_cs ?cs xs = [] \\<and>\n                       (\\<forall>xs' ys'.\n                           xs = xs' @ ys' \\<and>\n                           ys' \\<noteq> [] \\<longrightarrow>\n                           upd_cs ?cs xs' \\<noteq> []) \\<and>\n                       upd_cs [] ys = []\n\ngoal (1 subgoal):\n 1. \\<And>a as cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>upd_cs cs as = []; cs \\<noteq> [];\n                    as \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys.\n  as = xs @ ys \\<and>\n  xs \\<noteq> [] \\<and>\n  upd_cs cs xs = [] \\<and>\n  (\\<forall>xs' ys'.\n      xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs' \\<noteq> []) \\<and>\n  upd_cs [] ys = [];\n        upd_cs cs (a # as) = []; cs \\<noteq> []; a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # as = xs @ ys \\<and>\n                            xs \\<noteq> [] \\<and>\n                            upd_cs cs xs = [] \\<and>\n                            (\\<forall>xs' ys'.\n                                xs = xs' @ ys' \\<and>\n                                ys' \\<noteq> [] \\<longrightarrow>\n                                upd_cs cs xs' \\<noteq> []) \\<and>\n                            upd_cs [] ys = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "with \\<open>upd_cs cs (a'#as') = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a' # as') = []\n  intra_kind (kind a')", "have \"upd_cs cs as' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (a' # as') = []\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_cs cs as' = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs as' = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "with \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  cs \\<noteq> []\n  upd_cs cs as' = []", "have \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  upd_cs cs as' = []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "from IH[OF \\<open>upd_cs cs as' = []\\<close> \\<open>cs \\<noteq> []\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys.\n     as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []", "obtain xs ys where \"as' = xs@ys\"\n        and \"xs \\<noteq> []\" and \"upd_cs cs xs = []\" and \"upd_cs [] ys = []\"\n        and \"\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys.\n     as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as' = xs @ ys; xs \\<noteq> []; upd_cs cs xs = [];\n         upd_cs [] ys = [];\n         \\<forall>xs' ys'.\n            xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as' = xs @ ys\n  xs \\<noteq> []\n  upd_cs cs xs = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "from \\<open>upd_cs cs xs = []\\<close> Intra"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  intra_kind (kind a')", "have \"upd_cs cs (a'#xs) = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_cs cs (a' # xs) = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs (a' # xs) = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "from \\<open>\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []\\<close> \\<open>xs \\<noteq> []\\<close> Intra"], ["proof (chain)\npicking this:\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n  xs \\<noteq> []\n  intra_kind (kind a')", "have \"\\<forall>xs' ys'. a'#xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n  xs \\<noteq> []\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<forall>xs' ys'.\n       a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n       upd_cs cs xs' \\<noteq> []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>\\<forall>xs'.\n                   (\\<exists>ys'.\n                       xs = xs' @ ys' \\<and>\n                       ys' \\<noteq> []) \\<longrightarrow>\n                   upd_cs cs xs' \\<noteq> [];\n        xs \\<noteq> []; intra_kind (kind a'); a' # xs = xs' @ ys';\n        ys' \\<noteq> []; upd_cs cs xs' = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac xs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>\\<forall>xs'.\n                   (\\<exists>ys'.\n                       xs = xs' @ ys' \\<and>\n                       ys' \\<noteq> []) \\<longrightarrow>\n                   upd_cs cs xs' \\<noteq> [];\n        xs \\<noteq> []; intra_kind (kind a'); a' # xs = xs' @ ys';\n        ys' \\<noteq> []; upd_cs cs xs' = []; xs' = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xs' ys' a list.\n       \\<lbrakk>\\<forall>xs'.\n                   (\\<exists>ys'.\n                       xs = xs' @ ys' \\<and>\n                       ys' \\<noteq> []) \\<longrightarrow>\n                   upd_cs cs xs' \\<noteq> [];\n        xs \\<noteq> []; intra_kind (kind a'); a' # xs = xs' @ ys';\n        ys' \\<noteq> []; upd_cs cs xs' = []; xs' = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp:intra_kind_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>xs'.\n                   (\\<exists>ys'.\n                       xs = xs' @ ys' \\<and>\n                       ys' \\<noteq> []) \\<longrightarrow>\n                   upd_cs [] xs' \\<noteq> [];\n        xs \\<noteq> []; cs = []; kind a' = \\<Up>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Q.\n       \\<lbrakk>\\<forall>xs'.\n                   (\\<exists>ys'.\n                       xs = xs' @ ys' \\<and>\n                       ys' \\<noteq> []) \\<longrightarrow>\n                   upd_cs [] xs' \\<noteq> [];\n        xs \\<noteq> []; cs = []; kind a' = (Q)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> False", "by(erule_tac x=\"[]\" in allE,fastforce)+"], ["proof (state)\nthis:\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "with \\<open>as' = xs@ys\\<close> \\<open>upd_cs cs (a'#xs) = []\\<close> \\<open>upd_cs [] ys = []\\<close>"], ["proof (chain)\npicking this:\n  as' = xs @ ys\n  upd_cs cs (a' # xs) = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = xs @ ys\n  upd_cs cs (a' # xs) = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "apply(rule_tac x=\"a'#xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as' = xs @ ys; upd_cs cs (a' # xs) = []; upd_cs [] ys = [];\n     \\<forall>xs' ys'.\n        a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n        upd_cs cs xs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         a' # as' = (a' # xs) @ ys \\<and>\n                         a' # xs \\<noteq> [] \\<and>\n                         upd_cs cs (a' # xs) = [] \\<and>\n                         (\\<forall>xs' ys'.\n                             a' # xs = xs' @ ys' \\<and>\n                             ys' \\<noteq> [] \\<longrightarrow>\n                             upd_cs cs xs' \\<noteq> []) \\<and>\n                         upd_cs [] ys = []", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a' # as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "case (Call Q p f)"], ["proof (state)\nthis:\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "with \\<open>upd_cs cs (a'#as') = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a' # as') = []\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_", "have \"upd_cs (a'#cs) as' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (a' # as') = []\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. upd_cs (a' # cs) as' = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (a' # cs) as' = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "with \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  cs \\<noteq> []\n  upd_cs (a' # cs) as' = []", "have \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  upd_cs (a' # cs) as' = []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "from IH[OF \\<open>upd_cs (a'#cs) as' = []\\<close> _ this]"], ["proof (chain)\npicking this:\n  a' # cs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>xs ys.\n     as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs (a' # cs) xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs (a' # cs) xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []", "obtain xs ys where \"as' = xs@ys\"\n        and \"xs \\<noteq> []\" and \"upd_cs (a'#cs) xs = []\" and \"upd_cs [] ys = []\"\n        and \"\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs (a'#cs) xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  a' # cs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>xs ys.\n     as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs (a' # cs) xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs (a' # cs) xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as' = xs @ ys; xs \\<noteq> []; upd_cs (a' # cs) xs = [];\n         upd_cs [] ys = [];\n         \\<forall>xs' ys'.\n            xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n            upd_cs (a' # cs) xs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as' = xs @ ys\n  xs \\<noteq> []\n  upd_cs (a' # cs) xs = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs (a' # cs) xs' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "from \\<open>upd_cs (a'#cs) xs = []\\<close> Call"], ["proof (chain)\npicking this:\n  upd_cs (a' # cs) xs = []\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_", "have \"upd_cs cs (a'#xs) = []\""], ["proof (prove)\nusing this:\n  upd_cs (a' # cs) xs = []\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. upd_cs cs (a' # xs) = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a' # xs) = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "from \\<open>\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs (a'#cs) xs' \\<noteq> []\\<close> \n        \\<open>xs \\<noteq> []\\<close> \\<open>cs \\<noteq> []\\<close> Call"], ["proof (chain)\npicking this:\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs (a' # cs) xs' \\<noteq> []\n  xs \\<noteq> []\n  cs \\<noteq> []\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_", "have \"\\<forall>xs' ys'. a'#xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs (a' # cs) xs' \\<noteq> []\n  xs \\<noteq> []\n  cs \\<noteq> []\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. \\<forall>xs' ys'.\n       a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n       upd_cs cs xs' \\<noteq> []", "by auto(case_tac xs',auto)"], ["proof (state)\nthis:\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "with \\<open>as' = xs@ys\\<close> \\<open>upd_cs cs (a'#xs) = []\\<close> \\<open>upd_cs [] ys = []\\<close>"], ["proof (chain)\npicking this:\n  as' = xs @ ys\n  upd_cs cs (a' # xs) = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = xs @ ys\n  upd_cs cs (a' # xs) = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "apply(rule_tac x=\"a'#xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as' = xs @ ys; upd_cs cs (a' # xs) = []; upd_cs [] ys = [];\n     \\<forall>xs' ys'.\n        a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n        upd_cs cs xs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         a' # as' = (a' # xs) @ ys \\<and>\n                         a' # xs \\<noteq> [] \\<and>\n                         upd_cs cs (a' # xs) = [] \\<and>\n                         (\\<forall>xs' ys'.\n                             a' # xs = xs' @ ys' \\<and>\n                             ys' \\<noteq> [] \\<longrightarrow>\n                             upd_cs cs xs' \\<noteq> []) \\<and>\n                         upd_cs [] ys = []", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a' # as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "with \\<open>upd_cs cs (a'#as') = []\\<close> \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a' # as') = []\n  cs \\<noteq> []\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain c' cs' where \"cs = c'#cs'\"\n        and \"upd_cs cs' as' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (a' # as') = []\n  cs \\<noteq> []\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>c' cs'.\n        \\<lbrakk>cs = c' # cs'; upd_cs cs' as' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cs) auto"], ["proof (state)\nthis:\n  cs = c' # cs'\n  upd_cs cs' as' = []\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>xs ys.\n          a' # as' = xs @ ys \\<and>\n          xs \\<noteq> [] \\<and>\n          upd_cs cs xs = [] \\<and>\n          (\\<forall>xs' ys'.\n              xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n              upd_cs cs xs' \\<noteq> []) \\<and>\n          upd_cs [] ys = []", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "proof(cases \"cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "case True"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "with \\<open>cs = c'#cs'\\<close> \\<open>upd_cs cs' as' = []\\<close> Return"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  upd_cs cs' as' = []\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  upd_cs cs' as' = []\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "apply(rule_tac x=\"[a']\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cs = c' # cs'; upd_cs cs' as' = [];\n     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs' = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         a' # as' = [a'] @ ys \\<and>\n                         [a'] \\<noteq> [] \\<and>\n                         upd_cs cs [a'] = [] \\<and>\n                         (\\<forall>xs' ys'.\n                             [a'] = xs' @ ys' \\<and>\n                             ys' \\<noteq> [] \\<longrightarrow>\n                             upd_cs cs xs' \\<noteq> []) \\<and>\n                         upd_cs [] ys = []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs' ys'.\n       \\<lbrakk>cs = [c']; upd_cs [] as' = [];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs' = [];\n        [a'] = xs' @ ys'; ys' \\<noteq> []; upd_cs [c'] xs' = []\\<rbrakk>\n       \\<Longrightarrow> False", "by(case_tac xs') auto"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a' # as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "case False"], ["proof (state)\nthis:\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "with \\<open>upd_cs cs' as' = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs' as' = []\n  cs' \\<noteq> []", "have \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  upd_cs cs' as' = []\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "from IH[OF \\<open>upd_cs cs' as' = []\\<close> False this]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys.\n     as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs' xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs' xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []", "obtain xs ys where \"as' = xs@ys\"\n          and \"xs \\<noteq> []\" and \"upd_cs cs' xs = []\" and \"upd_cs [] ys = []\"\n          and \"\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs' xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys.\n     as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs' xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs' xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as' = xs @ ys; xs \\<noteq> []; upd_cs cs' xs = [];\n         upd_cs [] ys = [];\n         \\<forall>xs' ys'.\n            xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as' = xs @ ys\n  xs \\<noteq> []\n  upd_cs cs' xs = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs' xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "from \\<open>upd_cs cs' xs = []\\<close> \\<open>cs = c'#cs'\\<close> Return"], ["proof (chain)\npicking this:\n  upd_cs cs' xs = []\n  cs = c' # cs'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"upd_cs cs (a'#xs) = []\""], ["proof (prove)\nusing this:\n  upd_cs cs' xs = []\n  cs = c' # cs'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. upd_cs cs (a' # xs) = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a' # xs) = []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "from \\<open>\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs' xs' \\<noteq> []\\<close>\n          \\<open>xs \\<noteq> []\\<close> \\<open>cs = c'#cs'\\<close> Return"], ["proof (chain)\npicking this:\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs' xs' \\<noteq> []\n  xs \\<noteq> []\n  cs = c' # cs'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"\\<forall>xs' ys'. a'#xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs cs xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs' xs' \\<noteq> []\n  xs \\<noteq> []\n  cs = c' # cs'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<forall>xs' ys'.\n       a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n       upd_cs cs xs' \\<noteq> []", "by auto(case_tac xs',auto)"], ["proof (state)\nthis:\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "with \\<open>as' = xs@ys\\<close> \\<open>upd_cs cs (a'#xs) = []\\<close> \\<open>upd_cs [] ys = []\\<close>"], ["proof (chain)\npicking this:\n  as' = xs @ ys\n  upd_cs cs (a' # xs) = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = xs @ ys\n  upd_cs cs (a' # xs) = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a' # as' = xs @ ys \\<and>\n       xs \\<noteq> [] \\<and>\n       upd_cs cs xs = [] \\<and>\n       (\\<forall>xs' ys'.\n           xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs' \\<noteq> []) \\<and>\n       upd_cs [] ys = []", "apply(rule_tac x=\"a'#xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as' = xs @ ys; upd_cs cs (a' # xs) = []; upd_cs [] ys = [];\n     \\<forall>xs' ys'.\n        a' # xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n        upd_cs cs xs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         a' # as' = (a' # xs) @ ys \\<and>\n                         a' # xs \\<noteq> [] \\<and>\n                         upd_cs cs (a' # xs) = [] \\<and>\n                         (\\<forall>xs' ys'.\n                             a' # xs = xs' @ ys' \\<and>\n                             ys' \\<noteq> [] \\<longrightarrow>\n                             upd_cs cs xs' \\<noteq> []) \\<and>\n                         upd_cs [] ys = []", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a' # as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a' # as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a' # as' = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     as = xs @ ys \\<and>\n     xs \\<noteq> [] \\<and>\n     upd_cs cs xs = [] \\<and>\n     (\\<forall>xs' ys'.\n         xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n         upd_cs cs xs' \\<noteq> []) \\<and>\n     upd_cs [] ys = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_cs_snoc_Return_Cons:\n  assumes \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  shows \"upd_cs cs as = c'#cs' \\<Longrightarrow> upd_cs cs (as@[a]) = cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs as = c' # cs' \\<Longrightarrow> upd_cs cs (as @ [a]) = cs'", "proof(induct as arbitrary:cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       upd_cs cs [] = c' # cs' \\<Longrightarrow> upd_cs cs ([] @ [a]) = cs'\n 2. \\<And>aa as cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_cs cs as = c' # cs' \\<Longrightarrow>\n                   upd_cs cs (as @ [a]) = cs';\n        upd_cs cs (aa # as) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_cs cs ((aa # as) @ [a]) = cs'", "case Nil"], ["proof (state)\nthis:\n  upd_cs cs [] = c' # cs'\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       upd_cs cs [] = c' # cs' \\<Longrightarrow> upd_cs cs ([] @ [a]) = cs'\n 2. \\<And>aa as cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_cs cs as = c' # cs' \\<Longrightarrow>\n                   upd_cs cs (as @ [a]) = cs';\n        upd_cs cs (aa # as) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_cs cs ((aa # as) @ [a]) = cs'", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs cs [] = c' # cs'", "have \"upd_cs cs [a] = cs'\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs cs [] = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [a] = cs'\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       upd_cs cs [] = c' # cs' \\<Longrightarrow> upd_cs cs ([] @ [a]) = cs'\n 2. \\<And>aa as cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_cs cs as = c' # cs' \\<Longrightarrow>\n                   upd_cs cs (as @ [a]) = cs';\n        upd_cs cs (aa # as) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_cs cs ((aa # as) @ [a]) = cs'", "thus ?case"], ["proof (prove)\nusing this:\n  upd_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs ([] @ [a]) = cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ([] @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_cs cs as = c' # cs' \\<Longrightarrow>\n                   upd_cs cs (as @ [a]) = cs';\n        upd_cs cs (aa # as) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_cs cs ((aa # as) @ [a]) = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_cs cs as = c' # cs' \\<Longrightarrow>\n                   upd_cs cs (as @ [a]) = cs';\n        upd_cs cs (aa # as) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_cs cs ((aa # as) @ [a]) = cs'", "case (Cons a' as')"], ["proof (state)\nthis:\n  upd_cs ?cs as' = c' # cs' \\<Longrightarrow> upd_cs ?cs (as' @ [a]) = cs'\n  upd_cs cs (a' # as') = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_cs cs as = c' # cs' \\<Longrightarrow>\n                   upd_cs cs (as @ [a]) = cs';\n        upd_cs cs (aa # as) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_cs cs ((aa # as) @ [a]) = cs'", "note IH = \\<open>\\<And>cs. upd_cs cs as' = c'#cs' \\<Longrightarrow> upd_cs cs (as'@[a]) = cs'\\<close>"], ["proof (state)\nthis:\n  upd_cs ?cs as' = c' # cs' \\<Longrightarrow> upd_cs ?cs (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_cs cs as = c' # cs' \\<Longrightarrow>\n                   upd_cs cs (as @ [a]) = cs';\n        upd_cs cs (aa # as) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_cs cs ((aa # as) @ [a]) = cs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = cs'", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "with \\<open>upd_cs cs (a'#as') = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a' # as') = c' # cs'\n  intra_kind (kind a')", "have \"upd_cs cs as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs (a' # as') = c' # cs'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_cs cs as' = c' # cs'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs as' = c' # cs'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_cs cs (as' @ [a]) = cs'", "have \"upd_cs cs (as'@[a]) = cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs (as' @ [a]) = cs'", "."], ["proof (state)\nthis:\n  upd_cs cs (as' @ [a]) = cs'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "with Intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  upd_cs cs (as' @ [a]) = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  upd_cs cs (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = cs'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = cs'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "case Call"], ["proof (state)\nthis:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "with \\<open>upd_cs cs (a'#as') = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a' # as') = c' # cs'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_", "have \"upd_cs (a'#cs) as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs (a' # as') = c' # cs'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. upd_cs (a' # cs) as' = c' # cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs (a' # cs) as' = c' # cs'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_cs (a' # cs) (as' @ [a]) = cs'", "have \"upd_cs (a'#cs) (as'@[a]) = cs'\""], ["proof (prove)\nusing this:\n  upd_cs (a' # cs) (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs (a' # cs) (as' @ [a]) = cs'", "."], ["proof (state)\nthis:\n  upd_cs (a' # cs) (as' @ [a]) = cs'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "with Call"], ["proof (chain)\npicking this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_cs (a' # cs) (as' @ [a]) = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_cs (a' # cs) (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "case Return"], ["proof (state)\nthis:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = cs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = cs'", "proof(cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "with \\<open>upd_cs cs (a'#as') = c'#cs'\\<close> Return"], ["proof (chain)\npicking this:\n  upd_cs cs (a' # as') = c' # cs'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = []", "have \"upd_cs cs as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs (a' # as') = c' # cs'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = []\n\ngoal (1 subgoal):\n 1. upd_cs cs as' = c' # cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs as' = c' # cs'\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_cs cs (as' @ [a]) = cs'", "have \"upd_cs cs (as'@[a]) = cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs (as' @ [a]) = cs'", "."], ["proof (state)\nthis:\n  upd_cs cs (as' @ [a]) = cs'\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "with Nil Return"], ["proof (chain)\npicking this:\n  cs = []\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_cs cs (as' @ [a]) = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = []\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_cs cs (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "case (Cons cx csx)"], ["proof (state)\nthis:\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "with \\<open>upd_cs cs (a'#as') = c'#cs'\\<close> Return"], ["proof (chain)\npicking this:\n  upd_cs cs (a' # as') = c' # cs'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = cx # csx", "have \"upd_cs csx as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs (a' # as') = c' # cs'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. upd_cs csx as' = c' # cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs csx as' = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_cs csx (as' @ [a]) = cs'", "have \"upd_cs csx (as'@[a]) = cs'\""], ["proof (prove)\nusing this:\n  upd_cs csx (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs csx (as' @ [a]) = cs'", "."], ["proof (state)\nthis:\n  upd_cs csx (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_cs cs ((a' # as') @ [a]) = cs'", "with Cons Return"], ["proof (chain)\npicking this:\n  cs = cx # csx\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_cs csx (as' @ [a]) = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = cx # csx\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_cs csx (as' @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = cs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = cs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = cs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_cs_snoc_Call:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"upd_cs cs (as@[a]) = a#(upd_cs cs as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs (as @ [a]) = a # upd_cs cs as", "proof(induct as arbitrary:cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs. upd_cs cs ([] @ [a]) = a # upd_cs cs []\n 2. \\<And>aa as cs.\n       (\\<And>cs. upd_cs cs (as @ [a]) = a # upd_cs cs as) \\<Longrightarrow>\n       upd_cs cs ((aa # as) @ [a]) = a # upd_cs cs (aa # as)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>cs. upd_cs cs ([] @ [a]) = a # upd_cs cs []\n 2. \\<And>aa as cs.\n       (\\<And>cs. upd_cs cs (as @ [a]) = a # upd_cs cs as) \\<Longrightarrow>\n       upd_cs cs ((aa # as) @ [a]) = a # upd_cs cs (aa # as)", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. upd_cs cs ([] @ [a]) = a # upd_cs cs []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ([] @ [a]) = a # upd_cs cs []\n\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       (\\<And>cs. upd_cs cs (as @ [a]) = a # upd_cs cs as) \\<Longrightarrow>\n       upd_cs cs ((aa # as) @ [a]) = a # upd_cs cs (aa # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       (\\<And>cs. upd_cs cs (as @ [a]) = a # upd_cs cs as) \\<Longrightarrow>\n       upd_cs cs ((aa # as) @ [a]) = a # upd_cs cs (aa # as)", "case (Cons a' as')"], ["proof (state)\nthis:\n  upd_cs ?cs (as' @ [a]) = a # upd_cs ?cs as'\n\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       (\\<And>cs. upd_cs cs (as @ [a]) = a # upd_cs cs as) \\<Longrightarrow>\n       upd_cs cs ((aa # as) @ [a]) = a # upd_cs cs (aa # as)", "note IH = \\<open>\\<And>cs. upd_cs cs (as'@[a]) = a#upd_cs cs as'\\<close>"], ["proof (state)\nthis:\n  upd_cs ?cs (as' @ [a]) = a # upd_cs ?cs as'\n\ngoal (1 subgoal):\n 1. \\<And>aa as cs.\n       (\\<And>cs. upd_cs cs (as @ [a]) = a # upd_cs cs as) \\<Longrightarrow>\n       upd_cs cs ((aa # as) @ [a]) = a # upd_cs cs (aa # as)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "with IH[of cs]"], ["proof (chain)\npicking this:\n  upd_cs cs (as' @ [a]) = a # upd_cs cs as'\n  intra_kind (kind a')", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_cs cs (as' @ [a]) = a # upd_cs cs as'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "case Call"], ["proof (state)\nthis:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "with IH[of \"a'#cs\"]"], ["proof (chain)\npicking this:\n  upd_cs (a' # cs) (as' @ [a]) = a # upd_cs (a' # cs) as'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_cs (a' # cs) (as' @ [a]) = a # upd_cs (a' # cs) as'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "case Return"], ["proof (state)\nthis:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "proof(cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "with IH[of \"[]\"] Return"], ["proof (chain)\npicking this:\n  upd_cs [] (as' @ [a]) = a # upd_cs [] as'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_cs [] (as' @ [a]) = a # upd_cs [] as'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = []\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "case (Cons cx csx)"], ["proof (state)\nthis:\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "with IH[of csx] Return"], ["proof (chain)\npicking this:\n  upd_cs csx (as' @ [a]) = a # upd_cs csx as'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = cx # csx", "show ?thesis"], ["proof (prove)\nusing this:\n  upd_cs csx (as' @ [a]) = a # upd_cs csx as'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_cs cs ((a' # as') @ [a]) = a # upd_cs cs (a' # as')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_path_aux_split:\n  assumes \"valid_path_aux cs (as@as')\"\n  shows \"valid_path_aux cs as\" and \"valid_path_aux (upd_cs cs as) as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux cs as &&& valid_path_aux (upd_cs cs as) as'", "using \\<open>valid_path_aux cs (as@as')\\<close>"], ["proof (prove)\nusing this:\n  valid_path_aux cs (as @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as &&& valid_path_aux (upd_cs cs as) as'", "proof(induct cs \"as@as'\" arbitrary:as as' rule:vpa_induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 10. \\<And>cs a as Q p f c' cs' asa as'.\n        \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         cs = c' # cs'; valid_path_aux cs' as; a \\<in> get_return_edges c';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_aux (upd_cs cs' asa) as';\n         a # as = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case (vpa_intra cs a as as'')"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 10. \\<And>cs a as Q p f c' cs' asa as'.\n        \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         cs = c' # cs'; valid_path_aux cs' as; a \\<in> get_return_edges c';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_aux (upd_cs cs' asa) as';\n         a # as = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_aux cs xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux cs ?xs\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 10. \\<And>cs a as Q p f c' cs' asa as'.\n        \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         cs = c' # cs'; valid_path_aux cs' as; a \\<in> get_return_edges c';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_aux (upd_cs cs' asa) as';\n         a # as = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_aux (upd_cs cs xs) ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs cs ?xs) ?ys\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 10. \\<And>cs a as Q p f c' cs' asa as'.\n        \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         cs = c' # cs'; valid_path_aux cs' as; a \\<in> get_return_edges c';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_aux (upd_cs cs' asa) as';\n         a # as = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs cs ?xs) ?ys\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 10. \\<And>cs a as Q p f c' cs' asa as'.\n        \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         cs = c' # cs'; valid_path_aux cs' as; a \\<in> get_return_edges c';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_aux (upd_cs cs' asa) as';\n         a # as = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 10. \\<And>cs a as Q p f c' cs' asa as'.\n        \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         cs = c' # cs'; valid_path_aux cs' as; a \\<in> get_return_edges c';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_aux (upd_cs cs' asa) as';\n         a # as = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 10. \\<And>cs a as Q p f c' cs' asa as'.\n        \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         cs = c' # cs'; valid_path_aux cs' as; a \\<in> get_return_edges c';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_aux (upd_cs cs' asa) as';\n         a # as = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "thus ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "from IH1[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux cs xs", "have \"valid_path_aux cs xs\""], ["proof (prove)\nusing this:\n  valid_path_aux cs xs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs xs", "."], ["proof (state)\nthis:\n  valid_path_aux cs xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "with \\<open>a#xs = as''\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  a # xs = as''\n  intra_kind (kind a)\n  valid_path_aux cs xs", "show ?thesis"], ["proof (prove)\nusing this:\n  a # xs = as''\n  intra_kind (kind a)\n  valid_path_aux cs xs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (9 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (9 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 9. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "hence \"as = []@tl as'\""], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. as = [] @ tl as'", "by(cases as') auto"], ["proof (state)\nthis:\n  as = [] @ tl as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs []) (tl as')", "have \"valid_path_aux (upd_cs cs []) (tl as')\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs []) (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs []) (tl as')", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs []) (tl as')\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>as'' = [] \\<and> a#as = as'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  as'' = [] \\<and> a # as = as'\n  intra_kind (kind a)\n  valid_path_aux (upd_cs cs []) (tl as')", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n  intra_kind (kind a)\n  valid_path_aux (upd_cs cs []) (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs xs) as'", "have \"valid_path_aux (upd_cs cs xs) as'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs xs) as'\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs xs) as'", "."], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs xs) as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from \\<open>a#xs = as''\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  a # xs = as''\n  intra_kind (kind a)", "have \"upd_cs cs xs = upd_cs cs as''\""], ["proof (prove)\nusing this:\n  a # xs = as''\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs cs xs = upd_cs cs as''", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs xs = upd_cs cs as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>valid_path_aux (upd_cs cs xs) as'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs xs) as'\n  upd_cs cs xs = upd_cs cs as''", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs xs) as'\n  upd_cs cs xs = upd_cs cs as''\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "}"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case (vpa_Call cs a as Q r p fs as'')"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (a # cs) ?as\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_aux (upd_cs (a # cs) ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_aux (a#cs) xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (a # cs) ?xs\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow>   valid_path_aux (upd_cs (a#cs) xs) ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs (a # cs) ?xs) ?ys\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs (a # cs) ?xs) ?ys\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_Call"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (a # cs) ?as\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_aux (upd_cs (a # cs) ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (a # cs) ?as\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_aux (upd_cs (a # cs) ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 8. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "thus ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "from IH1[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux (a # cs) xs", "have \"valid_path_aux (a#cs) xs\""], ["proof (prove)\nusing this:\n  valid_path_aux (a # cs) xs\n\ngoal (1 subgoal):\n 1. valid_path_aux (a # cs) xs", "."], ["proof (state)\nthis:\n  valid_path_aux (a # cs) xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "with \\<open>a#xs = as''\\<close>[THEN sym] \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  as'' = a # xs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = a # xs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) xs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (7 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_Call"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (a # cs) ?as\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_aux (upd_cs (a # cs) ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (a # cs) ?as\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_aux (upd_cs (a # cs) ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (7 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux (a # cs) asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs (a # cs) asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 7. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "hence \"as = []@tl as'\""], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. as = [] @ tl as'", "by(cases as') auto"], ["proof (state)\nthis:\n  as = [] @ tl as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs (a # cs) []) (tl as')", "have \"valid_path_aux (upd_cs (a#cs) []) (tl as')\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs (a # cs) []) (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs (a # cs) []) (tl as')", "."], ["proof (state)\nthis:\n  valid_path_aux (upd_cs (a # cs) []) (tl as')\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>as'' = [] \\<and> a#as = as'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  as'' = [] \\<and> a # as = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (upd_cs (a # cs) []) (tl as')", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (upd_cs (a # cs) []) (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by clarsimp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs (a # cs) xs) as'", "have \"valid_path_aux (upd_cs (a # cs) xs) as'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs (a # cs) xs) as'\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs (a # cs) xs) as'", "."], ["proof (state)\nthis:\n  valid_path_aux (upd_cs (a # cs) xs) as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>a#xs = as''\\<close>[THEN sym]  \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  as'' = a # xs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (upd_cs (a # cs) xs) as'", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = a # xs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (upd_cs (a # cs) xs) as'\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "}"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case (vpa_ReturnEmpty cs a as Q p f as'')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux [] ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs [] ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_aux [] xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux [] ?xs\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_aux (upd_cs [] xs) ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs [] ?xs) ?ys\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs [] ?xs) ?ys\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_ReturnEmpty"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux [] ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs [] ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux [] ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs [] ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 6. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "thus ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "from IH1[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux [] xs", "have \"valid_path_aux [] xs\""], ["proof (prove)\nusing this:\n  valid_path_aux [] xs\n\ngoal (1 subgoal):\n 1. valid_path_aux [] xs", "."], ["proof (state)\nthis:\n  valid_path_aux [] xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "with \\<open>a#xs = as''\\<close>[THEN sym] \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] xs", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] xs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (5 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_ReturnEmpty"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux [] ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs [] ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux [] ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs [] ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (5 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux [] asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs [] asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 5. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "hence \"as = []@tl as'\""], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. as = [] @ tl as'", "by(cases as') auto"], ["proof (state)\nthis:\n  as = [] @ tl as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs [] []) (tl as')", "have \"valid_path_aux [] (tl as')\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs [] []) (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux [] (tl as')", "by simp"], ["proof (state)\nthis:\n  valid_path_aux [] (tl as')\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>as'' = [] \\<and> a#as = as'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  as'' = [] \\<and> a # as = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] (tl as')", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by fastforce"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs [] xs) as'", "have \"valid_path_aux (upd_cs [] xs) as'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs [] xs) as'\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs [] xs) as'", "."], ["proof (state)\nthis:\n  valid_path_aux (upd_cs [] xs) as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from \\<open>a#xs = as''\\<close>[THEN sym] \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []", "have \"upd_cs [] xs = upd_cs cs as''\""], ["proof (prove)\nusing this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n\ngoal (1 subgoal):\n 1. upd_cs [] xs = upd_cs cs as''", "by simp"], ["proof (state)\nthis:\n  upd_cs [] xs = upd_cs cs as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>valid_path_aux (upd_cs [] xs) as'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs [] xs) as'\n  upd_cs [] xs = upd_cs cs as''", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs [] xs) as'\n  upd_cs [] xs = upd_cs cs as''\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "}"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case (vpa_ReturnCons cs a as Q p f c' cs' as'')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs' ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs' ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_aux cs' xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux cs' ?xs\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_aux (upd_cs cs' xs) ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs cs' ?xs) ?ys\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_aux (upd_cs cs' ?xs) ?ys\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_ReturnCons"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs' ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs' ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs' ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs' ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs asa\n 4. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow> valid_path_aux cs as''\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "thus ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "from IH1[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux cs' xs", "have \"valid_path_aux cs' xs\""], ["proof (prove)\nusing this:\n  valid_path_aux cs' xs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs' xs", "."], ["proof (state)\nthis:\n  valid_path_aux cs' xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux cs as''", "with \\<open>a#xs = as''\\<close>[THEN sym] \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>\n         \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  valid_path_aux cs' xs", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  valid_path_aux cs' xs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs as''", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux cs as''\n\ngoal (3 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "from vpa_ReturnCons"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs' ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs' ?as) ?as'\n  a # as = as'' @ as'", "have \"as'' = [] \\<and> a#as = as' \\<or> (\\<exists>xs. a#xs = as'' \\<and> as = xs@as')\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux cs' ?as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_aux (upd_cs cs' ?as) ?as'\n  a # as = as'' @ as'\n\ngoal (1 subgoal):\n 1. as'' = [] \\<and> a # as = as' \\<or>\n    (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')", "by(simp add:Cons_eq_append_conv)"], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (3 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'\n 3. \\<And>cs a as Q p f c' cs' asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_aux cs' asa;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_aux (upd_cs cs' asa) as';\n        a # as = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux (upd_cs cs asa) as'", "thus ?case"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as' \\<or>\n  (\\<exists>xs. a # xs = as'' \\<and> as = xs @ as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"as'' = [] \\<and> a#as = as'\""], ["proof (state)\nthis:\n  as'' = [] \\<and> a # as = as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "hence \"as = []@tl as'\""], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n\ngoal (1 subgoal):\n 1. as = [] @ tl as'", "by(cases as') auto"], ["proof (state)\nthis:\n  as = [] @ tl as'\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs' []) (tl as')", "have \"valid_path_aux (upd_cs cs' []) (tl as')\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs' []) (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs' []) (tl as')", "."], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs' []) (tl as')\n\ngoal (2 subgoals):\n 1. as'' = [] \\<and> a # as = as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'\n 2. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>as'' = [] \\<and> a#as = as'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>\n         \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  as'' = [] \\<and> a # as = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  valid_path_aux (upd_cs cs' []) (tl as')", "show ?thesis"], ["proof (prove)\nusing this:\n  as'' = [] \\<and> a # as = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  valid_path_aux (upd_cs cs' []) (tl as')\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by fastforce"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "assume \"\\<exists>xs. a#xs = as'' \\<and> as = xs@as'\""], ["proof (state)\nthis:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'", "obtain xs where \"a#xs = as''\" and \"as = xs@as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. a # xs = as'' \\<and> as = xs @ as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>a # xs = as''; as = xs @ as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a # xs = as''\n  as = xs @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from IH2[OF \\<open>as = xs@as'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs' xs) as'", "have \"valid_path_aux (upd_cs cs' xs) as'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs' xs) as'\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs' xs) as'", "."], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs' xs) as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "from \\<open>a#xs = as''\\<close>[THEN sym] \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'", "have \"upd_cs cs' xs = upd_cs cs as''\""], ["proof (prove)\nusing this:\n  as'' = a # xs\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs' xs = upd_cs cs as''", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' xs = upd_cs cs as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. a # xs = as'' \\<and> as = xs @ as' \\<Longrightarrow>\n    valid_path_aux (upd_cs cs as'') as'", "with \\<open>valid_path_aux (upd_cs cs' xs) as'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs' xs) as'\n  upd_cs cs' xs = upd_cs cs as''", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs' xs) as'\n  upd_cs cs' xs = upd_cs cs as''\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as'') as'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (2 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'", "}"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as'') as'\n\ngoal (2 subgoals):\n 1. \\<And>cs as as'. [] = as @ as' \\<Longrightarrow> valid_path_aux cs as\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_aux (upd_cs cs as) as'", "qed simp_all"], ["", "lemma valid_path_aux_Append:\n  \"\\<lbrakk>valid_path_aux cs as; valid_path_aux (upd_cs cs as) as'\\<rbrakk>\n  \\<Longrightarrow> valid_path_aux cs (as@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_aux cs as;\n     valid_path_aux (upd_cs cs as) as'\\<rbrakk>\n    \\<Longrightarrow> valid_path_aux cs (as @ as')", "by(induct rule:vpa_induct,auto simp:intra_kind_def)"], ["", "lemma vpa_snoc_Call:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"valid_path_aux cs as \\<Longrightarrow> valid_path_aux cs (as@[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux cs as \\<Longrightarrow> valid_path_aux cs (as @ [a])", "proof(induct rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_aux cs ([] @ [a])\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_aux cs as;\n        valid_path_aux cs (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 4. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 5. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "case (vpa_empty cs)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_aux cs ([] @ [a])\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_aux cs as;\n        valid_path_aux cs (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 4. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 5. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"valid_path_aux cs [a]\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs [a]", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs [a]\n\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_aux cs ([] @ [a])\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_aux cs as;\n        valid_path_aux cs (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 4. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 5. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_aux cs [a]\n\ngoal (1 subgoal):\n 1. valid_path_aux cs ([] @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs ([] @ [a])\n\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_aux cs as;\n        valid_path_aux cs (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 4. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_aux cs as;\n        valid_path_aux cs (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 4. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "case (vpa_intra cs a' as')"], ["proof (state)\nthis:\n  intra_kind (kind a')\n  valid_path_aux cs as'\n  valid_path_aux cs (as' @ [a])\n\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_aux cs as;\n        valid_path_aux cs (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 4. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "from \\<open>valid_path_aux cs (as'@[a])\\<close> \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux cs (as' @ [a])\n  intra_kind (kind a')", "have \"valid_path_aux cs (a'#(as'@[a]))\""], ["proof (prove)\nusing this:\n  valid_path_aux cs (as' @ [a])\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a' # as' @ [a])", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_aux cs as;\n        valid_path_aux cs (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 4. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_aux cs ((a' # as') @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs ((a' # as') @ [a])\n\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "case (vpa_Call cs a' as' Q' r' p' fs')"], ["proof (state)\nthis:\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  valid_path_aux (a' # cs) as'\n  valid_path_aux (a' # cs) (as' @ [a])\n\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "from \\<open>valid_path_aux (a'#cs) (as'@[a])\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (a' # cs) (as' @ [a])\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'", "have \"valid_path_aux cs (a'#(as'@[a]))\""], ["proof (prove)\nusing this:\n  valid_path_aux (a' # cs) (as' @ [a])\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a' # as' @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (aa # cs) as;\n        valid_path_aux (aa # cs) (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 3. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_aux cs ((a' # as') @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs ((a' # as') @ [a])\n\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "case (vpa_ReturnEmpty cs a' as' Q' p' f')"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  cs = []\n  valid_path_aux [] as'\n  valid_path_aux [] (as' @ [a])\n\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "from \\<open>valid_path_aux [] (as'@[a])\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux [] (as' @ [a])\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  cs = []", "have \"valid_path_aux cs (a'#(as'@[a]))\""], ["proof (prove)\nusing this:\n  valid_path_aux [] (as' @ [a])\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  cs = []\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a' # as' @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as; valid_path_aux [] (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])\n 2. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_aux cs ((a' # as') @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs ((a' # as') @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "case (vpa_ReturnCons cs a' as' Q' p' f' c' cs')"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  cs = c' # cs'\n  valid_path_aux cs' as'\n  a' \\<in> get_return_edges c'\n  valid_path_aux cs' (as' @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "from \\<open>valid_path_aux cs' (as'@[a])\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close> \\<open>cs = c'#cs'\\<close>\n    \\<open>a' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux cs' (as' @ [a])\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  cs = c' # cs'\n  a' \\<in> get_return_edges c'", "have \"valid_path_aux cs (a'#(as'@[a]))\""], ["proof (prove)\nusing this:\n  valid_path_aux cs' (as' @ [a])\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  cs = c' # cs'\n  a' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a' # as' @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q p f c' cs'.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'; valid_path_aux cs' as; aa \\<in> get_return_edges c';\n        valid_path_aux cs' (as @ [a])\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs ((aa # as) @ [a])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_aux cs (a' # as' @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_aux cs ((a' # as') @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs ((a' # as') @ [a])\n\ngoal:\nNo subgoals!", "qed"], ["", "definition valid_path :: \"'edge list \\<Rightarrow> bool\"\n  where \"valid_path as \\<equiv> valid_path_aux [] as\""], ["", "lemma valid_path_aux_valid_path:\n  \"valid_path_aux cs as \\<Longrightarrow> valid_path as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux cs as \\<Longrightarrow> valid_path as", "by(fastforce intro:valid_path_aux_callstack_prefix simp:valid_path_def)"], ["", "lemma valid_path_split:\n  assumes \"valid_path (as@as')\" shows \"valid_path as\" and \"valid_path as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path as &&& valid_path as'", "using \\<open>valid_path (as@as')\\<close>"], ["proof (prove)\nusing this:\n  valid_path (as @ as')\n\ngoal (1 subgoal):\n 1. valid_path as &&& valid_path as'", "apply(auto simp:valid_path_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path_aux [] (as @ as') \\<Longrightarrow> valid_path_aux [] as\n 2. valid_path_aux [] (as @ as') \\<Longrightarrow> valid_path_aux [] as'", "apply(erule valid_path_aux_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux [] (as @ as') \\<Longrightarrow> valid_path_aux [] as'", "apply(drule valid_path_aux_split(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs [] as) as' \\<Longrightarrow>\n    valid_path_aux [] as'", "by(fastforce intro:valid_path_aux_callstack_prefix)"], ["", "definition valid_path' :: \"'node \\<Rightarrow> 'edge list \\<Rightarrow> 'node \\<Rightarrow> bool\"\n  (\"_ -_\\<rightarrow>\\<^sub>\\<surd>* _\" [51,0,0] 80)\nwhere vp_def:\"n -as\\<rightarrow>\\<^sub>\\<surd>* n' \\<equiv> n -as\\<rightarrow>* n' \\<and> valid_path as\""], ["", "lemma intra_path_vp:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" shows \"n -as\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -as\\<rightarrow>* n'\" and \"\\<forall>a \\<in> set as. intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* n' &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>\\<forall>a \\<in> set as. intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"valid_path_aux [] as\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. valid_path_aux [] as", "by(rule valid_path_aux_intra_path)"], ["proof (state)\nthis:\n  valid_path_aux [] as\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_path_aux [] as\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "using \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (prove)\nusing this:\n  valid_path_aux [] as\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "by(simp add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vp_split_Cons:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = a'#as'\" and \"n = sourcenode a'\"\n  and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; n = sourcenode a'; valid_edge a';\n         targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* n'\\<close> \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n  as \\<noteq> []", "obtain a' as' where \"as = a'#as'\"\n    and \"n = sourcenode a'\" and \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; n = sourcenode a'; valid_edge a';\n         targetnode a' -as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:path_split_Cons simp:vp_def)"], ["proof (state)\nthis:\n  as = a' # as'\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "have \"valid_path as\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal (1 subgoal):\n 1. valid_path as", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  valid_path as\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'", "have \"as = [a']@as'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. as = [a'] @ as'", "by simp"], ["proof (state)\nthis:\n  as = [a'] @ as'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "with \\<open>valid_path as\\<close>"], ["proof (chain)\npicking this:\n  valid_path as\n  as = [a'] @ as'", "have \"valid_path ([a']@as')\""], ["proof (prove)\nusing this:\n  valid_path as\n  as = [a'] @ as'\n\ngoal (1 subgoal):\n 1. valid_path ([a'] @ as')", "by simp"], ["proof (state)\nthis:\n  valid_path ([a'] @ as')\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "hence \"valid_path as'\""], ["proof (prove)\nusing this:\n  valid_path ([a'] @ as')\n\ngoal (1 subgoal):\n 1. valid_path as'", "by(rule valid_path_split)"], ["proof (state)\nthis:\n  valid_path as'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "with \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -as'\\<rightarrow>* n'\n  valid_path as'", "have \"targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\nusing this:\n  targetnode a' -as'\\<rightarrow>* n'\n  valid_path as'\n\ngoal (1 subgoal):\n 1. targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "with \\<open>as = a'#as'\\<close> \\<open>n = sourcenode a'\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "show \"\\<exists>a' as'. as = a'#as' \\<and> n = sourcenode a' \\<and> valid_edge a' \\<and> \n                 targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       n = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>a' as'.\n     as = a' # as' \\<and>\n     n = sourcenode a' \\<and>\n     valid_edge a' \\<and> targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vp_split_snoc:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<surd>* n'\" and \"as \\<noteq> []\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\"\n  and \"valid_edge a'\" and \"n' = targetnode a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        \\<lbrakk>as = as' @ [a'];\n         n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'; valid_edge a';\n         n' = targetnode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* n'\\<close> \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n  as \\<noteq> []", "obtain a' as' where \"as = as'@[a']\"\n    and \"n -as'\\<rightarrow>* sourcenode a'\" and \"valid_edge a'\" and \"n' = targetnode a'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        \\<lbrakk>as = as' @ [a']; n -as'\\<rightarrow>* sourcenode a';\n         valid_edge a'; n' = targetnode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp:vp_def)(erule path_split_snoc,auto)"], ["proof (state)\nthis:\n  as = as' @ [a']\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  n' = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* n'\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n  as = as' @ [a']", "have \"valid_path (as'@[a'])\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* n'\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. valid_path (as' @ [a'])", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  valid_path (as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "hence \"valid_path as'\""], ["proof (prove)\nusing this:\n  valid_path (as' @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path as'", "by(rule valid_path_split)"], ["proof (state)\nthis:\n  valid_path as'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "with \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_path as'", "have \"n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_path as'\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "with \\<open>as = as'@[a']\\<close> \\<open>valid_edge a'\\<close> \\<open>n' = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  valid_edge a'\n  n' = targetnode a'\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'", "show \"\\<exists>as' a'. as = as'@[a'] \\<and> n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and> valid_edge a' \\<and> \n                 n' = targetnode a'\""], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  valid_edge a'\n  n' = targetnode a'\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and>\n       valid_edge a' \\<and> n' = targetnode a'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as' a'.\n     as = as' @ [a'] \\<and>\n     n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' \\<and>\n     valid_edge a' \\<and> n' = targetnode a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vp_split:\n  assumes \"n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\"\n  shows \"n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\" and \"valid_edge a\" and \"targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a &&&\n    valid_edge a &&& targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n 2. valid_edge a\n 3. targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "have \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\" \n    and \"targetnode a -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&&\n    valid_edge a &&& targetnode a -as'\\<rightarrow>* n'", "by(auto intro:path_split simp:vp_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  targetnode a -as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n 2. valid_edge a\n 3. targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "have \"valid_path (as@a#as')\""], ["proof (prove)\nusing this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal (1 subgoal):\n 1. valid_path (as @ a # as')", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  valid_path (as @ a # as')\n\ngoal (3 subgoals):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n 2. valid_edge a\n 3. targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "hence \"valid_path as\" and \"valid_path (a#as')\""], ["proof (prove)\nusing this:\n  valid_path (as @ a # as')\n\ngoal (1 subgoal):\n 1. valid_path as &&& valid_path (a # as')", "by(auto intro:valid_path_split)"], ["proof (state)\nthis:\n  valid_path as\n  valid_path (a # as')\n\ngoal (3 subgoals):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n 2. valid_edge a\n 3. targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>valid_path (a#as')\\<close>"], ["proof (chain)\npicking this:\n  valid_path (a # as')", "have \"valid_path ([a]@as')\""], ["proof (prove)\nusing this:\n  valid_path (a # as')\n\ngoal (1 subgoal):\n 1. valid_path ([a] @ as')", "by simp"], ["proof (state)\nthis:\n  valid_path ([a] @ as')\n\ngoal (3 subgoals):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n 2. valid_edge a\n 3. targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "hence \"valid_path as'\""], ["proof (prove)\nusing this:\n  valid_path ([a] @ as')\n\ngoal (1 subgoal):\n 1. valid_path as'", "by(rule valid_path_split)"], ["proof (state)\nthis:\n  valid_path as'\n\ngoal (3 subgoals):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n 2. valid_edge a\n 3. targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "with \\<open>n -as\\<rightarrow>* sourcenode a\\<close> \\<open>valid_path as\\<close> \\<open>valid_edge a\\<close> \\<open>targetnode a -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* sourcenode a\n  valid_path as\n  valid_edge a\n  targetnode a -as'\\<rightarrow>* n'\n  valid_path as'", "show \"n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\" \"valid_edge a\" \"targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* sourcenode a\n  valid_path as\n  valid_edge a\n  targetnode a -as'\\<rightarrow>* n'\n  valid_path as'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a &&&\n    valid_edge a &&& targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'", "by(auto simp:vp_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  valid_edge a\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vp_split_second:\n  assumes \"n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\" shows \"sourcenode a -a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "have \"sourcenode a -a#as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>* n'", "by(fastforce elim:path_split_second simp:vp_def)"], ["proof (state)\nthis:\n  sourcenode a -a # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "from \\<open>n -as@a#as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "have \"valid_path (as@a#as')\""], ["proof (prove)\nusing this:\n  n -as @ a # as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal (1 subgoal):\n 1. valid_path (as @ a # as')", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  valid_path (as @ a # as')\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "hence \"valid_path (a#as')\""], ["proof (prove)\nusing this:\n  valid_path (as @ a # as')\n\ngoal (1 subgoal):\n 1. valid_path (a # as')", "by(rule valid_path_split)"], ["proof (state)\nthis:\n  valid_path (a # as')\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "with \\<open>sourcenode a -a#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -a # as'\\<rightarrow>* n'\n  valid_path (a # as')", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a -a # as'\\<rightarrow>* n'\n  valid_path (a # as')\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<surd>* n'", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<surd>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "function valid_path_rev_aux :: \"'edge list \\<Rightarrow> 'edge list \\<Rightarrow> bool\"\n  where \"valid_path_rev_aux cs [] \\<longleftrightarrow> True\"\n  | \"valid_path_rev_aux cs (as@[a]) \\<longleftrightarrow> \n       (case (kind a) of Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow> valid_path_rev_aux (a#cs) as\n                       | Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow> case cs of [] \\<Rightarrow> valid_path_rev_aux [] as\n                                     | c'#cs' \\<Rightarrow> c' \\<in> get_return_edges a \\<and>\n                                                 valid_path_rev_aux cs' as\n                       |    _ \\<Rightarrow> valid_path_rev_aux cs as)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>cs. x = (cs, []) \\<Longrightarrow> P;\n        \\<And>cs as a. x = (cs, as @ [a]) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cs csa. (cs, []) = (csa, []) \\<Longrightarrow> True = True\n 3. \\<And>cs csa as a.\n       (cs, []) = (csa, as @ [a]) \\<Longrightarrow>\n       True =\n       (case kind a of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case csa of [] \\<Rightarrow> valid_path_rev_aux_sumC ([], as)\n          | c' # cs' \\<Rightarrow>\n              c' \\<in> get_return_edges a \\<and>\n              valid_path_rev_aux_sumC (cs', as)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            valid_path_rev_aux_sumC (a # csa, as)\n        | _ \\<Rightarrow> valid_path_rev_aux_sumC (csa, as))\n 4. \\<And>cs as a csa asa aa.\n       (cs, as @ [a]) = (csa, asa @ [aa]) \\<Longrightarrow>\n       (case kind a of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case cs of [] \\<Rightarrow> valid_path_rev_aux_sumC ([], as)\n          | c' # cs' \\<Rightarrow>\n              c' \\<in> get_return_edges a \\<and>\n              valid_path_rev_aux_sumC (cs', as)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            valid_path_rev_aux_sumC (a # cs, as)\n        | _ \\<Rightarrow> valid_path_rev_aux_sumC (cs, as)) =\n       (case kind aa of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case csa of [] \\<Rightarrow> valid_path_rev_aux_sumC ([], asa)\n          | c' # cs' \\<Rightarrow>\n              c' \\<in> get_return_edges aa \\<and>\n              valid_path_rev_aux_sumC (cs', asa)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            valid_path_rev_aux_sumC (aa # csa, asa)\n        | _ \\<Rightarrow> valid_path_rev_aux_sumC (csa, asa))", "by auto(case_tac b rule:rev_cases,auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All valid_path_rev_aux_dom", "by lexicographic_order"], ["", "lemma vpra_induct [consumes 1,case_names vpra_empty vpra_intra vpra_Return \n  vpra_CallEmpty vpra_CallCons]:\n  assumes major: \"valid_path_rev_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); valid_path_rev_aux cs as; P cs as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q p f. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; valid_path_rev_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q r p fs. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = []; valid_path_rev_aux [] as; \n         P [] as\\<rbrakk> \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q r p fs c' cs'. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = c'#cs'; \n         valid_path_rev_aux cs' as; c' \\<in> get_return_edges a; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (as@[a])\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "using major"], ["proof (prove)\nusing this:\n  valid_path_rev_aux xs ys\n\ngoal (1 subgoal):\n 1. P xs ys", "apply(induct ys arbitrary:xs rule:rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. valid_path_rev_aux xs [] \\<Longrightarrow> P xs []\n 2. \\<And>x xs xsa.\n       \\<lbrakk>\\<And>xsa.\n                   valid_path_rev_aux xsa xs \\<Longrightarrow> P xsa xs;\n        valid_path_rev_aux xsa (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> P xsa (xs @ [x])", "by(auto intro:rules split:edge_kind.split_asm list.split_asm simp:intra_kind_def)"], ["", "lemma vpra_callstack_prefix:\n  \"valid_path_rev_aux (cs@cs') as \\<Longrightarrow> valid_path_rev_aux cs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_rev_aux (cs @ cs') as \\<Longrightarrow>\n    valid_path_rev_aux cs as", "proof(induct \"cs@cs'\" as arbitrary:cs cs' rule:vpra_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs cs'. valid_path_rev_aux cs []\n 2. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 4. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 5. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "case vpra_empty"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>cs cs'. valid_path_rev_aux cs []\n 2. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 4. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 5. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs []", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs []\n\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 4. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 4. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "case (vpra_intra a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_rev_aux (cs @ cs') as\n  cs @ cs' = ?cs @ ?cs' \\<Longrightarrow> valid_path_rev_aux ?cs as\n\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 4. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "hence \"valid_path_rev_aux cs as\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_rev_aux (cs @ cs') as\n  cs @ cs' = ?cs @ ?cs' \\<Longrightarrow> valid_path_rev_aux ?cs as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as\n\ngoal (4 subgoals):\n 1. \\<And>a as cs cs'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux (cs @ cs') as;\n        \\<And>csa cs'a.\n           cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 4. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as", "show ?case"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (as @ [a])", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (as @ [a])\n\ngoal (3 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "case (vpra_Return a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs @ cs') as\n  a # cs @ cs' = ?cs @ ?cs' \\<Longrightarrow> valid_path_rev_aux ?cs as\n\ngoal (3 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "note IH = \\<open>\\<And>ds ds'. a#cs@cs' = ds@ds' \\<Longrightarrow> valid_path_rev_aux ds as\\<close>"], ["proof (state)\nthis:\n  a # cs @ cs' = ?ds @ ?ds' \\<Longrightarrow> valid_path_rev_aux ?ds as\n\ngoal (3 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "have \"a#cs@cs' = (a#cs)@cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # cs @ cs' = (a # cs) @ cs'", "by simp"], ["proof (state)\nthis:\n  a # cs @ cs' = (a # cs) @ cs'\n\ngoal (3 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "from IH[OF this]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (a # cs) as", "have \"valid_path_rev_aux (a#cs) as\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (a # cs) as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (a # cs) as", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (a # cs) as\n\ngoal (3 subgoals):\n 1. \\<And>a as Q p f cs cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs @ cs') as;\n        \\<And>csa cs'a.\n           a # cs @ cs' = csa @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux csa as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 3. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (as @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (as @ [a])\n\ngoal (2 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "case (vpra_CallEmpty a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs @ cs' = []\n  valid_path_rev_aux [] as\n  [] = ?cs @ ?cs' \\<Longrightarrow> valid_path_rev_aux ?cs as\n\ngoal (2 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "hence \"valid_path_rev_aux cs as\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs @ cs' = []\n  valid_path_rev_aux [] as\n  [] = ?cs @ ?cs' \\<Longrightarrow> valid_path_rev_aux ?cs as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as\n\ngoal (2 subgoals):\n 1. \\<And>a as Q r p fs cs cs'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs' = []; valid_path_rev_aux [] as;\n        \\<And>cs cs'.\n           [] = cs @ cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])\n 2. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs@cs' = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs @ cs' = []\n  valid_path_rev_aux cs as", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs @ cs' = []\n  valid_path_rev_aux cs as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (as @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (as @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "case (vpra_CallCons a as Q r p fs c' csx)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs @ cs' = c' # csx\n  valid_path_rev_aux csx as\n  c' \\<in> get_return_edges a\n  csx = ?cs @ ?cs' \\<Longrightarrow> valid_path_rev_aux ?cs as\n\ngoal (1 subgoal):\n 1. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "note IH = \\<open>\\<And>cs cs'. csx = cs@cs' \\<Longrightarrow> valid_path_rev_aux cs as\\<close>"], ["proof (state)\nthis:\n  csx = ?cs @ ?cs' \\<Longrightarrow> valid_path_rev_aux ?cs as\n\ngoal (1 subgoal):\n 1. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "from \\<open>cs@cs' = c'#csx\\<close>"], ["proof (chain)\npicking this:\n  cs @ cs' = c' # csx", "have \"(cs = [] \\<and> cs' = c'#csx) \\<or> (\\<exists>zs. cs = c'#zs \\<and> zs@cs' = csx)\""], ["proof (prove)\nusing this:\n  cs @ cs' = c' # csx\n\ngoal (1 subgoal):\n 1. cs = [] \\<and> cs' = c' # csx \\<or>\n    (\\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx)", "by(simp add:append_eq_Cons_conv)"], ["proof (state)\nthis:\n  cs = [] \\<and> cs' = c' # csx \\<or>\n  (\\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx)\n\ngoal (1 subgoal):\n 1. \\<And>a as Q r p fs c' cs' cs cs'a.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs @ cs'a = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>cs cs'a.\n           cs' = cs @ cs'a \\<Longrightarrow>\n           valid_path_rev_aux cs as\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (as @ [a])", "thus ?case"], ["proof (prove)\nusing this:\n  cs = [] \\<and> cs' = c' # csx \\<or>\n  (\\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (as @ [a])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<and> cs' = c' # csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])\n 2. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "assume \"cs = [] \\<and> cs' = c'#csx\""], ["proof (state)\nthis:\n  cs = [] \\<and> cs' = c' # csx\n\ngoal (2 subgoals):\n 1. cs = [] \\<and> cs' = c' # csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])\n 2. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "hence \"cs = []\" and \"cs' = c'#csx\""], ["proof (prove)\nusing this:\n  cs = [] \\<and> cs' = c' # csx\n\ngoal (1 subgoal):\n 1. cs = [] &&& cs' = c' # csx", "by simp_all"], ["proof (state)\nthis:\n  cs = []\n  cs' = c' # csx\n\ngoal (2 subgoals):\n 1. cs = [] \\<and> cs' = c' # csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])\n 2. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "from \\<open>cs' = c'#csx\\<close>"], ["proof (chain)\npicking this:\n  cs' = c' # csx", "have \"csx = []@tl cs'\""], ["proof (prove)\nusing this:\n  cs' = c' # csx\n\ngoal (1 subgoal):\n 1. csx = [] @ tl cs'", "by simp"], ["proof (state)\nthis:\n  csx = [] @ tl cs'\n\ngoal (2 subgoals):\n 1. cs = [] \\<and> cs' = c' # csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])\n 2. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "from IH[OF this]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux [] as", "have \"valid_path_rev_aux [] as\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux [] as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux [] as", "."], ["proof (state)\nthis:\n  valid_path_rev_aux [] as\n\ngoal (2 subgoals):\n 1. cs = [] \\<and> cs' = c' # csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])\n 2. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "with \\<open>cs = []\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  cs = []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_rev_aux [] as", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_rev_aux [] as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (as @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (as @ [a])\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "assume \"\\<exists>zs. cs = c'#zs \\<and> zs@cs' = csx\""], ["proof (state)\nthis:\n  \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "then"], ["proof (chain)\npicking this:\n  \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx", "obtain zs where \"cs = c'#zs\" and \"csx = zs@cs'\""], ["proof (prove)\nusing this:\n  \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>cs = c' # zs; csx = zs @ cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cs = c' # zs\n  csx = zs @ cs'\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "from IH[OF \\<open>csx = zs@cs'\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux zs as", "have \"valid_path_rev_aux zs as\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux zs as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux zs as", "."], ["proof (state)\nthis:\n  valid_path_rev_aux zs as\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cs = c' # zs \\<and> zs @ cs' = csx \\<Longrightarrow>\n    valid_path_rev_aux cs (as @ [a])", "with \\<open>cs = c'#zs\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>c' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # zs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux zs as", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = c' # zs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux zs as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (as @ [a])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (as @ [a])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (as @ [a])\n\ngoal:\nNo subgoals!", "qed"], ["", "function upd_rev_cs :: \"'edge list \\<Rightarrow> 'edge list \\<Rightarrow> 'edge list\"\n  where \"upd_rev_cs cs [] = cs\"\n  | \"upd_rev_cs cs (as@[a]) =\n       (case (kind a) of Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow> upd_rev_cs (a#cs) as\n                       | Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow> case cs of [] \\<Rightarrow> upd_rev_cs cs as\n                                      | c'#cs' \\<Rightarrow> upd_rev_cs cs' as\n                       |    _ \\<Rightarrow> upd_rev_cs cs as)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>cs. x = (cs, []) \\<Longrightarrow> P;\n        \\<And>cs as a. x = (cs, as @ [a]) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cs csa. (cs, []) = (csa, []) \\<Longrightarrow> cs = csa\n 3. \\<And>cs csa as a.\n       (cs, []) = (csa, as @ [a]) \\<Longrightarrow>\n       cs =\n       (case kind a of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case csa of [] \\<Rightarrow> upd_rev_cs_sumC (csa, as)\n          | c' # cs' \\<Rightarrow> upd_rev_cs_sumC (cs', as)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            upd_rev_cs_sumC (a # csa, as)\n        | _ \\<Rightarrow> upd_rev_cs_sumC (csa, as))\n 4. \\<And>cs as a csa asa aa.\n       (cs, as @ [a]) = (csa, asa @ [aa]) \\<Longrightarrow>\n       (case kind a of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case cs of [] \\<Rightarrow> upd_rev_cs_sumC (cs, as)\n          | c' # cs' \\<Rightarrow> upd_rev_cs_sumC (cs', as)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            upd_rev_cs_sumC (a # cs, as)\n        | _ \\<Rightarrow> upd_rev_cs_sumC (cs, as)) =\n       (case kind aa of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case csa of [] \\<Rightarrow> upd_rev_cs_sumC (csa, asa)\n          | c' # cs' \\<Rightarrow> upd_rev_cs_sumC (cs', asa)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            upd_rev_cs_sumC (aa # csa, asa)\n        | _ \\<Rightarrow> upd_rev_cs_sumC (csa, asa))", "by auto(case_tac b rule:rev_cases,auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All upd_rev_cs_dom", "by lexicographic_order"], ["", "lemma upd_rev_cs_empty [dest]:\n  \"upd_rev_cs cs [] = [] \\<Longrightarrow> cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs [] = [] \\<Longrightarrow> cs = []", "by(cases cs) auto"], ["", "lemma valid_path_rev_aux_split:\n  assumes \"valid_path_rev_aux cs (as@as')\"\n  shows \"valid_path_rev_aux cs as'\" and \"valid_path_rev_aux (upd_rev_cs cs as') as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as' &&& valid_path_rev_aux (upd_rev_cs cs as') as", "using \\<open>valid_path_rev_aux cs (as@as')\\<close>"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs (as @ as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as' &&& valid_path_rev_aux (upd_rev_cs cs as') as", "proof(induct cs \"as@as'\" arbitrary:as as' rule:vpra_induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 10. \\<And>cs a as Q r p fs c' cs' asa as'.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         cs = c' # cs'; valid_path_rev_aux cs' as;\n         c' \\<in> get_return_edges a;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_rev_aux (upd_rev_cs cs' as') asa;\n         as @ [a] = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case (vpra_intra cs a as as'')"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 10. \\<And>cs a as Q r p fs c' cs' asa as'.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         cs = c' # cs'; valid_path_rev_aux cs' as;\n         c' \\<in> get_return_edges a;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_rev_aux (upd_rev_cs cs' as') asa;\n         as @ [a] = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux cs ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_rev_aux cs ?ys\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 10. \\<And>cs a as Q r p fs c' cs' asa as'.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         cs = c' # cs'; valid_path_rev_aux cs' as;\n         c' \\<in> get_return_edges a;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_rev_aux (upd_rev_cs cs' as') asa;\n         as @ [a] = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs ys) xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs ?ys) ?xs\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 10. \\<And>cs a as Q r p fs c' cs' asa as'.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         cs = c' # cs'; valid_path_rev_aux cs' as;\n         c' \\<in> get_return_edges a;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_rev_aux (upd_rev_cs cs' as') asa;\n         as @ [a] = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs ?ys) ?xs\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 10. \\<And>cs a as Q r p fs c' cs' asa as'.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         cs = c' # cs'; valid_path_rev_aux cs' as;\n         c' \\<in> get_return_edges a;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_rev_aux (upd_rev_cs cs' as') asa;\n         as @ [a] = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 10. \\<And>cs a as Q r p fs c' cs' asa as'.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         cs = c' # cs'; valid_path_rev_aux cs' as;\n         c' \\<in> get_return_edges a;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_rev_aux (upd_rev_cs cs' as') asa;\n         as @ [a] = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (10 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 10. \\<And>cs a as Q r p fs c' cs' asa as'.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         cs = c' # cs'; valid_path_rev_aux cs' as;\n         c' \\<in> get_return_edges a;\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n         \\<And>asa as'.\n            as = asa @ as' \\<Longrightarrow>\n            valid_path_rev_aux (upd_rev_cs cs' as') asa;\n         as @ [a] = asa @ as'\\<rbrakk>\n        \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "thus ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "from IH1[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs xs", "have \"valid_path_rev_aux cs xs\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs xs", "."], ["proof (state)\nthis:\n  valid_path_rev_aux cs xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "with \\<open>xs@[a] = as'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  intra_kind (kind a)\n  valid_path_rev_aux cs xs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  intra_kind (kind a)\n  valid_path_rev_aux cs xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (9 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (9 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as asa as'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 9. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "hence \"as = butlast as''@[]\""], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. as = butlast as'' @ []", "by(cases as) auto"], ["proof (state)\nthis:\n  as = butlast as'' @ []\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs []) (butlast as'')", "have \"valid_path_rev_aux (upd_rev_cs cs []) (butlast as'')\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs []) (butlast as'')", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs []) (butlast as'')\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>as' = [] \\<and> as@[a] = as''\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  as' = [] \\<and> as @ [a] = as''\n  intra_kind (kind a)\n  valid_path_rev_aux (upd_rev_cs cs []) (butlast as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n  intra_kind (kind a)\n  valid_path_rev_aux (upd_rev_cs cs []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs xs) as''", "have \"valid_path_rev_aux (upd_rev_cs cs xs) as''\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs xs) as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs xs) as''", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs xs) as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from \\<open>xs@[a] = as'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  intra_kind (kind a)", "have \"upd_rev_cs cs xs = upd_rev_cs cs as'\""], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs xs = upd_rev_cs cs as'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs xs = upd_rev_cs cs as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>valid_path_rev_aux (upd_rev_cs cs xs) as''\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs xs) as''\n  upd_rev_cs cs xs = upd_rev_cs cs as'", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs xs) as''\n  upd_rev_cs cs xs = upd_rev_cs cs as'\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "}"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case (vpra_Return cs a as Q p f as'')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux (a # cs) ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs (a # cs) ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux (a#cs) ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_rev_aux (a # cs) ?ys\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs (a#cs) ys) xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs (a # cs) ?ys) ?xs\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs (a # cs) ?ys) ?xs\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_Return"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux (a # cs) ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs (a # cs) ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux (a # cs) ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs (a # cs) ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (8 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 8. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "thus ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "from IH1[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (a # cs) xs", "have \"valid_path_rev_aux (a#cs) xs\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (a # cs) xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (a # cs) xs", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (a # cs) xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "with \\<open>xs@[a] = as'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (7 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_Return"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux (a # cs) ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs (a # cs) ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux (a # cs) ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs (a # cs) ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (7 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q p f asa as'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux (a # cs) as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs (a # cs) as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 7. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "hence \"as = butlast as''@[]\""], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. as = butlast as'' @ []", "by(cases as) auto"], ["proof (state)\nthis:\n  as = butlast as'' @ []\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs (a # cs) []) (butlast as'')", "have \"valid_path_rev_aux (upd_rev_cs (a#cs) []) (butlast as'')\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs (a # cs) []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs (a # cs) []) (butlast as'')", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs (a # cs) []) (butlast as'')\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>as' = [] \\<and> as@[a] = as''\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  as' = [] \\<and> as @ [a] = as''\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (upd_rev_cs (a # cs) []) (butlast as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (upd_rev_cs (a # cs) []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs (a # cs) xs) as''", "have \"valid_path_rev_aux (upd_rev_cs (a#cs) xs) as''\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs (a # cs) xs) as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs (a # cs) xs) as''", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs (a # cs) xs) as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from \\<open>xs@[a] = as'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"upd_rev_cs (a#cs) xs = upd_rev_cs cs as'\""], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a # cs) xs = upd_rev_cs cs as'", "by fastforce"], ["proof (state)\nthis:\n  upd_rev_cs (a # cs) xs = upd_rev_cs cs as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>valid_path_rev_aux (upd_rev_cs (a#cs) xs) as''\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs (a # cs) xs) as''\n  upd_rev_cs (a # cs) xs = upd_rev_cs cs as'", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs (a # cs) xs) as''\n  upd_rev_cs (a # cs) xs = upd_rev_cs cs as'\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "}"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case (vpra_CallEmpty cs a as Q r p fs as'')"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux [] ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs [] ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux [] ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_rev_aux [] ?ys\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs [] ys) xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs [] ?ys) ?xs\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs [] ?ys) ?xs\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_CallEmpty"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux [] ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs [] ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux [] ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs [] ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (6 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 6. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "thus ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "from IH1[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux [] xs", "have \"valid_path_rev_aux [] xs\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux [] xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux [] xs", "."], ["proof (state)\nthis:\n  valid_path_rev_aux [] xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "with \\<open>xs@[a] = as'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux [] xs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux [] xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (5 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_CallEmpty"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux [] ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs [] ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux [] as\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux [] ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs [] ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (5 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux [] as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs [] as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 5. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "hence \"as = butlast as''@[]\""], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. as = butlast as'' @ []", "by(cases as) auto"], ["proof (state)\nthis:\n  as = butlast as'' @ []\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs [] []) (butlast as'')", "have \"valid_path_rev_aux (upd_rev_cs [] []) (butlast as'')\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs [] []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs [] []) (butlast as'')", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs [] []) (butlast as'')\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>as' = [] \\<and> as@[a] = as''\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  as' = [] \\<and> as @ [a] = as''\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux (upd_rev_cs [] []) (butlast as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux (upd_rev_cs [] []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs [] xs) as''", "have \"valid_path_rev_aux (upd_rev_cs [] xs) as''\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs [] xs) as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs [] xs) as''", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs [] xs) as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>xs@[a] = as'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux (upd_rev_cs [] xs) as''", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n  valid_path_rev_aux (upd_rev_cs [] xs) as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "}"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case (vpra_CallCons cs a as Q r p fs c' cs' as'')"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  valid_path_rev_aux cs' as\n  c' \\<in> get_return_edges a\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs' ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs' ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH1 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux cs' ys\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow> valid_path_rev_aux cs' ?ys\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "note IH2 = \\<open>\\<And>xs ys. as = xs@ys \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs' ys) xs\\<close>"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs' ?ys) ?xs\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "{"], ["proof (state)\nthis:\n  as = ?xs @ ?ys \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs' ?ys) ?xs\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_CallCons"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  valid_path_rev_aux cs' as\n  c' \\<in> get_return_edges a\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs' ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs' ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  valid_path_rev_aux cs' as\n  c' \\<in> get_return_edges a\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs' ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs' ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (4 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs as'\n 4. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux cs as'\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "thus ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "from IH1[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' xs", "have \"valid_path_rev_aux cs' xs\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' xs", "."], ["proof (state)\nthis:\n  valid_path_rev_aux cs' xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux cs as'", "with \\<open>xs@[a] = as'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs = c' # cs'\\<close> \\<open>c' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux cs' xs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux cs' xs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as'", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux cs as'\n\ngoal (3 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "from vpra_CallCons"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  valid_path_rev_aux cs' as\n  c' \\<in> get_return_edges a\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs' ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs' ?as') ?as\n  as @ [a] = as'' @ as'", "have \"as' = [] \\<and> as@[a] = as'' \\<or> (\\<exists>xs. as = as''@xs \\<and> xs@[a] = as')\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  valid_path_rev_aux cs' as\n  c' \\<in> get_return_edges a\n  as = ?as @ ?as' \\<Longrightarrow> valid_path_rev_aux cs' ?as'\n  as = ?as @ ?as' \\<Longrightarrow>\n  valid_path_rev_aux (upd_rev_cs cs' ?as') ?as\n  as @ [a] = as'' @ as'\n\ngoal (1 subgoal):\n 1. as' = [] \\<and> as @ [a] = as'' \\<or>\n    (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')", "by(cases as' rule:rev_cases) auto"], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (3 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as\n 3. \\<And>cs a as Q r p fs c' cs' asa as'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow> valid_path_rev_aux cs' as';\n        \\<And>asa as'.\n           as = asa @ as' \\<Longrightarrow>\n           valid_path_rev_aux (upd_rev_cs cs' as') asa;\n        as @ [a] = asa @ as'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (upd_rev_cs cs as') asa", "thus ?case"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as'' \\<or>\n  (\\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"as' = [] \\<and> as@[a] = as''\""], ["proof (state)\nthis:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "hence \"as = butlast as''@[]\""], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n\ngoal (1 subgoal):\n 1. as = butlast as'' @ []", "by(cases as) auto"], ["proof (state)\nthis:\n  as = butlast as'' @ []\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF this]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' []) (butlast as'')", "have \"valid_path_rev_aux (upd_rev_cs cs' []) (butlast as'')\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' []) (butlast as'')", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' []) (butlast as'')\n\ngoal (2 subgoals):\n 1. as' = [] \\<and> as @ [a] = as'' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''\n 2. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>as' = [] \\<and> as@[a] = as''\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs = c' # cs'\\<close>\n        \\<open>c' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  as' = [] \\<and> as @ [a] = as''\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux (upd_rev_cs cs' []) (butlast as'')", "show ?thesis"], ["proof (prove)\nusing this:\n  as' = [] \\<and> as @ [a] = as''\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux (upd_rev_cs cs' []) (butlast as'')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "assume \"\\<exists>xs. as = as''@xs \\<and> xs@[a] = as'\""], ["proof (state)\nthis:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'", "obtain xs where \"as = as''@xs\" and \"xs@[a] = as'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>as = as'' @ xs; xs @ [a] = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = as'' @ xs\n  xs @ [a] = as'\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "from IH2[OF \\<open>as = as''@xs\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' xs) as''", "have \"valid_path_rev_aux (upd_rev_cs cs' xs) as''\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' xs) as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' xs) as''", "."], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' xs) as''\n\ngoal (1 subgoal):\n 1. \\<exists>xs. as = as'' @ xs \\<and> xs @ [a] = as' \\<Longrightarrow>\n    valid_path_rev_aux (upd_rev_cs cs as') as''", "with \\<open>xs@[a] = as'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs = c' # cs'\\<close>\n        \\<open>c' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux (upd_rev_cs cs' xs) as''", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [a] = as'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a\n  valid_path_rev_aux (upd_rev_cs cs' xs) as''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs as') as''", "by fastforce"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (2 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as", "}"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs as') as''\n\ngoal (2 subgoals):\n 1. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow> valid_path_rev_aux cs as'\n 2. \\<And>cs as as'.\n       [] = as @ as' \\<Longrightarrow>\n       valid_path_rev_aux (upd_rev_cs cs as') as", "qed simp_all"], ["", "lemma valid_path_rev_aux_Append:\n  \"\\<lbrakk>valid_path_rev_aux cs as'; valid_path_rev_aux (upd_rev_cs cs as') as\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs (as@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_rev_aux cs as';\n     valid_path_rev_aux (upd_rev_cs cs as') as\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux cs (as @ as')", "by(induct rule:vpra_induct,\n   auto simp:intra_kind_def simp del:append_assoc simp:append_assoc[THEN sym])"], ["", "lemma vpra_Cons_intra:\n  assumes \"intra_kind(kind a)\"\n  shows \"valid_path_rev_aux cs as \\<Longrightarrow> valid_path_rev_aux cs (a#as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as \\<Longrightarrow>\n    valid_path_rev_aux cs (a # as)", "proof(induct rule:vpra_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_rev_aux cs [a]\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 5. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "case (vpra_empty cs)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_rev_aux cs [a]\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 5. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "have \"valid_path_rev_aux cs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs []", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs []\n\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_rev_aux cs [a]\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 5. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "with \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs []", "have \"valid_path_rev_aux cs ([]@[a])\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs []\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs ([] @ [a])", "by(simp only:valid_path_rev_aux.simps intra_kind_def,fastforce)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs ([] @ [a])\n\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_rev_aux cs [a]\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 5. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs ([] @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs [a]", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs [a]\n\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "qed(simp only:append_Cons[THEN sym] valid_path_rev_aux.simps intra_kind_def,fastforce)+"], ["", "lemma vpra_Cons_Return:\n  assumes \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  shows \"valid_path_rev_aux cs as \\<Longrightarrow> valid_path_rev_aux cs (a#as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs as \\<Longrightarrow>\n    valid_path_rev_aux cs (a # as)", "proof(induct rule:vpra_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_rev_aux cs [a]\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 5. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "case (vpra_empty cs)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_rev_aux cs [a]\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 5. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"valid_path_rev_aux cs ([]@[a])\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs ([] @ [a])", "by(simp only:valid_path_rev_aux.simps,clarsimp)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs ([] @ [a])\n\ngoal (5 subgoals):\n 1. \\<And>cs. valid_path_rev_aux cs [a]\n 2. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 5. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs ([] @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs [a]", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs [a]\n\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "case (vpra_intra cs a' as')"], ["proof (state)\nthis:\n  intra_kind (kind a')\n  valid_path_rev_aux cs as'\n  valid_path_rev_aux cs (a # as')\n\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "from \\<open>valid_path_rev_aux cs (a#as')\\<close> \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs (a # as')\n  intra_kind (kind a')", "have \"valid_path_rev_aux cs ((a#as')@[a'])\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs (a # as')\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs ((a # as') @ [a'])", "by(simp only:valid_path_rev_aux.simps,fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (4 subgoals):\n 1. \\<And>cs aa as.\n       \\<lbrakk>intra_kind (kind aa); valid_path_rev_aux cs as;\n        valid_path_rev_aux cs (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 4. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (a # as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (a # as' @ [a'])\n\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "case (vpra_Return cs a' as' Q' p' f')"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  valid_path_rev_aux (a' # cs) as'\n  valid_path_rev_aux (a' # cs) (a # as')\n\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "from \\<open>valid_path_rev_aux (a'#cs) (a#as')\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (a' # cs) (a # as')\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'", "have \"valid_path_rev_aux cs ((a#as')@[a'])\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (a' # cs) (a # as')\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs ((a # as') @ [a'])", "by(simp only:valid_path_rev_aux.simps,clarsimp)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (3 subgoals):\n 1. \\<And>cs aa as Q p f.\n       \\<lbrakk>kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (aa # cs) as;\n        valid_path_rev_aux (aa # cs) (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 3. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (a # as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (a # as' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "case (vpra_CallEmpty cs a' as' Q' r' p' fs')"], ["proof (state)\nthis:\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  cs = []\n  valid_path_rev_aux [] as'\n  valid_path_rev_aux [] (a # as')\n\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "from \\<open>valid_path_rev_aux [] (a#as')\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux [] (a # as')\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  cs = []", "have \"valid_path_rev_aux cs ((a#as')@[a'])\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux [] (a # as')\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  cs = []\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs ((a # as') @ [a'])", "by(simp only:valid_path_rev_aux.simps,clarsimp)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (2 subgoals):\n 1. \\<And>cs aa as Q r p fs.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as; valid_path_rev_aux [] (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])\n 2. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (a # as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (a # as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "case (vpra_CallCons cs a' as' Q' r' p' fs' c' cs')"], ["proof (state)\nthis:\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  cs = c' # cs'\n  valid_path_rev_aux cs' as'\n  c' \\<in> get_return_edges a'\n  valid_path_rev_aux cs' (a # as')\n\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "from \\<open>valid_path_rev_aux cs' (a#as')\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close> \\<open>cs = c'#cs'\\<close>\n    \\<open>c' \\<in> get_return_edges a'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' (a # as')\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  cs = c' # cs'\n  c' \\<in> get_return_edges a'", "have \"valid_path_rev_aux cs ((a#as')@[a'])\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' (a # as')\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  cs = c' # cs'\n  c' \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs ((a # as') @ [a'])", "by(simp only:valid_path_rev_aux.simps,clarsimp)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>cs aa as Q r p fs c' cs'.\n       \\<lbrakk>kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges aa;\n        valid_path_rev_aux cs' (a # as)\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs (a # as @ [aa])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs ((a # as') @ [a'])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs (a # as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs (a # as' @ [a'])\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "lemmas append_Cons_rev = append_Cons[THEN sym]"], ["", "declare append_Cons [simp del] append_Cons_rev [simp]"], ["", "(*>*)"], ["", "lemma upd_rev_cs_Cons_intra:\n  assumes \"intra_kind(kind a)\" shows \"upd_rev_cs cs (a#as) = upd_rev_cs cs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as) = upd_rev_cs cs as", "proof(induct as arbitrary:cs rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [a] = upd_rev_cs cs []\n 2. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = upd_rev_cs cs (xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [a] = upd_rev_cs cs []\n 2. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = upd_rev_cs cs (xs @ [x])", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"upd_rev_cs cs ([]@[a]) = upd_rev_cs cs []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ([] @ [a]) = upd_rev_cs cs []", "by(simp only:upd_rev_cs.simps,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ([] @ [a]) = upd_rev_cs cs []\n\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [a] = upd_rev_cs cs []\n 2. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = upd_rev_cs cs (xs @ [x])", "thus ?case"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ([] @ [a]) = upd_rev_cs cs []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs [a] = upd_rev_cs cs []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs [a] = upd_rev_cs cs []\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = upd_rev_cs cs (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = upd_rev_cs cs (xs @ [x])", "case (snoc a' as')"], ["proof (state)\nthis:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = upd_rev_cs cs (xs @ [x])", "note IH = \\<open>\\<And>cs. upd_rev_cs cs (a#as') = upd_rev_cs cs as'\\<close>"], ["proof (state)\nthis:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = upd_rev_cs cs (xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'", "have \"upd_rev_cs cs (a#as') = upd_rev_cs cs as'\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as') = upd_rev_cs cs as'", "."], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as') = upd_rev_cs cs as'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "with Intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = upd_rev_cs cs as'", "have \"upd_rev_cs cs ((a#as')@[a']) = upd_rev_cs cs (as'@[a'])\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = upd_rev_cs cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "case Return"], ["proof (state)\nthis:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'", "have \"upd_rev_cs (a'#cs) (a#as') = upd_rev_cs (a'#cs) as'\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a' # cs) (a # as') = upd_rev_cs (a' # cs) as'", "."], ["proof (state)\nthis:\n  upd_rev_cs (a' # cs) (a # as') = upd_rev_cs (a' # cs) as'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "with Return"], ["proof (chain)\npicking this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = upd_rev_cs (a' # cs) as'", "have \"upd_rev_cs cs ((a#as')@[a']) = upd_rev_cs cs (as'@[a'])\""], ["proof (prove)\nusing this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = upd_rev_cs (a' # cs) as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "case Call"], ["proof (state)\nthis:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "proof(cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'", "have \"upd_rev_cs [] (a#as') = upd_rev_cs [] as'\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs [] (a # as') = upd_rev_cs [] as'", "."], ["proof (state)\nthis:\n  upd_rev_cs [] (a # as') = upd_rev_cs [] as'\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "with Call Nil"], ["proof (chain)\npicking this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []\n  upd_rev_cs [] (a # as') = upd_rev_cs [] as'", "have \"upd_rev_cs cs ((a#as')@[a']) = upd_rev_cs cs (as'@[a'])\""], ["proof (prove)\nusing this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []\n  upd_rev_cs [] (a # as') = upd_rev_cs [] as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "case (Cons c' cs')"], ["proof (state)\nthis:\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'", "have \"upd_rev_cs cs' (a#as') = upd_rev_cs cs' as'\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs' (a # as') = upd_rev_cs cs' as'", "."], ["proof (state)\nthis:\n  upd_rev_cs cs' (a # as') = upd_rev_cs cs' as'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "with Call Cons"], ["proof (chain)\npicking this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = c' # cs'\n  upd_rev_cs cs' (a # as') = upd_rev_cs cs' as'", "have \"upd_rev_cs cs ((a#as')@[a']) = upd_rev_cs cs (as'@[a'])\""], ["proof (prove)\nusing this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = c' # cs'\n  upd_rev_cs cs' (a # as') = upd_rev_cs cs' as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = upd_rev_cs cs (as' @ [a'])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_rev_cs_Cons_Return:\n  assumes \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" shows \"upd_rev_cs cs (a#as) = a#(upd_rev_cs cs as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as) = a # upd_rev_cs cs as", "proof(induct as arbitrary:cs rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [a] = a # upd_rev_cs cs []\n 2. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = a # upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = a # upd_rev_cs cs (xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [a] = a # upd_rev_cs cs []\n 2. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = a # upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = a # upd_rev_cs cs (xs @ [x])", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"upd_rev_cs cs ([]@[a]) = a#(upd_rev_cs cs [])\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ([] @ [a]) = a # upd_rev_cs cs []", "by(simp only:upd_rev_cs.simps) clarsimp"], ["proof (state)\nthis:\n  upd_rev_cs cs ([] @ [a]) = a # upd_rev_cs cs []\n\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [a] = a # upd_rev_cs cs []\n 2. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = a # upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = a # upd_rev_cs cs (xs @ [x])", "thus ?case"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ([] @ [a]) = a # upd_rev_cs cs []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs [a] = a # upd_rev_cs cs []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs [a] = a # upd_rev_cs cs []\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = a # upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = a # upd_rev_cs cs (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = a # upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = a # upd_rev_cs cs (xs @ [x])", "case (snoc a' as')"], ["proof (state)\nthis:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = a # upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = a # upd_rev_cs cs (xs @ [x])", "note IH = \\<open>\\<And>cs. upd_rev_cs cs (a#as') = a#upd_rev_cs cs as'\\<close>"], ["proof (state)\nthis:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       (\\<And>cs.\n           upd_rev_cs cs (a # xs) = a # upd_rev_cs cs xs) \\<Longrightarrow>\n       upd_rev_cs cs (a # xs @ [x]) = a # upd_rev_cs cs (xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'", "have \"upd_rev_cs cs (a#as') = a#(upd_rev_cs cs as')\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as') = a # upd_rev_cs cs as'", "."], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as') = a # upd_rev_cs cs as'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "with Intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = a # upd_rev_cs cs as'", "have \"upd_rev_cs cs ((a#as')@[a']) = a#(upd_rev_cs cs (as'@[a']))\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = a # upd_rev_cs cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "case Return"], ["proof (state)\nthis:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'", "have \"upd_rev_cs (a'#cs) (a#as') = a#(upd_rev_cs (a'#cs) as')\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a' # cs) (a # as') = a # upd_rev_cs (a' # cs) as'", "."], ["proof (state)\nthis:\n  upd_rev_cs (a' # cs) (a # as') = a # upd_rev_cs (a' # cs) as'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "with Return"], ["proof (chain)\npicking this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = a # upd_rev_cs (a' # cs) as'", "have \"upd_rev_cs cs ((a#as')@[a']) = a#(upd_rev_cs cs (as'@[a']))\""], ["proof (prove)\nusing this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = a # upd_rev_cs (a' # cs) as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "case Call"], ["proof (state)\nthis:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "proof(cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'", "have \"upd_rev_cs [] (a#as') = a#(upd_rev_cs [] as')\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs [] (a # as') = a # upd_rev_cs [] as'", "."], ["proof (state)\nthis:\n  upd_rev_cs [] (a # as') = a # upd_rev_cs [] as'\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "with Call Nil"], ["proof (chain)\npicking this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []\n  upd_rev_cs [] (a # as') = a # upd_rev_cs [] as'", "have \"upd_rev_cs cs ((a#as')@[a']) = a#(upd_rev_cs cs (as'@[a']))\""], ["proof (prove)\nusing this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []\n  upd_rev_cs [] (a # as') = a # upd_rev_cs [] as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "case (Cons c' cs')"], ["proof (state)\nthis:\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "from IH"], ["proof (chain)\npicking this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'", "have \"upd_rev_cs cs' (a#as') = a#(upd_rev_cs cs' as')\""], ["proof (prove)\nusing this:\n  upd_rev_cs ?cs (a # as') = a # upd_rev_cs ?cs as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs' (a # as') = a # upd_rev_cs cs' as'", "."], ["proof (state)\nthis:\n  upd_rev_cs cs' (a # as') = a # upd_rev_cs cs' as'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "with Call Cons"], ["proof (chain)\npicking this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = c' # cs'\n  upd_rev_cs cs' (a # as') = a # upd_rev_cs cs' as'", "have \"upd_rev_cs cs ((a#as')@[a']) = a#(upd_rev_cs cs (as'@[a']))\""], ["proof (prove)\nusing this:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = c' # cs'\n  upd_rev_cs cs' (a # as') = a # upd_rev_cs cs' as'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "thus ?thesis"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ((a # as') @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = a # upd_rev_cs cs (as' @ [a'])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_rev_cs_Cons_Call_Cons:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"upd_rev_cs cs as = c'#cs' \\<Longrightarrow> upd_rev_cs cs (a#as) = cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs as = c' # cs' \\<Longrightarrow>\n    upd_rev_cs cs (a # as) = cs'", "proof(induct as arbitrary:cs rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       upd_rev_cs cs [] = c' # cs' \\<Longrightarrow> upd_rev_cs cs [a] = cs'\n 2. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = c' # cs' \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = cs';\n        upd_rev_cs cs (xs @ [x]) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = cs'", "case Nil"], ["proof (state)\nthis:\n  upd_rev_cs cs [] = c' # cs'\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       upd_rev_cs cs [] = c' # cs' \\<Longrightarrow> upd_rev_cs cs [a] = cs'\n 2. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = c' # cs' \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = cs';\n        upd_rev_cs cs (xs @ [x]) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = cs'", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs [] = c' # cs'", "have \"upd_rev_cs cs ([]@[a]) = cs'\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs [] = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ([] @ [a]) = cs'", "by(simp only:upd_rev_cs.simps) clarsimp"], ["proof (state)\nthis:\n  upd_rev_cs cs ([] @ [a]) = cs'\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       upd_rev_cs cs [] = c' # cs' \\<Longrightarrow> upd_rev_cs cs [a] = cs'\n 2. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = c' # cs' \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = cs';\n        upd_rev_cs cs (xs @ [x]) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = cs'", "thus ?case"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ([] @ [a]) = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs [a] = cs'", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs [a] = cs'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = c' # cs' \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = cs';\n        upd_rev_cs cs (xs @ [x]) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = c' # cs' \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = cs';\n        upd_rev_cs cs (xs @ [x]) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = cs'", "case (snoc a' as')"], ["proof (state)\nthis:\n  upd_rev_cs ?cs as' = c' # cs' \\<Longrightarrow>\n  upd_rev_cs ?cs (a # as') = cs'\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = c' # cs' \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = cs';\n        upd_rev_cs cs (xs @ [x]) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = cs'", "note IH = \\<open>\\<And>cs. upd_rev_cs cs as' = c'#cs' \\<Longrightarrow> upd_rev_cs cs (a#as') = cs'\\<close>"], ["proof (state)\nthis:\n  upd_rev_cs ?cs as' = c' # cs' \\<Longrightarrow>\n  upd_rev_cs ?cs (a # as') = cs'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = c' # cs' \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = cs';\n        upd_rev_cs cs (xs @ [x]) = c' # cs'\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = cs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = cs'", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "with \\<open>upd_rev_cs cs (as'@[a']) = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  intra_kind (kind a')", "have \"upd_rev_cs cs as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs as' = c' # cs'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs as' = c' # cs'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (a # as') = cs'", "have \"upd_rev_cs cs (a#as') = cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as') = cs'", "."], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as') = cs'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "with Intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = cs'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = cs'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "case Return"], ["proof (state)\nthis:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "with \\<open>upd_rev_cs cs (as'@[a']) = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_", "have \"upd_rev_cs (a'#cs) as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a' # cs) as' = c' # cs'", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs (a' # cs) as' = c' # cs'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs (a' # cs) (a # as') = cs'", "have \"upd_rev_cs (a'#cs) (a#as') = cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs (a' # cs) (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a' # cs) (a # as') = cs'", "."], ["proof (state)\nthis:\n  upd_rev_cs (a' # cs) (a # as') = cs'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "with Return"], ["proof (chain)\npicking this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = cs'", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "case Call"], ["proof (state)\nthis:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = cs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = cs'", "proof(cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "with \\<open>upd_rev_cs cs (as'@[a']) = c'#cs'\\<close> Call"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []", "have \"upd_rev_cs cs as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs as' = c' # cs'", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs as' = c' # cs'\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (a # as') = cs'", "have \"upd_rev_cs cs (a#as') = cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as') = cs'", "."], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as') = cs'\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "with Nil Call"], ["proof (chain)\npicking this:\n  cs = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs cs (a # as') = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs cs (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = cs'", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "case (Cons cx csx)"], ["proof (state)\nthis:\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "with \\<open>upd_rev_cs cs (as'@[a']) = c'#cs'\\<close> Call"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = cx # csx", "have \"upd_rev_cs csx as' = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = c' # cs'\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. upd_rev_cs csx as' = c' # cs'", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs csx as' = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs csx (a # as') = cs'", "have \"upd_rev_cs csx (a#as') = cs'\""], ["proof (prove)\nusing this:\n  upd_rev_cs csx (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs csx (a # as') = cs'", "."], ["proof (state)\nthis:\n  upd_rev_cs csx (a # as') = cs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = cs'", "with Cons Call"], ["proof (chain)\npicking this:\n  cs = cx # csx\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs csx (a # as') = cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = cx # csx\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs csx (a # as') = cs'\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = cs'", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = cs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = cs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = cs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_rev_cs_Cons_Call_Cons_Empty:\n  assumes \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  shows \"upd_rev_cs cs as = [] \\<Longrightarrow> upd_rev_cs cs (a#as) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs as = [] \\<Longrightarrow> upd_rev_cs cs (a # as) = []", "proof(induct as arbitrary:cs rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [] = [] \\<Longrightarrow> upd_rev_cs cs [a] = []\n 2. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = [] \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = [];\n        upd_rev_cs cs (xs @ [x]) = []\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = []", "case Nil"], ["proof (state)\nthis:\n  upd_rev_cs cs [] = []\n\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [] = [] \\<Longrightarrow> upd_rev_cs cs [a] = []\n 2. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = [] \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = [];\n        upd_rev_cs cs (xs @ [x]) = []\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = []", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs [] = []", "have \"upd_rev_cs cs ([]@[a]) = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs [] = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs ([] @ [a]) = []", "by(simp only:upd_rev_cs.simps) clarsimp"], ["proof (state)\nthis:\n  upd_rev_cs cs ([] @ [a]) = []\n\ngoal (2 subgoals):\n 1. \\<And>cs. upd_rev_cs cs [] = [] \\<Longrightarrow> upd_rev_cs cs [a] = []\n 2. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = [] \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = [];\n        upd_rev_cs cs (xs @ [x]) = []\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = []", "thus ?case"], ["proof (prove)\nusing this:\n  upd_rev_cs cs ([] @ [a]) = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs [a] = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs [a] = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = [] \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = [];\n        upd_rev_cs cs (xs @ [x]) = []\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = [] \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = [];\n        upd_rev_cs cs (xs @ [x]) = []\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = []", "case (snoc a' as')"], ["proof (state)\nthis:\n  upd_rev_cs ?cs as' = [] \\<Longrightarrow> upd_rev_cs ?cs (a # as') = []\n  upd_rev_cs cs (as' @ [a']) = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = [] \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = [];\n        upd_rev_cs cs (xs @ [x]) = []\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = []", "note IH = \\<open>\\<And>cs. upd_rev_cs cs as' = [] \\<Longrightarrow> upd_rev_cs cs (a#as') = []\\<close>"], ["proof (state)\nthis:\n  upd_rev_cs ?cs as' = [] \\<Longrightarrow> upd_rev_cs ?cs (a # as') = []\n\ngoal (1 subgoal):\n 1. \\<And>x xs cs.\n       \\<lbrakk>\\<And>cs.\n                   upd_rev_cs cs xs = [] \\<Longrightarrow>\n                   upd_rev_cs cs (a # xs) = [];\n        upd_rev_cs cs (xs @ [x]) = []\\<rbrakk>\n       \\<Longrightarrow> upd_rev_cs cs (a # xs @ [x]) = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = []", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "with \\<open>upd_rev_cs cs (as'@[a']) = []\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = []\n  intra_kind (kind a')", "have \"upd_rev_cs cs as' = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = []\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs as' = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs as' = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (a # as') = []", "have \"upd_rev_cs cs (a#as') = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as') = []", "."], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as') = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "with Intra"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = []", "show ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  upd_rev_cs cs (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "case Return"], ["proof (state)\nthis:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "with \\<open>upd_rev_cs cs (as'@[a']) = []\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = []\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_", "have \"upd_rev_cs (a'#cs) as' = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = []\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a' # cs) as' = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs (a' # cs) as' = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs (a' # cs) (a # as') = []", "have \"upd_rev_cs (a'#cs) (a#as') = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs (a' # cs) (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a' # cs) (a # as') = []", "."], ["proof (state)\nthis:\n  upd_rev_cs (a' # cs) (a # as') = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "with Return"], ["proof (chain)\npicking this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = []", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a' = Q_\\<hookleftarrow>\\<^bsub>p_\\<^esub>f_\n  upd_rev_cs (a' # cs) (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = []\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "case Call"], ["proof (state)\nthis:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       upd_rev_cs cs (a # as' @ [a']) = []", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = []", "proof(cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "with \\<open>upd_rev_cs cs (as'@[a']) = []\\<close> Call"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []", "have \"upd_rev_cs cs as' = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs as' = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs as' = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (a # as') = []", "have \"upd_rev_cs cs (a#as') = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as') = []", "."], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as') = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []\n 2. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "with Nil Call"], ["proof (chain)\npicking this:\n  cs = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs cs (a # as') = []", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs cs (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "case (Cons cx csx)"], ["proof (state)\nthis:\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "with \\<open>upd_rev_cs cs (as'@[a']) = []\\<close> Call"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as' @ [a']) = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = cx # csx", "have \"upd_rev_cs csx as' = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as' @ [a']) = []\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  cs = cx # csx\n\ngoal (1 subgoal):\n 1. upd_rev_cs csx as' = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs csx as' = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "from IH[OF this]"], ["proof (chain)\npicking this:\n  upd_rev_cs csx (a # as') = []", "have \"upd_rev_cs csx (a#as') = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs csx (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs csx (a # as') = []", "."], ["proof (state)\nthis:\n  upd_rev_cs csx (a # as') = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs = aa # list \\<Longrightarrow> upd_rev_cs cs (a # as' @ [a']) = []", "with Cons Call"], ["proof (chain)\npicking this:\n  cs = cx # csx\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs csx (a # as') = []", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = cx # csx\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n  upd_rev_cs csx (a # as') = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs (a # as' @ [a']) = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd_rev_cs cs (a # as' @ [a']) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "declare append_Cons [simp] append_Cons_rev [simp del]"], ["", "(*>*)"], ["", "definition valid_call_list :: \"'edge list \\<Rightarrow> 'node \\<Rightarrow> bool\"\n  where \"valid_call_list cs n \\<equiv>\n  \\<forall>cs' c cs''. cs = cs'@c#cs'' \\<longrightarrow> (valid_edge c \\<and> (\\<exists>Q r p fs. (kind c = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> \n                    p = get_proc (case cs' of [] \\<Rightarrow> n | _ \\<Rightarrow> last (sourcenodes cs'))))\""], ["", "definition valid_return_list :: \"'edge list \\<Rightarrow> 'node \\<Rightarrow> bool\"\n  where \"valid_return_list cs n \\<equiv>\n  \\<forall>cs' c cs''. cs = cs'@c#cs'' \\<longrightarrow> (valid_edge c \\<and> (\\<exists>Q p f. (kind c = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<and> \n                    p = get_proc (case cs' of [] \\<Rightarrow> n | _ \\<Rightarrow> last (targetnodes cs'))))\""], ["", "lemma valid_call_list_valid_edges: \n  assumes \"valid_call_list cs n\" shows \"\\<forall>c \\<in> set cs. valid_edge c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs. valid_edge c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs. valid_edge c", "from \\<open>valid_call_list cs n\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n", "have \"\\<forall>cs' c cs''. cs = cs'@c#cs'' \\<longrightarrow> valid_edge c\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n\ngoal (1 subgoal):\n 1. \\<forall>cs' c cs''. cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c", "by(simp add:valid_call_list_def)"], ["proof (state)\nthis:\n  \\<forall>cs' c cs''. cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs. valid_edge c", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>cs' c cs''. cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set cs. valid_edge c", "proof(induct cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>cs' c cs''.\n       [] = cs' @ c # cs'' \\<longrightarrow> valid_edge c \\<Longrightarrow>\n    Ball (set []) valid_edge\n 2. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "case Nil"], ["proof (state)\nthis:\n  \\<forall>cs' c cs''. [] = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (2 subgoals):\n 1. \\<forall>cs' c cs''.\n       [] = cs' @ c # cs'' \\<longrightarrow> valid_edge c \\<Longrightarrow>\n    Ball (set []) valid_edge\n 2. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>cs' c cs''. [] = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set []. valid_edge a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "case (Cons cx csx)"], ["proof (state)\nthis:\n  \\<forall>cs' c cs''.\n     csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c \\<Longrightarrow>\n  \\<forall>a\\<in>set csx. valid_edge a\n  \\<forall>cs' c cs''.\n     cx # csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "note IH = \\<open>\\<forall>cs' c cs''. csx = cs'@c#cs'' \\<longrightarrow> valid_edge c \\<Longrightarrow>\n                            \\<forall>a\\<in>set csx. valid_edge a\\<close>"], ["proof (state)\nthis:\n  \\<forall>cs' c cs''.\n     csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c \\<Longrightarrow>\n  \\<forall>a\\<in>set csx. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "from \\<open>\\<forall>cs' c cs''. cx#csx = cs'@c#cs'' \\<longrightarrow> valid_edge c\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>cs' c cs''.\n     cx # csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c", "have \"valid_edge cx\""], ["proof (prove)\nusing this:\n  \\<forall>cs' c cs''.\n     cx # csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (1 subgoal):\n 1. valid_edge cx", "by blast"], ["proof (state)\nthis:\n  valid_edge cx\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "from \\<open>\\<forall>cs' c cs''. cx#csx = cs'@c#cs'' \\<longrightarrow> valid_edge c\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>cs' c cs''.\n     cx # csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c", "have \"\\<forall>cs' c cs''. csx = cs'@c#cs'' \\<longrightarrow> valid_edge c\""], ["proof (prove)\nusing this:\n  \\<forall>cs' c cs''.\n     cx # csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (1 subgoal):\n 1. \\<forall>cs' c cs''. csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c", "by auto(erule_tac x=\"cx#cs'\" in allE,auto)"], ["proof (state)\nthis:\n  \\<forall>cs' c cs''. csx = cs' @ c # cs'' \\<longrightarrow> valid_edge c\n\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<forall>cs' c cs''.\n                   cs = cs' @ c # cs'' \\<longrightarrow>\n                   valid_edge c \\<Longrightarrow>\n                Ball (set cs) valid_edge;\n        \\<forall>cs' c cs''.\n           a # cs = cs' @ c # cs'' \\<longrightarrow> valid_edge c\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # cs)) valid_edge", "from IH[OF this] \\<open>valid_edge cx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set csx. valid_edge a\n  valid_edge cx", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set csx. valid_edge a\n  valid_edge cx\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (cx # csx). valid_edge a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (cx # csx). valid_edge a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set cs. valid_edge c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_return_list_valid_edges: \n  assumes \"valid_return_list rs n\" shows \"\\<forall>r \\<in> set rs. valid_edge r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs. valid_edge r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs. valid_edge r", "from \\<open>valid_return_list rs n\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs n", "have \"\\<forall>rs' r rs''. rs = rs'@r#rs'' \\<longrightarrow> valid_edge r\""], ["proof (prove)\nusing this:\n  valid_return_list rs n\n\ngoal (1 subgoal):\n 1. \\<forall>rs' r rs''. rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r", "by(simp add:valid_return_list_def)"], ["proof (state)\nthis:\n  \\<forall>rs' r rs''. rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs. valid_edge r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>rs' r rs''. rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs. valid_edge r", "proof(induct rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>rs' r rs''.\n       [] = rs' @ r # rs'' \\<longrightarrow> valid_edge r \\<Longrightarrow>\n    Ball (set []) valid_edge\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "case Nil"], ["proof (state)\nthis:\n  \\<forall>rs' r rs''. [] = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (2 subgoals):\n 1. \\<forall>rs' r rs''.\n       [] = rs' @ r # rs'' \\<longrightarrow> valid_edge r \\<Longrightarrow>\n    Ball (set []) valid_edge\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>rs' r rs''. [] = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set []. valid_edge a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "case (Cons rx rsx)"], ["proof (state)\nthis:\n  \\<forall>rs' r rs''.\n     rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r \\<Longrightarrow>\n  \\<forall>a\\<in>set rsx. valid_edge a\n  \\<forall>rs' r rs''.\n     rx # rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "note IH = \\<open>\\<forall>rs' r rs''. rsx = rs'@r#rs'' \\<longrightarrow> valid_edge r \\<Longrightarrow>\n                            \\<forall>a\\<in>set rsx. valid_edge a\\<close>"], ["proof (state)\nthis:\n  \\<forall>rs' r rs''.\n     rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r \\<Longrightarrow>\n  \\<forall>a\\<in>set rsx. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "from \\<open>\\<forall>rs' r rs''. rx#rsx = rs'@r#rs'' \\<longrightarrow> valid_edge r\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>rs' r rs''.\n     rx # rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r", "have \"valid_edge rx\""], ["proof (prove)\nusing this:\n  \\<forall>rs' r rs''.\n     rx # rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (1 subgoal):\n 1. valid_edge rx", "by blast"], ["proof (state)\nthis:\n  valid_edge rx\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "from \\<open>\\<forall>rs' r rs''. rx#rsx = rs'@r#rs'' \\<longrightarrow> valid_edge r\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>rs' r rs''.\n     rx # rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r", "have \"\\<forall>rs' r rs''. rsx = rs'@r#rs'' \\<longrightarrow> valid_edge r\""], ["proof (prove)\nusing this:\n  \\<forall>rs' r rs''.\n     rx # rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (1 subgoal):\n 1. \\<forall>rs' r rs''. rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r", "by auto(erule_tac x=\"rx#rs'\" in allE,auto)"], ["proof (state)\nthis:\n  \\<forall>rs' r rs''. rsx = rs' @ r # rs'' \\<longrightarrow> valid_edge r\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>rs' r rs''.\n                   rs = rs' @ r # rs'' \\<longrightarrow>\n                   valid_edge r \\<Longrightarrow>\n                Ball (set rs) valid_edge;\n        \\<forall>rs' r rs''.\n           a # rs = rs' @ r # rs'' \\<longrightarrow> valid_edge r\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # rs)) valid_edge", "from IH[OF this] \\<open>valid_edge rx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set rsx. valid_edge a\n  valid_edge rx", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set rsx. valid_edge a\n  valid_edge rx\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (rx # rsx). valid_edge a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (rx # rsx). valid_edge a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs. valid_edge r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vpra_empty_valid_call_list_rev:\n  \"valid_call_list cs n \\<Longrightarrow> valid_path_rev_aux [] (rev cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_call_list cs n \\<Longrightarrow> valid_path_rev_aux [] (rev cs)", "proof(induct cs arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_call_list [] n \\<Longrightarrow> valid_path_rev_aux [] (rev [])\n 2. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "case Nil"], ["proof (state)\nthis:\n  valid_call_list [] n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       valid_call_list [] n \\<Longrightarrow> valid_path_rev_aux [] (rev [])\n 2. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_call_list [] n\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux [] (rev [])", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux [] (rev [])\n\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "case (Cons c' cs')"], ["proof (state)\nthis:\n  valid_call_list cs' ?n \\<Longrightarrow> valid_path_rev_aux [] (rev cs')\n  valid_call_list (c' # cs') n\n\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "note IH = \\<open>\\<And>n. valid_call_list cs' n \\<Longrightarrow> valid_path_rev_aux [] (rev cs')\\<close>"], ["proof (state)\nthis:\n  valid_call_list cs' ?n \\<Longrightarrow> valid_path_rev_aux [] (rev cs')\n\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "from \\<open>valid_call_list (c'#cs') n\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list (c' # cs') n", "have \"valid_call_list cs' (sourcenode c')\""], ["proof (prove)\nusing this:\n  valid_call_list (c' # cs') n\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (sourcenode c')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> n\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> sourcenode c'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<forall>cs'a ca.\n          (\\<exists>cs''a.\n              c' # cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n          valid_edge ca \\<and>\n          (\\<exists>Q r fs.\n              kind ca =\n              Q:r\\<hookrightarrow>\\<^bsub>get_proc\n     (case cs'a of [] \\<Rightarrow> n\n      | a # list \\<Rightarrow>\n          last (sourcenodes cs'a))\\<^esub>fs) \\<Longrightarrow>\n       valid_edge c \\<and>\n       (\\<exists>Q r fs.\n           kind c =\n           Q:r\\<hookrightarrow>\\<^bsub>get_proc\n  (case cs' of [] \\<Rightarrow> sourcenode c'\n   | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<forall>ca.\n          (\\<exists>cs''a.\n              c' # cs' @ c # cs'' =\n              (c' # cs') @ ca # cs''a) \\<longrightarrow>\n          valid_edge ca \\<and>\n          (\\<exists>Q r fs.\n              kind ca =\n              Q:r\\<hookrightarrow>\\<^bsub>get_proc\n     (case c' # cs' of [] \\<Rightarrow> n\n      | a # list \\<Rightarrow>\n          last (sourcenodes (c' # cs')))\\<^esub>fs) \\<Longrightarrow>\n       valid_edge c \\<and>\n       (\\<exists>Q r fs.\n           kind c =\n           Q:r\\<hookrightarrow>\\<^bsub>get_proc\n  (case cs' of [] \\<Rightarrow> sourcenode c'\n   | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c Q r fs.\n       \\<lbrakk>valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (last\n (sourcenodes (c' # cs')))\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (last (sourcenodes (c' # cs'))) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode c'\n                           | a # list \\<Rightarrow> last (sourcenodes cs'))", "by(case_tac cs',auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "from IH[OF this]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux [] (rev cs')", "have \"valid_path_rev_aux [] (rev cs')\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux [] (rev cs')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux [] (rev cs')", "."], ["proof (state)\nthis:\n  valid_path_rev_aux [] (rev cs')\n\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "moreover"], ["proof (state)\nthis:\n  valid_path_rev_aux [] (rev cs')\n\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "from \\<open>valid_call_list (c'#cs') n\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list (c' # cs') n", "obtain Q r p fs where \"kind c' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_call_list (c' # cs') n\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind c' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q r p fs.\n                kind c' =\n                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n                thesis;\n     \\<forall>cs'a c.\n        (\\<exists>cs''. c' # cs' = cs'a @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs'a of [] \\<Rightarrow> n\n    | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule_tac x=\"[]\" in allE) fastforce"], ["proof (state)\nthis:\n  kind c' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>a cs n.\n       \\<lbrakk>\\<And>n.\n                   valid_call_list cs n \\<Longrightarrow>\n                   valid_path_rev_aux [] (rev cs);\n        valid_call_list (a # cs) n\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev (a # cs))", "ultimately"], ["proof (chain)\npicking this:\n  valid_path_rev_aux [] (rev cs')\n  kind c' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux [] (rev cs')\n  kind c' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux [] (rev (c' # cs'))", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux [] (rev (c' # cs'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vpa_upd_cs_cases:\n  \"\\<lbrakk>valid_path_aux cs as; valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case (upd_cs cs as) of [] \\<Rightarrow> (\\<forall>c \\<in> set cs. \\<exists>a \\<in> set as. a \\<in> get_return_edges c)\n                      | cx#csx \\<Rightarrow> valid_call_list (cx#csx) n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_aux cs as; valid_call_list cs n;\n     n -as\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> case upd_cs cs as of\n                      [] \\<Rightarrow>\n                        \\<forall>c\\<in>set cs.\n                           \\<exists>a\\<in>set as. a \\<in> get_return_edges c\n                      | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "proof(induct arbitrary:n rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>valid_call_list cs n; n -[]\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs [] of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set [].\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 5. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "case (vpa_empty cs)"], ["proof (state)\nthis:\n  valid_call_list cs n\n  n -[]\\<rightarrow>* n'\n\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>valid_call_list cs n; n -[]\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs [] of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set [].\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 5. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>n -[]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -[]\\<rightarrow>* n'", "have \"n = n'\""], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = n'", "by fastforce"], ["proof (state)\nthis:\n  n = n'\n\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>valid_call_list cs n; n -[]\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs [] of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set [].\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 5. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "with \\<open>valid_call_list cs n\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  n = n'", "show ?case"], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  n = n'\n\ngoal (1 subgoal):\n 1. case upd_cs cs [] of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set cs.\n         \\<exists>a\\<in>set []. a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by(cases cs) auto"], ["proof (state)\nthis:\n  case upd_cs cs [] of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs. \\<exists>a\\<in>set []. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "case (vpa_intra cs a' as')"], ["proof (state)\nthis:\n  intra_kind (kind a')\n  valid_path_aux cs as'\n  \\<lbrakk>valid_call_list cs ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs cs as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set cs.\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  valid_call_list cs n\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_call_list cs n; n -as'\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> case (upd_cs cs as') of [] \\<Rightarrow> \\<forall>c\\<in>set cs. \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                         | cx#csx \\<Rightarrow> valid_call_list (cx # csx) n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_call_list cs ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs cs as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set cs.\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')", "have \"upd_cs cs (a'#as') = upd_cs cs as'\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_cs cs (a' # as') = upd_cs cs as'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs (a' # as') = upd_cs cs as'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>n -a'#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n'", "have [simp]:\"n = sourcenode a'\" and \"valid_edge a'\"\n    and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>valid_edge a'\\<close> \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  intra_kind (kind a')", "have \"get_proc (sourcenode a') = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = get_proc (targetnode a')", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = get_proc (targetnode a')\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "with \\<open>valid_call_list cs n\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  get_proc (sourcenode a') = get_proc (targetnode a')", "have \"valid_call_list cs (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  get_proc (sourcenode a') = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_call_list cs (targetnode a')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a'\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode a') = get_proc (targetnode a');\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a'\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a') = get_proc (targetnode a');\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a'\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a'\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q r fs.\n       \\<lbrakk>get_proc (sourcenode a') = get_proc (targetnode a');\n        cs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (case cs' of\n[] \\<Rightarrow> sourcenode a'\n| a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a'\n                           | a # list \\<Rightarrow>\n                               last (sourcenodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a'\n                           | a # list \\<Rightarrow> last (sourcenodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_call_list cs (targetnode a')\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from IH[OF this \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>] \\<open>upd_cs cs (a'#as') = upd_cs cs as'\\<close>"], ["proof (chain)\npicking this:\n  case upd_cs cs as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs.\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs cs (a' # as') = upd_cs cs as'", "show ?case"], ["proof (prove)\nusing this:\n  case upd_cs cs as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs.\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs cs (a' # as') = upd_cs cs as'\n\ngoal (1 subgoal):\n 1. case upd_cs cs (a' # as') of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set cs.\n         \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by(cases \"upd_cs cs as'\") auto"], ["proof (state)\nthis:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs.\n       \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "case (vpa_Call cs a' as' Q r p fs)"], ["proof (state)\nthis:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a' # cs) as'\n  \\<lbrakk>valid_call_list (a' # cs) ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs (a' # cs) as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set (a' # cs).\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  valid_call_list cs n\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_call_list (a'#cs) n; n -as'\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> case (upd_cs (a'#cs) as') \n             of [] \\<Rightarrow> \\<forall>c\\<in>set (a'#cs). \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n          | cx#csx \\<Rightarrow> valid_call_list (cx # csx) n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_call_list (a' # cs) ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs (a' # cs) as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set (a' # cs).\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"upd_cs (a'#cs) as' = upd_cs cs (a'#as')\""], ["proof (prove)\nusing this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. upd_cs (a' # cs) as' = upd_cs cs (a' # as')", "by simp"], ["proof (state)\nthis:\n  upd_cs (a' # cs) as' = upd_cs cs (a' # as')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>n -a'#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n'", "have [simp]:\"n = sourcenode a'\" and \"valid_edge a'\"\n    and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a') = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a') = p\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "with \\<open>valid_edge a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_call_list cs n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_call_list cs n\n  get_proc (targetnode a') = p", "have \"valid_call_list (a'#cs) (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_call_list cs n\n  get_proc (targetnode a') = p\n\ngoal (1 subgoal):\n 1. valid_call_list (a' # cs) (targetnode a')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a')\\<^esub>fs;\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q r fs.\n               kind c =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a'\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        p = get_proc (targetnode a'); a' # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a')\\<^esub>fs;\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q r fs.\n               kind c =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a'\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        p = get_proc (targetnode a'); a' # cs = cs' @ c # cs'';\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a')\\<^esub>fs;\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q r fs.\n               kind c =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a'\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        p = get_proc (targetnode a'); a' # cs = cs' @ c # cs'';\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a')\\<^esub>fs;\n        \\<forall>cs' ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a'\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        p = get_proc (targetnode a'); cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a' # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a')\\<^esub>fs;\n        p = get_proc (targetnode a'); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a'\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a' # list)))\\<^esub>fs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list Qa ra fsa.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a')\\<^esub>fs;\n        p = get_proc (targetnode a'); cs = list @ c # cs''; valid_edge c;\n        kind c =\n        Qa:ra\\<hookrightarrow>\\<^bsub>get_proc\n (case list of [] \\<Rightarrow> sourcenode a'\n  | a # lista \\<Rightarrow> last (sourcenodes list))\\<^esub>fsa\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case list of [] \\<Rightarrow> sourcenode a'\n                           | a # lista \\<Rightarrow>\n                               last (sourcenodes list)) =\n                         get_proc (last (sourcenodes (a' # list)))", "by(case_tac list,auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a' # cs) (targetnode a')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from IH[OF this \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>] \n    \\<open>upd_cs (a'#cs) as' = upd_cs cs (a'#as')\\<close>"], ["proof (chain)\npicking this:\n  case upd_cs (a' # cs) as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set (a' # cs).\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs (a' # cs) as' = upd_cs cs (a' # as')", "have \"case upd_cs cs (a'#as') \n         of [] \\<Rightarrow> \\<forall>c\\<in>set (a' # cs). \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\""], ["proof (prove)\nusing this:\n  case upd_cs (a' # cs) as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set (a' # cs).\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs (a' # cs) as' = upd_cs cs (a' # as')\n\ngoal (1 subgoal):\n 1. case upd_cs cs (a' # as') of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set (a' # cs).\n         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by simp"], ["proof (state)\nthis:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set (a' # cs).\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs (a # cs) as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set (a # cs).\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "thus ?case"], ["proof (prove)\nusing this:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set (a' # cs).\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (1 subgoal):\n 1. case upd_cs cs (a' # as') of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set cs.\n         \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by(cases \"upd_cs cs (a'#as')\") simp+"], ["proof (state)\nthis:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs.\n       \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "case (vpa_ReturnEmpty cs a' as' Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as'\n  \\<lbrakk>valid_call_list [] ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs [] as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set [].\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  valid_call_list cs n\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_call_list [] n; n -as'\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> case (upd_cs [] as') \n             of [] \\<Rightarrow> \\<forall>c\\<in>set []. \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n          | cx#csx \\<Rightarrow> valid_call_list (cx # csx) n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_call_list [] ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs [] as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set [].\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []", "have \"upd_cs [] as' = upd_cs cs (a'#as')\""], ["proof (prove)\nusing this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n\ngoal (1 subgoal):\n 1. upd_cs [] as' = upd_cs cs (a' # as')", "by simp"], ["proof (state)\nthis:\n  upd_cs [] as' = upd_cs cs (a' # as')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>n -a'#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n'", "have [simp]:\"n = sourcenode a'\" and \"valid_edge a'\"\n    and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "have \"valid_call_list [] (targetnode a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_call_list [] (targetnode a')", "by(simp add:valid_call_list_def)"], ["proof (state)\nthis:\n  valid_call_list [] (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from IH[OF this \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>]\n    \\<open>upd_cs [] as' = upd_cs cs (a'#as')\\<close>"], ["proof (chain)\npicking this:\n  case upd_cs [] as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set [].\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs [] as' = upd_cs cs (a' # as')", "have \"case (upd_cs cs (a'#as')) \n         of [] \\<Rightarrow> \\<forall>c\\<in>set []. \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n    | cx#csx \\<Rightarrow> valid_call_list (cx#csx) n'\""], ["proof (prove)\nusing this:\n  case upd_cs [] as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set [].\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs [] as' = upd_cs cs (a' # as')\n\ngoal (1 subgoal):\n 1. case upd_cs cs (a' # as') of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set [].\n         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by simp"], ["proof (state)\nthis:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set [].\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_call_list [] n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs [] as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set [].\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "with \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  cs = []\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set [].\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "show ?case"], ["proof (prove)\nusing this:\n  cs = []\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set [].\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (1 subgoal):\n 1. case upd_cs cs (a' # as') of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set cs.\n         \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by(cases \"upd_cs cs (a'#as')\") simp+"], ["proof (state)\nthis:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs.\n       \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "case (vpa_ReturnCons cs a' as' Q p f c' cs')"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as'\n  a' \\<in> get_return_edges c'\n  \\<lbrakk>valid_call_list cs' ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs cs' as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set cs'.\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  valid_call_list cs n\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_call_list cs' n; n -as'\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> case (upd_cs cs' as') \n             of [] \\<Rightarrow> \\<forall>c\\<in>set cs'. \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n          | cx#csx \\<Rightarrow> valid_call_list (cx # csx) n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_call_list cs' ?n; ?n -as'\\<rightarrow>* n'\\<rbrakk>\n  \\<Longrightarrow> case upd_cs cs' as' of\n                    [] \\<Rightarrow>\n                      \\<forall>c\\<in>set cs'.\n                         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n                    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close> \\<open>a' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a' \\<in> get_return_edges c'", "have \"upd_cs cs' as' = upd_cs cs (a'#as')\""], ["proof (prove)\nusing this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. upd_cs cs' as' = upd_cs cs (a' # as')", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' as' = upd_cs cs (a' # as')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>n -a'#as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a' # as'\\<rightarrow>* n'", "have [simp]:\"n = sourcenode a'\" and \"valid_edge a'\"\n    and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a' # as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>valid_call_list cs n\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs = c' # cs'", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c'", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cs'a c.\n                (\\<exists>cs''.\n                    c' # cs' = cs'a @ c # cs'') \\<longrightarrow>\n                valid_edge c \\<and>\n                (\\<exists>Q r fs.\n                    kind c =\n                    Q:r\\<hookrightarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a'\n            | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n     cs = c' # cs'\\<rbrakk>\n    \\<Longrightarrow> valid_edge c'", "by(erule_tac x=\"[]\" in allE,auto)"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "with \\<open>a' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  a' \\<in> get_return_edges c'\n  valid_edge c'", "obtain ax where \"valid_edge ax\"\n    and sources:\"sourcenode ax = sourcenode c'\" \n    and targets:\"targetnode ax = targetnode a'\" and \"kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  a' \\<in> get_return_edges c'\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode ax = sourcenode c';\n         targetnode ax = targetnode a';\n         kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax = sourcenode c'\n  targetnode ax = targetnode a'\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from \\<open>valid_edge ax\\<close> sources[THEN sym] targets[THEN sym] \\<open>kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode c' = sourcenode ax\n  targetnode a' = targetnode ax\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"get_proc (sourcenode c') = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode c' = sourcenode ax\n  targetnode a' = targetnode ax\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a')", "by(fastforce intro:get_proc_intra simp:intra_kind_def)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "with \\<open>valid_call_list cs n\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a')", "have \"valid_call_list cs' (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> sourcenode a'\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode a');\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a'\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a');\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> sourcenode a'\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs',auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "from IH[OF this \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>] \n    \\<open>upd_cs cs' as' = upd_cs cs (a'#as')\\<close>"], ["proof (chain)\npicking this:\n  case upd_cs cs' as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs'.\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs cs' as' = upd_cs cs (a' # as')", "have \"case (upd_cs cs (a'#as')) \n         of [] \\<Rightarrow> \\<forall>c\\<in>set cs'. \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n    | cx#csx \\<Rightarrow> valid_call_list (cx#csx) n'\""], ["proof (prove)\nusing this:\n  case upd_cs cs' as' of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs'.\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n  upd_cs cs' as' = upd_cs cs (a' # as')\n\ngoal (1 subgoal):\n 1. case upd_cs cs (a' # as') of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set cs'.\n         \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by simp"], ["proof (state)\nthis:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs'.\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_call_list cs' n; n -as\\<rightarrow>* n'\\<rbrakk>\n           \\<Longrightarrow> case upd_cs cs' as of\n                             [] \\<Rightarrow>\n                               \\<forall>c\\<in>set cs'.\n                                  \\<exists>a\\<in>set as.\n                                     a \\<in> get_return_edges c\n                             | cx # csx \\<Rightarrow>\n                                 valid_call_list (cx # csx) n';\n        valid_call_list cs n; n -a # as\\<rightarrow>* n'\\<rbrakk>\n       \\<Longrightarrow> case upd_cs cs (a # as) of\n                         [] \\<Rightarrow>\n                           \\<forall>c\\<in>set cs.\n                              \\<exists>a\\<in>set (a # as).\n                                 a \\<in> get_return_edges c\n                         | cx # csx \\<Rightarrow>\n                             valid_call_list (cx # csx) n'", "with \\<open>cs = c' # cs'\\<close> \\<open>a' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  a' \\<in> get_return_edges c'\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs'.\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "show ?case"], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  a' \\<in> get_return_edges c'\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs'.\n       \\<exists>a\\<in>set as'. a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal (1 subgoal):\n 1. case upd_cs cs (a' # as') of\n    [] \\<Rightarrow>\n      \\<forall>c\\<in>set cs.\n         \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n    | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'", "by(cases \"upd_cs cs (a'#as')\") simp+"], ["proof (state)\nthis:\n  case upd_cs cs (a' # as') of\n  [] \\<Rightarrow>\n    \\<forall>c\\<in>set cs.\n       \\<exists>a\\<in>set (a' # as'). a \\<in> get_return_edges c\n  | cx # csx \\<Rightarrow> valid_call_list (cx # csx) n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vpa_valid_call_list_valid_return_list_vpra:\n  \"\\<lbrakk>valid_path_aux cs cs'; valid_call_list cs n; valid_return_list cs' n'\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' (rev cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_aux cs cs'; valid_call_list cs n;\n     valid_return_list cs' n'\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux cs' (rev cs)", "proof(induct arbitrary:n n' rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs n n'.\n       \\<lbrakk>valid_call_list cs n; valid_return_list [] n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev cs)\n 2. \\<And>cs a as n n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 4. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 5. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "case (vpa_empty cs)"], ["proof (state)\nthis:\n  valid_call_list cs n\n  valid_return_list [] n'\n\ngoal (5 subgoals):\n 1. \\<And>cs n n'.\n       \\<lbrakk>valid_call_list cs n; valid_return_list [] n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux [] (rev cs)\n 2. \\<And>cs a as n n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 4. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 5. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from \\<open>valid_call_list cs n\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n", "show ?case"], ["proof (prove)\nusing this:\n  valid_call_list cs n\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux [] (rev cs)", "by(rule vpra_empty_valid_call_list_rev)"], ["proof (state)\nthis:\n  valid_path_rev_aux [] (rev cs)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 4. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as n n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 4. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "case (vpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  \\<lbrakk>valid_call_list cs ?n; valid_return_list as ?n'\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux as (rev cs)\n  valid_call_list cs n\n  valid_return_list (a # as) n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 4. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from \\<open>intra_kind (kind a)\\<close> \\<open>valid_return_list (a#as) n'\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_return_list (a # as) n'", "have False"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_return_list (a # as) n'\n\ngoal (1 subgoal):\n 1. False", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>intra_kind (kind a);\n     \\<forall>cs' c.\n        (\\<exists>cs''. a # as = cs' @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case cs' of [] \\<Rightarrow> n'\n | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n    \\<Longrightarrow> False", "by(erule_tac x=\"[]\" in allE,clarsimp simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 4. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (a # as) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (a # as) (rev cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "case (vpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  \\<lbrakk>valid_call_list (a # cs) ?n; valid_return_list as ?n'\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs))\n  valid_call_list cs n\n  valid_return_list (a # as) n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_return_list (a#as) n'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_return_list (a # as) n'", "have False"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_return_list (a # as) n'\n\ngoal (1 subgoal):\n 1. False", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     \\<forall>cs' c.\n        (\\<exists>cs''. a # as = cs' @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case cs' of [] \\<Rightarrow> n'\n | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n    \\<Longrightarrow> False", "by(erule_tac x=\"[]\" in allE,clarsimp)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list (a # cs) n;\n            valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev (a # cs));\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 3. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (a # as) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (a # as) (rev cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "case (vpa_ReturnEmpty cs a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  \\<lbrakk>valid_call_list [] ?n; valid_return_list as ?n'\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux as (rev [])\n  valid_call_list cs n\n  valid_return_list (a # as) n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list [] n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev []);\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)\n 2. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  cs = []", "show ?case"], ["proof (prove)\nusing this:\n  cs = []\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (a # as) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (a # as) (rev cs)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "case (vpa_ReturnCons cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>valid_call_list cs' ?n; valid_return_list as ?n'\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux as (rev cs')\n  valid_call_list cs n\n  valid_return_list (a # as) n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "note IH = \\<open>\\<And>n n'. \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux as (rev cs')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_call_list cs' ?n; valid_return_list as ?n'\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux as (rev cs')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from \\<open>valid_return_list (a#as) n'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list (a # as) n'", "have \"valid_return_list as (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list (a # as) n'\n\ngoal (1 subgoal):\n 1. valid_return_list as (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       a # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> n'\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        as = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"a#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>as = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               a # cs' @ c # cs'' =\n               (a # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case a # cs' of [] \\<Rightarrow> n'\n    | aa # list \\<Rightarrow>\n        last (targetnodes (a # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "by(case_tac cs',auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list as (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from \\<open>valid_call_list cs n\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs = c' # cs'", "have \"valid_call_list cs' (sourcenode c')\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (sourcenode c')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> n\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        cs = c' # cs' @ c # cs''; cs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> sourcenode c'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>cs = c' # cs' @ c # cs''; cs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> n\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> sourcenode c'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs',auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from \\<open>valid_call_list cs n\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs = c' # cs'", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c'", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cs' c.\n                (\\<exists>cs''. c' # cs' = cs' @ c # cs'') \\<longrightarrow>\n                valid_edge c \\<and>\n                (\\<exists>Q r fs.\n                    kind c =\n                    Q:r\\<hookrightarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> n\n            | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n     cs = c' # cs'\\<rbrakk>\n    \\<Longrightarrow> valid_edge c'", "by(erule_tac x=\"[]\" in allE,auto)"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "with \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> get_return_edges c'\n  valid_edge c'", "obtain Q' r' p' f' where \"kind c' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (prove)\nusing this:\n  a \\<in> get_return_edges c'\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. (\\<And>Q' r' p' f'.\n        kind c' =\n        Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"kind c'\" rule:edge_kind_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>Q' r' p' f'.\n                kind c' =\n                Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f' \\<Longrightarrow>\n                thesis;\n     a \\<in> get_return_edges c'; valid_edge c';\n     intra_kind (kind c')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>Q r p fs.\n       \\<lbrakk>\\<And>Q' r' p' f'.\n                   kind c' =\n                   Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f' \\<Longrightarrow>\n                   thesis;\n        a \\<in> get_return_edges c'; valid_edge c';\n        kind c' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>Q p f.\n       \\<lbrakk>\\<And>Q' r' p' f'.\n                   kind c' =\n                   Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f' \\<Longrightarrow>\n                   thesis;\n        a \\<in> get_return_edges c'; valid_edge c';\n        kind c' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(auto dest:only_call_get_return_edges simp:intra_kind_def)"], ["proof (state)\nthis:\n  kind c' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "from IH[OF \\<open>valid_call_list cs' (sourcenode c')\\<close>\n    \\<open>valid_return_list as (targetnode a)\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux as (rev cs')", "have \"valid_path_rev_aux as (rev cs')\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux as (rev cs')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux as (rev cs')", "."], ["proof (state)\nthis:\n  valid_path_rev_aux as (rev cs')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n n'.\n           \\<lbrakk>valid_call_list cs' n; valid_return_list as n'\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux as (rev cs');\n        valid_call_list cs n; valid_return_list (a # as) n'\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux (a # as) (rev cs)", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close> \\<open>kind c' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind c' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  valid_path_rev_aux as (rev cs')", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind c' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  valid_path_rev_aux as (rev cs')\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (a # as) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (a # as) (rev cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vpa_to_vpra:\n  \"\\<lbrakk>valid_path_aux cs as; valid_path_aux (upd_cs cs as) cs'; \n    n -as\\<rightarrow>* n'; valid_call_list cs n; valid_return_list cs' n''\\<rbrakk> \n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and> valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_aux cs as; valid_path_aux (upd_cs cs as) cs';\n     n -as\\<rightarrow>* n'; valid_call_list cs n;\n     valid_return_list cs' n''\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                      valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)", "proof(induct arbitrary:n rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>valid_path_aux (upd_cs cs []) cs'; n -[]\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' [] \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' []) (rev cs)\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 5. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "case vpa_empty"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs_ []) cs'\n  n -[]\\<rightarrow>* n'\n  valid_call_list cs_ n\n  valid_return_list cs' n''\n\ngoal (5 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>valid_path_aux (upd_cs cs []) cs'; n -[]\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' [] \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' []) (rev cs)\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 5. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs_ []) cs'\n  n -[]\\<rightarrow>* n'\n  valid_call_list cs_ n\n  valid_return_list cs' n''\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' [] \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' []) (rev cs_)", "by(fastforce intro:vpa_valid_call_list_valid_return_list_vpra)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' [] \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' []) (rev cs_)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "case (vpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  \\<lbrakk>valid_path_aux (upd_cs cs as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list cs ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  valid_return_list cs' n''\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_path_aux (upd_cs cs as) cs'; n -as\\<rightarrow>* n';\n    valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path_aux (upd_cs cs as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list cs ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"n = sourcenode a\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_call_list cs n\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  n = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  n = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        n = sourcenode a; get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>n = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q r fs.\n       \\<lbrakk>n = sourcenode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (case cs' of\n[] \\<Rightarrow> sourcenode a\n| a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow>\n                               last (sourcenodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (sourcenodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_call_list cs (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>valid_path_aux (upd_cs cs (a#as)) cs'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  intra_kind (kind a)", "have \"valid_path_aux (upd_cs cs as) cs'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs cs as) cs'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs cs as) cs'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from IH[OF this \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>valid_call_list cs (targetnode a)\\<close>\n    \\<open>valid_return_list cs' n''\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)", "have \"valid_path_rev_aux cs' as\" \n    and \"valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' as &&&\n    valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)", "by simp_all"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from  \\<open>intra_kind (kind a)\\<close> \\<open>valid_path_rev_aux cs' as\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs' as", "have \"valid_path_rev_aux cs' (a#as)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_rev_aux cs' as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as)", "by(rule vpra_Cons_intra)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"upd_rev_cs cs' (a#as) = upd_rev_cs cs' as\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs' (a # as) = upd_rev_cs cs' as", "by(simp add:upd_rev_cs_Cons_intra)"], ["proof (state)\nthis:\n  upd_rev_cs cs' (a # as) = upd_rev_cs cs' as\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\n  upd_rev_cs cs' (a # as) = upd_rev_cs cs' as", "have \"valid_path_rev_aux (upd_rev_cs cs' (a#as)) (rev cs)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev cs)\n  upd_rev_cs cs' (a # as) = upd_rev_cs cs' as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 4. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_path_rev_aux cs' (a#as)\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' (a # as)\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "show ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' (a # as)\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as) \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "case (vpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list (a # cs) ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  valid_return_list cs' n''\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_path_aux (upd_cs (a#cs) as) cs'; n -as\\<rightarrow>* n';\n    valid_call_list (a#cs) n; valid_return_list cs' n''\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' as) (rev (a#cs))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list (a # cs) ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"n = sourcenode a\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"p = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. p = get_proc (targetnode a)", "by(rule get_proc_call[THEN sym])"], ["proof (state)\nthis:\n  p = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>valid_call_list cs n\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  n = sourcenode a", "have \"valid_call_list cs (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  n = sourcenode a\n\ngoal (1 subgoal):\n 1. valid_call_list cs (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_call_list cs (sourcenode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge a\\<close> \\<open>p = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  p = get_proc (targetnode a)\n  valid_call_list cs (sourcenode a)", "have \"valid_call_list (a#cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  p = get_proc (targetnode a)\n  valid_call_list cs (sourcenode a)\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>kind a =\n                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n       (targetnode a)\\<^esub>fs;\n        valid_edge a; p = get_proc (targetnode a);\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q r fs.\n               kind c =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>kind a =\n                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n       (targetnode a)\\<^esub>fs;\n        valid_edge a; p = get_proc (targetnode a);\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q r fs.\n               kind c =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        a # cs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>kind a =\n                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n       (targetnode a)\\<^esub>fs;\n        valid_edge a; p = get_proc (targetnode a);\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q r fs.\n               kind c =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        a # cs = cs' @ c # cs''; cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>kind a =\n                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n       (targetnode a)\\<^esub>fs;\n        valid_edge a; p = get_proc (targetnode a);\n        \\<forall>cs' ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>kind a =\n                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n       (targetnode a)\\<^esub>fs;\n        valid_edge a; p = get_proc (targetnode a); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list Qa ra fsa.\n       \\<lbrakk>kind a =\n                Q:r\\<hookrightarrow>\\<^bsub>get_proc\n       (targetnode a)\\<^esub>fs;\n        valid_edge a; p = get_proc (targetnode a); cs = list @ c # cs'';\n        valid_edge c;\n        kind c =\n        Qa:ra\\<hookrightarrow>\\<^bsub>get_proc\n (case list of [] \\<Rightarrow> sourcenode a\n  | a # lista \\<Rightarrow> last (sourcenodes list))\\<^esub>fsa\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case list of [] \\<Rightarrow> sourcenode a\n                           | a # lista \\<Rightarrow>\n                               last (sourcenodes list)) =\n                         get_proc (last (sourcenodes (a # list)))", "by(case_tac list,auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"upd_cs cs (a#as) = upd_cs (a#cs) as\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # as) = upd_cs (a # cs) as", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = upd_cs (a # cs) as\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_path_aux (upd_cs cs (a#as)) cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  upd_cs cs (a # as) = upd_cs (a # cs) as", "have \"valid_path_aux (upd_cs (a#cs) as) cs'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  upd_cs cs (a # as) = upd_cs (a # cs) as\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs (a # cs) as) cs'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs (a # cs) as) cs'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from IH[OF this \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>valid_call_list (a#cs) (targetnode a)\\<close>\n    \\<open>valid_return_list cs' n''\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))", "have \"valid_path_rev_aux cs' as\"\n    and \"valid_path_rev_aux (upd_rev_cs cs' as) (rev (a#cs))\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' as &&&\n    valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))", "by simp_all"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs (a # cs) as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list (a # cs) n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev (a # cs));\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 3. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "proof(cases \"upd_rev_cs cs' as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. upd_rev_cs cs' as = [] \\<Longrightarrow>\n    valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n 2. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "case Nil"], ["proof (state)\nthis:\n  upd_rev_cs cs' as = []\n\ngoal (2 subgoals):\n 1. upd_rev_cs cs' as = [] \\<Longrightarrow>\n    valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n 2. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = []", "have \"upd_rev_cs cs' (a#as) = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs' (a # as) = []", "by(rule upd_rev_cs_Cons_Call_Cons_Empty)"], ["proof (state)\nthis:\n  upd_rev_cs cs' (a # as) = []\n\ngoal (2 subgoals):\n 1. upd_rev_cs cs' as = [] \\<Longrightarrow>\n    valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n 2. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>valid_path_rev_aux (upd_rev_cs cs' as) (rev (a#cs))\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> Nil"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = []\n  upd_rev_cs cs' (a # as) = []", "have \"valid_path_rev_aux (upd_rev_cs cs' (a#as)) (rev cs)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = []\n  upd_rev_cs cs' (a # as) = []\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (2 subgoals):\n 1. upd_rev_cs cs' as = [] \\<Longrightarrow>\n    valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n 2. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "from Nil \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs cs' as = []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"valid_path_rev_aux (upd_rev_cs cs' as) ([]@[a])\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs' as = []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])", "by(simp only:valid_path_rev_aux.simps) clarsimp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])\n\ngoal (2 subgoals):\n 1. upd_rev_cs cs' as = [] \\<Longrightarrow>\n    valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n 2. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>valid_path_rev_aux cs' as\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])", "have \"valid_path_rev_aux cs' ([a]@as)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' ([a] @ as)", "by(fastforce intro:valid_path_rev_aux_Append)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' ([a] @ as)\n\ngoal (2 subgoals):\n 1. upd_rev_cs cs' as = [] \\<Longrightarrow>\n    valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n 2. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>valid_path_rev_aux (upd_rev_cs cs' (a#as)) (rev cs)\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n  valid_path_rev_aux cs' ([a] @ as)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n  valid_path_rev_aux cs' ([a] @ as)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as) \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "case (Cons cx csx)"], ["proof (state)\nthis:\n  upd_rev_cs cs' as = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>valid_path_rev_aux (upd_rev_cs cs' as) (rev (a#cs))\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = cx # csx", "have match:\"cx \\<in> get_return_edges a\" \"valid_path_rev_aux csx (rev cs)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = cx # csx\n\ngoal (1 subgoal):\n 1. cx \\<in> get_return_edges a &&& valid_path_rev_aux csx (rev cs)", "by auto"], ["proof (state)\nthis:\n  cx \\<in> get_return_edges a\n  valid_path_rev_aux csx (rev cs)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> Cons"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = cx # csx", "have \"upd_rev_cs cs' (a#as) = csx\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_rev_cs cs' as = cx # csx\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs' (a # as) = csx", "by(rule upd_rev_cs_Cons_Call_Cons)"], ["proof (state)\nthis:\n  upd_rev_cs cs' (a # as) = csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>valid_path_rev_aux (upd_rev_cs cs' as) (rev(a#cs))\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> match"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cx \\<in> get_return_edges a\n  valid_path_rev_aux csx (rev cs)\n  upd_rev_cs cs' (a # as) = csx", "have \"valid_path_rev_aux (upd_rev_cs cs' (a#as)) (rev cs)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev (a # cs))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cx \\<in> get_return_edges a\n  valid_path_rev_aux csx (rev cs)\n  upd_rev_cs cs' (a # as) = csx\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "from Cons \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> match"], ["proof (chain)\npicking this:\n  upd_rev_cs cs' as = cx # csx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cx \\<in> get_return_edges a\n  valid_path_rev_aux csx (rev cs)", "have \"valid_path_rev_aux (upd_rev_cs cs' as) ([]@[a])\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs' as = cx # csx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cx \\<in> get_return_edges a\n  valid_path_rev_aux csx (rev cs)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])", "by(simp only:valid_path_rev_aux.simps) clarsimp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>valid_path_rev_aux cs' as\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])", "have \"valid_path_rev_aux cs' ([a]@as)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) ([] @ [a])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' ([a] @ as)", "by(fastforce intro:valid_path_rev_aux_Append)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' ([a] @ as)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_rev_cs cs' as = aa # list \\<Longrightarrow>\n       valid_path_rev_aux cs' (a # as) \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "with \\<open>valid_path_rev_aux (upd_rev_cs cs' (a#as)) (rev cs)\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n  valid_path_rev_aux cs' ([a] @ as)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n  valid_path_rev_aux cs' ([a] @ as)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as) \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as) \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "case (vpa_ReturnEmpty cs a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  \\<lbrakk>valid_path_aux (upd_cs [] as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list [] ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev [])\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  valid_return_list cs' n''\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_path_aux (upd_cs [] as) cs'; n -as\\<rightarrow>* n';\n    valid_call_list [] n; valid_return_list cs' n''\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' as) (rev [])\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path_aux (upd_cs [] as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list [] ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev [])\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"n = sourcenode a\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>cs = []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  cs = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"upd_cs cs (a#as) = upd_cs [] as\""], ["proof (prove)\nusing this:\n  cs = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # as) = upd_cs [] as", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = upd_cs [] as\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_path_aux (upd_cs cs (a#as)) cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  upd_cs cs (a # as) = upd_cs [] as", "have \"valid_path_aux (upd_cs [] as) cs'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  upd_cs cs (a # as) = upd_cs [] as\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs [] as) cs'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs [] as) cs'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from IH[OF this \\<open>targetnode a -as\\<rightarrow>* n'\\<close> _ \\<open>valid_return_list cs' n''\\<close>]"], ["proof (chain)\npicking this:\n  valid_call_list [] (targetnode a) \\<Longrightarrow>\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev [])", "have \"valid_path_rev_aux cs' as\" \n    and \"valid_path_rev_aux (upd_rev_cs cs' as) (rev [])\""], ["proof (prove)\nusing this:\n  valid_call_list [] (targetnode a) \\<Longrightarrow>\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev [])\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' as &&&\n    valid_path_rev_aux (upd_rev_cs cs' as) (rev [])", "by(auto simp:valid_call_list_def)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev [])\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>valid_path_rev_aux cs' as\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux cs' as", "have \"valid_path_rev_aux cs' (a#as)\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux cs' as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as)", "by(rule vpra_Cons_Return)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "moreover"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  cs = []", "have \"valid_path_rev_aux (upd_rev_cs cs' (a#as)) (rev cs)\""], ["proof (prove)\nusing this:\n  cs = []\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs [] as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list [] n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev []);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)\n 2. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "ultimately"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' (a # as)\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "show ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' (a # as)\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as) \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "case (vpa_ReturnCons cs a as Q p f cx csx)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = cx # csx\n  valid_path_aux csx as\n  a \\<in> get_return_edges cx\n  \\<lbrakk>valid_path_aux (upd_cs csx as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list csx ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  n -a # as\\<rightarrow>* n'\n  valid_call_list cs n\n  valid_return_list cs' n''\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "note IH = \\<open>\\<And>n. \\<lbrakk>valid_path_aux (upd_cs csx as) cs'; n -as\\<rightarrow>* n';\n    valid_call_list csx n; valid_return_list cs' n''\\<rbrakk>\n    \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n       valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path_aux (upd_cs csx as) cs'; ?n -as\\<rightarrow>* n';\n   valid_call_list csx ?n; valid_return_list cs' n''\\<rbrakk>\n  \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                    valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "note match = \\<open>cs = cx#csx\\<close> \\<open>a \\<in> get_return_edges cx\\<close>"], ["proof (state)\nthis:\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"n = sourcenode a\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>cs = cx#csx\\<close> \\<open>valid_call_list cs n\\<close>"], ["proof (chain)\npicking this:\n  cs = cx # csx\n  valid_call_list cs n", "have \"valid_edge cx\""], ["proof (prove)\nusing this:\n  cs = cx # csx\n  valid_call_list cs n\n\ngoal (1 subgoal):\n 1. valid_edge cx", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cs = cx # csx;\n     \\<forall>cs' c.\n        (\\<exists>cs''. cx # csx = cs' @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> n\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n    \\<Longrightarrow> valid_edge cx", "by(erule_tac x=\"[]\" in allE) clarsimp"], ["proof (state)\nthis:\n  valid_edge cx\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with match"], ["proof (chain)\npicking this:\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n  valid_edge cx", "have \"get_proc (sourcenode cx) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n  valid_edge cx\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode cx) = get_proc (targetnode a)", "by(fastforce intro:get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode cx) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_call_list cs n\\<close> \\<open>cs = cx#csx\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs n\n  cs = cx # csx\n  get_proc (sourcenode cx) = get_proc (targetnode a)", "have \"valid_call_list csx (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs n\n  cs = cx # csx\n  get_proc (sourcenode cx) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list csx (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cx # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> n\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        cs = cx # cs' @ c # cs'';\n        get_proc (sourcenode cx) = get_proc (targetnode a);\n        csx = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"cx#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>cs = cx # cs' @ c # cs'';\n        get_proc (sourcenode cx) = get_proc (targetnode a);\n        csx = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cx # cs' @ c # cs'' =\n               (cx # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cx # cs' of [] \\<Rightarrow> n\n       | a # list \\<Rightarrow>\n           last (sourcenodes (cx # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q r fs.\n       \\<lbrakk>cs = cx # cs' @ c # cs'';\n        get_proc (sourcenode cx) = get_proc (targetnode a);\n        csx = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (last\n (sourcenodes (cx # cs')))\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (last (sourcenodes (cx # cs'))) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (sourcenodes cs'))", "by(case_tac cs',auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list csx (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> match"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = cx # csx\n  a \\<in> get_return_edges cx", "have \"upd_cs cs (a#as) = upd_cs csx as\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # as) = upd_cs csx as", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = upd_cs csx as\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_path_aux (upd_cs cs (a#as)) cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  upd_cs cs (a # as) = upd_cs csx as", "have \"valid_path_aux (upd_cs csx as) cs'\""], ["proof (prove)\nusing this:\n  valid_path_aux (upd_cs cs (a # as)) cs'\n  upd_cs cs (a # as) = upd_cs csx as\n\ngoal (1 subgoal):\n 1. valid_path_aux (upd_cs csx as) cs'", "by simp"], ["proof (state)\nthis:\n  valid_path_aux (upd_cs csx as) cs'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from IH[OF this \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>valid_call_list csx (targetnode a)\\<close>\n    \\<open>valid_return_list cs' n''\\<close>]"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)", "have \"valid_path_rev_aux cs' as\" \n    and \"valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' as \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' as &&&\n    valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)", "by simp_all"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' as\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>valid_path_rev_aux cs' as\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux cs' as", "have \"valid_path_rev_aux cs' (a#as)\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux cs' as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as)", "by(rule vpra_Cons_Return)"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from match \\<open>valid_edge cx\\<close>"], ["proof (chain)\npicking this:\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n  valid_edge cx", "obtain Q' r' p' f' where \"kind cx = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (prove)\nusing this:\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n  valid_edge cx\n\ngoal (1 subgoal):\n 1. (\\<And>Q' r' p' f'.\n        kind cx =\n        Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind cx = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"upd_rev_cs cs' (a#as) = a#(upd_rev_cs cs' as)\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs' (a # as) = a # upd_rev_cs cs' as", "by(rule upd_rev_cs_Cons_Return)"], ["proof (state)\nthis:\n  upd_rev_cs cs' (a # as) = a # upd_rev_cs cs' as\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \n    \\<open>kind cx = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\\<close> match"], ["proof (chain)\npicking this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  kind cx = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n  upd_rev_cs cs' (a # as) = a # upd_rev_cs cs' as", "have \"valid_path_rev_aux (upd_rev_cs cs' (a#as)) (rev cs)\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux (upd_rev_cs cs' as) (rev csx)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  kind cx = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  cs = cx # csx\n  a \\<in> get_return_edges cx\n  upd_rev_cs cs' (a # as) = a # upd_rev_cs cs' as\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'a n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        cs = c' # cs'a; valid_path_aux cs'a as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>valid_path_aux (upd_cs cs'a as) cs';\n            n -as\\<rightarrow>* n'; valid_call_list cs'a n;\n            valid_return_list cs' n''\\<rbrakk>\n           \\<Longrightarrow> valid_path_rev_aux cs' as \\<and>\n                             valid_path_rev_aux (upd_rev_cs cs' as)\n                              (rev cs'a);\n        valid_path_aux (upd_cs cs (a # as)) cs'; n -a # as\\<rightarrow>* n';\n        valid_call_list cs n; valid_return_list cs' n''\\<rbrakk>\n       \\<Longrightarrow> valid_path_rev_aux cs' (a # as) \\<and>\n                         valid_path_rev_aux (upd_rev_cs cs' (a # as))\n                          (rev cs)", "with \\<open>valid_path_rev_aux cs' (a#as)\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux cs' (a # as)\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "show ?case"], ["proof (prove)\nusing this:\n  valid_path_rev_aux cs' (a # as)\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux cs' (a # as) \\<and>\n    valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux cs' (a # as) \\<and>\n  valid_path_rev_aux (upd_rev_cs cs' (a # as)) (rev cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vp_to_vpra:\n  \"n -as\\<rightarrow>\\<^sub>\\<surd>* n' \\<Longrightarrow> valid_path_rev_aux [] as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<surd>* n' \\<Longrightarrow>\n    valid_path_rev_aux [] as", "by(fastforce elim:vpa_to_vpra[THEN conjunct1] \n            simp:vp_def valid_path_def valid_call_list_def valid_return_list_def)"], ["", "subsubsection \\<open>Same level paths\\<close>"], ["", "fun same_level_path_aux :: \"'edge list \\<Rightarrow> 'edge list \\<Rightarrow> bool\"\n  where \"same_level_path_aux cs [] \\<longleftrightarrow> True\"\n  | \"same_level_path_aux cs (a#as) \\<longleftrightarrow> \n       (case (kind a) of Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow> same_level_path_aux (a#cs) as\n                       | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow> case cs of [] \\<Rightarrow> False\n                                     | c'#cs' \\<Rightarrow> a \\<in> get_return_edges c' \\<and>\n                                             same_level_path_aux cs' as\n                       |    _ \\<Rightarrow> same_level_path_aux cs as)\""], ["", "lemma slpa_induct [consumes 1,case_names slpa_empty slpa_intra slpa_Call \n  slpa_Return]:\n  assumes major: \"same_level_path_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); same_level_path_aux cs as; P cs as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q r p fs. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; same_level_path_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (a#as)\"\n    \"\\<And>cs a as Q p f c' cs'. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c'#cs'; same_level_path_aux cs' as;\n                             a \\<in> get_return_edges c'; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (a#as)\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "using major"], ["proof (prove)\nusing this:\n  same_level_path_aux xs ys\n\ngoal (1 subgoal):\n 1. P xs ys", "apply(induct ys arbitrary: xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. same_level_path_aux xs [] \\<Longrightarrow> P xs []\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   same_level_path_aux xs ys \\<Longrightarrow> P xs ys;\n        same_level_path_aux xs (a # ys)\\<rbrakk>\n       \\<Longrightarrow> P xs (a # ys)", "by(auto intro:rules split:edge_kind.split_asm list.split_asm simp:intra_kind_def)"], ["", "lemma slpa_cases [consumes 4,case_names intra_path return_intra_path]:\n  assumes \"same_level_path_aux cs as\" and \"upd_cs cs as = []\"\n  and \"\\<forall>c \\<in> set cs. valid_edge c\" and \"\\<forall>a \\<in> set as. valid_edge a\"\n  obtains \"\\<forall>a \\<in> set as. intra_kind(kind a)\"\n  | asx a asx' Q p f c' cs' where \"as = asx@a#asx'\" and \"same_level_path_aux cs asx\"\n    and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"upd_cs cs asx = c'#cs'\" and \"upd_cs cs (asx@[a]) = []\" \n    and \"a \\<in> get_return_edges c'\" and \"valid_edge c'\"\n    and \"\\<forall>a \\<in> set asx'. intra_kind(kind a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a) \\<Longrightarrow>\n             thesis;\n     \\<And>asx a asx' Q p f c' cs'.\n        \\<lbrakk>as = asx @ a # asx'; same_level_path_aux cs asx;\n         kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         upd_cs cs asx = c' # cs'; upd_cs cs (asx @ [a]) = [];\n         a \\<in> get_return_edges c'; valid_edge c';\n         \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n    (\\<exists>asx a asx' Q p f c' cs'.\n        as = asx @ a # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [a]) = [] \\<and>\n        a \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from assms"], ["proof (chain)\npicking this:\n  same_level_path_aux cs as\n  upd_cs cs as = []\n  \\<forall>c\\<in>set cs. valid_edge c\n  \\<forall>a\\<in>set as. valid_edge a", "show \"(\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n    (\\<exists>asx a asx' Q p f c' cs'. as = asx@a#asx' \\<and> same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and> upd_cs cs asx = c'#cs' \\<and> upd_cs cs (asx@[a]) = [] \\<and> \n       a \\<in> get_return_edges c' \\<and> valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs as\n  upd_cs cs as = []\n  \\<forall>c\\<in>set cs. valid_edge c\n  \\<forall>a\\<in>set as. valid_edge a\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n    (\\<exists>asx a asx' Q p f c' cs'.\n        as = asx @ a # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [a]) = [] \\<and>\n        a \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "proof(induct rule:slpa_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>upd_cs cs [] = []; Ball (set cs) valid_edge;\n        Ball (set []) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set []. intra_kind (kind a)) \\<or>\n                         (\\<exists>asx a asx' Q p f c' cs'.\n                             [] = asx @ a # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [a]) = [] \\<and>\n                             a \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 4. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  upd_cs cs [] = []\n  \\<forall>a\\<in>set cs. valid_edge a\n  \\<forall>a\\<in>set []. valid_edge a\n\ngoal (4 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>upd_cs cs [] = []; Ball (set cs) valid_edge;\n        Ball (set []) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set []. intra_kind (kind a)) \\<or>\n                         (\\<exists>asx a asx' Q p f c' cs'.\n                             [] = asx @ a # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [a]) = [] \\<and>\n                             a \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 4. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "have \"\\<forall>a\\<in>set []. intra_kind (kind a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set []. intra_kind (kind a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (4 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>upd_cs cs [] = []; Ball (set cs) valid_edge;\n        Ball (set []) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set []. intra_kind (kind a)) \\<or>\n                         (\\<exists>asx a asx' Q p f c' cs'.\n                             [] = asx @ a # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [a]) = [] \\<and>\n                             a \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 4. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set []. intra_kind (kind a)) \\<or>\n    (\\<exists>asx a asx' Q p f c' cs'.\n        [] = asx @ a # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [a]) = [] \\<and>\n        a \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set []. intra_kind (kind a)) \\<or>\n  (\\<exists>asx a asx' Q p f c' cs'.\n      [] = asx @ a # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [a]) = [] \\<and>\n      a \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  \\<lbrakk>upd_cs cs as = []; \\<forall>a\\<in>set cs. valid_edge a;\n   \\<forall>a\\<in>set as. valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                    (\\<exists>asx a asx' Q p f c' cs'.\n                        as = asx @ a # asx' \\<and>\n                        same_level_path_aux cs asx \\<and>\n                        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                        upd_cs cs asx = c' # cs' \\<and>\n                        upd_cs cs (asx @ [a]) = [] \\<and>\n                        a \\<in> get_return_edges c' \\<and>\n                        valid_edge c' \\<and>\n                        (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n  upd_cs cs (a # as) = []\n  \\<forall>a\\<in>set cs. valid_edge a\n  \\<forall>a\\<in>set (a # as). valid_edge a\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "note IH = \\<open>\\<lbrakk>upd_cs cs as = []; \\<forall>c\\<in>set cs. valid_edge c; \\<forall>a'\\<in>set as. valid_edge a'\\<rbrakk> \n      \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n      (\\<exists>asx a asx' Q p f c' cs'. as = asx@a#asx' \\<and> same_level_path_aux cs asx \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>  upd_cs cs asx = c' # cs' \\<and> upd_cs cs (asx@[a]) = [] \\<and> \n        a \\<in> get_return_edges c' \\<and> valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs cs as = []; \\<forall>c\\<in>set cs. valid_edge c;\n   \\<forall>a'\\<in>set as. valid_edge a'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                    (\\<exists>asx a asx' Q p f c' cs'.\n                        as = asx @ a # asx' \\<and>\n                        same_level_path_aux cs asx \\<and>\n                        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                        upd_cs cs asx = c' # cs' \\<and>\n                        upd_cs cs (asx @ [a]) = [] \\<and>\n                        a \\<in> get_return_edges c' \\<and>\n                        valid_edge c' \\<and>\n                        (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>\\<forall>a'\\<in>set (a#as). valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set (a # as). valid_edge a'", "have \"\\<forall>a'\\<in>set as. valid_edge a'\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set (a # as). valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set as. valid_edge a'", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set as. valid_edge a'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>intra_kind (kind a)\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []", "have \"upd_cs cs as = []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. upd_cs cs as = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs as = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set cs) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs asx = c' # cs' \\<and>\n                              upd_cs cs (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from IH[OF this \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>\\<forall>a'\\<in>set as. valid_edge a'\\<close>]"], ["proof (chain)\npicking this:\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n  (\\<exists>asx a asx' Q p f c' cs'.\n      as = asx @ a # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [a]) = [] \\<and>\n      a \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n  (\\<exists>asx a asx' Q p f c' cs'.\n      as = asx @ a # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [a]) = [] \\<and>\n      a \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "assume \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"\\<forall>a'\\<in>set (a#as). intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (a # as). intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (a # as). intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set (a # as). intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "assume \"\\<exists>asx a asx' Q p f c' cs'. as = asx@a#asx' \\<and> same_level_path_aux cs asx \\<and>\n                kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and> upd_cs cs asx = c'#cs' \\<and> upd_cs cs (asx@[a]) = [] \\<and> \n                a \\<in> get_return_edges c' \\<and> valid_edge c' \\<and> \n                (\\<forall>a\\<in>set asx'. intra_kind (kind a))\""], ["proof (state)\nthis:\n  \\<exists>asx a asx' Q p f c' cs'.\n     as = asx @ a # asx' \\<and>\n     same_level_path_aux cs asx \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n     upd_cs cs asx = c' # cs' \\<and>\n     upd_cs cs (asx @ [a]) = [] \\<and>\n     a \\<in> get_return_edges c' \\<and>\n     valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>asx a asx' Q p f c' cs'.\n     as = asx @ a # asx' \\<and>\n     same_level_path_aux cs asx \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n     upd_cs cs asx = c' # cs' \\<and>\n     upd_cs cs (asx @ [a]) = [] \\<and>\n     a \\<in> get_return_edges c' \\<and>\n     valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a))", "obtain asx a' Q p f asx' c' cs' where \"as = asx@a'#asx'\" \n        and \"same_level_path_aux cs asx\" and \"upd_cs cs (asx@[a']) = []\"\n        and \"upd_cs cs asx = c'#cs'\" and assms:\"a' \\<in> get_return_edges c'\"\n        \"kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" \"valid_edge c'\" \"\\<forall>a\\<in>set asx'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>asx a asx' Q p f c' cs'.\n     as = asx @ a # asx' \\<and>\n     same_level_path_aux cs asx \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n     upd_cs cs asx = c' # cs' \\<and>\n     upd_cs cs (asx @ [a]) = [] \\<and>\n     a \\<in> get_return_edges c' \\<and>\n     valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>asx a' asx' c' cs' Q p f.\n        \\<lbrakk>as = asx @ a' # asx'; same_level_path_aux cs asx;\n         upd_cs cs (asx @ [a']) = []; upd_cs cs asx = c' # cs';\n         a' \\<in> get_return_edges c';\n         kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; valid_edge c';\n         \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = asx @ a' # asx'\n  same_level_path_aux cs asx\n  upd_cs cs (asx @ [a']) = []\n  upd_cs cs asx = c' # cs'\n  a' \\<in> get_return_edges c'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge c'\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>as = asx@a'#asx'\\<close>"], ["proof (chain)\npicking this:\n  as = asx @ a' # asx'", "have \"a#as = (a#asx)@a'#asx'\""], ["proof (prove)\nusing this:\n  as = asx @ a' # asx'\n\ngoal (1 subgoal):\n 1. a # as = (a # asx) @ a' # asx'", "by simp"], ["proof (state)\nthis:\n  a # as = (a # asx) @ a' # asx'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  a # as = (a # asx) @ a' # asx'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>intra_kind (kind a)\\<close> \\<open>same_level_path_aux cs asx\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  same_level_path_aux cs asx", "have \"same_level_path_aux cs (a#asx)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  same_level_path_aux cs asx\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # asx)", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # asx)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # asx)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>upd_cs cs asx = c'#cs'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs asx = c' # cs'\n  intra_kind (kind a)", "have \"upd_cs cs (a#asx) = c'#cs'\""], ["proof (prove)\nusing this:\n  upd_cs cs asx = c' # cs'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # asx) = c' # cs'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs (a # asx) = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  upd_cs cs (a # asx) = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>upd_cs cs (asx@[a']) = []\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (asx @ [a']) = []\n  intra_kind (kind a)", "have \"upd_cs cs ((a#asx)@[a']) = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (asx @ [a']) = []\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a # asx) @ [a']) = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs ((a # asx) @ [a']) = []\n\ngoal (1 subgoal):\n 1. \\<exists>asx a asx' Q p f c' cs'.\n       as = asx @ a # asx' \\<and>\n       same_level_path_aux cs asx \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n       upd_cs cs asx = c' # cs' \\<and>\n       upd_cs cs (asx @ [a]) = [] \\<and>\n       a \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a\\<in>set asx'. intra_kind (kind a)) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "ultimately"], ["proof (chain)\npicking this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c' # cs'\n  upd_cs cs ((a # asx) @ [a']) = []", "show ?case"], ["proof (prove)\nusing this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c' # cs'\n  upd_cs cs ((a # asx) @ [a']) = []\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "using assms"], ["proof (prove)\nusing this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c' # cs'\n  upd_cs cs ((a # asx) @ [a']) = []\n  a' \\<in> get_return_edges c'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge c'\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  \\<lbrakk>upd_cs (a # cs) as = [];\n   \\<forall>a\\<in>set (a # cs). valid_edge a;\n   \\<forall>a\\<in>set as. valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                    (\\<exists>asx aa asx' Q p f c' cs'.\n                        as = asx @ aa # asx' \\<and>\n                        same_level_path_aux (a # cs) asx \\<and>\n                        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                        upd_cs (a # cs) asx = c' # cs' \\<and>\n                        upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                        aa \\<in> get_return_edges c' \\<and>\n                        valid_edge c' \\<and>\n                        (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n  upd_cs cs (a # as) = []\n  \\<forall>a\\<in>set cs. valid_edge a\n  \\<forall>a\\<in>set (a # as). valid_edge a\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "note IH = \\<open>\\<lbrakk>upd_cs (a#cs) as = []; \\<forall>c\\<in>set (a#cs). valid_edge c;\n      \\<forall>a'\\<in>set as. valid_edge a'\\<rbrakk> \\<Longrightarrow> \n      (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n      (\\<exists>asx a' asx' Q' p' f' c' cs'. as = asx@a'#asx' \\<and> \n        same_level_path_aux (a#cs) asx \\<and> kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and> \n        upd_cs (a#cs) asx = c'#cs' \\<and> upd_cs (a#cs) (asx@[a']) = [] \\<and> \n        a' \\<in> get_return_edges c' \\<and> valid_edge c' \\<and> \n        (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs (a # cs) as = [];\n   \\<forall>c\\<in>set (a # cs). valid_edge c;\n   \\<forall>a'\\<in>set as. valid_edge a'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n                    (\\<exists>asx a' asx' Q' p' f' c' cs'.\n                        as = asx @ a' # asx' \\<and>\n                        same_level_path_aux (a # cs) asx \\<and>\n                        kind a' =\n                        Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n                        upd_cs (a # cs) asx = c' # cs' \\<and>\n                        upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n                        a' \\<in> get_return_edges c' \\<and>\n                        valid_edge c' \\<and>\n                        (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>\\<forall>a'\\<in>set (a#as). valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set (a # as). valid_edge a'", "have \"valid_edge a\" \n      and \"\\<forall>a'\\<in>set as. valid_edge a'\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set (a # as). valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_edge a &&& \\<forall>a'\\<in>set as. valid_edge a'", "by simp_all"], ["proof (state)\nthis:\n  valid_edge a\n  \\<forall>a'\\<in>set as. valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  valid_edge a", "have \"\\<forall>c\\<in>set (a#cs). valid_edge c\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (a # cs). valid_edge c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set (a # cs). valid_edge c\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>upd_cs cs (a#as) = []\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a # as) = []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"upd_cs (a#cs) as = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (a # as) = []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. upd_cs (a # cs) as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (a # cs) as = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set (a # cs)) valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx aa asx' Q p f c' cs'.\n                              as = asx @ aa # asx' \\<and>\n                              same_level_path_aux (a # cs) asx \\<and>\n                              kind aa =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs (a # cs) asx = c' # cs' \\<and>\n                              upd_cs (a # cs) (asx @ [aa]) = [] \\<and>\n                              aa \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from IH[OF this \\<open>\\<forall>c\\<in>set (a#cs). valid_edge c\\<close> \\<open>\\<forall>a'\\<in>set as. valid_edge a'\\<close>]"], ["proof (chain)\npicking this:\n  (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n  (\\<exists>asx a' asx' Q' p' f' c' cs'.\n      as = asx @ a' # asx' \\<and>\n      same_level_path_aux (a # cs) asx \\<and>\n      kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n      upd_cs (a # cs) asx = c' # cs' \\<and>\n      upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n      a' \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n  (\\<exists>asx a' asx' Q' p' f' c' cs'.\n      as = asx @ a' # asx' \\<and>\n      same_level_path_aux (a # cs) asx \\<and>\n      kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n      upd_cs (a # cs) asx = c' # cs' \\<and>\n      upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n      a' \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "assume \"\\<forall>a'\\<in>set as. intra_kind (kind a')\""], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set as. intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>a'\\<in>set as. intra_kind (kind a')", "have \"upd_cs cs (a#as) = a#cs\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>a'\\<in>set as. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # as) = a # cs", "by(fastforce intro:upd_cs_intra_path)"], ["proof (state)\nthis:\n  upd_cs cs (a # as) = a # cs\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "with \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a # as) = []\n  upd_cs cs (a # as) = a # cs", "have False"], ["proof (prove)\nusing this:\n  upd_cs cs (a # as) = []\n  upd_cs cs (a # as) = a # cs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "assume \"\\<exists>asx a' asx' Q p f c' cs'. as = asx@a'#asx' \\<and> \n                same_level_path_aux (a#cs) asx \\<and> kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and> \n                upd_cs (a#cs) asx = c'#cs' \\<and> upd_cs (a#cs) (asx@[a']) = [] \\<and> \n                a' \\<in> get_return_edges c' \\<and> valid_edge c' \\<and> \n                (\\<forall>a\\<in>set asx'. intra_kind (kind a))\""], ["proof (state)\nthis:\n  \\<exists>asx a' asx' Q p f c' cs'.\n     as = asx @ a' # asx' \\<and>\n     same_level_path_aux (a # cs) asx \\<and>\n     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n     upd_cs (a # cs) asx = c' # cs' \\<and>\n     upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n     a' \\<in> get_return_edges c' \\<and>\n     valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>asx a' asx' Q p f c' cs'.\n     as = asx @ a' # asx' \\<and>\n     same_level_path_aux (a # cs) asx \\<and>\n     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n     upd_cs (a # cs) asx = c' # cs' \\<and>\n     upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n     a' \\<in> get_return_edges c' \\<and>\n     valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a))", "obtain asx a' Q' p' f' asx' c' cs' where \"as = asx@a'#asx'\" \n        and \"same_level_path_aux (a#cs) asx\" and \"upd_cs (a#cs) (asx@[a']) = []\"\n        and \"upd_cs (a#cs) asx = c'#cs'\" and assms:\"a' \\<in> get_return_edges c'\"\n        \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\" \"valid_edge c'\" \"\\<forall>a\\<in>set asx'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>asx a' asx' Q p f c' cs'.\n     as = asx @ a' # asx' \\<and>\n     same_level_path_aux (a # cs) asx \\<and>\n     kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n     upd_cs (a # cs) asx = c' # cs' \\<and>\n     upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n     a' \\<in> get_return_edges c' \\<and>\n     valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>asx a' asx' c' cs' Q' p' f'.\n        \\<lbrakk>as = asx @ a' # asx'; same_level_path_aux (a # cs) asx;\n         upd_cs (a # cs) (asx @ [a']) = []; upd_cs (a # cs) asx = c' # cs';\n         a' \\<in> get_return_edges c';\n         kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'; valid_edge c';\n         \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = asx @ a' # asx'\n  same_level_path_aux (a # cs) asx\n  upd_cs (a # cs) (asx @ [a']) = []\n  upd_cs (a # cs) asx = c' # cs'\n  a' \\<in> get_return_edges c'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  valid_edge c'\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>as = asx@a'#asx'\\<close>"], ["proof (chain)\npicking this:\n  as = asx @ a' # asx'", "have \"a#as = (a#asx)@a'#asx'\""], ["proof (prove)\nusing this:\n  as = asx @ a' # asx'\n\ngoal (1 subgoal):\n 1. a # as = (a # asx) @ a' # asx'", "by simp"], ["proof (state)\nthis:\n  a # as = (a # asx) @ a' # asx'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  a # as = (a # asx) @ a' # asx'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>same_level_path_aux (a#cs) asx\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) asx", "have \"same_level_path_aux cs (a#asx)\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) asx\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # asx)", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # asx)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # asx)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>upd_cs (a#cs) asx = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs (a # cs) asx = c' # cs'", "have \"upd_cs cs (a#asx) = c'#cs'\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs (a # cs) asx = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # asx) = c' # cs'", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a # asx) = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  upd_cs cs (a # asx) = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>upd_cs (a#cs) (asx@[a']) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs (a # cs) (asx @ [a']) = []", "have \"upd_cs cs ((a#asx)@[a']) = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs (a # cs) (asx @ [a']) = []\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a # asx) @ [a']) = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a # asx) @ [a']) = []\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c' cs'.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux (a # cs) asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs (a # cs) asx = c' # cs' \\<and>\n       upd_cs (a # cs) (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c' \\<and>\n       valid_edge c' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "ultimately"], ["proof (chain)\npicking this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c' # cs'\n  upd_cs cs ((a # asx) @ [a']) = []", "show ?case"], ["proof (prove)\nusing this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c' # cs'\n  upd_cs cs ((a # asx) @ [a']) = []\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "using assms"], ["proof (prove)\nusing this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c' # cs'\n  upd_cs cs ((a # asx) @ [a']) = []\n  a' \\<in> get_return_edges c'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  valid_edge c'\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "case (slpa_Return cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>upd_cs cs' as = []; \\<forall>a\\<in>set cs'. valid_edge a;\n   \\<forall>a\\<in>set as. valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                    (\\<exists>asx a asx' Q p f c' cs'a.\n                        as = asx @ a # asx' \\<and>\n                        same_level_path_aux cs' asx \\<and>\n                        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                        upd_cs cs' asx = c' # cs'a \\<and>\n                        upd_cs cs' (asx @ [a]) = [] \\<and>\n                        a \\<in> get_return_edges c' \\<and>\n                        valid_edge c' \\<and>\n                        (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n  upd_cs cs (a # as) = []\n  \\<forall>a\\<in>set cs. valid_edge a\n  \\<forall>a\\<in>set (a # as). valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "note IH = \\<open>\\<lbrakk>upd_cs cs' as = []; \\<forall>c\\<in>set cs'. valid_edge c; \n      \\<forall>a'\\<in>set as. valid_edge a'\\<rbrakk> \\<Longrightarrow> \n      (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n      (\\<exists>asx a' asx' Q' p' f' c'' cs''. as = asx@a'#asx' \\<and> \n        same_level_path_aux cs' asx \\<and> kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and> upd_cs cs' asx = c''#cs'' \\<and>\n        upd_cs cs' (asx@[a']) = [] \\<and> a' \\<in> get_return_edges c'' \\<and> valid_edge c'' \\<and> \n        (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs cs' as = []; \\<forall>c\\<in>set cs'. valid_edge c;\n   \\<forall>a'\\<in>set as. valid_edge a'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n                    (\\<exists>asx a' asx' Q' p' f' c'' cs''.\n                        as = asx @ a' # asx' \\<and>\n                        same_level_path_aux cs' asx \\<and>\n                        kind a' =\n                        Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n                        upd_cs cs' asx = c'' # cs'' \\<and>\n                        upd_cs cs' (asx @ [a']) = [] \\<and>\n                        a' \\<in> get_return_edges c'' \\<and>\n                        valid_edge c'' \\<and>\n                        (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>\\<forall>a'\\<in>set (a#as). valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set (a # as). valid_edge a'", "have \"valid_edge a\" \n      and \"\\<forall>a'\\<in>set as. valid_edge a'\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set (a # as). valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_edge a &&& \\<forall>a'\\<in>set as. valid_edge a'", "by simp_all"], ["proof (state)\nthis:\n  valid_edge a\n  \\<forall>a'\\<in>set as. valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  cs = c' # cs'", "have \"valid_edge c'\" and \"\\<forall>c\\<in>set cs'. valid_edge c\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c' &&& \\<forall>c\\<in>set cs'. valid_edge c", "by simp_all"], ["proof (state)\nthis:\n  valid_edge c'\n  \\<forall>c\\<in>set cs'. valid_edge c\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>upd_cs cs (a#as) = []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close> \n      \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a # as) = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'", "have \"upd_cs cs' as = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (a # as) = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. upd_cs cs' as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set cs') valid_edge;\n         Ball (set as) valid_edge\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n                          (\\<exists>asx a asx' Q p f c' cs'a.\n                              as = asx @ a # asx' \\<and>\n                              same_level_path_aux cs' asx \\<and>\n                              kind a =\n                              Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                              upd_cs cs' asx = c' # cs'a \\<and>\n                              upd_cs cs' (asx @ [a]) = [] \\<and>\n                              a \\<in> get_return_edges c' \\<and>\n                              valid_edge c' \\<and>\n                              (\\<forall>a\\<in>set asx'.\n                                  intra_kind (kind a)));\n        upd_cs cs (a # as) = []; Ball (set cs) valid_edge;\n        Ball (set (a # as)) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>set (a # as).\n                             intra_kind (kind a)) \\<or>\n                         (\\<exists>asx aa asx' Q p f c' cs'.\n                             a # as = asx @ aa # asx' \\<and>\n                             same_level_path_aux cs asx \\<and>\n                             kind aa =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             upd_cs cs asx = c' # cs' \\<and>\n                             upd_cs cs (asx @ [aa]) = [] \\<and>\n                             aa \\<in> get_return_edges c' \\<and>\n                             valid_edge c' \\<and>\n                             (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from IH[OF this \\<open>\\<forall>c\\<in>set cs'. valid_edge c\\<close> \\<open>\\<forall>a'\\<in>set as. valid_edge a'\\<close>]"], ["proof (chain)\npicking this:\n  (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n  (\\<exists>asx a' asx' Q' p' f' c'' cs''.\n      as = asx @ a' # asx' \\<and>\n      same_level_path_aux cs' asx \\<and>\n      kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n      upd_cs cs' asx = c'' # cs'' \\<and>\n      upd_cs cs' (asx @ [a']) = [] \\<and>\n      a' \\<in> get_return_edges c'' \\<and>\n      valid_edge c'' \\<and>\n      (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<or>\n  (\\<exists>asx a' asx' Q' p' f' c'' cs''.\n      as = asx @ a' # asx' \\<and>\n      same_level_path_aux cs' asx \\<and>\n      kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n      upd_cs cs' asx = c'' # cs'' \\<and>\n      upd_cs cs' (asx @ [a']) = [] \\<and>\n      a' \\<in> get_return_edges c'' \\<and>\n      valid_edge c'' \\<and>\n      (\\<forall>a'\\<in>set asx'. intra_kind (kind a')))\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "assume \"\\<forall>a'\\<in>set as. intra_kind (kind a')\""], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set as. intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "hence \"upd_cs cs' as = cs'\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set as. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. upd_cs cs' as = cs'", "by(rule upd_cs_intra_path)"], ["proof (state)\nthis:\n  upd_cs cs' as = cs'\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "with \\<open>upd_cs cs' as = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs' as = []\n  upd_cs cs' as = cs'", "have \"cs' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs' as = []\n  upd_cs cs' as = cs'\n\ngoal (1 subgoal):\n 1. cs' = []", "by simp"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "with \\<open>cs = c'#cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []", "have \"upd_cs cs [a] = []\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [a] = []\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  upd_cs cs [a] = []\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'", "have \"upd_cs cs [] \\<noteq> []\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs [] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  upd_cs cs [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "have \"same_level_path_aux cs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs []\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n 2. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "ultimately"], ["proof (chain)\npicking this:\n  upd_cs cs [a] = []\n  upd_cs cs [] \\<noteq> []\n  same_level_path_aux cs []", "show ?case"], ["proof (prove)\nusing this:\n  upd_cs cs [a] = []\n  upd_cs cs [] \\<noteq> []\n  same_level_path_aux cs []\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "using \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>\\<forall>a'\\<in>set as. intra_kind (kind a')\\<close> \\<open>cs = c'#cs'\\<close>\n          \\<open>a \\<in> get_return_edges c'\\<close> \\<open>valid_edge c'\\<close>"], ["proof (prove)\nusing this:\n  upd_cs cs [a] = []\n  upd_cs cs [] \\<noteq> []\n  same_level_path_aux cs []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<forall>a'\\<in>set as. intra_kind (kind a')\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "by fastforce"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "assume \"\\<exists>asx a' asx' Q' p' f' c'' cs''. as = asx@a'#asx' \\<and>\n        same_level_path_aux cs' asx \\<and> kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and> upd_cs cs' asx = c''#cs'' \\<and>\n        upd_cs cs' (asx@[a']) = [] \\<and> a' \\<in> get_return_edges c'' \\<and> valid_edge c'' \\<and>\n        (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\""], ["proof (state)\nthis:\n  \\<exists>asx a' asx' Q' p' f' c'' cs''.\n     as = asx @ a' # asx' \\<and>\n     same_level_path_aux cs' asx \\<and>\n     kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n     upd_cs cs' asx = c'' # cs'' \\<and>\n     upd_cs cs' (asx @ [a']) = [] \\<and>\n     a' \\<in> get_return_edges c'' \\<and>\n     valid_edge c'' \\<and> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>asx a' asx' Q' p' f' c'' cs''.\n     as = asx @ a' # asx' \\<and>\n     same_level_path_aux cs' asx \\<and>\n     kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n     upd_cs cs' asx = c'' # cs'' \\<and>\n     upd_cs cs' (asx @ [a']) = [] \\<and>\n     a' \\<in> get_return_edges c'' \\<and>\n     valid_edge c'' \\<and> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))", "obtain asx a' asx' Q' p' f' c'' cs'' where \"as = asx@a'#asx'\"\n        and \"same_level_path_aux cs' asx\" and \"upd_cs cs' asx = c''#cs''\" \n        and \"upd_cs cs' (asx@[a']) = []\" and assms:\"a' \\<in> get_return_edges c''\" \n        \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\" \"valid_edge c''\" \"\\<forall>a'\\<in>set asx'. intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  \\<exists>asx a' asx' Q' p' f' c'' cs''.\n     as = asx @ a' # asx' \\<and>\n     same_level_path_aux cs' asx \\<and>\n     kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n     upd_cs cs' asx = c'' # cs'' \\<and>\n     upd_cs cs' (asx @ [a']) = [] \\<and>\n     a' \\<in> get_return_edges c'' \\<and>\n     valid_edge c'' \\<and> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. (\\<And>asx a' asx' c'' cs'' Q' p' f'.\n        \\<lbrakk>as = asx @ a' # asx'; same_level_path_aux cs' asx;\n         upd_cs cs' asx = c'' # cs''; upd_cs cs' (asx @ [a']) = [];\n         a' \\<in> get_return_edges c'';\n         kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'; valid_edge c'';\n         \\<forall>a'\\<in>set asx'. intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = asx @ a' # asx'\n  same_level_path_aux cs' asx\n  upd_cs cs' asx = c'' # cs''\n  upd_cs cs' (asx @ [a']) = []\n  a' \\<in> get_return_edges c''\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  valid_edge c''\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>as = asx@a'#asx'\\<close>"], ["proof (chain)\npicking this:\n  as = asx @ a' # asx'", "have \"a#as = (a#asx)@a'#asx'\""], ["proof (prove)\nusing this:\n  as = asx @ a' # asx'\n\ngoal (1 subgoal):\n 1. a # as = (a # asx) @ a' # asx'", "by simp"], ["proof (state)\nthis:\n  a # as = (a # asx) @ a' # asx'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  a # as = (a # asx) @ a' # asx'\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>same_level_path_aux cs' asx\\<close> \\<open>cs = c'#cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>\n        \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux cs' asx\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"same_level_path_aux cs (a#asx)\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs' asx\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # asx)", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # asx)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # asx)\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>upd_cs cs' asx = c''#cs''\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs' asx = c'' # cs''\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'", "have \"upd_cs cs (a#asx) = c''#cs''\""], ["proof (prove)\nusing this:\n  upd_cs cs' asx = c'' # cs''\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs (a # asx) = c'' # cs''", "by simp"], ["proof (state)\nthis:\n  upd_cs cs (a # asx) = c'' # cs''\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "moreover"], ["proof (state)\nthis:\n  upd_cs cs (a # asx) = c'' # cs''\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "from \\<open>upd_cs cs' (asx@[a']) = []\\<close> \\<open>cs = c'#cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>\n        \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs' (asx @ [a']) = []\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"upd_cs cs ((a#asx)@[a']) = []\""], ["proof (prove)\nusing this:\n  upd_cs cs' (asx @ [a']) = []\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. upd_cs cs ((a # asx) @ [a']) = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs ((a # asx) @ [a']) = []\n\ngoal (1 subgoal):\n 1. \\<exists>asx a' asx' Q' p' f' c'' cs''.\n       as = asx @ a' # asx' \\<and>\n       same_level_path_aux cs' asx \\<and>\n       kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<and>\n       upd_cs cs' asx = c'' # cs'' \\<and>\n       upd_cs cs' (asx @ [a']) = [] \\<and>\n       a' \\<in> get_return_edges c'' \\<and>\n       valid_edge c'' \\<and>\n       (\\<forall>a'\\<in>set asx'. intra_kind (kind a')) \\<Longrightarrow>\n    (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "ultimately"], ["proof (chain)\npicking this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c'' # cs''\n  upd_cs cs ((a # asx) @ [a']) = []", "show ?case"], ["proof (prove)\nusing this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c'' # cs''\n  upd_cs cs ((a # asx) @ [a']) = []\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "using assms"], ["proof (prove)\nusing this:\n  a # as = (a # asx) @ a' # asx'\n  same_level_path_aux cs (a # asx)\n  upd_cs cs (a # asx) = c'' # cs''\n  upd_cs cs ((a # asx) @ [a']) = []\n  a' \\<in> get_return_edges c''\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  valid_edge c''\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n    (\\<exists>asx aa asx' Q p f c' cs'.\n        a # as = asx @ aa # asx' \\<and>\n        same_level_path_aux cs asx \\<and>\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        upd_cs cs asx = c' # cs' \\<and>\n        upd_cs cs (asx @ [aa]) = [] \\<and>\n        aa \\<in> get_return_edges c' \\<and>\n        valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (a # as). intra_kind (kind a)) \\<or>\n  (\\<exists>asx aa asx' Q p f c' cs'.\n      a # as = asx @ aa # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [aa]) = [] \\<and>\n      aa \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<or>\n  (\\<exists>asx a asx' Q p f c' cs'.\n      as = asx @ a # asx' \\<and>\n      same_level_path_aux cs asx \\<and>\n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      upd_cs cs asx = c' # cs' \\<and>\n      upd_cs cs (asx @ [a]) = [] \\<and>\n      a \\<in> get_return_edges c' \\<and>\n      valid_edge c' \\<and> (\\<forall>a\\<in>set asx'. intra_kind (kind a)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma same_level_path_aux_valid_path_aux: \n  \"same_level_path_aux cs as \\<Longrightarrow> valid_path_aux cs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs as \\<Longrightarrow> valid_path_aux cs as", "by(induct rule:slpa_induct,auto split:edge_kind.split simp:intra_kind_def)"], ["", "lemma same_level_path_aux_Append:\n  \"\\<lbrakk>same_level_path_aux cs as; same_level_path_aux (upd_cs cs as) as'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs (as@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as;\n     same_level_path_aux (upd_cs cs as) as'\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs (as @ as')", "by(induct rule:slpa_induct,auto simp:intra_kind_def)"], ["", "lemma same_level_path_aux_callstack_Append:\n  \"same_level_path_aux cs as \\<Longrightarrow> same_level_path_aux (cs@cs') as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs as \\<Longrightarrow>\n    same_level_path_aux (cs @ cs') as", "by(induct rule:slpa_induct,auto simp:intra_kind_def)"], ["", "lemma same_level_path_upd_cs_callstack_Append:\n  \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = cs'\\<rbrakk> \n  \\<Longrightarrow> upd_cs (cs@cs'') as = (cs'@cs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as; upd_cs cs as = cs'\\<rbrakk>\n    \\<Longrightarrow> upd_cs (cs @ cs'') as = cs' @ cs''", "by(induct rule:slpa_induct,auto split:edge_kind.split simp:intra_kind_def)"], ["", "lemma slpa_split:\n  assumes \"same_level_path_aux cs as\" and \"as = xs@ys\" and \"upd_cs cs xs = []\"\n  shows \"same_level_path_aux cs xs\" and \"same_level_path_aux [] ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs &&& same_level_path_aux [] ys", "using assms"], ["proof (prove)\nusing this:\n  same_level_path_aux cs as\n  as = xs @ ys\n  upd_cs cs xs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs &&& same_level_path_aux [] ys", "proof(induct arbitrary:xs ys rule:slpa_induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 7. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 8. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 7. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 8. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 1"], ["proof (state)\nthis:\n  [] = xs @ ys\n  upd_cs cs xs = []\n\ngoal (8 subgoals):\n 1. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 7. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 8. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "from \\<open>[] = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  [] = xs @ ys", "show ?case"], ["proof (prove)\nusing this:\n  [] = xs @ ys\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal (7 subgoals):\n 1. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 5. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 7. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 5. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 7. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 5. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 7. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 2"], ["proof (state)\nthis:\n  [] = xs @ ys\n  upd_cs cs xs = []\n\ngoal (7 subgoals):\n 1. \\<And>cs xs ys.\n       \\<lbrakk>[] = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 5. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 7. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "from \\<open>[] = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  [] = xs @ ys", "show ?case"], ["proof (prove)\nusing this:\n  [] = xs @ ys\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal (6 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs ?xs\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (6 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "note IH1 = \\<open>\\<And>xs ys. \\<lbrakk>as = xs@ys; upd_cs cs xs = []\\<rbrakk> \\<Longrightarrow> same_level_path_aux cs xs\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs ?xs\n\ngoal (6 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "note IH2 = \\<open>\\<And>xs ys. \\<lbrakk>as = xs@ys; upd_cs cs xs = []\\<rbrakk> \\<Longrightarrow> same_level_path_aux [] ys\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (6 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "{"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (6 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 1"], ["proof (state)\nthis:\n  a # as = xs @ ys\n  upd_cs cs xs = []\n\ngoal (6 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 6. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>a#as = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  a # as = xs @ ys\n  xs = x' # xs'", "have \"a = x'\" and \"as = xs'@ys\""], ["proof (prove)\nusing this:\n  a # as = xs @ ys\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. a = x' &&& as = xs' @ ys", "by simp_all"], ["proof (state)\nthis:\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>upd_cs cs xs = []\\<close> Cons \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  intra_kind (kind a)\n  a = x'\n  as = xs' @ ys", "have \"upd_cs cs xs' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  intra_kind (kind a)\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. upd_cs cs xs' = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs xs' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "from IH1[OF \\<open>as = xs'@ys\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux cs xs'", "have \"same_level_path_aux cs xs'\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs xs'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs'", "."], ["proof (state)\nthis:\n  same_level_path_aux cs xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>a = x'\\<close> \\<open>intra_kind (kind a)\\<close> Cons"], ["proof (chain)\npicking this:\n  a = x'\n  intra_kind (kind a)\n  xs = x' # xs'\n  same_level_path_aux cs xs'", "show ?thesis"], ["proof (prove)\nusing this:\n  a = x'\n  intra_kind (kind a)\n  xs = x' # xs'\n  same_level_path_aux cs xs'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal (5 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 2"], ["proof (state)\nthis:\n  a # as = xs @ ys\n  upd_cs cs xs = []\n\ngoal (5 subgoals):\n 1. \\<And>cs a as xs ys.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 5. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>upd_cs cs xs = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = []", "have \"cs = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = []\n\ngoal (1 subgoal):\n 1. cs = []", "by fastforce"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with Nil \\<open>a#as = xs@ys\\<close> \\<open>same_level_path_aux cs as\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  xs = []\n  a # as = xs @ ys\n  same_level_path_aux cs as\n  intra_kind (kind a)\n  cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n  a # as = xs @ ys\n  same_level_path_aux cs as\n  intra_kind (kind a)\n  cs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "by(cases ys,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>a#as = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  a # as = xs @ ys\n  xs = x' # xs'", "have \"a = x'\" and \"as = xs'@ys\""], ["proof (prove)\nusing this:\n  a # as = xs @ ys\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. a = x' &&& as = xs' @ ys", "by simp_all"], ["proof (state)\nthis:\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>upd_cs cs xs = []\\<close> Cons \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  intra_kind (kind a)\n  a = x'\n  as = xs' @ ys", "have \"upd_cs cs xs' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  intra_kind (kind a)\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. upd_cs cs xs' = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs xs' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "from IH2[OF \\<open>as = xs'@ys\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux [] ys", "show ?thesis"], ["proof (prove)\nusing this:\n  same_level_path_aux [] ys\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "."], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a # as = ?xsa2 @ ?ysa2; upd_cs cs ?xsa2 = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ysa2\n\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs (a # cs) ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux (a # cs) ?xs\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs (a # cs) ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "note IH1 = \\<open>\\<And>xs ys. \\<lbrakk>as = xs@ys; upd_cs (a#cs) xs = []\\<rbrakk> \n    \\<Longrightarrow> same_level_path_aux (a#cs) xs\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs (a # cs) ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux (a # cs) ?xs\n\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "note IH2 = \\<open>\\<And>xs ys. \\<lbrakk>as = xs@ys; upd_cs (a#cs) xs = []\\<rbrakk> \n    \\<Longrightarrow> same_level_path_aux [] ys\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs (a # cs) ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "{"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs (a # cs) ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 1"], ["proof (state)\nthis:\n  a # as = xs @ ys\n  upd_cs cs xs = []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 4. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>a#as = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  a # as = xs @ ys\n  xs = x' # xs'", "have \"a = x'\" and \"as = xs'@ys\""], ["proof (prove)\nusing this:\n  a # as = xs @ ys\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. a = x' &&& as = xs' @ ys", "by simp_all"], ["proof (state)\nthis:\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>upd_cs cs xs = []\\<close> Cons \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a = x'\n  as = xs' @ ys", "have \"upd_cs (a#cs) xs' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. upd_cs (a # cs) xs' = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (a # cs) xs' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "from IH1[OF \\<open>as = xs'@ys\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux (a # cs) xs'", "have \"same_level_path_aux (a#cs) xs'\""], ["proof (prove)\nusing this:\n  same_level_path_aux (a # cs) xs'\n\ngoal (1 subgoal):\n 1. same_level_path_aux (a # cs) xs'", "."], ["proof (state)\nthis:\n  same_level_path_aux (a # cs) xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>a = x'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> Cons"], ["proof (chain)\npicking this:\n  a = x'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  xs = x' # xs'\n  same_level_path_aux (a # cs) xs'", "show ?thesis"], ["proof (prove)\nusing this:\n  a = x'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  xs = x' # xs'\n  same_level_path_aux (a # cs) xs'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 2"], ["proof (state)\nthis:\n  a # as = xs @ ys\n  upd_cs cs xs = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs (a # cs) xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 3. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>upd_cs cs xs = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = []", "have \"cs = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = []\n\ngoal (1 subgoal):\n 1. cs = []", "by fastforce"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with Nil \\<open>a#as = xs@ys\\<close> \\<open>same_level_path_aux (a#cs) as\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  xs = []\n  a # as = xs @ ys\n  same_level_path_aux (a # cs) as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n  a # as = xs @ ys\n  same_level_path_aux (a # cs) as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "by(cases ys) auto"], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>a#as = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  a # as = xs @ ys\n  xs = x' # xs'", "have \"a = x'\" and \"as = xs'@ys\""], ["proof (prove)\nusing this:\n  a # as = xs @ ys\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. a = x' &&& as = xs' @ ys", "by simp_all"], ["proof (state)\nthis:\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>upd_cs cs xs = []\\<close> Cons \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a = x'\n  as = xs' @ ys", "have \"upd_cs (a#cs) xs' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. upd_cs (a # cs) xs' = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (a # cs) xs' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "from IH2[OF \\<open>as = xs'@ys\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux [] ys", "show ?thesis"], ["proof (prove)\nusing this:\n  same_level_path_aux [] ys\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "."], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a # as = ?xsa2 @ ?ysa2; upd_cs cs ?xsa2 = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ysa2\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case (slpa_Return cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs' ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs' ?xs\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs' ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "note IH1 = \\<open>\\<And>xs ys. \\<lbrakk>as = xs@ys; upd_cs cs' xs = []\\<rbrakk> \\<Longrightarrow> same_level_path_aux cs' xs\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs' ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs' ?xs\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "note IH2 = \\<open>\\<And>xs ys. \\<lbrakk>as = xs@ys; upd_cs cs' xs = []\\<rbrakk> \\<Longrightarrow> same_level_path_aux [] ys\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs' ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "{"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ ?ys; upd_cs cs' ?xs = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ys\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 1"], ["proof (state)\nthis:\n  a # as = xs @ ys\n  upd_cs cs xs = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux cs xs\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>a#as = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  a # as = xs @ ys\n  xs = x' # xs'", "have \"a = x'\" and \"as = xs'@ys\""], ["proof (prove)\nusing this:\n  a # as = xs @ ys\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. a = x' &&& as = xs' @ ys", "by simp_all"], ["proof (state)\nthis:\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>upd_cs cs xs = []\\<close> Cons \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a = x'\n  as = xs' @ ys", "have \"upd_cs cs' xs' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. upd_cs cs' xs' = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' xs' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "from IH1[OF \\<open>as = xs'@ys\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux cs' xs'", "have \"same_level_path_aux cs' xs'\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs' xs'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs' xs'", "."], ["proof (state)\nthis:\n  same_level_path_aux cs' xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux cs xs", "with \\<open>a = x'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close> Cons"], ["proof (chain)\npicking this:\n  a = x'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  xs = x' # xs'\n  same_level_path_aux cs' xs'", "show ?thesis"], ["proof (prove)\nusing this:\n  a = x'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  xs = x' # xs'\n  same_level_path_aux cs' xs'\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs xs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux cs xs\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "case 2"], ["proof (state)\nthis:\n  a # as = xs @ ys\n  upd_cs cs xs = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' xs;\n        \\<And>xs ys.\n           \\<lbrakk>as = xs @ ys; upd_cs cs' xs = []\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] ys;\n        a # as = xs @ ys; upd_cs cs xs = []\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>upd_cs cs xs = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = []", "have \"cs = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = []\n\ngoal (1 subgoal):\n 1. cs = []", "by fastforce"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  cs = []", "have False"], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  cs = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> same_level_path_aux [] ys\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>a#as = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  a # as = xs @ ys\n  xs = x' # xs'", "have \"a = x'\" and \"as = xs'@ys\""], ["proof (prove)\nusing this:\n  a # as = xs @ ys\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. a = x' &&& as = xs' @ ys", "by simp_all"], ["proof (state)\nthis:\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "with \\<open>upd_cs cs xs = []\\<close> Cons \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a = x'\n  as = xs' @ ys", "have \"upd_cs cs' xs' = []\""], ["proof (prove)\nusing this:\n  upd_cs cs xs = []\n  xs = x' # xs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a = x'\n  as = xs' @ ys\n\ngoal (1 subgoal):\n 1. upd_cs cs' xs' = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' xs' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> same_level_path_aux [] ys", "from IH2[OF \\<open>as = xs'@ys\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux [] ys", "show ?thesis"], ["proof (prove)\nusing this:\n  same_level_path_aux [] ys\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] ys", "."], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux [] ys\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a # as = ?xsa2 @ ?ysa2; upd_cs cs ?xsa2 = []\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] ?ysa2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slpa_number_Calls_eq_number_Returns:\n  \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = []; \n    \\<forall>a \\<in> set as. valid_edge a; \\<forall>c \\<in> set cs. valid_edge c\\<rbrakk>\n  \\<Longrightarrow> length [a\\<leftarrow>as@cs. \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs] = \n     length [a\\<leftarrow>as. \\<exists>Q p f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as; upd_cs cs as = [];\n     \\<forall>a\\<in>set as. valid_edge a;\n     \\<forall>c\\<in>set cs. valid_edge c\\<rbrakk>\n    \\<Longrightarrow> length\n                       (filter\n                         (\\<lambda>a.\n                             \\<exists>Q r p fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                         (as @ cs)) =\n                      length\n                       (filter\n                         (\\<lambda>a.\n                             \\<exists>Q p f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                         as)", "apply(induct rule:slpa_induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>upd_cs cs [] = []; Ball (set []) valid_edge;\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q r p fs.\n                                   kind a =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                            ([] @ cs)) =\n                         length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q p f.\n                                   kind a =\n                                   Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                            [])\n 2. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>upd_cs cs as = []; Ball (set as) valid_edge;\n         Ball (set cs) valid_edge\\<rbrakk>\n        \\<Longrightarrow> length\n                           (filter\n                             (\\<lambda>a.\n                                 \\<exists>Q r p fs.\n                                    kind a =\n                                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                             (as @ cs)) =\n                          length\n                           (filter\n                             (\\<lambda>a.\n                                 \\<exists>Q p f.\n                                    kind a =\n                                    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                             as);\n        upd_cs cs (a # as) = []; Ball (set (a # as)) valid_edge;\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q r p fs.\n                                   kind a =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                            ((a # as) @ cs)) =\n                         length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q p f.\n                                   kind a =\n                                   Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                            (a # as))\n 3. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>upd_cs (a # cs) as = []; Ball (set as) valid_edge;\n         Ball (set (a # cs)) valid_edge\\<rbrakk>\n        \\<Longrightarrow> length\n                           (filter\n                             (\\<lambda>a.\n                                 \\<exists>Q r p fs.\n                                    kind a =\n                                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                             (as @ a # cs)) =\n                          length\n                           (filter\n                             (\\<lambda>a.\n                                 \\<exists>Q p f.\n                                    kind a =\n                                    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                             as);\n        upd_cs cs (a # as) = []; Ball (set (a # as)) valid_edge;\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q r p fs.\n                                   kind a =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                            ((a # as) @ cs)) =\n                         length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q p f.\n                                   kind a =\n                                   Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                            (a # as))\n 4. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>upd_cs cs' as = []; Ball (set as) valid_edge;\n         Ball (set cs') valid_edge\\<rbrakk>\n        \\<Longrightarrow> length\n                           (filter\n                             (\\<lambda>a.\n                                 \\<exists>Q r p fs.\n                                    kind a =\n                                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                             (as @ cs')) =\n                          length\n                           (filter\n                             (\\<lambda>a.\n                                 \\<exists>Q p f.\n                                    kind a =\n                                    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                             as);\n        upd_cs cs (a # as) = []; Ball (set (a # as)) valid_edge;\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q r p fs.\n                                   kind a =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                            ((a # as) @ cs)) =\n                         length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>Q p f.\n                                   kind a =\n                                   Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                            (a # as))", "by(auto split:list.split edge_kind.split intro:only_call_get_return_edges \n         simp:intra_kind_def)"], ["", "lemma slpa_get_proc:\n  \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = []; n -as\\<rightarrow>* n'; \n    \\<forall>c \\<in> set cs. valid_edge c\\<rbrakk>\n  \\<Longrightarrow> (if cs = [] then get_proc n else get_proc(last(sourcenodes cs))) = get_proc n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as; upd_cs cs as = [];\n     n -as\\<rightarrow>* n'; \\<forall>c\\<in>set cs. valid_edge c\\<rbrakk>\n    \\<Longrightarrow> (if cs = [] then get_proc n\n                       else get_proc (last (sourcenodes cs))) =\n                      get_proc n'", "proof(induct arbitrary:n rule:slpa_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>upd_cs cs [] = []; n -[]\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "case slpa_empty"], ["proof (state)\nthis:\n  upd_cs cs_ [] = []\n  n -[]\\<rightarrow>* n'\n  \\<forall>a\\<in>set cs_. valid_edge a\n\ngoal (4 subgoals):\n 1. \\<And>cs n.\n       \\<lbrakk>upd_cs cs [] = []; n -[]\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 4. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "thus ?case"], ["proof (prove)\nusing this:\n  upd_cs cs_ [] = []\n  n -[]\\<rightarrow>* n'\n  \\<forall>a\\<in>set cs_. valid_edge a\n\ngoal (1 subgoal):\n 1. (if cs_ = [] then get_proc n else get_proc (last (sourcenodes cs_))) =\n    get_proc n'", "by fastforce"], ["proof (state)\nthis:\n  (if cs_ = [] then get_proc n else get_proc (last (sourcenodes cs_))) =\n  get_proc n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  \\<lbrakk>upd_cs cs as = []; ?n -as\\<rightarrow>* n';\n   \\<forall>a\\<in>set cs. valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (if cs = [] then get_proc ?n\n                     else get_proc (last (sourcenodes cs))) =\n                    get_proc n'\n  upd_cs cs (a # as) = []\n  n -a # as\\<rightarrow>* n'\n  \\<forall>a\\<in>set cs. valid_edge a\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "note IH = \\<open>\\<And>n. \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n'; \\<forall>a\\<in>set cs. valid_edge a\\<rbrakk>\n    \\<Longrightarrow> (if cs = [] then get_proc n else get_proc (last (sourcenodes cs))) = \n        get_proc n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs cs as = []; ?n -as\\<rightarrow>* n';\n   \\<forall>a\\<in>set cs. valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (if cs = [] then get_proc ?n\n                     else get_proc (last (sourcenodes cs))) =\n                    get_proc n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>intra_kind (kind a)\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []", "have \"upd_cs cs as = []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. upd_cs cs as = []", "by(cases \"kind a\",auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs as = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"n -[]@a#as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -[] @ a # as\\<rightarrow>* n'", "by simp"], ["proof (state)\nthis:\n  n -[] @ a # as\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "hence \"valid_edge a\" and \"n = sourcenode a\" and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -[] @ a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_edge a &&& n = sourcenode a &&& targetnode a -as\\<rightarrow>* n'", "by(fastforce dest:path_split)+"], ["proof (state)\nthis:\n  valid_edge a\n  n = sourcenode a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open> n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  n = sourcenode a", "have \"get_proc n = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  n = sourcenode a\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc (targetnode a)", "by(fastforce intro:get_proc_intra)"], ["proof (state)\nthis:\n  get_proc n = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from IH[OF \\<open>upd_cs cs as = []\\<close> \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>\\<forall>a\\<in>set cs. valid_edge a\\<close>]"], ["proof (chain)\npicking this:\n  (if cs = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs))) =\n  get_proc n'", "have \"(if cs = [] then get_proc (targetnode a) \n         else get_proc (last (sourcenodes cs))) = get_proc n'\""], ["proof (prove)\nusing this:\n  (if cs = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs))) =\n  get_proc n'\n\ngoal (1 subgoal):\n 1. (if cs = [] then get_proc (targetnode a)\n     else get_proc (last (sourcenodes cs))) =\n    get_proc n'", "."], ["proof (state)\nthis:\n  (if cs = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs))) =\n  get_proc n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>n.\n           \\<lbrakk>upd_cs cs as = []; n -as\\<rightarrow>* n';\n            Ball (set cs) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs = [] then get_proc n\n                              else get_proc (last (sourcenodes cs))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 3. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "with \\<open>get_proc n = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  get_proc n = get_proc (targetnode a)\n  (if cs = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs))) =\n  get_proc n'", "show ?case"], ["proof (prove)\nusing this:\n  get_proc n = get_proc (targetnode a)\n  (if cs = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs))) =\n  get_proc n'\n\ngoal (1 subgoal):\n 1. (if cs = [] then get_proc n else get_proc (last (sourcenodes cs))) =\n    get_proc n'", "by auto"], ["proof (state)\nthis:\n  (if cs = [] then get_proc n else get_proc (last (sourcenodes cs))) =\n  get_proc n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  \\<lbrakk>upd_cs (a # cs) as = []; ?n -as\\<rightarrow>* n';\n   \\<forall>a\\<in>set (a # cs). valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (if a # cs = [] then get_proc ?n\n                     else get_proc (last (sourcenodes (a # cs)))) =\n                    get_proc n'\n  upd_cs cs (a # as) = []\n  n -a # as\\<rightarrow>* n'\n  \\<forall>a\\<in>set cs. valid_edge a\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "note IH = \\<open>\\<And>n. \\<lbrakk>upd_cs (a#cs) as = []; n -as\\<rightarrow>* n'; \\<forall>a\\<in>set (a#cs). valid_edge a\\<rbrakk>\n    \\<Longrightarrow> (if a#cs = [] then get_proc n else get_proc (last (sourcenodes (a#cs)))) = \n        get_proc n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs (a # cs) as = []; ?n -as\\<rightarrow>* n';\n   \\<forall>a\\<in>set (a # cs). valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (if a # cs = [] then get_proc ?n\n                     else get_proc (last (sourcenodes (a # cs)))) =\n                    get_proc n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []", "have \"upd_cs (a#cs) as = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. upd_cs (a # cs) as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (a # cs) as = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"n -[]@a#as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -[] @ a # as\\<rightarrow>* n'", "by simp"], ["proof (state)\nthis:\n  n -[] @ a # as\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "hence \"valid_edge a\" and \"n = sourcenode a\" and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -[] @ a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_edge a &&& n = sourcenode a &&& targetnode a -as\\<rightarrow>* n'", "by(fastforce dest:path_split)+"], ["proof (state)\nthis:\n  valid_edge a\n  n = sourcenode a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>valid_edge a\\<close> \\<open>\\<forall>a\\<in>set cs. valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>a\\<in>set cs. valid_edge a", "have \"\\<forall>a\\<in>set (a#cs). valid_edge a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>a\\<in>set cs. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (a # cs). valid_edge a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (a # cs). valid_edge a\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from IH[OF \\<open>upd_cs (a#cs) as = []\\<close> \\<open>targetnode a -as\\<rightarrow>* n'\\<close> this]"], ["proof (chain)\npicking this:\n  (if a # cs = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes (a # cs)))) =\n  get_proc n'", "have \"get_proc (last (sourcenodes (a#cs))) = get_proc n'\""], ["proof (prove)\nusing this:\n  (if a # cs = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes (a # cs)))) =\n  get_proc n'\n\ngoal (1 subgoal):\n 1. get_proc (last (sourcenodes (a # cs))) = get_proc n'", "by simp"], ["proof (state)\nthis:\n  get_proc (last (sourcenodes (a # cs))) = get_proc n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>n.\n           \\<lbrakk>upd_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            Ball (set (a # cs)) valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if a # cs = [] then get_proc n\n                              else get_proc (last (sourcenodes (a # cs)))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'\n 2. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "with \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  n = sourcenode a\n  get_proc (last (sourcenodes (a # cs))) = get_proc n'", "show ?case"], ["proof (prove)\nusing this:\n  n = sourcenode a\n  get_proc (last (sourcenodes (a # cs))) = get_proc n'\n\ngoal (1 subgoal):\n 1. (if cs = [] then get_proc n else get_proc (last (sourcenodes cs))) =\n    get_proc n'", "by(cases cs,auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  (if cs = [] then get_proc n else get_proc (last (sourcenodes cs))) =\n  get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "case (slpa_Return cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>upd_cs cs' as = []; ?n -as\\<rightarrow>* n';\n   \\<forall>a\\<in>set cs'. valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (if cs' = [] then get_proc ?n\n                     else get_proc (last (sourcenodes cs'))) =\n                    get_proc n'\n  upd_cs cs (a # as) = []\n  n -a # as\\<rightarrow>* n'\n  \\<forall>a\\<in>set cs. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "note IH = \\<open>\\<And>n. \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n'; \\<forall>a\\<in>set cs'. valid_edge a\\<rbrakk>\n    \\<Longrightarrow> (if cs' = [] then get_proc n else get_proc (last (sourcenodes cs'))) = \n       get_proc n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs cs' as = []; ?n -as\\<rightarrow>* n';\n   \\<forall>a\\<in>set cs'. valid_edge a\\<rbrakk>\n  \\<Longrightarrow> (if cs' = [] then get_proc ?n\n                     else get_proc (last (sourcenodes cs'))) =\n                    get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>\\<forall>a\\<in>set cs. valid_edge a\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set cs. valid_edge a\n  cs = c' # cs'", "have \"valid_edge c'\" and \"\\<forall>a\\<in>set cs'. valid_edge a\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set cs. valid_edge a\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c' &&& \\<forall>a\\<in>set cs'. valid_edge a", "by simp_all"], ["proof (state)\nthis:\n  valid_edge c'\n  \\<forall>a\\<in>set cs'. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>upd_cs cs (a#as) = []\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs cs (a # as) = []\n  cs = c' # cs'", "have \"upd_cs cs' as = []\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs cs (a # as) = []\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. upd_cs cs' as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>n -a#as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'", "have \"n -[]@a#as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -[] @ a # as\\<rightarrow>* n'", "by simp"], ["proof (state)\nthis:\n  n -[] @ a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "hence \"n = sourcenode a\" and \"targetnode a -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -[] @ a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = sourcenode a &&& targetnode a -as\\<rightarrow>* n'", "by(fastforce dest:path_split)+"], ["proof (state)\nthis:\n  n = sourcenode a\n  targetnode a -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "from IH[OF \\<open>upd_cs cs' as = []\\<close> \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>\\<forall>a\\<in>set cs'. valid_edge a\\<close>]"], ["proof (chain)\npicking this:\n  (if cs' = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs'))) =\n  get_proc n'", "have \"(if cs' = [] then get_proc (targetnode a) \n         else get_proc (last (sourcenodes cs'))) = get_proc n'\""], ["proof (prove)\nusing this:\n  (if cs' = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs'))) =\n  get_proc n'\n\ngoal (1 subgoal):\n 1. (if cs' = [] then get_proc (targetnode a)\n     else get_proc (last (sourcenodes cs'))) =\n    get_proc n'", "."], ["proof (state)\nthis:\n  (if cs' = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs'))) =\n  get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' n.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>n.\n           \\<lbrakk>upd_cs cs' as = []; n -as\\<rightarrow>* n';\n            Ball (set cs') valid_edge\\<rbrakk>\n           \\<Longrightarrow> (if cs' = [] then get_proc n\n                              else get_proc (last (sourcenodes cs'))) =\n                             get_proc n';\n        upd_cs cs (a # as) = []; n -a # as\\<rightarrow>* n';\n        Ball (set cs) valid_edge\\<rbrakk>\n       \\<Longrightarrow> (if cs = [] then get_proc n\n                          else get_proc (last (sourcenodes cs))) =\n                         get_proc n'", "with \\<open>cs = c'#cs'\\<close> \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n  (if cs' = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs'))) =\n  get_proc n'", "show ?case"], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n  (if cs' = [] then get_proc (targetnode a)\n   else get_proc (last (sourcenodes cs'))) =\n  get_proc n'\n\ngoal (1 subgoal):\n 1. (if cs = [] then get_proc n else get_proc (last (sourcenodes cs))) =\n    get_proc n'", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  (if cs = [] then get_proc n else get_proc (last (sourcenodes cs))) =\n  get_proc n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slpa_get_return_edges:\n  \"\\<lbrakk>same_level_path_aux cs as; cs \\<noteq> []; upd_cs cs as = [];\n  \\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as; cs \\<noteq> []; upd_cs cs as = [];\n     \\<forall>xs ys.\n        as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n        upd_cs cs xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last as \\<in> get_return_edges (last cs)", "proof(induct rule:slpa_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>cs \\<noteq> []; upd_cs cs [] = [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last [] \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs);\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 3. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 4. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  cs \\<noteq> []\n  upd_cs cs [] = []\n  \\<forall>xs ys.\n     [] = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>cs \\<noteq> []; upd_cs cs [] = [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last [] \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs);\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 3. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 4. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "from \\<open>cs \\<noteq> []\\<close> \\<open>upd_cs cs [] = []\\<close>"], ["proof (chain)\npicking this:\n  cs \\<noteq> []\n  upd_cs cs [] = []", "have False"], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  upd_cs cs [] = []\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>cs \\<noteq> []; upd_cs cs [] = [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last [] \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs);\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 3. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 4. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. last [] \\<in> get_return_edges (last cs)", "by simp"], ["proof (state)\nthis:\n  last [] \\<in> get_return_edges (last cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs);\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs);\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last cs)\n  cs \\<noteq> []\n  upd_cs cs (a # as) = []\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs);\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "note IH = \\<open>\\<lbrakk>cs \\<noteq> []; upd_cs cs as = []; \n              \\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last as \\<in> get_return_edges (last cs)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n      upd_cs cs xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<lbrakk>cs \\<noteq> []; upd_cs cs as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs);\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 3. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>intra_kind (kind a)\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []\n  as = []", "have \"cs = []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []\n  as = []\n\ngoal (1 subgoal):\n 1. cs = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  cs \\<noteq> []\n  cs = []", "have False"], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  cs = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "by simp"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from \\<open>intra_kind (kind a)\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []", "have \"upd_cs cs as = []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. upd_cs cs as = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs as = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from \\<open>\\<forall>xs ys. a#as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  intra_kind (kind a)", "have \"\\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n       upd_cs cs xs \\<noteq> []", "apply(clarsimp,erule_tac x=\"a#xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>intra_kind (kind a); ys \\<noteq> []; as = xs @ ys;\n        upd_cs cs xs = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> [];\n        intra_kind (kind a);\n        (\\<exists>ysa.\n            a # xs @ ys = (a # xs) @ ysa \\<and>\n            ysa \\<noteq> []) \\<longrightarrow>\n        upd_cs cs (a # xs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from IH[OF \\<open>cs \\<noteq> []\\<close> \\<open>upd_cs cs as = []\\<close> this]"], ["proof (chain)\npicking this:\n  last as \\<in> get_return_edges (last cs)", "have \"last as \\<in> get_return_edges (last cs)\""], ["proof (prove)\nusing this:\n  last as \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. last as \\<in> get_return_edges (last cs)", "."], ["proof (state)\nthis:\n  last as \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with False"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  last as \\<in> get_return_edges (last cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  last as \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "by simp"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n      upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs))\n  cs \\<noteq> []\n  upd_cs cs (a # as) = []\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "note IH = \\<open>\\<lbrakk>a#cs \\<noteq> []; upd_cs (a#cs) as = [];\n    \\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs (a#cs) xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last as \\<in> get_return_edges (last (a#cs))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n      upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs))\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<lbrakk>a # cs \\<noteq> []; upd_cs (a # cs) as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs (a # cs) xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last (a # cs));\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []\n  as = []", "have \"a#cs = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []\n  as = []\n\ngoal (1 subgoal):\n 1. a # cs = []", "by simp"], ["proof (state)\nthis:\n  a # cs = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a # cs = []\n\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "by simp"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []", "have \"upd_cs (a#cs) as = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. upd_cs (a # cs) as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (a # cs) as = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from \\<open>\\<forall>xs ys. a#as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs (a#cs) xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n       upd_cs (a # cs) xs \\<noteq> []", "by(clarsimp,erule_tac x=\"a#xs\" in allE,simp)"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs (a # cs) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from IH[OF _ \\<open>upd_cs (a#cs) as = []\\<close> this]"], ["proof (chain)\npicking this:\n  a # cs \\<noteq> [] \\<Longrightarrow>\n  last as \\<in> get_return_edges (last (a # cs))", "have \"last as \\<in> get_return_edges (last (a#cs))\""], ["proof (prove)\nusing this:\n  a # cs \\<noteq> [] \\<Longrightarrow>\n  last as \\<in> get_return_edges (last (a # cs))\n\ngoal (1 subgoal):\n 1. last as \\<in> get_return_edges (last (a # cs))", "by simp"], ["proof (state)\nthis:\n  last as \\<in> get_return_edges (last (a # cs))\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with False \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  cs \\<noteq> []\n  last as \\<in> get_return_edges (last (a # cs))", "show ?thesis"], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  cs \\<noteq> []\n  last as \\<in> get_return_edges (last (a # cs))\n\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "case (slpa_Return cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n      upd_cs cs' xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last cs')\n  cs \\<noteq> []\n  upd_cs cs (a # as) = []\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "note IH = \\<open>\\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = []; \n    \\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs' xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last as \\<in> get_return_edges (last cs')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n      upd_cs cs' xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last as \\<in> get_return_edges (last cs')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<lbrakk>cs' \\<noteq> []; upd_cs cs' as = [];\n         \\<forall>xs ys.\n            as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n            upd_cs cs' xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> last as \\<in> get_return_edges (last cs');\n        cs \\<noteq> []; upd_cs cs (a # as) = [];\n        \\<forall>xs ys.\n           a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n           upd_cs cs xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  upd_cs cs (a # as) = []\n  as = []", "have \"cs' = []\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  upd_cs cs (a # as) = []\n  as = []\n\ngoal (1 subgoal):\n 1. cs' = []", "by simp"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> last (a # as) \\<in> get_return_edges (last cs)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>cs = c'#cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close> True"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  as = []\n  cs' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  as = []\n  cs' = []\n\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "by simp"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close> \\<open>upd_cs cs (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  upd_cs cs (a # as) = []", "have \"upd_cs cs' as = []\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. upd_cs cs' as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "proof(cases \"cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case True"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>cs = c'#cs'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []", "have \"upd_cs cs [a] = []\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []\n\ngoal (1 subgoal):\n 1. upd_cs cs [a] = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs [a] = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>\\<forall>xs ys. a#as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\\<close> False"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  as \\<noteq> []\n  upd_cs cs [a] = []", "have False"], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  as \\<noteq> []\n  upd_cs cs [a] = []\n\ngoal (1 subgoal):\n 1. False", "apply(erule_tac x=\"[a]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> []; upd_cs cs [a] = [];\n     \\<forall>ys.\n        a # as = [a] @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n        upd_cs cs [a] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "by simp"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "case False"], ["proof (state)\nthis:\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from \\<open>\\<forall>xs ys. a#as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs xs \\<noteq> []\\<close>\n        \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'", "have \"\\<forall>xs ys. as = xs@ys \\<and> ys \\<noteq> [] \\<longrightarrow> upd_cs cs' xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     a # as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs xs \\<noteq> []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n       upd_cs cs' xs \\<noteq> []", "by(clarsimp,erule_tac x=\"a#xs\" in allE,simp)"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<and> ys \\<noteq> [] \\<longrightarrow>\n     upd_cs cs' xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "from IH[OF False \\<open>upd_cs cs' as = []\\<close> this]"], ["proof (chain)\npicking this:\n  last as \\<in> get_return_edges (last cs')", "have \"last as \\<in> get_return_edges (last cs')\""], ["proof (prove)\nusing this:\n  last as \\<in> get_return_edges (last cs')\n\ngoal (1 subgoal):\n 1. last as \\<in> get_return_edges (last cs')", "."], ["proof (state)\nthis:\n  last as \\<in> get_return_edges (last cs')\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    last (a # as) \\<in> get_return_edges (last cs)", "with \\<open>as \\<noteq> []\\<close> False \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  cs' \\<noteq> []\n  cs = c' # cs'\n  last as \\<in> get_return_edges (last cs')", "show ?thesis"], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  cs' \\<noteq> []\n  cs = c' # cs'\n  last as \\<in> get_return_edges (last cs')\n\ngoal (1 subgoal):\n 1. last (a # as) \\<in> get_return_edges (last cs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (a # as) \\<in> get_return_edges (last cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slpa_callstack_length:\n  assumes \"same_level_path_aux cs as\" and \"length cs = length cfsx\"\n  obtains cfx cfsx' where \"transfers (kinds as) (cfsx@cf#cfs) = cfsx'@cfx#cfs\"\n  and \"transfers (kinds as) (cfsx@cf#cfs') = cfsx'@cfx#cfs'\"\n  and \"length cfsx' = length (upd_cs cs as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cfsx' cfx.\n        \\<lbrakk>transfers (kinds as) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs;\n         transfers (kinds as) (cfsx @ cf # cfs') = cfsx' @ cfx # cfs';\n         length cfsx' = length (upd_cs cs as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds as) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n       transfers (kinds as) (cfsx @ cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs as)", "from assms"], ["proof (chain)\npicking this:\n  same_level_path_aux cs as\n  length cs = length cfsx", "show \"\\<exists>cfsx' cfx. transfers (kinds as) (cfsx@cf#cfs) = cfsx'@cfx#cfs \\<and>\n    transfers (kinds as) (cfsx@cf#cfs') = cfsx'@cfx#cfs' \\<and>\n    length cfsx' = length (upd_cs cs as)\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs as\n  length cs = length cfsx\n\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds as) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n       transfers (kinds as) (cfsx @ cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs as)", "proof(induct arbitrary:cfsx cf rule:slpa_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs cfsx cf.\n       length cs = length cfsx \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds []) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n          transfers (kinds []) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs [])\n 2. \\<And>cs a as cfsx cf.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>cfsx cf.\n           length cs = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 3. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 4. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  length cs = length cfsx\n\ngoal (4 subgoals):\n 1. \\<And>cs cfsx cf.\n       length cs = length cfsx \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds []) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n          transfers (kinds []) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs [])\n 2. \\<And>cs a as cfsx cf.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>cfsx cf.\n           length cs = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 3. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 4. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "thus ?case"], ["proof (prove)\nusing this:\n  length cs = length cfsx\n\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds []) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n       transfers (kinds []) (cfsx @ cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs [])", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds []) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds []) (cfsx @ cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs [])\n\ngoal (3 subgoals):\n 1. \\<And>cs a as cfsx cf.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>cfsx cf.\n           length cs = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 3. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as cfsx cf.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>cfsx cf.\n           length cs = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 3. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  length cs = length ?cfsx \\<Longrightarrow>\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) (?cfsx @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) (?cfsx @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs as)\n  length cs = length cfsx\n\ngoal (3 subgoals):\n 1. \\<And>cs a as cfsx cf.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>cfsx cf.\n           length cs = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 3. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "note IH = \\<open>\\<And>cfsx cf. length cs = length cfsx \\<Longrightarrow>\n      \\<exists>cfsx' cfx. transfers (kinds as) (cfsx@cf#cfs) = cfsx'@cfx#cfs \\<and>\n                  transfers (kinds as) (cfsx@cf#cfs') = cfsx'@cfx#cfs' \\<and>\n                  length cfsx' = length (upd_cs cs as)\\<close>"], ["proof (state)\nthis:\n  length cs = length ?cfsx \\<Longrightarrow>\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) (?cfsx @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) (?cfsx @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs as)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as cfsx cf.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>cfsx cf.\n           length cs = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 3. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"length (upd_cs cs (a#as)) = length (upd_cs cs as)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. length (upd_cs cs (a # as)) = length (upd_cs cs as)", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  length (upd_cs cs (a # as)) = length (upd_cs cs as)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as cfsx cf.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>cfsx cf.\n           length cs = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 3. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))", "proof(cases cfsx)"], ["proof (state)\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "case Nil"], ["proof (state)\nthis:\n  cfsx = []\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  length cs = length cfsx\n  cfsx = []", "have \"length cs = length []\""], ["proof (prove)\nusing this:\n  length cs = length cfsx\n  cfsx = []\n\ngoal (1 subgoal):\n 1. length cs = length []", "by simp"], ["proof (state)\nthis:\n  length cs = length []\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from Nil \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  cfsx = []\n  intra_kind (kind a)", "obtain cfx where transfer:\"transfer (kind a) (cfsx@cf#cfs) = []@cfx#cfs\"\n        \"transfer (kind a) (cfsx@cf#cfs') = []@cfx#cfs'\""], ["proof (prove)\nusing this:\n  cfsx = []\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        \\<lbrakk>transfer (kind a) (cfsx @ cf # cfs) = [] @ cfx # cfs;\n         transfer (kind a) (cfsx @ cf # cfs') = [] @ cfx # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"kind a\",auto simp:kinds_def intra_kind_def)"], ["proof (state)\nthis:\n  transfer (kind a) (cfsx @ cf # cfs) = [] @ cfx # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = [] @ cfx # cfs'\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from IH[OF \\<open>length cs = length []\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ([] @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ([] @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs as)", "obtain cfsx' cfx' \n        where \"transfers (kinds as) ([]@cfx#cfs) = cfsx'@cfx'#cfs\"\n        and \"transfers (kinds as) ([]@cfx#cfs') = cfsx'@cfx'#cfs'\"\n        and \"length cfsx' = length (upd_cs cs as)\""], ["proof (prove)\nusing this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ([] @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ([] @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs as)\n\ngoal (1 subgoal):\n 1. (\\<And>cfsx' cfx'.\n        \\<lbrakk>transfers (kinds as) ([] @ cfx # cfs) = cfsx' @ cfx' # cfs;\n         transfers (kinds as) ([] @ cfx # cfs') = cfsx' @ cfx' # cfs';\n         length cfsx' = length (upd_cs cs as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  transfers (kinds as) ([] @ cfx # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ([] @ cfx # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs cs as)\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>length (upd_cs cs (a#as)) = length (upd_cs cs as)\\<close> transfer"], ["proof (chain)\npicking this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs as)\n  transfer (kind a) (cfsx @ cf # cfs) = [] @ cfx # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = [] @ cfx # cfs'\n  transfers (kinds as) ([] @ cfx # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ([] @ cfx # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs cs as)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs as)\n  transfer (kind a) (cfsx @ cf # cfs) = [] @ cfx # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = [] @ cfx # cfs'\n  transfers (kinds as) ([] @ cfx # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ([] @ cfx # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs cs as)\n\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds (a # as)) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs (a # as))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "case (Cons x xs)"], ["proof (state)\nthis:\n  cfsx = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  cfsx = x # xs", "obtain cfx' \n        where transfer:\"transfer (kind a) (cfsx@cf#cfs) = (cfx'#xs)@cf#cfs\"\n        \"transfer (kind a) (cfsx@cf#cfs') = (cfx'#xs)@cf#cfs'\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  cfsx = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>cfx'.\n        \\<lbrakk>transfer (kind a) (cfsx @ cf # cfs) =\n                 (cfx' # xs) @ cf # cfs;\n         transfer (kind a) (cfsx @ cf # cfs') =\n         (cfx' # xs) @ cf # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"kind a\",auto simp:kinds_def intra_kind_def)"], ["proof (state)\nthis:\n  transfer (kind a) (cfsx @ cf # cfs) = (cfx' # xs) @ cf # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = (cfx' # xs) @ cf # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from \\<open>length cs = length cfsx\\<close> Cons"], ["proof (chain)\npicking this:\n  length cs = length cfsx\n  cfsx = x # xs", "have \"length cs = length (cfx'#xs)\""], ["proof (prove)\nusing this:\n  length cs = length cfsx\n  cfsx = x # xs\n\ngoal (1 subgoal):\n 1. length cs = length (cfx' # xs)", "by simp"], ["proof (state)\nthis:\n  length cs = length (cfx' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ((cfx' # xs) @ ?cf # cfs) =\n     cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ((cfx' # xs) @ ?cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs as)", "obtain cfs'' cf''\n        where \"transfers (kinds as) ((cfx'#xs)@cf#cfs) = cfs''@cf''#cfs\"\n        and \"transfers (kinds as) ((cfx'#xs)@cf#cfs') = cfs''@cf''#cfs'\"\n        and \"length cfs'' = length (upd_cs cs as)\""], ["proof (prove)\nusing this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ((cfx' # xs) @ ?cf # cfs) =\n     cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ((cfx' # xs) @ ?cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs as)\n\ngoal (1 subgoal):\n 1. (\\<And>cfs'' cf''.\n        \\<lbrakk>transfers (kinds as) ((cfx' # xs) @ cf # cfs) =\n                 cfs'' @ cf'' # cfs;\n         transfers (kinds as) ((cfx' # xs) @ cf # cfs') =\n         cfs'' @ cf'' # cfs';\n         length cfs'' = length (upd_cs cs as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  transfers (kinds as) ((cfx' # xs) @ cf # cfs) = cfs'' @ cf'' # cfs\n  transfers (kinds as) ((cfx' # xs) @ cf # cfs') = cfs'' @ cf'' # cfs'\n  length cfs'' = length (upd_cs cs as)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>length (upd_cs cs (a#as)) = length (upd_cs cs as)\\<close> transfer"], ["proof (chain)\npicking this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs as)\n  transfer (kind a) (cfsx @ cf # cfs) = (cfx' # xs) @ cf # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = (cfx' # xs) @ cf # cfs'\n  transfers (kinds as) ((cfx' # xs) @ cf # cfs) = cfs'' @ cf'' # cfs\n  transfers (kinds as) ((cfx' # xs) @ cf # cfs') = cfs'' @ cf'' # cfs'\n  length cfs'' = length (upd_cs cs as)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs as)\n  transfer (kind a) (cfsx @ cf # cfs) = (cfx' # xs) @ cf # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = (cfx' # xs) @ cf # cfs'\n  transfers (kinds as) ((cfx' # xs) @ cf # cfs) = cfs'' @ cf'' # cfs\n  transfers (kinds as) ((cfx' # xs) @ cf # cfs') = cfs'' @ cf'' # cfs'\n  length cfs'' = length (upd_cs cs as)\n\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds (a # as)) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs (a # as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds (a # as)) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs (a # as))\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  length (a # cs) = length ?cfsx \\<Longrightarrow>\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) (?cfsx @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) (?cfsx @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs (a # cs) as)\n  length cs = length cfsx\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "note IH = \\<open>\\<And>cfsx cf. length (a#cs) = length cfsx \\<Longrightarrow>\n      \\<exists>cfsx' cfx. transfers (kinds as) (cfsx@cf#cfs) = cfsx'@cfx#cfs \\<and>\n                  transfers (kinds as) (cfsx@cf#cfs') = cfsx'@cfx#cfs' \\<and>\n                  length cfsx' = length (upd_cs (a#cs) as)\\<close>"], ["proof (state)\nthis:\n  length (a # cs) = length ?cfsx \\<Longrightarrow>\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) (?cfsx @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) (?cfsx @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs (a # cs) as)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain cfx where transfer:\"transfer (kind a) (cfsx@cf#cfs) = (cfx#cfsx)@cf#cfs\"\n      \"transfer (kind a) (cfsx@cf#cfs') = (cfx#cfsx)@cf#cfs'\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        \\<lbrakk>transfer (kind a) (cfsx @ cf # cfs) =\n                 (cfx # cfsx) @ cf # cfs;\n         transfer (kind a) (cfsx @ cf # cfs') =\n         (cfx # cfsx) @ cf # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cfsx) auto"], ["proof (state)\nthis:\n  transfer (kind a) (cfsx @ cf # cfs) = (cfx # cfsx) @ cf # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = (cfx # cfsx) @ cf # cfs'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "from \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  length cs = length cfsx", "have \"length (a#cs) = length (cfx#cfsx)\""], ["proof (prove)\nusing this:\n  length cs = length cfsx\n\ngoal (1 subgoal):\n 1. length (a # cs) = length (cfx # cfsx)", "by simp"], ["proof (state)\nthis:\n  length (a # cs) = length (cfx # cfsx)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>cfsx' cfxa.\n     transfers (kinds as) ((cfx # cfsx) @ ?cf # cfs) =\n     cfsx' @ cfxa # cfs \\<and>\n     transfers (kinds as) ((cfx # cfsx) @ ?cf # cfs') =\n     cfsx' @ cfxa # cfs' \\<and>\n     length cfsx' = length (upd_cs (a # cs) as)", "obtain cfsx' cfx' \n      where \"transfers (kinds as) ((cfx#cfsx)@cf#cfs) = cfsx'@cfx'#cfs\"\n      and \"transfers (kinds as) ((cfx#cfsx)@cf#cfs') = cfsx'@cfx'#cfs'\"\n      and \"length cfsx' = length (upd_cs (a#cs) as)\""], ["proof (prove)\nusing this:\n  \\<exists>cfsx' cfxa.\n     transfers (kinds as) ((cfx # cfsx) @ ?cf # cfs) =\n     cfsx' @ cfxa # cfs \\<and>\n     transfers (kinds as) ((cfx # cfsx) @ ?cf # cfs') =\n     cfsx' @ cfxa # cfs' \\<and>\n     length cfsx' = length (upd_cs (a # cs) as)\n\ngoal (1 subgoal):\n 1. (\\<And>cfsx' cfx'.\n        \\<lbrakk>transfers (kinds as) ((cfx # cfsx) @ cf # cfs) =\n                 cfsx' @ cfx' # cfs;\n         transfers (kinds as) ((cfx # cfsx) @ cf # cfs') =\n         cfsx' @ cfx' # cfs';\n         length cfsx' = length (upd_cs (a # cs) as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  transfers (kinds as) ((cfx # cfsx) @ cf # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ((cfx # cfsx) @ cf # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs (a # cs) as)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs cfsx cf.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>cfsx cf.\n           length (a # cs) = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs (a # cs) as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> transfer"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  transfer (kind a) (cfsx @ cf # cfs) = (cfx # cfsx) @ cf # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = (cfx # cfsx) @ cf # cfs'\n  transfers (kinds as) ((cfx # cfsx) @ cf # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ((cfx # cfsx) @ cf # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs (a # cs) as)", "show ?case"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  transfer (kind a) (cfsx @ cf # cfs) = (cfx # cfsx) @ cf # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = (cfx # cfsx) @ cf # cfs'\n  transfers (kinds as) ((cfx # cfsx) @ cf # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ((cfx # cfsx) @ cf # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs (a # cs) as)\n\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds (a # as)) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs (a # as))\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "case (slpa_Return cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  length cs' = length ?cfsx \\<Longrightarrow>\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) (?cfsx @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) (?cfsx @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs' as)\n  length cs = length cfsx\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "note IH = \\<open>\\<And>cfsx cf. length cs' = length cfsx \\<Longrightarrow>\n       \\<exists>cfsx' cfx. transfers (kinds as) (cfsx@cf#cfs) = cfsx'@cfx#cfs \\<and>\n                   transfers (kinds as) (cfsx@cf#cfs') = cfsx'@cfx#cfs' \\<and>\n                   length cfsx' = length (upd_cs cs' as)\\<close>"], ["proof (state)\nthis:\n  length cs' = length ?cfsx \\<Longrightarrow>\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) (?cfsx @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) (?cfsx @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs' as)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'", "have \"length (upd_cs cs (a#as)) = length (upd_cs cs' as)\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. length (upd_cs cs (a # as)) = length (upd_cs cs' as)", "by simp"], ["proof (state)\nthis:\n  length (upd_cs cs (a # as)) = length (upd_cs cs' as)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' cfsx cf.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>cfsx cf.\n           length cs' = length cfsx \\<Longrightarrow>\n           \\<exists>cfsx' cfx.\n              transfers (kinds as) (cfsx @ cf # cfs) =\n              cfsx' @ cfx # cfs \\<and>\n              transfers (kinds as) (cfsx @ cf # cfs') =\n              cfsx' @ cfx # cfs' \\<and>\n              length cfsx' = length (upd_cs cs' as);\n        length cs = length cfsx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfsx' cfx.\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n                            cfsx' @ cfx # cfs \\<and>\n                            transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n                            cfsx' @ cfx # cfs' \\<and>\n                            length cfsx' = length (upd_cs cs (a # as))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))", "proof(cases cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "case Nil"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>cs = c'#cs'\\<close> \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  length cs = length cfsx\n  cs' = []", "obtain cfx\n         where [simp]:\"cfsx = [cfx]\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  length cs = length cfsx\n  cs' = []\n\ngoal (1 subgoal):\n 1. (\\<And>cfx. cfsx = [cfx] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cfsx) auto"], ["proof (state)\nthis:\n  cfsx = [cfx]\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cfsx = [cfx]", "obtain cf' \n         where transfer:\"transfer (kind a) (cfsx@cf#cfs) = []@cf'#cfs\"\n         \"transfer (kind a) (cfsx@cf#cfs') = []@cf'#cfs'\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cfsx = [cfx]\n\ngoal (1 subgoal):\n 1. (\\<And>cf'.\n        \\<lbrakk>transfer (kind a) (cfsx @ cf # cfs) = [] @ cf' # cfs;\n         transfer (kind a) (cfsx @ cf # cfs') = [] @ cf' # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  transfer (kind a) (cfsx @ cf # cfs) = [] @ cf' # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = [] @ cf' # cfs'\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from Nil"], ["proof (chain)\npicking this:\n  cs' = []", "have \"length cs' = length []\""], ["proof (prove)\nusing this:\n  cs' = []\n\ngoal (1 subgoal):\n 1. length cs' = length []", "by simp"], ["proof (state)\nthis:\n  length cs' = length []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ([] @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ([] @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs' as)", "obtain cfsx' cfx' \n         where \"transfers (kinds as) ([]@cf'#cfs) = cfsx'@cfx'#cfs\"\n         and \"transfers (kinds as) ([]@cf'#cfs') = cfsx'@cfx'#cfs'\"\n         and \"length cfsx' = length (upd_cs cs' as)\""], ["proof (prove)\nusing this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ([] @ ?cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ([] @ ?cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs' as)\n\ngoal (1 subgoal):\n 1. (\\<And>cfsx' cfx'.\n        \\<lbrakk>transfers (kinds as) ([] @ cf' # cfs) = cfsx' @ cfx' # cfs;\n         transfers (kinds as) ([] @ cf' # cfs') = cfsx' @ cfx' # cfs';\n         length cfsx' = length (upd_cs cs' as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  transfers (kinds as) ([] @ cf' # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ([] @ cf' # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs cs' as)\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>length (upd_cs cs (a#as)) = length (upd_cs cs' as)\\<close> transfer"], ["proof (chain)\npicking this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs' as)\n  transfer (kind a) (cfsx @ cf # cfs) = [] @ cf' # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = [] @ cf' # cfs'\n  transfers (kinds as) ([] @ cf' # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ([] @ cf' # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs cs' as)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs' as)\n  transfer (kind a) (cfsx @ cf # cfs) = [] @ cf' # cfs\n  transfer (kind a) (cfsx @ cf # cfs') = [] @ cf' # cfs'\n  transfers (kinds as) ([] @ cf' # cfs) = cfsx' @ cfx' # cfs\n  transfers (kinds as) ([] @ cf' # cfs') = cfsx' @ cfx' # cfs'\n  length cfsx' = length (upd_cs cs' as)\n\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds (a # as)) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs (a # as))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "case (Cons cx csx)"], ["proof (state)\nthis:\n  cs' = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>cs = c'#cs'\\<close> \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  length cs = length cfsx\n  cs' = cx # csx", "obtain x x' xs\n        where [simp]:\"cfsx = x#x'#xs\" and \"length xs = length csx\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  length cs = length cfsx\n  cs' = cx # csx\n\ngoal (1 subgoal):\n 1. (\\<And>x x' xs.\n        \\<lbrakk>cfsx = x # x' # xs; length xs = length csx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cfsx,auto,case_tac list,fastforce+)"], ["proof (state)\nthis:\n  cfsx = x # x' # xs\n  length xs = length csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cfsx = x # x' # xs\n  length xs = length csx", "obtain cf' \n        where transfer:\"transfer (kind a) ((x#x'#xs)@cf#cfs) = (cf'#xs)@cf#cfs\"\n        \"transfer (kind a) ((x#x'#xs)@cf#cfs') = (cf'#xs)@cf#cfs'\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cfsx = x # x' # xs\n  length xs = length csx\n\ngoal (1 subgoal):\n 1. (\\<And>cf'.\n        \\<lbrakk>transfer (kind a) ((x # x' # xs) @ cf # cfs) =\n                 (cf' # xs) @ cf # cfs;\n         transfer (kind a) ((x # x' # xs) @ cf # cfs') =\n         (cf' # xs) @ cf # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  transfer (kind a) ((x # x' # xs) @ cf # cfs) = (cf' # xs) @ cf # cfs\n  transfer (kind a) ((x # x' # xs) @ cf # cfs') = (cf' # xs) @ cf # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from \\<open>cs = c'#cs'\\<close> \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  length cs = length cfsx", "have \"length cs' = length (cf'#xs)\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  length cs = length cfsx\n\ngoal (1 subgoal):\n 1. length cs' = length (cf' # xs)", "by simp"], ["proof (state)\nthis:\n  length cs' = length (cf' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ((cf' # xs) @ ?cf # cfs) =\n     cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ((cf' # xs) @ ?cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs' as)", "obtain cfsx' cfx \n        where \"transfers (kinds as) ((cf'#xs)@cf#cfs) = cfsx'@cfx#cfs\"\n        and \"transfers (kinds as) ((cf'#xs)@cf#cfs') = cfsx'@cfx#cfs'\"\n        and \"length cfsx' = length (upd_cs cs' as)\""], ["proof (prove)\nusing this:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) ((cf' # xs) @ ?cf # cfs) =\n     cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) ((cf' # xs) @ ?cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs' as)\n\ngoal (1 subgoal):\n 1. (\\<And>cfsx' cfx.\n        \\<lbrakk>transfers (kinds as) ((cf' # xs) @ cf # cfs) =\n                 cfsx' @ cfx # cfs;\n         transfers (kinds as) ((cf' # xs) @ cf # cfs') = cfsx' @ cfx # cfs';\n         length cfsx' = length (upd_cs cs' as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  transfers (kinds as) ((cf' # xs) @ cf # cfs) = cfsx' @ cfx # cfs\n  transfers (kinds as) ((cf' # xs) @ cf # cfs') = cfsx' @ cfx # cfs'\n  length cfsx' = length (upd_cs cs' as)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow>\n       \\<exists>cfsx' cfx.\n          transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n          cfsx' @ cfx # cfs \\<and>\n          transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n          cfsx' @ cfx # cfs' \\<and>\n          length cfsx' = length (upd_cs cs (a # as))", "with \\<open>length (upd_cs cs (a#as)) = length (upd_cs cs' as)\\<close> transfer"], ["proof (chain)\npicking this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs' as)\n  transfer (kind a) ((x # x' # xs) @ cf # cfs) = (cf' # xs) @ cf # cfs\n  transfer (kind a) ((x # x' # xs) @ cf # cfs') = (cf' # xs) @ cf # cfs'\n  transfers (kinds as) ((cf' # xs) @ cf # cfs) = cfsx' @ cfx # cfs\n  transfers (kinds as) ((cf' # xs) @ cf # cfs') = cfsx' @ cfx # cfs'\n  length cfsx' = length (upd_cs cs' as)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (upd_cs cs (a # as)) = length (upd_cs cs' as)\n  transfer (kind a) ((x # x' # xs) @ cf # cfs) = (cf' # xs) @ cf # cfs\n  transfer (kind a) ((x # x' # xs) @ cf # cfs') = (cf' # xs) @ cf # cfs'\n  transfers (kinds as) ((cf' # xs) @ cf # cfs) = cfsx' @ cfx # cfs\n  transfers (kinds as) ((cf' # xs) @ cf # cfs') = cfsx' @ cfx # cfs'\n  length cfsx' = length (upd_cs cs' as)\n\ngoal (1 subgoal):\n 1. \\<exists>cfsx' cfx.\n       transfers (kinds (a # as)) (cfsx @ cf # cfs) =\n       cfsx' @ cfx # cfs \\<and>\n       transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n       cfsx' @ cfx # cfs' \\<and>\n       length cfsx' = length (upd_cs cs (a # as))", "by(fastforce simp:kinds_def)"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds (a # as)) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs (a # as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds (a # as)) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds (a # as)) (cfsx @ cf # cfs') =\n     cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs (a # as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfsx' cfx.\n     transfers (kinds as) (cfsx @ cf # cfs) = cfsx' @ cfx # cfs \\<and>\n     transfers (kinds as) (cfsx @ cf # cfs') = cfsx' @ cfx # cfs' \\<and>\n     length cfsx' = length (upd_cs cs as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slpa_snoc_intra:\n  \"\\<lbrakk>same_level_path_aux cs as; intra_kind (kind a)\\<rbrakk> \n  \\<Longrightarrow> same_level_path_aux cs (as@[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as; intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs (as @ [a])", "by(induct rule:slpa_induct,auto simp:intra_kind_def)"], ["", "lemma slpa_snoc_Call:\n  \"\\<lbrakk>same_level_path_aux cs as; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs (as@[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs (as @ [a])", "by(induct rule:slpa_induct,auto simp:intra_kind_def)"], ["", "lemma vpa_Main_slpa:\n  \"\\<lbrakk>valid_path_aux cs as; m -as\\<rightarrow>* m'; as \\<noteq> []; \n    valid_call_list cs m; get_proc m' = Main;\n    get_proc (case cs of [] \\<Rightarrow> m | _ \\<Rightarrow> sourcenode (last cs)) = Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_aux cs as; m -as\\<rightarrow>* m'; as \\<noteq> [];\n     valid_call_list cs m; get_proc m' = Main;\n     get_proc\n      (case cs of [] \\<Rightarrow> m\n       | a # list \\<Rightarrow> sourcenode (last cs)) =\n     Main\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = []", "proof(induct arbitrary:m rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; [] \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs [] \\<and> upd_cs cs [] = []\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "case (vpa_empty cs)"], ["proof (state)\nthis:\n  m -[]\\<rightarrow>* m'\n  [] \\<noteq> []\n  valid_call_list cs m\n  get_proc m' = Main\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; [] \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs [] \\<and> upd_cs cs [] = []\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "thus ?case"], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>* m'\n  [] \\<noteq> []\n  valid_call_list cs m\n  get_proc m' = Main\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs [] \\<and> upd_cs cs [] = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs [] \\<and> upd_cs cs [] = []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "case (vpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list cs ?m;\n   get_proc m' = Main;\n   get_proc\n    (case cs of [] \\<Rightarrow> ?m\n     | a # list \\<Rightarrow> sourcenode (last cs)) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = []\n  m -a # as\\<rightarrow>* m'\n  a # as \\<noteq> []\n  valid_call_list cs m\n  get_proc m' = Main\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list cs m; get_proc m' = Main;\n    get_proc (case cs of [] \\<Rightarrow> m | a # list \\<Rightarrow> sourcenode (last cs)) = Main\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list cs ?m;\n   get_proc m' = Main;\n   get_proc\n    (case cs of [] \\<Rightarrow> ?m\n     | a # list \\<Rightarrow> sourcenode (last cs)) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs as \\<and> upd_cs cs as = []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"sourcenode a = m\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. sourcenode a = m &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = m\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs m; get_proc m' = Main;\n            get_proc\n             (case cs of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs)) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs as \\<and>\n                             upd_cs cs as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>targetnode a -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* m'\n  as = []", "have \"targetnode a = m'\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* m'\n  as = []\n\ngoal (1 subgoal):\n 1. targetnode a = m'", "by fastforce"], ["proof (state)\nthis:\n  targetnode a = m'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close> \n      \\<open>sourcenode a = m\\<close> \\<open>get_proc m' = Main\\<close>"], ["proof (chain)\npicking this:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n  sourcenode a = m\n  get_proc m' = Main\n  targetnode a = m'", "have \"get_proc m = Main\""], ["proof (prove)\nusing this:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n  sourcenode a = m\n  get_proc m' = Main\n  targetnode a = m'\n\ngoal (1 subgoal):\n 1. get_proc m = Main", "by simp"], ["proof (state)\nthis:\n  get_proc m = Main\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "have \"cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs = []", "proof(cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> cs = []\n 2. \\<And>a list. cs = a # list \\<Longrightarrow> cs = []", "case Cons"], ["proof (state)\nthis:\n  cs = a_ # list_\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> cs = []\n 2. \\<And>a list. cs = a # list \\<Longrightarrow> cs = []", "with \\<open>valid_call_list cs m\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = a_ # list_", "obtain c Q r p fs where \"valid_edge c\" and \"kind c = Q:r\\<hookrightarrow>\\<^bsub>get_proc m\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = a_ # list_\n\ngoal (1 subgoal):\n 1. (\\<And>c Q r fs.\n        \\<lbrakk>valid_edge c;\n         kind c = Q:r\\<hookrightarrow>\\<^bsub>get_proc m\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:valid_call_list_def,erule_tac x=\"[]\" in allE,\n           auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_edge c\n  kind c = Q:r\\<hookrightarrow>\\<^bsub>get_proc m\\<^esub>fs\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> cs = []\n 2. \\<And>a list. cs = a # list \\<Longrightarrow> cs = []", "with \\<open>get_proc m = Main\\<close>"], ["proof (chain)\npicking this:\n  get_proc m = Main\n  valid_edge c\n  kind c = Q:r\\<hookrightarrow>\\<^bsub>get_proc m\\<^esub>fs", "have \"kind c = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\""], ["proof (prove)\nusing this:\n  get_proc m = Main\n  valid_edge c\n  kind c = Q:r\\<hookrightarrow>\\<^bsub>get_proc m\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind c = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind c = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> cs = []\n 2. \\<And>a list. cs = a # list \\<Longrightarrow> cs = []", "with \\<open>valid_edge c\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c\n  kind c = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "have False"], ["proof (prove)\nusing this:\n  valid_edge c\n  kind c = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow> cs = []\n 2. \\<And>a list. cs = a # list \\<Longrightarrow> cs = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. cs = []", "by simp"], ["proof (state)\nthis:\n  cs = []\n\ngoal (1 subgoal):\n 1. cs = [] \\<Longrightarrow> cs = []", "qed simp"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with True \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  as = []\n  intra_kind (kind a)\n  cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n  intra_kind (kind a)\n  cs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from \\<open>valid_call_list cs m\\<close> \\<open>sourcenode a = m\\<close>\n      \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  sourcenode a = m\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_call_list cs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  sourcenode a = m\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode a) = get_proc (targetnode a); m = sourcenode a;\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        m = sourcenode a; cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case cs' of [] \\<Rightarrow> sourcenode a\n       | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        m = sourcenode a; cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q r fs.\n            kind c =\n            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (case cs' of [] \\<Rightarrow> targetnode a\n                    | a # list \\<Rightarrow>\n                        last (sourcenodes cs'))\\<^esub>fs", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_call_list cs (targetnode a)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from \\<open>get_proc (case cs of [] \\<Rightarrow> m | _ \\<Rightarrow> sourcenode (last cs)) = Main\\<close>\n      \\<open>sourcenode a = m\\<close> \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  sourcenode a = m\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"get_proc (case cs of [] \\<Rightarrow> targetnode a | _ \\<Rightarrow> sourcenode (last cs)) = Main\""], ["proof (prove)\nusing this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  sourcenode a = m\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. get_proc\n     (case cs of [] \\<Rightarrow> targetnode a\n      | aa # list \\<Rightarrow> sourcenode (last cs)) =\n    Main", "by(cases cs) auto"], ["proof (state)\nthis:\n  get_proc\n   (case cs of [] \\<Rightarrow> targetnode a\n    | aa # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> False \\<open>valid_call_list cs (targetnode a)\\<close>\n      \\<open>get_proc m' = Main\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux cs as \\<and> upd_cs cs as = []", "have \"same_level_path_aux cs as \\<and> upd_cs cs as = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs as \\<and> upd_cs cs as = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs as \\<and> upd_cs cs as = []", "."], ["proof (state)\nthis:\n  same_level_path_aux cs as \\<and> upd_cs cs as = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  same_level_path_aux cs as \\<and> upd_cs cs as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  same_level_path_aux cs as \\<and> upd_cs cs as = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "case (vpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> [];\n   valid_call_list (a # cs) ?m; get_proc m' = Main;\n   get_proc\n    (case a # cs of [] \\<Rightarrow> ?m\n     | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                    upd_cs (a # cs) as = []\n  m -a # as\\<rightarrow>* m'\n  a # as \\<noteq> []\n  valid_call_list cs m\n  get_proc m' = Main\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list (a # cs) m; \n    get_proc m' = Main; \n    get_proc (case a # cs of [] \\<Rightarrow> m | _ \\<Rightarrow> sourcenode (last (a # cs))) = Main\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> [];\n   valid_call_list (a # cs) ?m; get_proc m' = Main;\n   get_proc\n    (case a # cs of [] \\<Rightarrow> ?m\n     | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                    upd_cs (a # cs) as = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"sourcenode a = m\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. sourcenode a = m &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = m\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list (a # cs) m; get_proc m' = Main;\n            get_proc\n             (case a # cs of [] \\<Rightarrow> m\n              | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux (a # cs) as \\<and>\n                             upd_cs (a # cs) as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>targetnode a -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* m'\n  as = []", "have \"targetnode a = m'\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* m'\n  as = []\n\ngoal (1 subgoal):\n 1. targetnode a = m'", "by fastforce"], ["proof (state)\nthis:\n  targetnode a = m'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>get_proc (targetnode a) = p\\<close> \\<open>get_proc m' = Main\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  get_proc (targetnode a) = p\n  get_proc m' = Main\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m'", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\""], ["proof (prove)\nusing this:\n  get_proc (targetnode a) = p\n  get_proc m' = Main\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m'\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from \\<open>get_proc (targetnode a) = p\\<close> \\<open>valid_call_list cs m\\<close> \\<open>valid_edge a\\<close>\n      \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  get_proc (targetnode a) = p\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m", "have \"valid_call_list (a # cs) (targetnode a)\""], ["proof (prove)\nusing this:\n  get_proc (targetnode a) = p\n  valid_call_list cs m\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n\ngoal (1 subgoal):\n 1. valid_call_list (a # cs) (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); m = sourcenode a;\n        a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); m = sourcenode a;\n        a # cs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q r fs.\n                       kind c =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); m = sourcenode a;\n        a # cs = cs' @ c # cs''; cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs' of [] \\<Rightarrow> sourcenode a\n               | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs);\n        valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); m = sourcenode a;\n        cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>fs;\n        p = get_proc (targetnode a); m = sourcenode a; cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case list of [] \\<Rightarrow> sourcenode a\n       | a # lista \\<Rightarrow>\n           last (sourcenodes list))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r fs.\n                            kind c =\n                            Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                   (last (sourcenodes (a # list)))\\<^esub>fs", "by(case_tac list)(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list (a # cs) (targetnode a)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from \\<open>get_proc (case cs of [] \\<Rightarrow> m | _ \\<Rightarrow> sourcenode (last cs)) = Main\\<close>\n      \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  sourcenode a = m", "have \"get_proc (case a # cs of [] \\<Rightarrow> targetnode a \n      | _ \\<Rightarrow> sourcenode (last (a # cs))) = Main\""], ["proof (prove)\nusing this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  sourcenode a = m\n\ngoal (1 subgoal):\n 1. get_proc\n     (case a # cs of [] \\<Rightarrow> targetnode a\n      | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n    Main", "by(cases cs) auto"], ["proof (state)\nthis:\n  get_proc\n   (case a # cs of [] \\<Rightarrow> targetnode a\n    | aa # list \\<Rightarrow> sourcenode (last (a # cs))) =\n  Main\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> False \\<open>valid_call_list (a#cs) (targetnode a)\\<close>\n      \\<open>get_proc m' = Main\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []", "have \"same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []", "."], ["proof (state)\nthis:\n  same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as \\<and> upd_cs (a # cs) as = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "case (vpa_ReturnEmpty cs a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list [] ?m;\n   get_proc m' = Main;\n   get_proc\n    (case [] of [] \\<Rightarrow> ?m\n     | a # list \\<Rightarrow> sourcenode (last [])) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and> upd_cs [] as = []\n  m -a # as\\<rightarrow>* m'\n  a # as \\<noteq> []\n  valid_call_list cs m\n  get_proc m' = Main\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list [] m; get_proc m' = Main;\n    get_proc (case [] of [] \\<Rightarrow> m | a # list \\<Rightarrow> sourcenode (last [])) = Main\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux [] as \\<and> upd_cs [] as = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list [] ?m;\n   get_proc m' = Main;\n   get_proc\n    (case [] of [] \\<Rightarrow> ?m\n     | a # list \\<Rightarrow> sourcenode (last [])) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and> upd_cs [] as = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"sourcenode a = m\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. sourcenode a = m &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = m\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>get_proc (case cs of [] \\<Rightarrow> m | a # list \\<Rightarrow> sourcenode (last cs)) = Main\\<close>\n    \\<open>cs = []\\<close>"], ["proof (chain)\npicking this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  cs = []", "have \"get_proc m = Main\""], ["proof (prove)\nusing this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  cs = []\n\ngoal (1 subgoal):\n 1. get_proc m = Main", "by simp"], ["proof (state)\nthis:\n  get_proc m = Main\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "with \\<open>sourcenode a = m\\<close> \\<open>get_proc (sourcenode a) = p\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = m\n  get_proc (sourcenode a) = p\n  get_proc m = Main", "have \"p = Main\""], ["proof (prove)\nusing this:\n  sourcenode a = m\n  get_proc (sourcenode a) = p\n  get_proc m = Main\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list [] m; get_proc m' = Main;\n            get_proc\n             (case [] of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last [])) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             upd_cs [] as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "case (vpa_ReturnCons cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list cs' ?m;\n   get_proc m' = Main;\n   get_proc\n    (case cs' of [] \\<Rightarrow> ?m\n     | a # list \\<Rightarrow> sourcenode (last cs')) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs' as \\<and> upd_cs cs' as = []\n  m -a # as\\<rightarrow>* m'\n  a # as \\<noteq> []\n  valid_call_list cs m\n  get_proc m' = Main\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list cs' m; get_proc m' = Main;\n    get_proc (case cs' of [] \\<Rightarrow> m | a # list \\<Rightarrow> sourcenode (last cs')) = Main\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux cs' as \\<and> upd_cs cs' as = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; as \\<noteq> []; valid_call_list cs' ?m;\n   get_proc m' = Main;\n   get_proc\n    (case cs' of [] \\<Rightarrow> ?m\n     | a # list \\<Rightarrow> sourcenode (last cs')) =\n   Main\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux cs' as \\<and> upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"sourcenode a = m\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. sourcenode a = m &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = m\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c'", "by(auto simp:valid_call_list_def,erule_tac x=\"[]\" in allE,auto)"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"get_proc (sourcenode c') = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode a)", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; as \\<noteq> [];\n            valid_call_list cs' m; get_proc m' = Main;\n            get_proc\n             (case cs' of [] \\<Rightarrow> m\n              | a # list \\<Rightarrow> sourcenode (last cs')) =\n            Main\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux cs' as \\<and>\n                             upd_cs cs' as = [];\n        m -a # as\\<rightarrow>* m'; a # as \\<noteq> [];\n        valid_call_list cs m; get_proc m' = Main;\n        get_proc\n         (case cs of [] \\<Rightarrow> m\n          | a # list \\<Rightarrow> sourcenode (last cs)) =\n        Main\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux cs (a # as) \\<and>\n                         upd_cs cs (a # as) = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>targetnode a -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* m'\n  as = []", "have \"targetnode a = m'\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* m'\n  as = []\n\ngoal (1 subgoal):\n 1. targetnode a = m'", "by fastforce"], ["proof (state)\nthis:\n  targetnode a = m'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>get_proc m' = Main\\<close>"], ["proof (chain)\npicking this:\n  get_proc m' = Main\n  targetnode a = m'", "have \"get_proc (targetnode a) = Main\""], ["proof (prove)\nusing this:\n  get_proc m' = Main\n  targetnode a = m'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (targetnode a) = Main\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>\n      \\<open>get_proc (targetnode a) = Main\\<close>"], ["proof (chain)\npicking this:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n  get_proc (targetnode a) = Main", "have \"get_proc (sourcenode c') = Main\""], ["proof (prove)\nusing this:\n  get_proc (sourcenode c') = get_proc (targetnode a)\n  get_proc (targetnode a) = Main\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = Main\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "have \"cs' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs' = []", "proof(cases cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> cs' = []\n 2. \\<And>a list. cs' = a # list \\<Longrightarrow> cs' = []", "case (Cons cx csx)"], ["proof (state)\nthis:\n  cs' = cx # csx\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> cs' = []\n 2. \\<And>a list. cs' = a # list \\<Longrightarrow> cs' = []", "with \\<open>cs = c' # cs'\\<close> \\<open>valid_call_list cs m\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  valid_call_list cs m\n  cs' = cx # csx", "obtain Qx rx fsx where \"valid_edge cx\" \n        and \"kind cx = Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (sourcenode c')\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  valid_call_list cs m\n  cs' = cx # csx\n\ngoal (1 subgoal):\n 1. (\\<And>Qx rx fsx.\n        \\<lbrakk>valid_edge cx;\n         kind cx =\n         Qx:rx\\<hookrightarrow>\\<^bsub>get_proc\n  (sourcenode c')\\<^esub>fsx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:valid_call_list_def,erule_tac x=\"[c']\" in allE,\n           auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_edge cx\n  kind cx =\n  Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (sourcenode c')\\<^esub>fsx\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> cs' = []\n 2. \\<And>a list. cs' = a # list \\<Longrightarrow> cs' = []", "with \\<open>get_proc (sourcenode c') = Main\\<close>"], ["proof (chain)\npicking this:\n  get_proc (sourcenode c') = Main\n  valid_edge cx\n  kind cx =\n  Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (sourcenode c')\\<^esub>fsx", "have \"kind cx = Qx:rx\\<hookrightarrow>\\<^bsub>Main\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  get_proc (sourcenode c') = Main\n  valid_edge cx\n  kind cx =\n  Qx:rx\\<hookrightarrow>\\<^bsub>get_proc (sourcenode c')\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. kind cx = Qx:rx\\<hookrightarrow>\\<^bsub>Main\\<^esub>fsx", "by simp"], ["proof (state)\nthis:\n  kind cx = Qx:rx\\<hookrightarrow>\\<^bsub>Main\\<^esub>fsx\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> cs' = []\n 2. \\<And>a list. cs' = a # list \\<Longrightarrow> cs' = []", "with \\<open>valid_edge cx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge cx\n  kind cx = Qx:rx\\<hookrightarrow>\\<^bsub>Main\\<^esub>fsx", "have False"], ["proof (prove)\nusing this:\n  valid_edge cx\n  kind cx = Qx:rx\\<hookrightarrow>\\<^bsub>Main\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> cs' = []\n 2. \\<And>a list. cs' = a # list \\<Longrightarrow> cs' = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. cs' = []", "by simp"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (1 subgoal):\n 1. cs' = [] \\<Longrightarrow> cs' = []", "qed simp"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n 2. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with True \\<open>cs = c' # cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  as = []\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs' = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from \\<open>valid_call_list cs m\\<close> \\<open>cs = c' # cs'\\<close>\n      \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"valid_call_list cs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_call_list cs m\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (targetnode a)", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs = c' # cs'a @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode a);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'a of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow> last (sourcenodes cs'a))\\<^esub>fs);\n        get_proc (sourcenode c') = get_proc (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c' # cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode c') = get_proc (targetnode a);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q r fs.\n               kind ca =\n               Q:r\\<hookrightarrow>\\<^bsub>get_proc\n      (case c' # cs' of [] \\<Rightarrow> m\n       | a # list \\<Rightarrow>\n           last (sourcenodes (c' # cs')))\\<^esub>fs)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs' of [] \\<Rightarrow> targetnode a\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'))\\<^esub>fs)", "by(case_tac cs')(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (targetnode a)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from \\<open>get_proc (case cs of [] \\<Rightarrow> m | a # list \\<Rightarrow> sourcenode (last cs)) = Main\\<close>\n      \\<open>cs = c' # cs'\\<close> \\<open>get_proc (sourcenode c') = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)", "have \"get_proc (case cs' of [] \\<Rightarrow> targetnode a \n      | _ \\<Rightarrow> sourcenode (last cs')) = Main\""], ["proof (prove)\nusing this:\n  get_proc\n   (case cs of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow> sourcenode (last cs)) =\n  Main\n  cs = c' # cs'\n  get_proc (sourcenode c') = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. get_proc\n     (case cs' of [] \\<Rightarrow> targetnode a\n      | aa # list \\<Rightarrow> sourcenode (last cs')) =\n    Main", "by(cases cs') auto"], ["proof (state)\nthis:\n  get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | aa # list \\<Rightarrow> sourcenode (last cs')) =\n  Main\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> False \\<open>valid_call_list cs' (targetnode a)\\<close>\n      \\<open>get_proc m' = Main\\<close> this]"], ["proof (chain)\npicking this:\n  same_level_path_aux cs' as \\<and> upd_cs cs' as = []", "have \"same_level_path_aux cs' as \\<and> upd_cs cs' as = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs' as \\<and> upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs' as \\<and> upd_cs cs' as = []", "."], ["proof (state)\nthis:\n  same_level_path_aux cs' as \\<and> upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c' # cs'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  same_level_path_aux cs' as \\<and> upd_cs cs' as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n  same_level_path_aux cs' as \\<and> upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux cs (a # as) \\<and> upd_cs cs (a # as) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "definition same_level_path :: \"'edge list \\<Rightarrow> bool\"\n  where \"same_level_path as \\<equiv> same_level_path_aux [] as \\<and> upd_cs [] as = []\""], ["", "lemma same_level_path_valid_path:\n  \"same_level_path as \\<Longrightarrow> valid_path as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path as \\<Longrightarrow> valid_path as", "by(fastforce intro:same_level_path_aux_valid_path_aux\n             simp:same_level_path_def valid_path_def)"], ["", "lemma same_level_path_Append:\n  \"\\<lbrakk>same_level_path as; same_level_path as'\\<rbrakk> \\<Longrightarrow> same_level_path (as@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path as; same_level_path as'\\<rbrakk>\n    \\<Longrightarrow> same_level_path (as @ as')", "by(fastforce elim:same_level_path_aux_Append upd_cs_Append simp:same_level_path_def)"], ["", "lemma same_level_path_number_Calls_eq_number_Returns:\n  \"\\<lbrakk>same_level_path as; \\<forall>a \\<in> set as. valid_edge a\\<rbrakk> \\<Longrightarrow> \n  length [a\\<leftarrow>as. \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs] = length [a\\<leftarrow>as. \\<exists>Q p f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path as;\n     \\<forall>a\\<in>set as. valid_edge a\\<rbrakk>\n    \\<Longrightarrow> length\n                       (filter\n                         (\\<lambda>a.\n                             \\<exists>Q r p fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n                         as) =\n                      length\n                       (filter\n                         (\\<lambda>a.\n                             \\<exists>Q p f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n                         as)", "by(fastforce dest:slpa_number_Calls_eq_number_Returns simp:same_level_path_def)"], ["", "lemma same_level_path_valid_path_Append:\n  \"\\<lbrakk>same_level_path as; valid_path as'\\<rbrakk> \\<Longrightarrow> valid_path (as@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path as; valid_path as'\\<rbrakk>\n    \\<Longrightarrow> valid_path (as @ as')", "by(fastforce intro:valid_path_aux_Append elim:same_level_path_aux_valid_path_aux\n               simp:valid_path_def same_level_path_def)"], ["", "lemma valid_path_same_level_path_Append:\n  \"\\<lbrakk>valid_path as; same_level_path as'\\<rbrakk> \\<Longrightarrow> valid_path (as@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path as; same_level_path as'\\<rbrakk>\n    \\<Longrightarrow> valid_path (as @ as')", "apply(auto simp:valid_path_def same_level_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_aux [] as; same_level_path_aux [] as';\n     upd_cs [] as' = []\\<rbrakk>\n    \\<Longrightarrow> valid_path_aux [] (as @ as')", "apply(erule valid_path_aux_Append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux [] as'; upd_cs [] as' = []\\<rbrakk>\n    \\<Longrightarrow> valid_path_aux (upd_cs [] as) as'", "by(fastforce intro!:same_level_path_aux_valid_path_aux \n                dest:same_level_path_aux_callstack_Append)"], ["", "lemma intras_same_level_path:\n  assumes \"\\<forall>a \\<in> set as. intra_kind(kind a)\" shows \"same_level_path as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. same_level_path as", "from \\<open>\\<forall>a \\<in> set as. intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"same_level_path_aux [] as\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as", "by(induct as)(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n\ngoal (1 subgoal):\n 1. same_level_path as", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n\ngoal (1 subgoal):\n 1. same_level_path as", "from \\<open>\\<forall>a \\<in> set as. intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"upd_cs [] as = []\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs [] as = []", "by(induct as)(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. same_level_path as", "ultimately"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  upd_cs [] as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. same_level_path as", "by(simp add:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path as\n\ngoal:\nNo subgoals!", "qed"], ["", "definition same_level_path' :: \"'node \\<Rightarrow> 'edge list \\<Rightarrow> 'node \\<Rightarrow> bool\" \n  (\"_ -_\\<rightarrow>\\<^bsub>sl\\<^esub>* _\" [51,0,0] 80)\nwhere slp_def:\"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<equiv> n -as\\<rightarrow>* n' \\<and> same_level_path as\""], ["", "lemma slp_vp: \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow> n -as\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    n -as\\<rightarrow>\\<^sub>\\<surd>* n'", "by(fastforce intro:same_level_path_valid_path simp:slp_def vp_def)"], ["", "lemma intra_path_slp: \"n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<Longrightarrow> n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<Longrightarrow>\n    n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "by(fastforce intro:intras_same_level_path simp:slp_def intra_path_def)"], ["", "lemma slp_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n''; n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'';\n     n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<rbrakk>\n    \\<Longrightarrow> n -as @ as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "by(fastforce simp:slp_def intro:path_Append same_level_path_Append)"], ["", "lemma slp_vp_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n''; n'' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'';\n     n'' -as'\\<rightarrow>\\<^sub>\\<surd>* n'\\<rbrakk>\n    \\<Longrightarrow> n -as @ as'\\<rightarrow>\\<^sub>\\<surd>* n'", "by(fastforce simp:slp_def vp_def intro:path_Append same_level_path_valid_path_Append)"], ["", "lemma vp_slp_Append:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<surd>* n''; n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<rbrakk> \\<Longrightarrow> n -as@as'\\<rightarrow>\\<^sub>\\<surd>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<surd>* n'';\n     n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<rbrakk>\n    \\<Longrightarrow> n -as @ as'\\<rightarrow>\\<^sub>\\<surd>* n'", "by(fastforce simp:slp_def vp_def intro:path_Append valid_path_same_level_path_Append)"], ["", "lemma slp_get_proc:\n  \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow> get_proc n = get_proc n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n' \\<Longrightarrow>\n    get_proc n = get_proc n'", "by(fastforce dest:slpa_get_proc simp:same_level_path_def slp_def)"], ["", "lemma same_level_path_inner_path:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\"\n  obtains as' where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<iota>* n';\n         set (sourcenodes as') \\<subseteq> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "have \"n -as\\<rightarrow>* n'\" and \"same_level_path as\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* n' &&& same_level_path as", "by(simp_all add:slp_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  same_level_path as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>same_level_path as\\<close>"], ["proof (chain)\npicking this:\n  same_level_path as", "have \"same_level_path_aux [] as\" and \"upd_cs [] as = []\""], ["proof (prove)\nusing this:\n  same_level_path as\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as &&& upd_cs [] as = []", "by(simp_all add:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>n -as\\<rightarrow>* n'\\<close> \\<open>same_level_path_aux [] as\\<close> \\<open>upd_cs [] as = []\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  same_level_path_aux [] as\n  upd_cs [] as = []", "show \"\\<exists>as'. n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> set(sourcenodes as') \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "proof(induct as arbitrary:n rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>* n' \\<longrightarrow>\n                       same_level_path_aux [] ys \\<longrightarrow>\n                       upd_cs [] ys = [] \\<longrightarrow>\n                       (\\<exists>as'.\n                           x -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys)));\n        n -xs\\<rightarrow>* n'; same_level_path_aux [] xs;\n        upd_cs [] xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs)", "fix as n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>* n' \\<longrightarrow>\n                       same_level_path_aux [] ys \\<longrightarrow>\n                       upd_cs [] ys = [] \\<longrightarrow>\n                       (\\<exists>as'.\n                           x -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys)));\n        n -xs\\<rightarrow>* n'; same_level_path_aux [] xs;\n        upd_cs [] xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs)", "assume IH:\"\\<forall>as''. length as'' < length as \\<longrightarrow>\n      (\\<forall>n''. n'' -as''\\<rightarrow>* n' \\<longrightarrow> same_level_path_aux [] as'' \\<longrightarrow>\n           upd_cs [] as'' = [] \\<longrightarrow>\n           (\\<exists>as'. n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> set (sourcenodes as') \\<subseteq> set (sourcenodes as'')))\"\n      and \"n -as\\<rightarrow>* n'\" and \"same_level_path_aux [] as\" and \"upd_cs [] as = []\""], ["proof (state)\nthis:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<exists>as'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'')))\n  n -as\\<rightarrow>* n'\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       x -ys\\<rightarrow>* n' \\<longrightarrow>\n                       same_level_path_aux [] ys \\<longrightarrow>\n                       upd_cs [] ys = [] \\<longrightarrow>\n                       (\\<exists>as'.\n                           x -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys)));\n        n -xs\\<rightarrow>* n'; same_level_path_aux [] xs;\n        upd_cs [] xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs)", "show \"\\<exists>as'. n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> set (sourcenodes as') \\<subseteq> set (sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "proof(cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "case (Cons a' as')"], ["proof (state)\nthis:\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with \\<open>n -as\\<rightarrow>* n'\\<close> Cons"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  as = a' # as'\n  as = a' # as'", "have \"n = sourcenode a'\" and \"valid_edge a'\" \n        and \"targetnode a' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  as = a' # as'\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. n = sourcenode a' &&&\n    valid_edge a' &&& targetnode a' -as'\\<rightarrow>* n'", "by(auto intro:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode a'\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with Cons \\<open>same_level_path_aux [] as\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  same_level_path_aux [] as\n  intra_kind (kind a')", "have \"same_level_path_aux [] as'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  same_level_path_aux [] as\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as'", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] as'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "moreover"], ["proof (state)\nthis:\n  same_level_path_aux [] as'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from Intra Cons \\<open>upd_cs [] as = []\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')\n  as = a' # as'\n  upd_cs [] as = []", "have \"upd_cs [] as' = []\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n  as = a' # as'\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. upd_cs [] as' = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs [] as' = []\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "ultimately"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = []", "obtain as'' where \"targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\"\n          and \"set (sourcenodes as'') \\<subseteq> set (sourcenodes as')\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = []\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n         set (sourcenodes as'') \\<subseteq> set (sourcenodes as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using IH Cons \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close>"], ["proof (prove)\nusing this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = []\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<exists>as'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'')))\n  as = a' # as'\n  targetnode a' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n         set (sourcenodes as'') \\<subseteq> set (sourcenodes as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule_tac x=\"as'\" in allE) auto"], ["proof (state)\nthis:\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  set (sourcenodes as'') \\<subseteq> set (sourcenodes as')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>n = sourcenode a'\\<close> \\<open>valid_edge a'\\<close> Intra \\<open>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n = sourcenode a'\n  valid_edge a'\n  intra_kind (kind a')\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -a'#as''\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  n = sourcenode a'\n  valid_edge a'\n  intra_kind (kind a')\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with \\<open>set (sourcenodes as'') \\<subseteq> set (sourcenodes as')\\<close> Cons"], ["proof (chain)\npicking this:\n  set (sourcenodes as'') \\<subseteq> set (sourcenodes as')\n  as = a' # as'\n  n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  set (sourcenodes as'') \\<subseteq> set (sourcenodes as')\n  as = a' # as'\n  n -a' # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "by(rule_tac x=\"a'#as''\" in exI,auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "case (Call Q p f)"], ["proof (state)\nthis:\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with Cons \\<open>same_level_path_aux [] as\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_", "have \"same_level_path_aux [a'] as'\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. same_level_path_aux [a'] as'", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [a'] as'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from Call Cons \\<open>upd_cs [] as = []\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n  as = a' # as'\n  upd_cs [] as = []", "have \"upd_cs [a'] as' = []\""], ["proof (prove)\nusing this:\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n  as = a' # as'\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. upd_cs [a'] as' = []", "by simp"], ["proof (state)\nthis:\n  upd_cs [a'] as' = []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "hence \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  upd_cs [a'] as' = []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with \\<open>upd_cs [a'] as' = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [a'] as' = []\n  as' \\<noteq> []", "obtain xs ys where \"as' = xs@ys\" and \"xs \\<noteq> []\"\n        and \"upd_cs [a'] xs = []\" and \"upd_cs [] ys = []\"\n        and \"\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs [a'] xs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  upd_cs [a'] as' = []\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as' = xs @ ys; xs \\<noteq> []; upd_cs [a'] xs = [];\n         upd_cs [] ys = [];\n         \\<forall>xs' ys'.\n            xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n            upd_cs [a'] xs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule upd_cs_empty_split,auto)"], ["proof (state)\nthis:\n  as' = xs @ ys\n  xs \\<noteq> []\n  upd_cs [a'] xs = []\n  upd_cs [] ys = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs [a'] xs' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>same_level_path_aux [a'] as'\\<close> \\<open>as' = xs@ys\\<close> \\<open>upd_cs [a'] xs = []\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [a'] as'\n  as' = xs @ ys\n  upd_cs [a'] xs = []", "have \"same_level_path_aux [a'] xs\" and \"same_level_path_aux [] ys\""], ["proof (prove)\nusing this:\n  same_level_path_aux [a'] as'\n  as' = xs @ ys\n  upd_cs [a'] xs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [a'] xs &&& same_level_path_aux [] ys", "by(auto intro:slpa_split)"], ["proof (state)\nthis:\n  same_level_path_aux [a'] xs\n  same_level_path_aux [] ys\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>same_level_path_aux [a'] xs\\<close> \\<open>upd_cs [a'] xs = []\\<close>\n          \\<open>\\<forall>xs' ys'. xs = xs'@ys' \\<and> ys' \\<noteq> [] \\<longrightarrow> upd_cs [a'] xs' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [a'] xs\n  upd_cs [a'] xs = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs [a'] xs' \\<noteq> []", "have \"last xs \\<in> get_return_edges (last [a'])\""], ["proof (prove)\nusing this:\n  same_level_path_aux [a'] xs\n  upd_cs [a'] xs = []\n  \\<forall>xs' ys'.\n     xs = xs' @ ys' \\<and> ys' \\<noteq> [] \\<longrightarrow>\n     upd_cs [a'] xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last xs \\<in> get_return_edges (last [a'])", "by(fastforce intro!:slpa_get_return_edges)"], ["proof (state)\nthis:\n  last xs \\<in> get_return_edges (last [a'])\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with \\<open>valid_edge a'\\<close> Call"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n  last xs \\<in> get_return_edges (last [a'])", "obtain a where \"valid_edge a\" and \"sourcenode a = sourcenode a'\"\n          and \"targetnode a = targetnode (last xs)\" and \"kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:p\\<hookrightarrow>\\<^bsub>f\\<^esub>fs_\n  last xs \\<in> get_return_edges (last [a'])\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = sourcenode a';\n         targetnode a = targetnode (last xs);\n         kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode (last xs)\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>targetnode a = targetnode (last xs)\\<close> \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = targetnode (last xs)\n  xs \\<noteq> []", "have \"targetnode a = targetnode (last (a'#xs))\""], ["proof (prove)\nusing this:\n  targetnode a = targetnode (last xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. targetnode a = targetnode (last (a' # xs))", "by simp"], ["proof (state)\nthis:\n  targetnode a = targetnode (last (a' # xs))\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>as' = xs@ys\\<close> \\<open>xs \\<noteq> []\\<close> Cons"], ["proof (chain)\npicking this:\n  as' = xs @ ys\n  xs \\<noteq> []\n  as = a' # as'", "have \"length ys < length as\""], ["proof (prove)\nusing this:\n  as' = xs @ ys\n  xs \\<noteq> []\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. length ys < length as", "by simp"], ["proof (state)\nthis:\n  length ys < length as\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>targetnode a' -as'\\<rightarrow>* n'\\<close> \\<open>as' = xs@ys\\<close> \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -as'\\<rightarrow>* n'\n  as' = xs @ ys\n  xs \\<noteq> []", "have \"targetnode (last (a'#xs)) -ys\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  targetnode a' -as'\\<rightarrow>* n'\n  as' = xs @ ys\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. targetnode (last (a' # xs)) -ys\\<rightarrow>* n'", "by(cases xs rule:rev_cases,auto dest:path_split)"], ["proof (state)\nthis:\n  targetnode (last (a' # xs)) -ys\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with IH \\<open>length ys < length as\\<close> \\<open>same_level_path_aux [] ys\\<close>\n          \\<open>upd_cs [] ys = []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<exists>as'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'')))\n  length ys < length as\n  same_level_path_aux [] ys\n  upd_cs [] ys = []\n  targetnode (last (a' # xs)) -ys\\<rightarrow>* n'", "obtain as'' where \"targetnode (last (a'#xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\"\n          and \"set(sourcenodes as'') \\<subseteq> set(sourcenodes ys)\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -as''\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] as'' \\<longrightarrow>\n         upd_cs [] as'' = [] \\<longrightarrow>\n         (\\<exists>as'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'')))\n  length ys < length as\n  same_level_path_aux [] ys\n  upd_cs [] ys = []\n  targetnode (last (a' # xs)) -ys\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>targetnode\n                  (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n         set (sourcenodes as'') \\<subseteq> set (sourcenodes ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"ys\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (last\n                            (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 set (sourcenodes as'')\n                 \\<subseteq> set (sourcenodes ys)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     targetnode (last (a' # xs)) -ys\\<rightarrow>* n';\n     length ys < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n'' -ys\\<rightarrow>* n' \\<longrightarrow>\n         same_level_path_aux [] ys \\<longrightarrow>\n         upd_cs [] ys = [] \\<longrightarrow>\n         (\\<exists>as'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n             set (sourcenodes as')\n             \\<subseteq> set (sourcenodes ys)))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (if xs = [] then a'\n                           else last\n                                 xs) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 set (sourcenodes as'')\n                 \\<subseteq> set (sourcenodes ys)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     targetnode (if xs = [] then a' else last xs) -ys\\<rightarrow>* n';\n     \\<forall>n''.\n        n'' -ys\\<rightarrow>* n' \\<longrightarrow>\n        (\\<exists>as'.\n            n'' -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n            set (sourcenodes as') \\<subseteq> set (sourcenodes ys))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"targetnode (last (a'#xs))\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as''.\n                \\<lbrakk>targetnode\n                          (if xs = [] then a'\n                           else last\n                                 xs) -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n                 set (sourcenodes as'')\n                 \\<subseteq> set (sourcenodes ys)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length ys < length as; same_level_path_aux [] ys; upd_cs [] ys = [];\n     targetnode (if xs = [] then a' else last xs) -ys\\<rightarrow>* n';\n     targetnode (last (a' # xs)) -ys\\<rightarrow>* n' \\<longrightarrow>\n     (\\<exists>as'.\n         targetnode\n          (last (a' # xs)) -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n         set (sourcenodes as') \\<subseteq> set (sourcenodes ys))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by clarsimp"], ["proof (state)\nthis:\n  targetnode (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  set (sourcenodes as'') \\<subseteq> set (sourcenodes ys)\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>sourcenode a = sourcenode a'\\<close> \\<open>n = sourcenode a'\\<close>\n          \\<open>targetnode a = targetnode (last (a'#xs))\\<close> \\<open>valid_edge a\\<close>\n          \\<open>kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close> \\<open>targetnode (last (a'#xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  n = sourcenode a'\n  targetnode a = targetnode (last (a' # xs))\n  valid_edge a\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  targetnode (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -a#as''\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  n = sourcenode a'\n  targetnode a = targetnode (last (a' # xs))\n  valid_edge a\n  kind a = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  targetnode (last (a' # xs)) -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'", "by(fastforce intro:Cons_path simp:intra_path_def intra_kind_def)"], ["proof (state)\nthis:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "moreover"], ["proof (state)\nthis:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "from \\<open>set(sourcenodes as'') \\<subseteq> set(sourcenodes ys)\\<close> Cons \\<open>as' = xs@ys\\<close>\n          \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes as'') \\<subseteq> set (sourcenodes ys)\n  as = a' # as'\n  as' = xs @ ys\n  sourcenode a = sourcenode a'", "have \"set(sourcenodes (a#as'')) \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes as'') \\<subseteq> set (sourcenodes ys)\n  as = a' # as'\n  as' = xs @ ys\n  sourcenode a = sourcenode a'\n\ngoal (1 subgoal):\n 1. set (sourcenodes (a # as'')) \\<subseteq> set (sourcenodes as)", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes (a # as'')) \\<subseteq> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "ultimately"], ["proof (chain)\npicking this:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  set (sourcenodes (a # as'')) \\<subseteq> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -a # as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  set (sourcenodes (a # as'')) \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "with Cons \\<open>same_level_path_aux [] as\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  as = a' # as'\n  same_level_path_aux [] as\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n          set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as)", "by simp"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slp_callstack_length_equal:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" obtains cf' where \"transfers (kinds as) (cf#cfs) = cf'#cfs\"\n  and \"transfers (kinds as) (cf#cfs') = cf'#cfs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cf'.\n        \\<lbrakk>transfers (kinds as) (cf # cfs) = cf' # cfs;\n         transfers (kinds as) (cf # cfs') = cf' # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cf'.\n       transfers (kinds as) (cf # cfs) = cf' # cfs \\<and>\n       transfers (kinds as) (cf # cfs') = cf' # cfs'", "from \\<open>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "have \"same_level_path_aux [] as\" and \"upd_cs [] as = []\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as &&& upd_cs [] as = []", "by(simp_all add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. \\<exists>cf'.\n       transfers (kinds as) (cf # cfs) = cf' # cfs \\<and>\n       transfers (kinds as) (cf # cfs') = cf' # cfs'", "then"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  upd_cs [] as = []", "obtain cfx cfsx where \"transfers (kinds as) (cf#cfs) = cfsx@cfx#cfs\"\n    and \"transfers (kinds as) (cf#cfs') = cfsx@cfx#cfs'\"\n    and \"length cfsx = length (upd_cs [] as)\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. (\\<And>cfsx cfx.\n        \\<lbrakk>transfers (kinds as) (cf # cfs) = cfsx @ cfx # cfs;\n         transfers (kinds as) (cf # cfs') = cfsx @ cfx # cfs';\n         length cfsx = length (upd_cs [] as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:slpa_callstack_length)"], ["proof (state)\nthis:\n  transfers (kinds as) (cf # cfs) = cfsx @ cfx # cfs\n  transfers (kinds as) (cf # cfs') = cfsx @ cfx # cfs'\n  length cfsx = length (upd_cs [] as)\n\ngoal (1 subgoal):\n 1. \\<exists>cf'.\n       transfers (kinds as) (cf # cfs) = cf' # cfs \\<and>\n       transfers (kinds as) (cf # cfs') = cf' # cfs'", "with \\<open>upd_cs [] as = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [] as = []\n  transfers (kinds as) (cf # cfs) = cfsx @ cfx # cfs\n  transfers (kinds as) (cf # cfs') = cfsx @ cfx # cfs'\n  length cfsx = length (upd_cs [] as)", "have \"cfsx = []\""], ["proof (prove)\nusing this:\n  upd_cs [] as = []\n  transfers (kinds as) (cf # cfs) = cfsx @ cfx # cfs\n  transfers (kinds as) (cf # cfs') = cfsx @ cfx # cfs'\n  length cfsx = length (upd_cs [] as)\n\ngoal (1 subgoal):\n 1. cfsx = []", "by(cases cfsx) auto"], ["proof (state)\nthis:\n  cfsx = []\n\ngoal (1 subgoal):\n 1. \\<exists>cf'.\n       transfers (kinds as) (cf # cfs) = cf' # cfs \\<and>\n       transfers (kinds as) (cf # cfs') = cf' # cfs'", "with \\<open>transfers (kinds as) (cf#cfs) = cfsx@cfx#cfs\\<close>\n    \\<open>transfers (kinds as) (cf#cfs') = cfsx@cfx#cfs'\\<close>"], ["proof (chain)\npicking this:\n  transfers (kinds as) (cf # cfs) = cfsx @ cfx # cfs\n  transfers (kinds as) (cf # cfs') = cfsx @ cfx # cfs'\n  cfsx = []", "show \"\\<exists>cf'. transfers (kinds as) (cf#cfs) = cf'#cfs \\<and> \n    transfers (kinds as) (cf#cfs') = cf'#cfs'\""], ["proof (prove)\nusing this:\n  transfers (kinds as) (cf # cfs) = cfsx @ cfx # cfs\n  transfers (kinds as) (cf # cfs') = cfsx @ cfx # cfs'\n  cfsx = []\n\ngoal (1 subgoal):\n 1. \\<exists>cf'.\n       transfers (kinds as) (cf # cfs) = cf' # cfs \\<and>\n       transfers (kinds as) (cf # cfs') = cf' # cfs'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>cf'.\n     transfers (kinds as) (cf # cfs) = cf' # cfs \\<and>\n     transfers (kinds as) (cf # cfs') = cf' # cfs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slp_cases [consumes 1,case_names intra_path return_intra_path]:\n  assumes \"m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\"\n  obtains \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\"\n  | as' a as'' Q p f where \"as = as'@a#as''\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  and \"m -as'@[a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\" and \"targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<Longrightarrow> thesis;\n     \\<And>as' a as'' Q p f.\n        \\<lbrakk>as = as' @ a # as'';\n         kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a;\n         targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "from \\<open>m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'", "have \"m -as\\<rightarrow>* m'\" and \"same_level_path_aux [] as\"\n    and \"upd_cs [] as = []\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^bsub>sl\\<^esub>* m'\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* m' &&&\n    same_level_path_aux [] as &&& upd_cs [] as = []", "by(simp_all add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* m'\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "from \\<open>m -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>* m'", "have \"\\<forall>a \\<in> set as. valid_edge a\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. valid_edge a", "by(rule path_valid_edges)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. valid_edge a\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "have \"\\<forall>a \\<in> set []. valid_edge a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set []. valid_edge a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. valid_edge a\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "with \\<open>same_level_path_aux [] as\\<close> \\<open>upd_cs [] as = []\\<close> \\<open>\\<forall>a \\<in> set []. valid_edge a\\<close>\n    \\<open>\\<forall>a \\<in> set as. valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n  \\<forall>a\\<in>set []. valid_edge a\n  \\<forall>a\\<in>set as. valid_edge a\n  \\<forall>a\\<in>set []. valid_edge a", "show \"m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f. as = as' @ a # as'' \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n    m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and> targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n  \\<forall>a\\<in>set []. valid_edge a\n  \\<forall>a\\<in>set as. valid_edge a\n  \\<forall>a\\<in>set []. valid_edge a\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "proof(cases rule:slpa_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a;\n     \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                      (\\<exists>as' a as'' Q p f.\n                          as = as' @ a # as'' \\<and>\n                          kind a =\n                          Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                          m -as' @\n                             [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                            a \\<and>\n                          targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')\n 2. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "case intra_path"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a;\n     \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                      (\\<exists>as' a as'' Q p f.\n                          as = as' @ a # as'' \\<and>\n                          kind a =\n                          Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                          m -as' @\n                             [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                            a \\<and>\n                          targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')\n 2. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "with \\<open>m -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>* m'\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>* m'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m'", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a;\n     \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                      (\\<exists>as' a as'' Q p f.\n                          as = as' @ a # as'' \\<and>\n                          kind a =\n                          Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                          m -as' @\n                             [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                            a \\<and>\n                          targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')\n 2. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "thus ?thesis"], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "by blast"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n  (\\<exists>as' a as'' Q p f.\n      as = as' @ a # as'' \\<and>\n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n      targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "case (return_intra_path as' a as'' Q p f c' cs')"], ["proof (state)\nthis:\n  as = as' @ a # as''\n  same_level_path_aux [] as'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs [] as' = c' # cs'\n  upd_cs [] (as' @ [a]) = []\n  a \\<in> get_return_edges c'\n  valid_edge c'\n  \\<forall>a\\<in>set as''. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "from \\<open>m -as\\<rightarrow>* m'\\<close> \\<open>as = as' @ a # as''\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>* m'\n  as = as' @ a # as''", "have \"m -as'\\<rightarrow>* sourcenode a\" and \"valid_edge a\" and \"targetnode a -as''\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>* m'\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. m -as'\\<rightarrow>* sourcenode a &&&\n    valid_edge a &&& targetnode a -as''\\<rightarrow>* m'", "by(auto intro:path_split)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>* sourcenode a\n  valid_edge a\n  targetnode a -as''\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "from \\<open>m -as'\\<rightarrow>* sourcenode a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* sourcenode a\n  valid_edge a", "have \"m -as'@[a]\\<rightarrow>* targetnode a\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* sourcenode a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. m -as' @ [a]\\<rightarrow>* targetnode a", "by(fastforce intro:path_Append path_edge)"], ["proof (state)\nthis:\n  m -as' @ [a]\\<rightarrow>* targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "with \\<open>same_level_path_aux [] as'\\<close> \\<open>upd_cs [] as' = c' # cs'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n      \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges c'\n  m -as' @ [a]\\<rightarrow>* targetnode a", "have \"same_level_path_aux [] (as'@[a])\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as'\n  upd_cs [] as' = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges c'\n  m -as' @ [a]\\<rightarrow>* targetnode a\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as' @ [a])", "by(fastforce intro:same_level_path_aux_Append)"], ["proof (state)\nthis:\n  same_level_path_aux [] (as' @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "with \\<open>upd_cs [] (as' @ [a]) = []\\<close> \\<open>m -as'@[a]\\<rightarrow>* targetnode a\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [] (as' @ [a]) = []\n  m -as' @ [a]\\<rightarrow>* targetnode a\n  same_level_path_aux [] (as' @ [a])", "have \"m -as'@[a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\""], ["proof (prove)\nusing this:\n  upd_cs [] (as' @ [a]) = []\n  m -as' @ [a]\\<rightarrow>* targetnode a\n  same_level_path_aux [] (as' @ [a])\n\ngoal (1 subgoal):\n 1. m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a", "by(simp add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "moreover"], ["proof (state)\nthis:\n  m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "from \\<open>\\<forall>a\\<in>set as''. intra_kind (kind a)\\<close> \\<open>targetnode a -as''\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as''. intra_kind (kind a)\n  targetnode a -as''\\<rightarrow>* m'", "have \"targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as''. intra_kind (kind a)\n  targetnode a -as''\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. \\<And>asx a asx' Q p f c' cs'.\n       \\<lbrakk>\\<forall>a\\<in>set []. valid_edge a; as = asx @ a # asx';\n        same_level_path_aux [] asx;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        upd_cs [] asx = c' # cs'; upd_cs [] (asx @ [a]) = [];\n        a \\<in> get_return_edges c'; valid_edge c';\n        \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n                         (\\<exists>as' a as'' Q p f.\n                             as = as' @ a # as'' \\<and>\n                             kind a =\n                             Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n                             m -as' @\n                                [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode\n                               a \\<and>\n                             targetnode\n                              a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "ultimately"], ["proof (chain)\npicking this:\n  m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'", "show ?thesis"], ["proof (prove)\nusing this:\n  m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "using \\<open>as = as' @ a # as''\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (prove)\nusing this:\n  m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m'\n  as = as' @ a # as''\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n    (\\<exists>as' a as'' Q p f.\n        as = as' @ a # as'' \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n        m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n        targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')", "by blast"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n  (\\<exists>as' a as'' Q p f.\n      as = as' @ a # as'' \\<and>\n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n      targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<or>\n  (\\<exists>as' a as'' Q p f.\n      as = as' @ a # as'' \\<and>\n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n      m -as' @ [a]\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a \\<and>\n      targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m')\n\ngoal:\nNo subgoals!", "qed"], ["", "function same_level_path_rev_aux :: \"'edge list \\<Rightarrow> 'edge list \\<Rightarrow> bool\"\n  where \"same_level_path_rev_aux cs [] \\<longleftrightarrow> True\"\n  | \"same_level_path_rev_aux cs (as@[a]) \\<longleftrightarrow> \n       (case (kind a) of Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow> same_level_path_rev_aux (a#cs) as\n                       | Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow> case cs of [] \\<Rightarrow> False\n                                     | c'#cs' \\<Rightarrow> c' \\<in> get_return_edges a \\<and>\n                                             same_level_path_rev_aux cs' as\n                       |    _ \\<Rightarrow> same_level_path_rev_aux cs as)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>cs. x = (cs, []) \\<Longrightarrow> P;\n        \\<And>cs as a. x = (cs, as @ [a]) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>cs csa. (cs, []) = (csa, []) \\<Longrightarrow> True = True\n 3. \\<And>cs csa as a.\n       (cs, []) = (csa, as @ [a]) \\<Longrightarrow>\n       True =\n       (case kind a of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case csa of [] \\<Rightarrow> False\n          | c' # cs' \\<Rightarrow>\n              c' \\<in> get_return_edges a \\<and>\n              same_level_path_rev_aux_sumC (cs', as)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            same_level_path_rev_aux_sumC (a # csa, as)\n        | _ \\<Rightarrow> same_level_path_rev_aux_sumC (csa, as))\n 4. \\<And>cs as a csa asa aa.\n       (cs, as @ [a]) = (csa, asa @ [aa]) \\<Longrightarrow>\n       (case kind a of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case cs of [] \\<Rightarrow> False\n          | c' # cs' \\<Rightarrow>\n              c' \\<in> get_return_edges a \\<and>\n              same_level_path_rev_aux_sumC (cs', as)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            same_level_path_rev_aux_sumC (a # cs, as)\n        | _ \\<Rightarrow> same_level_path_rev_aux_sumC (cs, as)) =\n       (case kind aa of\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n          case csa of [] \\<Rightarrow> False\n          | c' # cs' \\<Rightarrow>\n              c' \\<in> get_return_edges aa \\<and>\n              same_level_path_rev_aux_sumC (cs', asa)\n        | Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Rightarrow>\n            same_level_path_rev_aux_sumC (aa # csa, asa)\n        | _ \\<Rightarrow> same_level_path_rev_aux_sumC (csa, asa))", "by auto(case_tac b rule:rev_cases,auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All same_level_path_rev_aux_dom", "by lexicographic_order"], ["", "lemma slpra_induct [consumes 1,case_names slpra_empty slpra_intra slpra_Return\n  slpra_Call]:\n  assumes major: \"same_level_path_rev_aux xs ys\"\n  and rules: \"\\<And>cs. P cs []\"\n    \"\\<And>cs a as. \\<lbrakk>intra_kind(kind a); same_level_path_rev_aux cs as; P cs as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q p f. \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; same_level_path_rev_aux (a#cs) as; P (a#cs) as\\<rbrakk> \n      \\<Longrightarrow> P cs (as@[a])\"\n    \"\\<And>cs a as Q r p fs c' cs'. \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = c'#cs'; \n                   same_level_path_rev_aux cs' as; c' \\<in> get_return_edges a; P cs' as\\<rbrakk>\n     \\<Longrightarrow> P cs (as@[a])\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "using major"], ["proof (prove)\nusing this:\n  same_level_path_rev_aux xs ys\n\ngoal (1 subgoal):\n 1. P xs ys", "apply(induct ys arbitrary: xs rule:rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. same_level_path_rev_aux xs [] \\<Longrightarrow> P xs []\n 2. \\<And>x xs xsa.\n       \\<lbrakk>\\<And>xsa.\n                   same_level_path_rev_aux xsa xs \\<Longrightarrow>\n                   P xsa xs;\n        same_level_path_rev_aux xsa (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> P xsa (xs @ [x])", "by(auto intro:rules split:edge_kind.split_asm list.split_asm simp:intra_kind_def)"], ["", "lemma same_level_path_rev_aux_Append:\n  \"\\<lbrakk>same_level_path_rev_aux cs as'; same_level_path_rev_aux (upd_rev_cs cs as') as\\<rbrakk>\n  \\<Longrightarrow> same_level_path_rev_aux cs (as@as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_rev_aux cs as';\n     same_level_path_rev_aux (upd_rev_cs cs as') as\\<rbrakk>\n    \\<Longrightarrow> same_level_path_rev_aux cs (as @ as')", "by(induct rule:slpra_induct,\n   auto simp:intra_kind_def simp del:append_assoc simp:append_assoc[THEN sym])"], ["", "lemma slpra_to_slpa:\n  \"\\<lbrakk>same_level_path_rev_aux cs as; upd_rev_cs cs as = []; n -as\\<rightarrow>* n'; \n  valid_return_list cs n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and> same_level_path_aux (upd_cs [] as) cs \\<and>\n     upd_cs (upd_cs [] as) cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_rev_aux cs as; upd_rev_cs cs as = [];\n     n -as\\<rightarrow>* n'; valid_return_list cs n'\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                      same_level_path_aux (upd_cs [] as) cs \\<and>\n                      upd_cs (upd_cs [] as) cs = []", "proof(induct arbitrary:n' rule:slpra_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs n'.\n       \\<lbrakk>upd_rev_cs cs [] = []; n -[]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] [] \\<and>\n                         same_level_path_aux (upd_cs [] []) cs \\<and>\n                         upd_cs (upd_cs [] []) cs = []\n 2. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "case slpra_empty"], ["proof (state)\nthis:\n  upd_rev_cs cs_ [] = []\n  n -[]\\<rightarrow>* n'\n  valid_return_list cs_ n'\n\ngoal (4 subgoals):\n 1. \\<And>cs n'.\n       \\<lbrakk>upd_rev_cs cs [] = []; n -[]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] [] \\<and>\n                         same_level_path_aux (upd_cs [] []) cs \\<and>\n                         upd_cs (upd_cs [] []) cs = []\n 2. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "thus ?case"], ["proof (prove)\nusing this:\n  upd_rev_cs cs_ [] = []\n  n -[]\\<rightarrow>* n'\n  valid_return_list cs_ n'\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] [] \\<and>\n    same_level_path_aux (upd_cs [] []) cs_ \\<and>\n    upd_cs (upd_cs [] []) cs_ = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] [] \\<and>\n  same_level_path_aux (upd_cs [] []) cs_ \\<and>\n  upd_cs (upd_cs [] []) cs_ = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "case (slpra_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_rev_aux cs as\n  \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* ?n';\n   valid_return_list cs ?n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                    same_level_path_aux (upd_cs [] as) cs \\<and>\n                    upd_cs (upd_cs [] as) cs = []\n  upd_rev_cs cs (as @ [a]) = []\n  n -as @ [a]\\<rightarrow>* n'\n  valid_return_list cs n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "note IH = \\<open>\\<And>n'. \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n'; valid_return_list cs n'\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux [] as \\<and> same_level_path_aux (upd_cs [] as) cs \\<and>\n       upd_cs (upd_cs [] as) cs = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* ?n';\n   valid_return_list cs ?n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                    same_level_path_aux (upd_cs [] as) cs \\<and>\n                    upd_cs (upd_cs [] as) cs = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>n -as@[a]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ [a]\\<rightarrow>* n'", "have \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\"\n    and \"n' = targetnode a\""], ["proof (prove)\nusing this:\n  n -as @ [a]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&& valid_edge a &&& n' = targetnode a", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  n' = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>valid_return_list cs n'\\<close> \\<open>n' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  n' = targetnode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list cs (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  n' = targetnode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list cs (sourcenode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> targetnode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        n' = targetnode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>n' = targetnode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>n' = targetnode a;\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        cs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> targetnode a\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list cs (sourcenode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>upd_rev_cs cs (as@[a]) = []\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as @ [a]) = []\n  intra_kind (kind a)", "have \"upd_rev_cs cs as = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as @ [a]) = []\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_rev_cs cs as = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_rev_cs cs as = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from IH[OF \\<open>upd_rev_cs cs as = []\\<close> \\<open>n -as\\<rightarrow>* sourcenode a\\<close>\n    \\<open>valid_return_list cs (sourcenode a)\\<close>]"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as \\<and>\n  same_level_path_aux (upd_cs [] as) cs \\<and> upd_cs (upd_cs [] as) cs = []", "have \"same_level_path_aux [] as\" \n    and \"same_level_path_aux (upd_cs [] as) cs\"\n    and \"upd_cs (upd_cs [] as) cs = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as \\<and>\n  same_level_path_aux (upd_cs [] as) cs \\<and> upd_cs (upd_cs [] as) cs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as &&&\n    same_level_path_aux (upd_cs [] as) cs &&& upd_cs (upd_cs [] as) cs = []", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n  same_level_path_aux (upd_cs [] as) cs\n  upd_cs (upd_cs [] as) cs = []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>same_level_path_aux [] as\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  intra_kind (kind a)", "have \"same_level_path_aux [] (as@[a])\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a])", "by(rule slpa_snoc_intra)"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a])\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"upd_cs [] (as@[a]) = upd_cs [] as\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs [] (as @ [a]) = upd_cs [] as", "by(fastforce simp:upd_cs_Append intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs [] (as @ [a]) = upd_cs [] as\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "moreover"], ["proof (state)\nthis:\n  upd_cs [] (as @ [a]) = upd_cs [] as\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>same_level_path_aux [] as\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  intra_kind (kind a)", "have \"same_level_path_aux [] (as@[a])\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a])", "by(rule slpa_snoc_intra)"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a])\n\ngoal (3 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs \\<and>\n                             upd_cs (upd_cs [] as) cs = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "ultimately"], ["proof (chain)\npicking this:\n  upd_cs [] (as @ [a]) = upd_cs [] as\n  same_level_path_aux [] (as @ [a])", "show ?case"], ["proof (prove)\nusing this:\n  upd_cs [] (as @ [a]) = upd_cs [] as\n  same_level_path_aux [] (as @ [a])\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []", "using \\<open>same_level_path_aux (upd_cs [] as) cs\\<close>\n    \\<open>upd_cs (upd_cs [] as) cs = []\\<close>"], ["proof (prove)\nusing this:\n  upd_cs [] (as @ [a]) = upd_cs [] as\n  same_level_path_aux [] (as @ [a])\n  same_level_path_aux (upd_cs [] as) cs\n  upd_cs (upd_cs [] as) cs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a]) \\<and>\n  same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "case (slpra_Return cs a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  same_level_path_rev_aux (a # cs) as\n  \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* ?n';\n   valid_return_list (a # cs) ?n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                    same_level_path_aux (upd_cs [] as) (a # cs) \\<and>\n                    upd_cs (upd_cs [] as) (a # cs) = []\n  upd_rev_cs cs (as @ [a]) = []\n  n -as @ [a]\\<rightarrow>* n'\n  valid_return_list cs n'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "note IH = \\<open>\\<And>n' n''. \\<lbrakk>upd_rev_cs (a#cs) as = []; n -as\\<rightarrow>* n';\n    valid_return_list (a#cs) n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and>\n     same_level_path_aux (upd_cs [] as) (a#cs) \\<and>\n     upd_cs (upd_cs [] as) (a#cs) = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* ?n';\n   valid_return_list (a # cs) ?n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                    same_level_path_aux (upd_cs [] as) (a # cs) \\<and>\n                    upd_cs (upd_cs [] as) (a # cs) = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>n -as@[a]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ [a]\\<rightarrow>* n'", "have \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\"\n    and \"n' = targetnode a\""], ["proof (prove)\nusing this:\n  n -as @ [a]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&& valid_edge a &&& n' = targetnode a", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  n' = targetnode a\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"p = get_proc (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. p = get_proc (sourcenode a)", "by(rule get_proc_return[THEN sym])"], ["proof (state)\nthis:\n  p = get_proc (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>valid_return_list cs n'\\<close> \\<open>n' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  n' = targetnode a", "have \"valid_return_list cs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  n' = targetnode a\n\ngoal (1 subgoal):\n 1. valid_return_list cs (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_return_list cs (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>p = get_proc (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = get_proc (sourcenode a)\n  valid_return_list cs (targetnode a)", "have \"valid_return_list (a#cs) (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = get_proc (sourcenode a)\n  valid_return_list cs (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list (a # cs) (sourcenode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        p = get_proc (sourcenode a);\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q f.\n               kind c =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        p = get_proc (sourcenode a);\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q f.\n               kind c =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        a # cs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        p = get_proc (sourcenode a);\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q f.\n               kind c =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        a # cs = cs' @ c # cs''; cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        p = get_proc (sourcenode a);\n        \\<forall>cs' ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        p = get_proc (sourcenode a); cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> targetnode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a # list)))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list Qa fa.\n       \\<lbrakk>valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        p = get_proc (sourcenode a); cs = list @ c # cs''; valid_edge c;\n        kind c =\n        Qa\\<hookleftarrow>\\<^bsub>get_proc\n                                   (case list of\n                                    [] \\<Rightarrow> targetnode a\n                                    | a # lista \\<Rightarrow>\n  last (targetnodes list))\\<^esub>fa\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case list of [] \\<Rightarrow> targetnode a\n                           | a # lista \\<Rightarrow>\n                               last (targetnodes list)) =\n                         get_proc (last (targetnodes (a # list)))", "by(case_tac list,auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a # cs) (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>upd_rev_cs cs (as@[a]) = []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs cs (as @ [a]) = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"upd_rev_cs (a#cs) as = []\""], ["proof (prove)\nusing this:\n  upd_rev_cs cs (as @ [a]) = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. upd_rev_cs (a # cs) as = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs (a # cs) as = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from IH[OF this \\<open>n -as\\<rightarrow>* sourcenode a\\<close> \\<open>valid_return_list (a#cs) (sourcenode a)\\<close>]"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as \\<and>\n  same_level_path_aux (upd_cs [] as) (a # cs) \\<and>\n  upd_cs (upd_cs [] as) (a # cs) = []", "have \"same_level_path_aux [] as\"\n     and \"same_level_path_aux (upd_cs [] as) (a#cs)\"\n     and \"upd_cs (upd_cs [] as) (a#cs) = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as \\<and>\n  same_level_path_aux (upd_cs [] as) (a # cs) \\<and>\n  upd_cs (upd_cs [] as) (a # cs) = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as &&&\n    same_level_path_aux (upd_cs [] as) (a # cs) &&&\n    upd_cs (upd_cs [] as) (a # cs) = []", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n  same_level_path_aux (upd_cs [] as) (a # cs)\n  upd_cs (upd_cs [] as) (a # cs) = []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        same_level_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs (a # cs) as = []; n -as\\<rightarrow>* n';\n            valid_return_list (a # cs) n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as)\n                              (a # cs) \\<and>\n                             upd_cs (upd_cs [] as) (a # cs) = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []", "proof(cases \"upd_cs [] as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. upd_cs [] as = [] \\<Longrightarrow>\n    same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "case Nil"], ["proof (state)\nthis:\n  upd_cs [] as = []\n\ngoal (2 subgoals):\n 1. upd_cs [] as = [] \\<Longrightarrow>\n    same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>same_level_path_aux (upd_cs [] as) (a#cs)\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  same_level_path_aux (upd_cs [] as) (a # cs)\n  upd_cs [] as = []", "have False"], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  same_level_path_aux (upd_cs [] as) (a # cs)\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. upd_cs [] as = [] \\<Longrightarrow>\n    same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []\n 2. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a]) \\<and>\n  same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "case (Cons cx csx)"], ["proof (state)\nthis:\n  upd_cs [] as = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>same_level_path_aux (upd_cs [] as) (a#cs)\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  same_level_path_aux (upd_cs [] as) (a # cs)\n  upd_cs [] as = cx # csx", "obtain Qx fx \n      where match:\"a \\<in> get_return_edges cx\" \"same_level_path_aux csx cs\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  same_level_path_aux (upd_cs [] as) (a # cs)\n  upd_cs [] as = cx # csx\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>a \\<in> get_return_edges cx;\n      same_level_path_aux csx cs\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> get_return_edges cx\n  same_level_path_aux csx cs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> Cons"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs [] as = cx # csx", "have \"upd_cs [] (as@[a]) = csx\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs [] as = cx # csx\n\ngoal (1 subgoal):\n 1. upd_cs [] (as @ [a]) = csx", "by(rule upd_cs_snoc_Return_Cons)"], ["proof (state)\nthis:\n  upd_cs [] (as @ [a]) = csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>same_level_path_aux (upd_cs [] as) (a#cs)\\<close>\n      \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> match"], ["proof (chain)\npicking this:\n  same_level_path_aux (upd_cs [] as) (a # cs)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges cx\n  same_level_path_aux csx cs\n  upd_cs [] (as @ [a]) = csx", "have \"same_level_path_aux (upd_cs [] (as@[a])) cs\""], ["proof (prove)\nusing this:\n  same_level_path_aux (upd_cs [] as) (a # cs)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges cx\n  same_level_path_aux csx cs\n  upd_cs [] (as @ [a]) = csx\n\ngoal (1 subgoal):\n 1. same_level_path_aux (upd_cs [] (as @ [a])) cs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux (upd_cs [] (as @ [a])) cs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>upd_cs [] (as@[a]) = csx\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> Cons\n      \\<open>upd_cs (upd_cs [] as) (a#cs) = []\\<close>"], ["proof (chain)\npicking this:\n  upd_cs [] (as @ [a]) = csx\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs [] as = cx # csx\n  upd_cs (upd_cs [] as) (a # cs) = []", "have \"upd_cs (upd_cs [] (as@[a])) cs = []\""], ["proof (prove)\nusing this:\n  upd_cs [] (as @ [a]) = csx\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  upd_cs [] as = cx # csx\n  upd_cs (upd_cs [] as) (a # cs) = []\n\ngoal (1 subgoal):\n 1. upd_cs (upd_cs [] (as @ [a])) cs = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "from Cons \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> match"], ["proof (chain)\npicking this:\n  upd_cs [] as = cx # csx\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges cx\n  same_level_path_aux csx cs", "have \"same_level_path_aux (upd_cs [] as) [a]\""], ["proof (prove)\nusing this:\n  upd_cs [] as = cx # csx\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges cx\n  same_level_path_aux csx cs\n\ngoal (1 subgoal):\n 1. same_level_path_aux (upd_cs [] as) [a]", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux (upd_cs [] as) [a]\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>same_level_path_aux [] as\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  same_level_path_aux (upd_cs [] as) [a]", "have \"same_level_path_aux [] (as@[a])\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  same_level_path_aux (upd_cs [] as) [a]\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a])", "by(rule same_level_path_aux_Append)"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       upd_cs [] as = aa # list \\<Longrightarrow>\n       same_level_path_aux [] (as @ [a]) \\<and>\n       same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n       upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>same_level_path_aux (upd_cs [] (as@[a])) cs\\<close>\n      \\<open>upd_cs (upd_cs [] (as@[a])) cs = []\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux (upd_cs [] (as @ [a])) cs\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n  same_level_path_aux [] (as @ [a])", "show ?thesis"], ["proof (prove)\nusing this:\n  same_level_path_aux (upd_cs [] (as @ [a])) cs\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n  same_level_path_aux [] (as @ [a])\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a]) \\<and>\n  same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a]) \\<and>\n  same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "case (slpra_Call cs a as Q r p fs cx csx)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = cx # csx\n  same_level_path_rev_aux csx as\n  cx \\<in> get_return_edges a\n  \\<lbrakk>upd_rev_cs csx as = []; n -as\\<rightarrow>* ?n';\n   valid_return_list csx ?n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                    same_level_path_aux (upd_cs [] as) csx \\<and>\n                    upd_cs (upd_cs [] as) csx = []\n  upd_rev_cs cs (as @ [a]) = []\n  n -as @ [a]\\<rightarrow>* n'\n  valid_return_list cs n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "note IH = \\<open>\\<And>n'. \\<lbrakk>upd_rev_cs csx as = []; n -as\\<rightarrow>* n'; valid_return_list csx n'\\<rbrakk>\n    \\<Longrightarrow> same_level_path_aux [] as \\<and>\n       same_level_path_aux (upd_cs [] as) csx \\<and> upd_cs (upd_cs [] as) csx = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_rev_cs csx as = []; n -as\\<rightarrow>* ?n';\n   valid_return_list csx ?n'\\<rbrakk>\n  \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                    same_level_path_aux (upd_cs [] as) csx \\<and>\n                    upd_cs (upd_cs [] as) csx = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "note match = \\<open>cs = cx#csx\\<close> \\<open>cx \\<in> get_return_edges a\\<close>"], ["proof (state)\nthis:\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>n -as@[a]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ [a]\\<rightarrow>* n'", "have \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\"\n    and \"n' = targetnode a\""], ["proof (prove)\nusing this:\n  n -as @ [a]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&& valid_edge a &&& n' = targetnode a", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  n' = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>valid_edge a\\<close> match"], ["proof (chain)\npicking this:\n  valid_edge a\n  cs = cx # csx\n  cx \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode cx)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode cx)", "by(fastforce intro:get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode cx)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>valid_return_list cs n'\\<close> \\<open>cs = cx#csx\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  cs = cx # csx\n  get_proc (sourcenode a) = get_proc (targetnode cx)", "have \"valid_return_list csx (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  cs = cx # csx\n  get_proc (sourcenode a) = get_proc (targetnode cx)\n\ngoal (1 subgoal):\n 1. valid_return_list csx (sourcenode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cx # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> n'\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        cs = cx # cs' @ c # cs'';\n        get_proc (sourcenode a) = get_proc (targetnode cx);\n        csx = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"cx#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>cs = cx # cs' @ c # cs'';\n        get_proc (sourcenode a) = get_proc (targetnode cx);\n        csx = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cx # cs' @ c # cs'' =\n               (cx # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cx # cs' of [] \\<Rightarrow> n'\n    | a # list \\<Rightarrow>\n        last (targetnodes (cx # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>cs = cx # cs' @ c # cs'';\n        get_proc (sourcenode a) = get_proc (targetnode cx);\n        csx = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (last\n                                    (targetnodes\n(cx # cs')))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc (last (targetnodes (cx # cs'))) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs',auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list csx (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> match \\<open>upd_rev_cs cs (as@[a]) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n  upd_rev_cs cs (as @ [a]) = []", "have \"upd_rev_cs csx as = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n  upd_rev_cs cs (as @ [a]) = []\n\ngoal (1 subgoal):\n 1. upd_rev_cs csx as = []", "by simp"], ["proof (state)\nthis:\n  upd_rev_cs csx as = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from IH[OF this \\<open>n -as\\<rightarrow>* sourcenode a\\<close> \\<open>valid_return_list csx (sourcenode a)\\<close>]"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as \\<and>\n  same_level_path_aux (upd_cs [] as) csx \\<and>\n  upd_cs (upd_cs [] as) csx = []", "have \"same_level_path_aux [] as\"\n    and \"same_level_path_aux (upd_cs [] as) csx\" and \"upd_cs (upd_cs [] as) csx = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as \\<and>\n  same_level_path_aux (upd_cs [] as) csx \\<and>\n  upd_cs (upd_cs [] as) csx = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as &&&\n    same_level_path_aux (upd_cs [] as) csx &&&\n    upd_cs (upd_cs [] as) csx = []", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n  same_level_path_aux (upd_cs [] as) csx\n  upd_cs (upd_cs [] as) csx = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>same_level_path_aux [] as\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"same_level_path_aux [] (as@[a])\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a])", "by(rule slpa_snoc_Call)"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> match"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = cx # csx\n  cx \\<in> get_return_edges a", "obtain Q' f' where \"kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"upd_cs [] (as@[a]) = a#(upd_cs [] as)\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. upd_cs [] (as @ [a]) = a # upd_cs [] as", "by(rule upd_cs_snoc_Call)"], ["proof (state)\nthis:\n  upd_cs [] (as @ [a]) = a # upd_cs [] as\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>same_level_path_aux (upd_cs [] as) csx\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \n    \\<open>kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> match"], ["proof (chain)\npicking this:\n  same_level_path_aux (upd_cs [] as) csx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n  upd_cs [] (as @ [a]) = a # upd_cs [] as", "have \"same_level_path_aux (upd_cs [] (as@[a])) cs\""], ["proof (prove)\nusing this:\n  same_level_path_aux (upd_cs [] as) csx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n  upd_cs [] (as @ [a]) = a # upd_cs [] as\n\ngoal (1 subgoal):\n 1. same_level_path_aux (upd_cs [] (as @ [a])) cs", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux (upd_cs [] (as @ [a])) cs\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "from \\<open>upd_cs (upd_cs [] as) csx = []\\<close> \\<open>upd_cs [] (as@[a]) = a#(upd_cs [] as)\\<close>\n    \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> match"], ["proof (chain)\npicking this:\n  upd_cs (upd_cs [] as) csx = []\n  upd_cs [] (as @ [a]) = a # upd_cs [] as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = cx # csx\n  cx \\<in> get_return_edges a", "have \"upd_cs (upd_cs [] (as@[a])) cs = []\""], ["proof (prove)\nusing this:\n  upd_cs (upd_cs [] as) csx = []\n  upd_cs [] (as @ [a]) = a # upd_cs [] as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind cx = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  cs = cx # csx\n  cx \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. upd_cs (upd_cs [] (as @ [a])) cs = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; same_level_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>upd_rev_cs cs' as = []; n -as\\<rightarrow>* n';\n            valid_return_list cs' n'\\<rbrakk>\n           \\<Longrightarrow> same_level_path_aux [] as \\<and>\n                             same_level_path_aux (upd_cs [] as) cs' \\<and>\n                             upd_cs (upd_cs [] as) cs' = [];\n        upd_rev_cs cs (as @ [a]) = []; n -as @ [a]\\<rightarrow>* n';\n        valid_return_list cs n'\\<rbrakk>\n       \\<Longrightarrow> same_level_path_aux [] (as @ [a]) \\<and>\n                         same_level_path_aux (upd_cs [] (as @ [a]))\n                          cs \\<and>\n                         upd_cs (upd_cs [] (as @ [a])) cs = []", "with \\<open>same_level_path_aux [] (as@[a])\\<close>\n    \\<open>same_level_path_aux (upd_cs [] (as@[a])) cs\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] (as @ [a])\n  same_level_path_aux (upd_cs [] (as @ [a])) cs\n  upd_cs (upd_cs [] (as @ [a])) cs = []", "show ?case"], ["proof (prove)\nusing this:\n  same_level_path_aux [] (as @ [a])\n  same_level_path_aux (upd_cs [] (as @ [a])) cs\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] (as @ [a]) \\<and>\n    same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n    upd_cs (upd_cs [] (as @ [a])) cs = []", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] (as @ [a]) \\<and>\n  same_level_path_aux (upd_cs [] (as @ [a])) cs \\<and>\n  upd_cs (upd_cs [] (as @ [a])) cs = []\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemmas on paths with \\<open>(_Entry_)\\<close>\\<close>"], ["", "lemma path_Entry_target [dest]:\n  assumes \"n -as\\<rightarrow>* (_Entry_)\"\n  shows \"n = (_Entry_)\" and \"as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = (_Entry_) &&& as = []", "using \\<open>n -as\\<rightarrow>* (_Entry_)\\<close>"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* (_Entry_)\n\ngoal (1 subgoal):\n 1. n = (_Entry_) &&& as = []", "proof(induct n as n'\\<equiv>\"(_Entry_)\" rule:path.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case (Cons_path n'' as a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* (_Entry_)\n  n'' = (_Entry_)\n  as = []\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n\ngoal (4 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "from \\<open>n'' = (_Entry_)\\<close> \\<open>targetnode a = n''\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  n'' = (_Entry_)\n  targetnode a = n''\n  valid_edge a", "have False"], ["proof (prove)\nusing this:\n  n'' = (_Entry_)\n  targetnode a = n''\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by -(rule Entry_target,simp_all)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "{"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "from \\<open>False\\<close>"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = (_Entry_)", ".."], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (3 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []\n 3. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Entry_); n'' = (_Entry_); as = [];\n        valid_edge a; sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "from \\<open>False\\<close>"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # as = []", ".."], ["proof (state)\nthis:\n  a # as = []\n\ngoal (2 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []", "}"], ["proof (state)\nthis:\n  a # as = []\n\ngoal (2 subgoals):\n 1. valid_node (_Entry_) \\<Longrightarrow> (_Entry_) = (_Entry_)\n 2. valid_node (_Entry_) \\<Longrightarrow> [] = []", "qed simp_all"], ["", "lemma Entry_sourcenode_hd:\n  assumes \"n -as\\<rightarrow>* n'\" and \"(_Entry_) \\<in> set (sourcenodes as)\"\n  shows \"n = (_Entry_)\" and \"(_Entry_) \\<notin> set (sourcenodes (tl as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = (_Entry_) &&& (_Entry_) \\<notin> set (sourcenodes (tl as))", "using \\<open>n -as\\<rightarrow>* n'\\<close> \\<open>(_Entry_) \\<in> set (sourcenodes as)\\<close>"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  (_Entry_) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n = (_Entry_) &&& (_Entry_) \\<notin> set (sourcenodes (tl as))", "proof(induct rule:path.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl []))\n 3. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "case (empty_path n)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl []))\n 3. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "case 1"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes [])\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl []))\n 3. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 4. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "thus ?case"], ["proof (prove)\nusing this:\n  (_Entry_) \\<in> set (sourcenodes [])\n\ngoal (1 subgoal):\n 1. n = (_Entry_)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl []))\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 3. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl []))\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 3. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "case (empty_path n)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl []))\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 3. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "case 2"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes [])\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; (_Entry_) \\<in> set (sourcenodes [])\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl []))\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 3. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "thus ?case"], ["proof (prove)\nusing this:\n  (_Entry_) \\<in> set (sourcenodes [])\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<notin> set (sourcenodes (tl []))", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  (_Entry_) \\<notin> set (sourcenodes (tl []))\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "case (Cons_path n'' as n' a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow> n'' = (_Entry_)\n  (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n  (_Entry_) \\<notin> set (sourcenodes (tl as))\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "note IH1 = \\<open>(_Entry_) \\<in> set(sourcenodes as) \\<Longrightarrow> n'' = (_Entry_)\\<close>"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow> n'' = (_Entry_)\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "note IH2 = \\<open>(_Entry_) \\<in> set(sourcenodes as) \\<Longrightarrow> (_Entry_) \\<notin> set(sourcenodes(tl as))\\<close>"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n  (_Entry_) \\<notin> set (sourcenodes (tl as))\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "have \"(_Entry_) \\<notin> set (sourcenodes(tl(a#as)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (_Entry_)\n           \\<notin> set (sourcenodes (tl (a # as))) \\<Longrightarrow>\n    False", "assume \"\\<not> (_Entry_) \\<notin> set (sourcenodes (tl (a#as)))\""], ["proof (state)\nthis:\n  \\<not> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal (1 subgoal):\n 1. \\<not> (_Entry_)\n           \\<notin> set (sourcenodes (tl (a # as))) \\<Longrightarrow>\n    False", "hence \"(_Entry_) \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  \\<not> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<in> set (sourcenodes as)", "by simp"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (_Entry_)\n           \\<notin> set (sourcenodes (tl (a # as))) \\<Longrightarrow>\n    False", "from IH1[OF this]"], ["proof (chain)\npicking this:\n  n'' = (_Entry_)", "have \"n'' = (_Entry_)\""], ["proof (prove)\nusing this:\n  n'' = (_Entry_)\n\ngoal (1 subgoal):\n 1. n'' = (_Entry_)", "by simp"], ["proof (state)\nthis:\n  n'' = (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<not> (_Entry_)\n           \\<notin> set (sourcenodes (tl (a # as))) \\<Longrightarrow>\n    False", "with \\<open>targetnode a = n''\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = n''\n  valid_edge a\n  n'' = (_Entry_)", "show False"], ["proof (prove)\nusing this:\n  targetnode a = n''\n  valid_edge a\n  n'' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by -(erule Entry_target,simp)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "hence \"(_Entry_) \\<notin> set (sourcenodes(tl(a#as)))\""], ["proof (prove)\nusing this:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "by fastforce"], ["proof (state)\nthis:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "{"], ["proof (state)\nthis:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "case 1"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes (a # as))\n\ngoal (2 subgoals):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> n = (_Entry_)\n 2. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "with \\<open>(_Entry_) \\<notin> set (sourcenodes(tl(a#as)))\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n  sourcenode a = n\n  (_Entry_) \\<in> set (sourcenodes (a # as))", "show ?case"], ["proof (prove)\nusing this:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n  sourcenode a = n\n  (_Entry_) \\<in> set (sourcenodes (a # as))\n\ngoal (1 subgoal):\n 1. n = (_Entry_)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "case 2"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes (a # as))\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        n'' = (_Entry_);\n        (_Entry_) \\<in> set (sourcenodes as) \\<Longrightarrow>\n        (_Entry_) \\<notin> set (sourcenodes (tl as));\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        (_Entry_) \\<in> set (sourcenodes (a # as))\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "with \\<open>(_Entry_) \\<notin> set (sourcenodes(tl(a#as)))\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n  sourcenode a = n\n  (_Entry_) \\<in> set (sourcenodes (a # as))", "show ?case"], ["proof (prove)\nusing this:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n  sourcenode a = n\n  (_Entry_) \\<in> set (sourcenodes (a # as))\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes (a # as)) \\<Longrightarrow>\n  (_Entry_) \\<notin> set (sourcenodes (tl (a # as)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Entry_no_inner_return_path: \n  assumes \"(_Entry_) -as@[a]\\<rightarrow>* n\" and \"\\<forall>a \\<in> set as. intra_kind(kind a)\"\n  and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>(_Entry_) -as@[a]\\<rightarrow>* n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as @ [a]\\<rightarrow>* n", "have \"(_Entry_) -as\\<rightarrow>* sourcenode a\" \n    and \"valid_edge a\" and \"targetnode a = n\""], ["proof (prove)\nusing this:\n  (_Entry_) -as @ [a]\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. (_Entry_) -as\\<rightarrow>* sourcenode a &&&\n    valid_edge a &&& targetnode a = n", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  targetnode a = n\n\ngoal (1 subgoal):\n 1. False", "from \\<open>(_Entry_) -as\\<rightarrow>* sourcenode a\\<close> \\<open>\\<forall>a \\<in> set as. intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* sourcenode a\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* sourcenode a\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. False", "hence \"get_proc (sourcenode a) = Main\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = Main", "by(fastforce dest:intra_path_get_procs simp:get_proc_Entry)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = Main\n\ngoal (1 subgoal):\n 1. False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  get_proc (sourcenode a) = Main", "have \"p = Main\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  get_proc (sourcenode a) = Main\n\ngoal (1 subgoal):\n 1. p = Main", "by(fastforce dest:get_proc_return)"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vpra_no_slpra:\n  \"\\<lbrakk>valid_path_rev_aux cs as; n -as\\<rightarrow>* n'; valid_return_list cs n'; cs \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> (\\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> [])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f. valid_edge a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path_rev_aux cs as; n -as\\<rightarrow>* n';\n     valid_return_list cs n'; cs \\<noteq> [];\n     \\<forall>xs ys.\n        as = xs @ ys \\<longrightarrow>\n        \\<not> same_level_path_rev_aux cs ys \\<or>\n        upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a Q f.\n                         valid_edge a \\<and>\n                         kind a =\n                         Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "proof(induct arbitrary:n' rule:vpra_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs n'.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 5. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "case (vpra_empty cs)"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n  valid_return_list cs n'\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     [] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>cs n'.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 5. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>valid_return_list cs n'\\<close> \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  cs \\<noteq> []", "obtain Q f where \"valid_edge (hd cs)\"\n    and \"kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>Q f.\n        \\<lbrakk>valid_edge (hd cs);\n         kind (hd cs) =\n         Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(unfold valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q p f.\n            kind c = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes cs')));\n     cs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(drule hd_Cons_tl[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q p f.\n            kind c = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes cs')));\n     cs = hd cs # tl cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>c cs''.\n        cs = [] @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q p f.\n            kind c = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"hd cs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>cs''.\n        cs = [] @ hd cs # cs'' \\<longrightarrow>\n        valid_edge (hd cs) \\<and>\n        (\\<exists>Q p f.\n            kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge (hd cs)\n  kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\n\ngoal (5 subgoals):\n 1. \\<And>cs n'.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 5. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>n -[]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -[]\\<rightarrow>* n'", "have \"n = n'\""], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = n'", "by fastforce"], ["proof (state)\nthis:\n  n = n'\n\ngoal (5 subgoals):\n 1. \\<And>cs n'.\n       \\<lbrakk>n -[]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           [] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 5. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "with \\<open>valid_edge (hd cs)\\<close> \\<open>kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge (hd cs)\n  kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\n  n = n'", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge (hd cs)\n  kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "by blast"], ["proof (state)\nthis:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "case (vpra_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_rev_aux cs as\n  \\<lbrakk>n -as\\<rightarrow>* ?n'; valid_return_list cs ?n';\n   cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_rev_aux cs ys \\<or>\n      upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f.\n                       valid_edge a \\<and>\n                       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n  n -as @ [a]\\<rightarrow>* n'\n  valid_return_list cs n'\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "note IH = \\<open>\\<And>n'. \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n'; cs \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow> \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a Q f. valid_edge a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n -as\\<rightarrow>* ?n'; valid_return_list cs ?n';\n   cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_rev_aux cs ys \\<or>\n      upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f.\n                       valid_edge a \\<and>\n                       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "note all = \\<open>\\<forall>xs ys. as@[a] = xs@ys \n    \\<longrightarrow> \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>n -as@[a]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ [a]\\<rightarrow>* n'", "have \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\"\n    and \"targetnode a = n'\""], ["proof (prove)\nusing this:\n  n -as @ [a]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&& valid_edge a &&& targetnode a = n'", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  targetnode a = n'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>valid_return_list cs n'\\<close> \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  cs \\<noteq> []", "obtain Q f where \"valid_edge (hd cs)\"\n    and \"kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>Q f.\n        \\<lbrakk>valid_edge (hd cs);\n         kind (hd cs) =\n         Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(unfold valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q p f.\n            kind c = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes cs')));\n     cs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(drule hd_Cons_tl[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>cs' c cs''.\n        cs = cs' @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q p f.\n            kind c = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case cs' of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes cs')));\n     cs = hd cs # tl cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>c cs''.\n        cs = [] @ c # cs'' \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q p f.\n            kind c = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"hd cs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q f.\n                \\<lbrakk>valid_edge (hd cs);\n                 kind (hd cs) =\n                 Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cs = hd cs # tl cs;\n     \\<forall>cs''.\n        cs = [] @ hd cs # cs'' \\<longrightarrow>\n        valid_edge (hd cs) \\<and>\n        (\\<exists>Q p f.\n            kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<and>\n            p =\n            get_proc\n             (case [] of [] \\<Rightarrow> n'\n              | a # list \\<Rightarrow> last (targetnodes [])))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge (hd cs)\n  kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "with \\<open>kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\\<close> \\<open>targetnode a = n'\\<close>"], ["proof (chain)\npicking this:\n  kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\n  targetnode a = n'\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f\""], ["proof (prove)\nusing this:\n  kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc n'\\<^esub>f\n  targetnode a = n'\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind (hd cs) = Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>valid_return_list cs n'\\<close> \\<open>targetnode a = n'\\<close>\n    \\<open>get_proc (sourcenode a) = get_proc (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  targetnode a = n'\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list cs (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  targetnode a = n'\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list cs (sourcenode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> targetnode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        get_proc (sourcenode a) = get_proc (targetnode a);\n        n' = targetnode a; cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        n' = targetnode a; cs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        n' = targetnode a; cs = cs' @ c # cs'';\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case cs' of [] \\<Rightarrow> targetnode a\n | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_return_list cs (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from all \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  intra_kind (kind a)", "have \"\\<forall>xs ys. as = xs@ys \n    \\<longrightarrow> \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux cs ys \\<or>\n       upd_rev_cs cs ys \\<noteq> []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>xsa ysa.\n                   xs @ ys @ [a] = xsa @ ysa \\<longrightarrow>\n                   same_level_path_rev_aux cs ysa \\<longrightarrow>\n                   upd_rev_cs cs ysa \\<noteq> [];\n        intra_kind (kind a); as = xs @ ys; same_level_path_rev_aux cs ys;\n        upd_rev_cs cs ys = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>intra_kind (kind a); as = xs @ ys;\n        same_level_path_rev_aux cs ys; upd_rev_cs cs ys = [];\n        \\<forall>ysa.\n           xs @ ys @ [a] = xs @ ysa \\<longrightarrow>\n           same_level_path_rev_aux cs ysa \\<longrightarrow>\n           upd_rev_cs cs ysa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>cs a as n'.\n       \\<lbrakk>intra_kind (kind a); valid_path_rev_aux cs as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs n';\n            cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs ys \\<or>\n               upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 4. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from IH[OF \\<open>n -as\\<rightarrow>* sourcenode a\\<close> \\<open>valid_return_list cs (sourcenode a)\\<close>\n    \\<open>cs \\<noteq> []\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "."], ["proof (state)\nthis:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "case (vpra_Return cs a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_path_rev_aux (a # cs) as\n  \\<lbrakk>n -as\\<rightarrow>* ?n'; valid_return_list (a # cs) ?n';\n   a # cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n      upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f.\n                       valid_edge a \\<and>\n                       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n  n -as @ [a]\\<rightarrow>* n'\n  valid_return_list cs n'\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "note IH = \\<open>\\<And>n'. \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a#cs) n'; a#cs \\<noteq> [];\n   \\<forall>xs ys. as = xs @ ys \\<longrightarrow>\n    \\<not> same_level_path_rev_aux (a#cs) ys \\<or> upd_rev_cs (a#cs) ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f. valid_edge a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n -as\\<rightarrow>* ?n'; valid_return_list (a # cs) ?n';\n   a # cs \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n      upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f.\n                       valid_edge a \\<and>\n                       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>n -as@[a]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ [a]\\<rightarrow>* n'", "have \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\"\n    and \"targetnode a = n'\""], ["proof (prove)\nusing this:\n  n -as @ [a]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&& valid_edge a &&& targetnode a = n'", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  targetnode a = n'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>valid_return_list cs n'\\<close> \\<open>valid_edge a\\<close> \\<open>targetnode a = n'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_return_list cs n'\n  valid_edge a\n  targetnode a = n'\n  get_proc (sourcenode a) = p", "have \"valid_return_list (a#cs) (sourcenode a)\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_return_list cs n'\n  valid_edge a\n  targetnode a = n'\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. valid_return_list (a # cs) (sourcenode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>kind a =\n                Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q f.\n               kind c =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a; n' = targetnode a; p = get_proc (sourcenode a);\n        a # cs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>kind a =\n                Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q f.\n               kind c =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a; n' = targetnode a; p = get_proc (sourcenode a);\n        a # cs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' aa list.\n       \\<lbrakk>kind a =\n                Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        \\<forall>cs' c.\n           (\\<exists>cs''. cs = cs' @ c # cs'') \\<longrightarrow>\n           valid_edge c \\<and>\n           (\\<exists>Q f.\n               kind c =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a; n' = targetnode a; p = get_proc (sourcenode a);\n        a # cs = cs' @ c # cs''; cs' = aa # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>kind a =\n                Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        \\<forall>cs' ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a; n' = targetnode a; p = get_proc (sourcenode a);\n        cs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>kind a =\n                Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        valid_edge a; n' = targetnode a; p = get_proc (sourcenode a);\n        cs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> targetnode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a # list)))\\<^esub>f", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>kind a =\n                Q\\<hookleftarrow>\\<^bsub>get_proc (sourcenode a)\\<^esub>f;\n        valid_edge a; n' = targetnode a; p = get_proc (sourcenode a);\n        cs = list @ c # cs'';\n        (\\<exists>cs''a.\n            list @ c # cs'' = list @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case list of [] \\<Rightarrow> targetnode a\n | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a # list)))\\<^esub>f", "by(auto split:list.split simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a # cs) (sourcenode a)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>\\<forall>xs ys. as@[a] = xs@ys \\<longrightarrow>\n    \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"\\<forall>xs ys. as = xs@ys \\<longrightarrow>\n    \\<not> same_level_path_rev_aux (a#cs) ys \\<or> upd_rev_cs (a#cs) ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n       upd_rev_cs (a # cs) ys \\<noteq> []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>xsa ysa.\n                   xs @ ys @ [a] = xsa @ ysa \\<longrightarrow>\n                   same_level_path_rev_aux cs ysa \\<longrightarrow>\n                   upd_rev_cs cs ysa \\<noteq> [];\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; as = xs @ ys;\n        same_level_path_rev_aux (a # cs) ys;\n        upd_rev_cs (a # cs) ys = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; as = xs @ ys;\n        same_level_path_rev_aux (a # cs) ys; upd_rev_cs (a # cs) ys = [];\n        \\<forall>ysa.\n           xs @ ys @ [a] = xs @ ysa \\<longrightarrow>\n           same_level_path_rev_aux cs ysa \\<longrightarrow>\n           upd_rev_cs cs ysa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n     upd_rev_cs (a # cs) ys \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q p f n'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        valid_path_rev_aux (a # cs) as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list (a # cs) n';\n            a # cs \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux (a # cs) ys \\<or>\n               upd_rev_cs (a # cs) ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 3. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from IH[OF \\<open>n -as\\<rightarrow>* sourcenode a\\<close> \\<open>valid_return_list (a#cs) (sourcenode a)\\<close>\n    _ this]"], ["proof (chain)\npicking this:\n  a # cs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "show ?case"], ["proof (prove)\nusing this:\n  a # cs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "case (vpra_CallEmpty cs a as Q p fs)"], ["proof (state)\nthis:\n  kind a = Q:p\\<hookrightarrow>\\<^bsub>fs\\<^esub>fs_\n  cs = []\n  valid_path_rev_aux [] as\n  \\<lbrakk>n -as\\<rightarrow>* ?n'; valid_return_list [] ?n';\n   [] \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_rev_aux [] ys \\<or>\n      upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f.\n                       valid_edge a \\<and>\n                       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n  n -as @ [a]\\<rightarrow>* n'\n  valid_return_list cs n'\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>cs = []\\<close> \\<open>cs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  cs = []\n  cs \\<noteq> []", "have False"], ["proof (prove)\nusing this:\n  cs = []\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = [];\n        valid_path_rev_aux [] as;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list [] n';\n            [] \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [] ys \\<or>\n               upd_rev_cs [] ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "case (vpra_CallCons cs a as Q r p fs c' cs')"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  valid_path_rev_aux cs' as\n  c' \\<in> get_return_edges a\n  \\<lbrakk>n -as\\<rightarrow>* ?n'; valid_return_list cs' ?n';\n   cs' \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_rev_aux cs' ys \\<or>\n      upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f.\n                       valid_edge a \\<and>\n                       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n  n -as @ [a]\\<rightarrow>* n'\n  valid_return_list cs n'\n  cs \\<noteq> []\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "note IH = \\<open>\\<And>n'. \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n'; cs' \\<noteq> [];\n    \\<forall>xs ys. as = xs@ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux cs' ys \\<or> upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a Q f. valid_edge a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n -as\\<rightarrow>* ?n'; valid_return_list cs' ?n';\n   cs' \\<noteq> [];\n   \\<forall>xs ys.\n      as = xs @ ys \\<longrightarrow>\n      \\<not> same_level_path_rev_aux cs' ys \\<or>\n      upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a Q f.\n                       valid_edge a \\<and>\n                       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "note all = \\<open>\\<forall>xs ys. as@[a] = xs@ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>n -as@[a]\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as @ [a]\\<rightarrow>* n'", "have \"n -as\\<rightarrow>* sourcenode a\" and \"valid_edge a\"\n    and \"targetnode a = n'\""], ["proof (prove)\nusing this:\n  n -as @ [a]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* sourcenode a &&& valid_edge a &&& targetnode a = n'", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* sourcenode a\n  valid_edge a\n  targetnode a = n'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>valid_return_list cs n'\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  cs = c' # cs'", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c'", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cs'a c.\n                (\\<exists>cs''.\n                    c' # cs' = cs'a @ c # cs'') \\<longrightarrow>\n                valid_edge c \\<and>\n                (\\<exists>Q f.\n                    kind c =\n                    Q\\<hookleftarrow>\\<^bsub>get_proc\n        (case cs'a of [] \\<Rightarrow> n'\n         | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n     cs = c' # cs'\\<rbrakk>\n    \\<Longrightarrow> valid_edge c'", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cs = c' # cs';\n     \\<forall>c.\n        (\\<exists>cs''. c' # cs' = [] @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case [] of [] \\<Rightarrow> n'\n | a # list \\<Rightarrow> last (targetnodes []))\\<^esub>f)\\<rbrakk>\n    \\<Longrightarrow> valid_edge c'", "by auto"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q r p fs c' cs' n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; valid_path_rev_aux cs' as;\n        c' \\<in> get_return_edges a;\n        \\<And>n'.\n           \\<lbrakk>n -as\\<rightarrow>* n'; valid_return_list cs' n';\n            cs' \\<noteq> [];\n            \\<forall>xs ys.\n               as = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux cs' ys \\<or>\n               upd_rev_cs cs' ys \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a Q f.\n                                valid_edge a \\<and>\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>get_proc\n                    n\\<^esub>f;\n        n -as @ [a]\\<rightarrow>* n'; valid_return_list cs n';\n        cs \\<noteq> [];\n        \\<forall>xs ys.\n           as @ [a] = xs @ ys \\<longrightarrow>\n           \\<not> same_level_path_rev_aux cs ys \\<or>\n           upd_rev_cs cs ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a Q f.\n                            valid_edge a \\<and>\n                            kind a =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "proof(cases \"cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "case True"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "with \\<open>cs = c'#cs'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>c' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  c' \\<in> get_return_edges a\n  cs' = []", "have \"same_level_path_rev_aux cs ([]@[a])\"\n      and \"upd_rev_cs cs ([]@[a]) = []\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  c' \\<in> get_return_edges a\n  cs' = []\n\ngoal (1 subgoal):\n 1. same_level_path_rev_aux cs ([] @ [a]) &&& upd_rev_cs cs ([] @ [a]) = []", "by(simp only:same_level_path_rev_aux.simps upd_rev_cs.simps,clarsimp)+"], ["proof (state)\nthis:\n  same_level_path_rev_aux cs ([] @ [a])\n  upd_rev_cs cs ([] @ [a]) = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "with all"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  same_level_path_rev_aux cs ([] @ [a])\n  upd_rev_cs cs ([] @ [a]) = []", "have False"], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  same_level_path_rev_aux cs ([] @ [a])\n  upd_rev_cs cs ([] @ [a]) = []\n\ngoal (1 subgoal):\n 1. False", "by(erule_tac x=\"as\" in allE) fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n 2. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "case False"], ["proof (state)\nthis:\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "with \\<open>valid_return_list cs n'\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs n'\n  cs = c' # cs'\n  cs' \\<noteq> []", "have \"valid_return_list cs' (targetnode c')\""], ["proof (prove)\nusing this:\n  valid_return_list cs n'\n  cs = c' # cs'\n  cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid_return_list cs' (targetnode c')", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'aa of [] \\<Rightarrow> n'\n            | a # list \\<Rightarrow> last (targetnodes cs'aa))\\<^esub>f);\n        cs = c' # cs'a @ c # cs''; cs' = cs'a @ c # cs'';\n        valid_edge c \\<longrightarrow>\n        (\\<forall>Q f.\n            kind c \\<noteq>\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case cs'a of [] \\<Rightarrow> targetnode c'\n | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       c' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> n'\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        valid_edge c \\<longrightarrow>\n        (\\<forall>Q f.\n            kind c \\<noteq>\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case cs' of [] \\<Rightarrow> targetnode c'\n | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"c'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge c \\<longrightarrow>\n                (\\<forall>Q f.\n                    kind c \\<noteq>\n                    Q\\<hookleftarrow>\\<^bsub>get_proc\n        (case cs' of [] \\<Rightarrow> targetnode c'\n         | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               c' # cs' @ c # cs'' =\n               (c' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case c' # cs' of [] \\<Rightarrow> n'\n    | a # list \\<Rightarrow>\n        last (targetnodes (c' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp:targetnodes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c Q f.\n       \\<lbrakk>get_proc\n                 (if cs' = [] then targetnode c'\n                  else last (map targetnode cs')) \\<noteq>\n                get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode c'\n                  | a # list \\<Rightarrow> last (targetnodes cs'));\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (if cs' = [] then targetnode c'\n                                   else last\n   (map targetnode cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c Q f.\n       \\<lbrakk>get_proc\n                 (if cs' = [] then targetnode c'\n                  else last (map targetnode cs')) \\<noteq>\n                get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode c'\n                  | a # list \\<Rightarrow> last (targetnodes cs'));\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (if cs' = [] then targetnode c'\n                                   else last (map targetnode cs'))\\<^esub>f;\n        cs' = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>cs' c Q f a list.\n       \\<lbrakk>get_proc\n                 (if cs' = [] then targetnode c'\n                  else last (map targetnode cs')) \\<noteq>\n                get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode c'\n                  | a # list \\<Rightarrow> last (targetnodes cs'));\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (if cs' = [] then targetnode c'\n                                   else last (map targetnode cs'))\\<^esub>f;\n        cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c Q f a list.\n       \\<lbrakk>get_proc\n                 (if list = [] then targetnode a\n                  else last (map targetnode list)) \\<noteq>\n                get_proc (last (targetnodes (a # list)));\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (if list = [] then targetnode a\n                                   else last\n   (map targetnode list))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c Q f a list.\n       \\<lbrakk>get_proc\n                 (if list = [] then targetnode a\n                  else last (map targetnode list)) \\<noteq>\n                get_proc (last (targetnodes (a # list)));\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (if list = [] then targetnode a\n                                   else last\n   (map targetnode list))\\<^esub>f;\n        list = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c Q f a list aa lista.\n       \\<lbrakk>get_proc\n                 (if list = [] then targetnode a\n                  else last (map targetnode list)) \\<noteq>\n                get_proc (last (targetnodes (a # list)));\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (if list = [] then targetnode a\n                                   else last\n   (map targetnode list))\\<^esub>f;\n        list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp:targetnodes_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_return_list cs' (targetnode c')\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from \\<open>valid_edge a\\<close> \\<open>c' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  c' \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode c')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  c' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode c')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode c')\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "with \\<open>valid_return_list cs' (targetnode c')\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list cs' (targetnode c')\n  get_proc (sourcenode a) = get_proc (targetnode c')", "have \"valid_return_list cs' (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_return_list cs' (targetnode c')\n  get_proc (sourcenode a) = get_proc (targetnode c')\n\ngoal (1 subgoal):\n 1. valid_return_list cs' (sourcenode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'aa of [] \\<Rightarrow> targetnode c'\n            | a # list \\<Rightarrow> last (targetnodes cs'aa))\\<^esub>f);\n        get_proc (sourcenode a) = get_proc (targetnode c');\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs'a of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> targetnode c'\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        get_proc (sourcenode a) = get_proc (targetnode c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode c');\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> targetnode c'\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"c\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode c');\n        (\\<exists>cs''a. cs' @ c # cs'' = cs' @ c # cs''a) \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case cs' of [] \\<Rightarrow> targetnode c'\n | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> sourcenode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "by(auto split:list.split)"], ["proof (state)\nthis:\n  valid_return_list cs' (sourcenode a)\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from all \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>cs = c'#cs'\\<close> \\<open>c' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a", "have \"\\<forall>xs ys. as = xs@ys \n      \\<longrightarrow> \\<not> same_level_path_rev_aux cs' ys \\<or> upd_rev_cs cs' ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     as @ [a] = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs ys \\<or> upd_rev_cs cs ys \\<noteq> []\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  cs = c' # cs'\n  c' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       as = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux cs' ys \\<or>\n       upd_rev_cs cs' ys \\<noteq> []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<forall>xsa ysa.\n                   xs @ ys @ [a] = xsa @ ysa \\<longrightarrow>\n                   same_level_path_rev_aux (c' # cs') ysa \\<longrightarrow>\n                   upd_rev_cs (c' # cs') ysa \\<noteq> [];\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; cs = c' # cs';\n        c' \\<in> get_return_edges a; as = xs @ ys;\n        same_level_path_rev_aux cs' ys; upd_rev_cs cs' ys = []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        cs = c' # cs'; c' \\<in> get_return_edges a; as = xs @ ys;\n        same_level_path_rev_aux cs' ys; upd_rev_cs cs' ys = [];\n        \\<forall>ysa.\n           xs @ ys @ [a] = xs @ ysa \\<longrightarrow>\n           same_level_path_rev_aux (c' # cs') ysa \\<longrightarrow>\n           upd_rev_cs (c' # cs') ysa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux cs' ys \\<or>\n     upd_rev_cs cs' ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. cs' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "from IH[OF \\<open>n -as\\<rightarrow>* sourcenode a\\<close> \\<open>valid_return_list cs' (sourcenode a)\\<close>\n      False this]"], ["proof (chain)\npicking this:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q f.\n       valid_edge a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f", "."], ["proof (state)\nthis:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a Q f.\n     valid_edge a \\<and>\n     kind a = Q\\<hookleftarrow>\\<^bsub>get_proc n\\<^esub>f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Entry_path_cases:\n  assumes \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\" and \"as \\<noteq> []\"\n  shows \"(\\<exists>a' as'. as = as'@[a'] \\<and> intra_kind(kind a')) \\<or>\n         (\\<exists>a' as' Q r p fs. as = as'@[a'] \\<and> kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n         (\\<exists>as' as'' n'. as = as'@as'' \\<and> as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "from \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []", "obtain a' as' where \"as = as'@[a']\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        as = as' @ [a'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases as rule:rev_cases) auto"], ["proof (state)\nthis:\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>as = as' @ [a']; intra_kind (kind a')\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a' as'.\n                          as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n                      (\\<exists>a' as' Q r p fs.\n                          as = as' @ [a'] \\<and>\n                          kind a' =\n                          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                      (\\<exists>as' as'' n'.\n                          as = as' @ as'' \\<and>\n                          as'' \\<noteq> [] \\<and>\n                          n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<And>Q r p fs.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 3. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as = as' @ [a']; intra_kind (kind a')\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>a' as'.\n                          as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n                      (\\<exists>a' as' Q r p fs.\n                          as = as' @ [a'] \\<and>\n                          kind a' =\n                          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                      (\\<exists>as' as'' n'.\n                          as = as' @ as'' \\<and>\n                          as'' \\<noteq> [] \\<and>\n                          n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<And>Q r p fs.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 3. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  intra_kind (kind a')", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q r p fs.\n      as = as' @ [a'] \\<and>\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "case Call"], ["proof (state)\nthis:\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  kind a' = Q_:r_\\<hookrightarrow>\\<^bsub>p_\\<^esub>fs_\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q r p fs.\n      as = as' @ [a'] \\<and>\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n", "have \"(_Entry_) -as\\<rightarrow>* n\" and \"valid_path_rev_aux [] as\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (1 subgoal):\n 1. (_Entry_) -as\\<rightarrow>* n &&& valid_path_rev_aux [] as", "by(auto intro:vp_to_vpra simp:vp_def valid_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>* n\n  valid_path_rev_aux [] as\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "from \\<open>(_Entry_) -as\\<rightarrow>* n\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n\n  as = as' @ [a']", "have \"(_Entry_) -as'\\<rightarrow>* sourcenode a'\" and \"valid_edge a'\" \n      and \"targetnode a' = n\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>* sourcenode a' &&&\n    valid_edge a' &&& targetnode a' = n", "by(auto intro:path_split_snoc)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  targetnode a' = n\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "from \\<open>valid_path_rev_aux [] as\\<close> \\<open>as = as'@[a']\\<close> Return"], ["proof (chain)\npicking this:\n  valid_path_rev_aux [] as\n  as = as' @ [a']\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"valid_path_rev_aux [a'] as'\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux [] as\n  as = as' @ [a']\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. valid_path_rev_aux [a'] as'", "by simp"], ["proof (state)\nthis:\n  valid_path_rev_aux [a'] as'\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "from \\<open>valid_edge a'\\<close> Return"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"valid_return_list [a'] (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. valid_return_list [a'] (sourcenode a')", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        [a'] = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>valid_edge a';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        [a'] = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>valid_edge a';\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        [a'] = cs' @ c # cs''; cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode a'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "by(auto intro:get_proc_return[THEN sym])"], ["proof (state)\nthis:\n  valid_return_list [a'] (sourcenode a')\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       \\<lbrakk>as = as' @ [a'];\n        kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>a' as'.\n                             as = as' @ [a'] \\<and>\n                             intra_kind (kind a')) \\<or>\n                         (\\<exists>a' as' Q r p fs.\n                             as = as' @ [a'] \\<and>\n                             kind a' =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n                         (\\<exists>as' as'' n'.\n                             as = as' @ as'' \\<and>\n                             as'' \\<noteq> [] \\<and>\n                             n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "proof(cases \"\\<forall>xs ys. as' = xs@ys \\<longrightarrow> \n        (\\<not> same_level_path_rev_aux [a'] ys \\<or> upd_rev_cs [a'] ys \\<noteq> [])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux [a'] ys \\<or>\n       upd_rev_cs [a'] ys \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "case True"], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     as' = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux [a'] ys \\<or>\n     upd_rev_cs [a'] ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux [a'] ys \\<or>\n       upd_rev_cs [a'] ys \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>valid_path_rev_aux [a'] as'\\<close> \\<open>(_Entry_) -as'\\<rightarrow>* sourcenode a'\\<close>\n        \\<open>valid_return_list [a'] (sourcenode a')\\<close>"], ["proof (chain)\npicking this:\n  valid_path_rev_aux [a'] as'\n  (_Entry_) -as'\\<rightarrow>* sourcenode a'\n  valid_return_list [a'] (sourcenode a')\n  \\<forall>xs ys.\n     as' = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux [a'] ys \\<or>\n     upd_rev_cs [a'] ys \\<noteq> []", "obtain ax Qx fx where \"valid_edge ax\" and \"kind ax = Qx\\<hookleftarrow>\\<^bsub>get_proc (_Entry_)\\<^esub>fx\""], ["proof (prove)\nusing this:\n  valid_path_rev_aux [a'] as'\n  (_Entry_) -as'\\<rightarrow>* sourcenode a'\n  valid_return_list [a'] (sourcenode a')\n  \\<forall>xs ys.\n     as' = xs @ ys \\<longrightarrow>\n     \\<not> same_level_path_rev_aux [a'] ys \\<or>\n     upd_rev_cs [a'] ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ax Qx fx.\n        \\<lbrakk>valid_edge ax;\n         kind ax =\n         Qx\\<hookleftarrow>\\<^bsub>get_proc (_Entry_)\\<^esub>fx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:vpra_no_slpra)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Qx\\<hookleftarrow>\\<^bsub>get_proc (_Entry_)\\<^esub>fx\n\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux [a'] ys \\<or>\n       upd_rev_cs [a'] ys \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "hence False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Qx\\<hookleftarrow>\\<^bsub>get_proc (_Entry_)\\<^esub>fx\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_return_source simp:get_proc_Entry)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>xs ys.\n       as' = xs @ ys \\<longrightarrow>\n       \\<not> same_level_path_rev_aux [a'] ys \\<or>\n       upd_rev_cs [a'] ys \\<noteq> [] \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n 2. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q r p fs.\n      as = as' @ [a'] \\<and>\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>xs ys.\n             as' = xs @ ys \\<longrightarrow>\n             \\<not> same_level_path_rev_aux [a'] ys \\<or>\n             upd_rev_cs [a'] ys \\<noteq> [])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>xs ys.\n             as' = xs @ ys \\<longrightarrow>\n             \\<not> same_level_path_rev_aux [a'] ys \\<or>\n             upd_rev_cs [a'] ys \\<noteq> [])", "obtain xs ys where \"as' = xs@ys\" and \"same_level_path_rev_aux [a'] ys\"\n        and \"upd_rev_cs [a'] ys = []\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>xs ys.\n             as' = xs @ ys \\<longrightarrow>\n             \\<not> same_level_path_rev_aux [a'] ys \\<or>\n             upd_rev_cs [a'] ys \\<noteq> [])\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>as' = xs @ ys; same_level_path_rev_aux [a'] ys;\n         upd_rev_cs [a'] ys = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as' = xs @ ys\n  same_level_path_rev_aux [a'] ys\n  upd_rev_cs [a'] ys = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with Return"], ["proof (chain)\npicking this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  as' = xs @ ys\n  same_level_path_rev_aux [a'] ys\n  upd_rev_cs [a'] ys = []", "have \"same_level_path_rev_aux [] (ys@[a'])\"\n        and \"upd_rev_cs [] (ys@[a']) = []\""], ["proof (prove)\nusing this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  as' = xs @ ys\n  same_level_path_rev_aux [a'] ys\n  upd_rev_cs [a'] ys = []\n\ngoal (1 subgoal):\n 1. same_level_path_rev_aux [] (ys @ [a']) &&&\n    upd_rev_cs [] (ys @ [a']) = []", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_rev_aux [] (ys @ [a'])\n  upd_rev_cs [] (ys @ [a']) = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "from \\<open>upd_rev_cs [a'] ys = []\\<close>"], ["proof (chain)\npicking this:\n  upd_rev_cs [a'] ys = []", "have \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  upd_rev_cs [a'] ys = []\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>(_Entry_) -as'\\<rightarrow>* sourcenode a'\\<close> \\<open>as' = xs@ys\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>* sourcenode a'\n  as' = xs @ ys\n  ys \\<noteq> []", "have \"hd(sourcenodes ys) -ys\\<rightarrow>* sourcenode a'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>* sourcenode a'\n  as' = xs @ ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes ys) -ys\\<rightarrow>* sourcenode a'", "by(cases ys)(auto dest:path_split_second simp:sourcenodes_def)"], ["proof (state)\nthis:\n  hd (sourcenodes ys) -ys\\<rightarrow>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>targetnode a' = n\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = n\n  valid_edge a'\n  hd (sourcenodes ys) -ys\\<rightarrow>* sourcenode a'", "have \"hd(sourcenodes ys) -ys@[a']\\<rightarrow>* n\""], ["proof (prove)\nusing this:\n  targetnode a' = n\n  valid_edge a'\n  hd (sourcenodes ys) -ys\\<rightarrow>* sourcenode a'\n\ngoal (1 subgoal):\n 1. hd (sourcenodes ys) -ys @ [a']\\<rightarrow>* n", "by(fastforce intro:path_Append path_edge)"], ["proof (state)\nthis:\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>same_level_path_rev_aux [] (ys@[a'])\\<close> \\<open>upd_rev_cs [] (ys@[a']) = []\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_rev_aux [] (ys @ [a'])\n  upd_rev_cs [] (ys @ [a']) = []\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>* n", "have \"same_level_path (ys@[a'])\""], ["proof (prove)\nusing this:\n  same_level_path_rev_aux [] (ys @ [a'])\n  upd_rev_cs [] (ys @ [a']) = []\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. same_level_path (ys @ [a'])", "by(fastforce dest:slpra_to_slpa simp:same_level_path_def valid_return_list_def)"], ["proof (state)\nthis:\n  same_level_path (ys @ [a'])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>hd(sourcenodes ys) -ys@[a']\\<rightarrow>* n\\<close>"], ["proof (chain)\npicking this:\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>* n\n  same_level_path (ys @ [a'])", "have \"hd(sourcenodes ys) -ys@[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* n\""], ["proof (prove)\nusing this:\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>* n\n  same_level_path (ys @ [a'])\n\ngoal (1 subgoal):\n 1. hd (sourcenodes ys) -ys @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* n", "by(simp add:slp_def)"], ["proof (state)\nthis:\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "with \\<open>as = as'@[a']\\<close> \\<open>as' = xs@ys\\<close> Return"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  as' = xs @ ys\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* n", "have \"\\<exists>as' as'' n'. as = as'@as'' \\<and> as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\""], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  as' = xs @ ys\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  hd (sourcenodes ys) -ys @ [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n", "by(rule_tac x=\"xs\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>xs ys.\n               as' = xs @ ys \\<longrightarrow>\n               \\<not> same_level_path_rev_aux [a'] ys \\<or>\n               upd_rev_cs [a'] ys \\<noteq> []) \\<Longrightarrow>\n    (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n    (\\<exists>a' as' Q r p fs.\n        as = as' @ [a'] \\<and>\n        kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q r p fs.\n      as = as' @ [a'] \\<and>\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q r p fs.\n      as = as' @ [a'] \\<and>\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n  (\\<exists>a' as' Q r p fs.\n      as = as' @ [a'] \\<and>\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_Entry_path_ascending_path:\n  assumes \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\"\n  obtains as' where \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n\" \n  and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\"\n  and \"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n;\n         set (sourcenodes as') \\<subseteq> set (sourcenodes as);\n         \\<forall>a'\\<in>set as'.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n", "show \"\\<exists>as'. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and> set(sourcenodes as') \\<subseteq> set(sourcenodes as)\\<and>\n              (\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "proof(induct as arbitrary:n rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<surd>* x \\<longrightarrow>\n                       (\\<exists>as'.\n                           (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* x \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys) \\<and>\n                           (\\<forall>a'\\<in>set as'.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q r p fs.\n                                   kind a' =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs) \\<and>\n                            (\\<forall>a'\\<in>set as'.\n                                intra_kind (kind a') \\<or>\n                                (\\<exists>Q r p fs.\n                                    kind a' =\n                                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "fix as n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<surd>* x \\<longrightarrow>\n                       (\\<exists>as'.\n                           (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* x \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys) \\<and>\n                           (\\<forall>a'\\<in>set as'.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q r p fs.\n                                   kind a' =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs) \\<and>\n                            (\\<forall>a'\\<in>set as'.\n                                intra_kind (kind a') \\<or>\n                                (\\<exists>Q r p fs.\n                                    kind a' =\n                                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "assume IH:\"\\<forall>as''. length as'' < length as \\<longrightarrow>\n      (\\<forall>n'. (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n       (\\<exists>as'. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and> set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n              (\\<forall>a'\\<in>set as'. intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\"\n      and \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\""], ["proof (state)\nthis:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'.\n             (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<surd>* x \\<longrightarrow>\n                       (\\<exists>as'.\n                           (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* x \\<and>\n                           set (sourcenodes as')\n                           \\<subseteq> set (sourcenodes ys) \\<and>\n                           (\\<forall>a'\\<in>set as'.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q r p fs.\n                                   kind a' =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n                            set (sourcenodes as')\n                            \\<subseteq> set (sourcenodes xs) \\<and>\n                            (\\<forall>a'\\<in>set as'.\n                                intra_kind (kind a') \\<or>\n                                (\\<exists>Q r p fs.\n                                    kind a' =\n                                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "show \"\\<exists>as'. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and> set(sourcenodes as') \\<subseteq> set(sourcenodes as)\\<and>\n              (\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "by(fastforce simp:sourcenodes_def vp_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q r p fs.\n             kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as \\<noteq> []", "have \"((\\<exists>a' as'. as = as'@[a'] \\<and> intra_kind(kind a')) \\<or>\n         (\\<exists>a' as' Q r p fs. as = as'@[a'] \\<and> kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<or>\n         (\\<exists>as' as'' n'. as = as'@as'' \\<and> as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. ((\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n     (\\<exists>a' as' Q r p fs.\n         as = as' @ [a'] \\<and>\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)", "by(fastforce dest!:valid_Entry_path_cases)"], ["proof (state)\nthis:\n  ((\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n   (\\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n   (\\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<or>\n  (\\<exists>as' as'' n'.\n      as = as' @ as'' \\<and>\n      as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')) \\<or>\n     (\\<exists>a' as' Q r p fs.\n         as = as' @ [a'] \\<and>\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<or>\n    (\\<exists>as' as'' n'.\n        as = as' @ as'' \\<and>\n        as'' \\<noteq> [] \\<and>\n        n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n) \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "assume \"\\<exists>a' as'. as = as'@[a'] \\<and> intra_kind(kind a')\""], ["proof (state)\nthis:\n  \\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')", "obtain a' as' where \"as = as'@[a']\" and \"intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  \\<exists>a' as'. as = as' @ [a'] \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        \\<lbrakk>as = as' @ [a']; intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as' @ [a']\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = as' @ [a']", "have \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\" and \"valid_edge a'\"\n          and \"targetnode a' = n\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' &&&\n    valid_edge a' &&& targetnode a' = n", "by(auto intro:vp_split_snoc)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  valid_edge a'\n  targetnode a' = n\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>valid_edge a'\\<close> \\<open>intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  intra_kind (kind a')", "have \"sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'", "by(fastforce intro:path_edge intras_same_level_path simp:slp_def)"], ["proof (state)\nthis:\n  sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from IH \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'.\n             (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  as = as' @ [a']", "obtain xs where \"(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\" \n          and \"set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\"\n          and \"\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'.\n             (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n         set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n         \\<forall>a'\\<in>set xs.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode\n                              a';\n                 set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n                 \\<forall>a'\\<in>set xs.\n                    intra_kind (kind a') \\<or>\n                    (\\<exists>Q r p fs.\n                        kind a' =\n                        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n     as = as' @ [a'];\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'a.\n             (_Entry_) -as'a\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as'a) \\<subseteq> set (sourcenodes as') \\<and>\n             (\\<forall>a'\\<in>set as'a.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\\<close> \\<open>sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'", "have \"(_Entry_) -xs@[a']\\<rightarrow>\\<^sub>\\<surd>* targetnode a'\""], ["proof (prove)\nusing this:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  sourcenode a' -[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* targetnode a'\n\ngoal (1 subgoal):\n 1. (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* targetnode a'", "by(rule vp_slp_Append)"], ["proof (state)\nthis:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* targetnode a'\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "with \\<open>targetnode a' = n\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = n\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* targetnode a'", "have \"(_Entry_) -xs@[a']\\<rightarrow>\\<^sub>\\<surd>* n\""], ["proof (prove)\nusing this:\n  targetnode a' = n\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* targetnode a'\n\ngoal (1 subgoal):\n 1. (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n", "by simp"], ["proof (state)\nthis:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "moreover"], ["proof (state)\nthis:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = as' @ [a']", "have \"set (sourcenodes (xs@[a'])) \\<subseteq> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "moreover"], ["proof (state)\nthis:\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close> \n          \\<open>intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  intra_kind (kind a')", "have \"\\<forall>a'\\<in>set (xs@[a']). intra_kind (kind a') \\<or> \n                                 (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (xs @ [a']).\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q r p fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (xs @ [a']).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (3 subgoals):\n 1. \\<exists>a' as'.\n       as = as' @ [a'] \\<and> intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 3. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "ultimately"], ["proof (chain)\npicking this:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (xs @ [a']).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (xs @ [a']).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q r p fs.\n             kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "assume \"\\<exists>a' as' Q r p fs. as = as'@[a'] \\<and> kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  \\<exists>a' as' Q r p fs.\n     as = as' @ [a'] \\<and>\n     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>a' as' Q r p fs.\n     as = as' @ [a'] \\<and>\n     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain a' as' Q r p fs where \"as = as'@[a']\" and \"kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  \\<exists>a' as' Q r p fs.\n     as = as' @ [a'] \\<and>\n     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>as' a' Q r p fs.\n        \\<lbrakk>as = as' @ [a'];\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as' @ [a']\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = as' @ [a']", "have \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\" and \"valid_edge a'\"\n          and \"targetnode a' = n\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' &&&\n    valid_edge a' &&& targetnode a' = n", "by(auto intro:vp_split_snoc)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  valid_edge a'\n  targetnode a' = n\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from IH \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'.\n             (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  as = as' @ [a']", "obtain xs where \"(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\" \n          and \"set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\"\n          and \"\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'.\n             (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n         set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n         \\<forall>a'\\<in>set xs.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode\n                              a';\n                 set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n                 \\<forall>a'\\<in>set xs.\n                    intra_kind (kind a') \\<or>\n                    (\\<exists>Q r p fs.\n                        kind a' =\n                        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n     as = as' @ [a'];\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'a.\n             (_Entry_) -as'a\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as'a) \\<subseteq> set (sourcenodes as') \\<and>\n             (\\<forall>a'\\<in>set as'a.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>targetnode a' = n\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n          \\<open>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = n\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'", "have \"(_Entry_) -xs@[a']\\<rightarrow>\\<^sub>\\<surd>* n\""], ["proof (prove)\nusing this:\n  targetnode a' = n\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n\ngoal (1 subgoal):\n 1. (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n", "by(fastforce intro:path_Append path_edge vpa_snoc_Call \n                       simp:vp_def valid_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "moreover"], ["proof (state)\nthis:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = as' @ [a']", "have \"set (sourcenodes (xs@[a'])) \\<subseteq> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "moreover"], ["proof (state)\nthis:\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close> \n          \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<forall>a'\\<in>set (xs@[a']). intra_kind (kind a') \\<or> \n                                 (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (xs @ [a']).\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q r p fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (xs @ [a']).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (2 subgoals):\n 1. \\<exists>a' as' Q r p fs.\n       as = as' @ [a'] \\<and>\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n 2. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "ultimately"], ["proof (chain)\npicking this:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (xs @ [a']).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (_Entry_) -xs @ [a']\\<rightarrow>\\<^sub>\\<surd>* n\n  set (sourcenodes (xs @ [a'])) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (xs @ [a']).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q r p fs.\n             kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "assume \"\\<exists>as' as'' n'. as = as'@as'' \\<and> as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\""], ["proof (state)\nthis:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n", "obtain as' as'' n' where \"as = as'@as''\" and \"as'' \\<noteq> []\"\n          and \"n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\""], ["proof (prove)\nusing this:\n  \\<exists>as' as'' n'.\n     as = as' @ as'' \\<and>\n     as'' \\<noteq> [] \\<and> n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. (\\<And>as' as'' n'.\n        \\<lbrakk>as = as' @ as''; as'' \\<noteq> [];\n         n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as' @ as''\n  as'' \\<noteq> []\n  n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close> \\<open>as = as'@as''\\<close> \\<open>as'' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = as' @ as''\n  as'' \\<noteq> []", "have \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* hd(sourcenodes as'')\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = as' @ as''\n  as'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* hd (sourcenodes as'')", "by(cases as'',auto intro:vp_split simp:sourcenodes_def)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* hd (sourcenodes as'')\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<close> \\<open>as'' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n  as'' \\<noteq> []", "have \"hd(sourcenodes as'') = n'\""], ["proof (prove)\nusing this:\n  n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n  as'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as'') = n'", "by(fastforce intro:path_sourcenode simp:slp_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as'') = n'\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>as = as'@as''\\<close> \\<open>as'' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ as''\n  as'' \\<noteq> []", "have \"length as' < length as\""], ["proof (prove)\nusing this:\n  as = as' @ as''\n  as'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length as' < length as", "by simp"], ["proof (state)\nthis:\n  length as' < length as\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "with IH \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* hd(sourcenodes as'')\\<close>\n          \\<open>hd(sourcenodes as'') = n'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'.\n             (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* hd (sourcenodes as'')\n  hd (sourcenodes as'') = n'\n  length as' < length as", "obtain xs where \"(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n'\" \n          and \"set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\"\n          and \"\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>as''.\n     length as'' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as''\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'.\n             (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as') \\<subseteq> set (sourcenodes as'') \\<and>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* hd (sourcenodes as'')\n  hd (sourcenodes as'') = n'\n  length as' < length as\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n';\n         set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n         \\<forall>a'\\<in>set xs.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n';\n                 set (sourcenodes xs) \\<subseteq> set (sourcenodes as');\n                 \\<forall>a'\\<in>set xs.\n                    intra_kind (kind a') \\<or>\n                    (\\<exists>Q r p fs.\n                        kind a' =\n                        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* hd (sourcenodes as'');\n     hd (sourcenodes as'') = n'; length as' < length as;\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n' \\<longrightarrow>\n         (\\<exists>as'a.\n             (_Entry_) -as'a\\<rightarrow>\\<^sub>\\<surd>* n' \\<and>\n             set (sourcenodes as'a) \\<subseteq> set (sourcenodes as') \\<and>\n             (\\<forall>a'\\<in>set as'a.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n'\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<close>"], ["proof (chain)\npicking this:\n  n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n", "obtain ys where \"n' -ys\\<rightarrow>\\<^sub>\\<iota>* n\"\n          and \"set(sourcenodes ys) \\<subseteq> set(sourcenodes as'')\""], ["proof (prove)\nusing this:\n  n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>n' -ys\\<rightarrow>\\<^sub>\\<iota>* n;\n         set (sourcenodes ys) \\<subseteq> set (sourcenodes as'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule same_level_path_inner_path)"], ["proof (state)\nthis:\n  n' -ys\\<rightarrow>\\<^sub>\\<iota>* n\n  set (sourcenodes ys) \\<subseteq> set (sourcenodes as'')\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n'\\<close> \\<open>n' -ys\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n'\n  n' -ys\\<rightarrow>\\<^sub>\\<iota>* n", "have \"(_Entry_) -xs@ys\\<rightarrow>\\<^sub>\\<surd>* n\""], ["proof (prove)\nusing this:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* n'\n  n' -ys\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. (_Entry_) -xs @ ys\\<rightarrow>\\<^sub>\\<surd>* n", "by(fastforce intro:vp_slp_Append intra_path_slp)"], ["proof (state)\nthis:\n  (_Entry_) -xs @ ys\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "moreover"], ["proof (state)\nthis:\n  (_Entry_) -xs @ ys\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\\<close>\n          \\<open>set(sourcenodes ys) \\<subseteq> set(sourcenodes as'')\\<close> \\<open>as = as'@as''\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  set (sourcenodes ys) \\<subseteq> set (sourcenodes as'')\n  as = as' @ as''", "have \"set (sourcenodes (xs@ys)) \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes xs) \\<subseteq> set (sourcenodes as')\n  set (sourcenodes ys) \\<subseteq> set (sourcenodes as'')\n  as = as' @ as''\n\ngoal (1 subgoal):\n 1. set (sourcenodes (xs @ ys)) \\<subseteq> set (sourcenodes as)", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  set (sourcenodes (xs @ ys)) \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "moreover"], ["proof (state)\nthis:\n  set (sourcenodes (xs @ ys)) \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "from \\<open>\\<forall>a'\\<in>set xs. intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>\n          \\<open>n' -ys\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  n' -ys\\<rightarrow>\\<^sub>\\<iota>* n", "have \"\\<forall>a'\\<in>set (xs@ys). intra_kind (kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set xs.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  n' -ys\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (xs @ ys).\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q r p fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (xs @ ys).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<exists>as' as'' n'.\n       as = as' @ as'' \\<and>\n       as'' \\<noteq> [] \\<and>\n       n' -as''\\<rightarrow>\\<^bsub>sl\\<^esub>* n \\<Longrightarrow>\n    \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "ultimately"], ["proof (chain)\npicking this:\n  (_Entry_) -xs @ ys\\<rightarrow>\\<^sub>\\<surd>* n\n  set (sourcenodes (xs @ ys)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (xs @ ys).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (_Entry_) -xs @ ys\\<rightarrow>\\<^sub>\\<surd>* n\n  set (sourcenodes (xs @ ys)) \\<subseteq> set (sourcenodes as)\n  \\<forall>a'\\<in>set (xs @ ys).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n       set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n       (\\<forall>a'\\<in>set as'.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q r p fs.\n             kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q r p fs.\n             kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q r p fs.\n             kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* n \\<and>\n     set (sourcenodes as') \\<subseteq> set (sourcenodes as) \\<and>\n     (\\<forall>a'\\<in>set as'.\n         intra_kind (kind a') \\<or>\n         (\\<exists>Q r p fs.\n             kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}