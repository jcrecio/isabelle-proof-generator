{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/SDG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma valid_SDG_CFG_node: \n  \"valid_SDG_node n \\<Longrightarrow> valid_node (parent_node n)\"", "lemma Formal_in_parent_det:\n  assumes \"valid_SDG_node (Formal_in (m,x))\" and \"valid_SDG_node (Formal_in (m',x'))\"\n  and \"get_proc m = get_proc m'\"\n  shows \"m = m'\"", "lemma valid_SDG_node_parent_Entry:\n  assumes \"valid_SDG_node n\" and \"parent_node n = (_Entry_)\"\n  shows \"n = CFG_node (_Entry_)\"", "lemma valid_SDG_node_parent_Exit:\n  assumes \"valid_SDG_node n\" and \"parent_node n = (_Exit_)\"\n  shows \"n = CFG_node (_Exit_)\"", "lemma in_Use_valid_SDG_node:\n  \"V \\<in> Use\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> valid_SDG_node n\"", "lemma SDG_Use_parent_Use: \n  \"V \\<in> Use\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> V \\<in> Use (parent_node n)\"", "lemma in_Def_valid_SDG_node:\n  \"V \\<in> Def\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> valid_SDG_node n\"", "lemma SDG_Def_parent_Def: \n  \"V \\<in> Def\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> V \\<in> Def (parent_node n)\"", "lemma control_dependence_path:\n  assumes \"n controls n'\" obtains as where \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"as \\<noteq> []\"", "lemma Exit_does_not_control [dest]:\n  assumes \"(_Exit_) controls n'\" shows \"False\"", "lemma Exit_not_control_dependent: \n  assumes \"n controls n'\" shows \"n' \\<noteq> (_Exit_)\"", "lemma which_node_intra_standard_control_dependence_source:\n  assumes \"nx -as@a#as'\\<rightarrow>\\<^sub>\\<iota>* n\" and \"sourcenode a = n'\" and \"sourcenode a' = n'\"\n  and \"n \\<notin> set(sourcenodes (a#as'))\" and \"valid_edge a'\" and \"intra_kind(kind a')\"\n  and \"inner_node n\" and \"\\<not> method_exit n\" and \"\\<not> n postdominates (targetnode a')\"\n  and last:\"\\<forall>ax ax'. ax \\<in> set as' \\<and> sourcenode ax = sourcenode ax' \\<and>\n    valid_edge ax' \\<and> intra_kind(kind ax') \\<longrightarrow> n postdominates targetnode ax'\"\n  shows \"n' controls n\"", "lemma cdep_edge_cases:\n  \"\\<lbrakk>n \\<longrightarrow>\\<^bsub>cd\\<^esub> n'; (parent_node n) controls (parent_node n') \\<Longrightarrow> P;\n    \\<And>a Q r p fs a'. \\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a;\n                  parent_node n = targetnode a; parent_node n' = sourcenode a'\\<rbrakk> \\<Longrightarrow> P;\n    \\<And>m. \\<lbrakk>n = CFG_node m; m = parent_node n'; n \\<noteq> n'\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma SDG_edge_valid_SDG_node:\n  assumes \"SDG_edge n Vopt popt n'\" \n  shows \"valid_SDG_node n\" and \"valid_SDG_node n'\"", "lemma valid_SDG_node_cases: \n  assumes \"valid_SDG_node n\"\n  shows \"n = CFG_node (parent_node n) \\<or> CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\"", "lemma SDG_cdep_edge_CFG_node: \"n \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow> \\<exists>m. n = CFG_node m\"", "lemma SDG_call_edge_CFG_node: \"n -p\\<rightarrow>\\<^bsub>call\\<^esub> n' \\<Longrightarrow> \\<exists>m. n = CFG_node m\"", "lemma SDG_return_edge_CFG_node: \"n -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<Longrightarrow> \\<exists>m. n = CFG_node m\"", "lemma SDG_call_or_param_in_edge_unique_CFG_call_edge:\n  \"SDG_edge n Vopt (Some(p,True)) n'\n  \\<Longrightarrow> \\<exists>!a. valid_edge a \\<and> sourcenode a = parent_node n \\<and> \n          targetnode a = parent_node n' \\<and> (\\<exists>Q r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\"", "lemma SDG_return_or_param_out_edge_unique_CFG_return_edge:\n  \"SDG_edge n Vopt (Some(p,False)) n'\n  \\<Longrightarrow> \\<exists>!a. valid_edge a \\<and> sourcenode a = parent_node n \\<and> \n          targetnode a = parent_node n' \\<and> (\\<exists>Q f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\"", "lemma Exit_no_SDG_edge_source:\n  \"SDG_edge (CFG_node (_Exit_)) Vopt popt n' \\<Longrightarrow> False\"", "lemma intra_SDG_path_Append:\n  \"\\<lbrakk>n'' i-ns'\\<rightarrow>\\<^sub>d* n'; n i-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n i-ns@ns'\\<rightarrow>\\<^sub>d* n'\"", "lemma intra_SDG_path_valid_SDG_node:\n  assumes \"n i-ns\\<rightarrow>\\<^sub>d* n'\" shows \"valid_SDG_node n\" and \"valid_SDG_node n'\"", "lemma intra_SDG_path_intra_CFG_path:\n  assumes \"n i-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"", "lemma cdep_SDG_path_intra_SDG_path:\n  \"n cd-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n i-ns\\<rightarrow>\\<^sub>d* n'\"", "lemma Entry_cdep_SDG_path:\n  assumes \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"inner_node n'\" and \"\\<not> method_exit n'\"\n  obtains ns where \"CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'\"\n  and \"ns \\<noteq> []\" and \"\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as)\"", "lemma in_proc_cdep_SDG_path:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"n \\<noteq> n'\" and \"n' \\<noteq> (_Exit_)\" and \"valid_edge a\"\n  and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"targetnode a = n\"\n  obtains ns where \"CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'\"\n  and \"ns \\<noteq> []\" and \"\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as)\"", "lemma cc_SDG_path_Append:\n  \"\\<lbrakk>n'' cc-ns'\\<rightarrow>\\<^sub>d* n'; n cc-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n cc-ns@ns'\\<rightarrow>\\<^sub>d* n'\"", "lemma cdep_SDG_path_cc_SDG_path:\n  \"n cd-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n cc-ns\\<rightarrow>\\<^sub>d* n'\"", "lemma Entry_cc_SDG_path_to_inner_node:\n  assumes \"valid_SDG_node n\" and \"parent_node n \\<noteq> (_Exit_)\"\n  obtains ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\"", "lemma matched_Append:\n  \"\\<lbrakk>matched n'' ns' n'; matched n ns n''\\<rbrakk> \\<Longrightarrow> matched n (ns@ns') n'\"", "lemma intra_SDG_path_matched:\n  assumes \"n i-ns\\<rightarrow>\\<^sub>d* n'\" shows \"matched n ns n'\"", "lemma intra_proc_matched:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a' \\<in> get_return_edges a\"\n  shows \"matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n                 (CFG_node (sourcenode a'))\"", "lemma matched_intra_CFG_path:\n  assumes \"matched n ns n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"", "lemma matched_same_level_CFG_path:\n  assumes \"matched n ns n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\"", "lemma realizable_Append_matched:\n  \"\\<lbrakk>realizable n ns n''; matched n'' ns' n'\\<rbrakk> \\<Longrightarrow> realizable n (ns@ns') n'\"", "lemma realizable_valid_CFG_path:\n  assumes \"realizable n ns n'\" \n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\"", "lemma cdep_SDG_path_realizable:\n  \"n cc-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> realizable n ns n'\"", "lemma sum_edge_cases:\n  \"\\<lbrakk>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'; \n    \\<And>a Q r fs a'. \\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a;\n                n = CFG_node (sourcenode a); n' = CFG_node (targetnode a')\\<rbrakk> \\<Longrightarrow> P;\n    \\<And>a Q p r fs a' ns x x' ins outs.\n      \\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a;\n       matched (Formal_in (targetnode a,x)) ns (Formal_out (sourcenode a',x'));\n       n = Actual_in (sourcenode a,x); n' = Actual_out (targetnode a',x');\n       (p,ins,outs) \\<in> set procs; x < length ins; x' < length outs\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\"", "lemma SDG_edge_sum_SDG_edge:\n  \"SDG_edge n Vopt popt n' \\<Longrightarrow> sum_SDG_edge n Vopt popt False n'\"", "lemma sum_SDG_edge_SDG_edge:\n  \"sum_SDG_edge n Vopt popt False n' \\<Longrightarrow> SDG_edge n Vopt popt n'\"", "lemma sum_SDG_edge_valid_SDG_node:\n  assumes \"sum_SDG_edge n Vopt popt b n'\" \n  shows \"valid_SDG_node n\" and \"valid_SDG_node n'\"", "lemma Exit_no_sum_SDG_edge_source:\n  assumes \"sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\" shows \"False\"", "lemma Exit_no_sum_SDG_edge_target:\n  \"sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)) \\<Longrightarrow> False\"", "lemma sum_SDG_summary_edge_matched:\n  assumes \"n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\" \n  obtains ns where \"matched n ns n'\" and \"n \\<in> set ns\"\n  and \"get_proc (parent_node(last ns)) = p\"", "lemma return_edge_determines_call_and_sum_edge:\n  assumes \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  obtains a' Q' r' fs' where \"a \\<in> get_return_edges a'\" and \"valid_edge a'\"\n  and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\" \n  and \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\"", "lemma is_SDG_path_Append:\n  \"\\<lbrakk>n'' is-ns'\\<rightarrow>\\<^sub>d* n'; n is-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n is-ns@ns'\\<rightarrow>\\<^sub>d* n'\"", "lemma is_SDG_path_valid_SDG_node:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\" shows \"valid_SDG_node n\" and \"valid_SDG_node n'\"", "lemma intra_SDG_path_is_SDG_path:\n  \"n i-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n is-ns\\<rightarrow>\\<^sub>d* n'\"", "lemma is_SDG_path_hd:\"\\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'; ns \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd ns = n\"", "lemma intra_sum_SDG_path_rev_induct [consumes 1, case_names \"isSp_Nil\" \n  \"isSp_Cons_cdep\"  \"isSp_Cons_ddep\"  \"isSp_Cons_sum\"]: \n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  and refl:\"\\<And>n. valid_SDG_node n \\<Longrightarrow> P n [] n\"\n  and step_cdep:\"\\<And>n ns n' n''. \\<lbrakk>n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''; n'' is-ns\\<rightarrow>\\<^sub>d* n'; P n'' ns n'\\<rbrakk> \n                 \\<Longrightarrow> P n (n#ns) n'\"\n  and step_ddep:\"\\<And>n ns n' V n''. \\<lbrakk>n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''; n'' is-ns\\<rightarrow>\\<^sub>d* n'; \n                                  P n'' ns n'\\<rbrakk> \\<Longrightarrow> P n (n#ns) n'\"\n  and step_sum:\"\\<And>n ns n' p n''. \\<lbrakk>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''; n'' is-ns\\<rightarrow>\\<^sub>d* n'; P n'' ns n'\\<rbrakk> \n                 \\<Longrightarrow> P n (n#ns) n'\"\n  shows \"P n ns n'\"", "lemma is_SDG_path_CFG_path:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"", "lemma matched_is_SDG_path:\n  assumes \"matched n ns n'\" obtains ns' where \"n is-ns'\\<rightarrow>\\<^sub>d* n'\"", "lemma is_SDG_path_matched:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\" obtains ns' where \"matched n ns' n'\" and \"set ns \\<subseteq> set ns'\"", "lemma is_SDG_path_intra_CFG_path:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"", "lemma ics_SDG_path_valid_SDG_node:\n  assumes \"n ics-ns\\<rightarrow>\\<^sub>d* n'\" shows \"valid_SDG_node n\" and \"valid_SDG_node n'\"", "lemma ics_SDG_path_Append:\n  \"\\<lbrakk>n'' ics-ns'\\<rightarrow>\\<^sub>d* n'; n ics-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n ics-ns@ns'\\<rightarrow>\\<^sub>d* n'\"", "lemma is_SDG_path_ics_SDG_path:\n  \"n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n ics-ns\\<rightarrow>\\<^sub>d* n'\"", "lemma cc_SDG_path_ics_SDG_path:\n  \"n cc-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n ics-ns\\<rightarrow>\\<^sub>d* n'\"", "lemma ics_SDG_path_split:\n  assumes \"n ics-ns\\<rightarrow>\\<^sub>d* n'\" and \"n'' \\<in> set ns\" \n  obtains ns' ns'' where \"ns = ns'@ns''\" and \"n ics-ns'\\<rightarrow>\\<^sub>d* n''\" \n  and \"n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\"", "lemma realizable_ics_SDG_path:\n  assumes \"realizable n ns n'\" obtains ns' where \"n ics-ns'\\<rightarrow>\\<^sub>d* n'\"", "lemma ics_SDG_path_realizable:\n  assumes \"n ics-ns\\<rightarrow>\\<^sub>d* n'\" \n  obtains ns' where \"realizable n ns' n'\" and \"set ns \\<subseteq> set ns'\"", "lemma realizable_Append_ics_SDG_path:\n  assumes \"realizable n ns n''\" and \"n'' ics-ns'\\<rightarrow>\\<^sub>d* n'\"\n  obtains ns'' where \"realizable n (ns@ns'') n'\"", "lemma irs_SDG_path_Append:\n  \"\\<lbrakk>n irs-ns\\<rightarrow>\\<^sub>d* n''; n'' irs-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk> \\<Longrightarrow> n irs-ns@ns'\\<rightarrow>\\<^sub>d* n'\"", "lemma is_SDG_path_irs_SDG_path:\n  \"n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n irs-ns\\<rightarrow>\\<^sub>d* n'\"", "lemma irs_SDG_path_split:\n  assumes \"n irs-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  | nsx nsx' nx nx' p where \"ns = nsx@nx#nsx'\" and \"n irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n  and \"nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\" and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\"", "lemma irs_SDG_path_matched:\n  assumes \"n irs-ns\\<rightarrow>\\<^sub>d* n''\" and \"n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\"\n  obtains nx nsx where \"matched nx nsx n'\" and \"n \\<in> set nsx\" \n  and \"nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\"", "lemma irs_SDG_path_realizable:\n  assumes \"n irs-ns\\<rightarrow>\\<^sub>d* n'\" and \"n \\<noteq> n'\"\n  obtains ns' where \"realizable (CFG_node (_Entry_)) ns' n'\" and \"n \\<in> set ns'\""], "translations": [["", "lemma valid_SDG_CFG_node: \n  \"valid_SDG_node n \\<Longrightarrow> valid_node (parent_node n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node n \\<Longrightarrow> valid_node (parent_node n)", "by(cases n) auto"], ["", "lemma Formal_in_parent_det:\n  assumes \"valid_SDG_node (Formal_in (m,x))\" and \"valid_SDG_node (Formal_in (m',x'))\"\n  and \"get_proc m = get_proc m'\"\n  shows \"m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m = m'", "from \\<open>valid_SDG_node (Formal_in (m,x))\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (Formal_in (m, x))", "obtain a Q r p fs ins outs\n    where \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"targetnode a = m\"\n    and \"(p,ins,outs) \\<in> set procs\" and \"x < length ins\""], ["proof (prove)\nusing this:\n  valid_SDG_node (Formal_in (m, x))\n\ngoal (1 subgoal):\n 1. (\\<And>a Q r p fs ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; targetnode a = m;\n         (p, ins, outs) \\<in> set procs; x < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n\ngoal (1 subgoal):\n 1. m = m'", "from \\<open>valid_SDG_node (Formal_in (m',x'))\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (Formal_in (m', x'))", "obtain a' Q' r' p' f' ins' outs'\n    where \"valid_edge a'\" and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\" and \"targetnode a' = m'\"\n    and \"(p',ins',outs') \\<in> set procs\" and \"x' < length ins'\""], ["proof (prove)\nusing this:\n  valid_SDG_node (Formal_in (m', x'))\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' r' p' f' ins' outs'.\n        \\<lbrakk>valid_edge a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f';\n         targetnode a' = m'; (p', ins', outs') \\<in> set procs;\n         x' < length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  targetnode a' = m'\n  (p', ins', outs') \\<in> set procs\n  x' < length ins'\n\ngoal (1 subgoal):\n 1. m = m'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>targetnode a = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m", "have \"get_proc m = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m\n\ngoal (1 subgoal):\n 1. get_proc m = p", "by(fastforce intro:get_proc_call)"], ["proof (state)\nthis:\n  get_proc m = p\n\ngoal (1 subgoal):\n 1. m = m'", "moreover"], ["proof (state)\nthis:\n  get_proc m = p\n\ngoal (1 subgoal):\n 1. m = m'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\\<close> \\<open>targetnode a' = m'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  targetnode a' = m'", "have \"get_proc m' = p'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  targetnode a' = m'\n\ngoal (1 subgoal):\n 1. get_proc m' = p'", "by(fastforce intro:get_proc_call)"], ["proof (state)\nthis:\n  get_proc m' = p'\n\ngoal (1 subgoal):\n 1. m = m'", "ultimately"], ["proof (chain)\npicking this:\n  get_proc m = p\n  get_proc m' = p'", "have \"p = p'\""], ["proof (prove)\nusing this:\n  get_proc m = p\n  get_proc m' = p'\n\ngoal (1 subgoal):\n 1. p = p'", "using \\<open>get_proc m = get_proc m'\\<close>"], ["proof (prove)\nusing this:\n  get_proc m = p\n  get_proc m' = p'\n  get_proc m = get_proc m'\n\ngoal (1 subgoal):\n 1. p = p'", "by simp"], ["proof (state)\nthis:\n  p = p'\n\ngoal (1 subgoal):\n 1. m = m'", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\\<close>\n    \\<open>targetnode a = m\\<close> \\<open>targetnode a' = m'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  targetnode a = m\n  targetnode a' = m'\n  p = p'", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>f'\n  targetnode a = m\n  targetnode a' = m'\n  p = p'\n\ngoal (1 subgoal):\n 1. m = m'", "by(fastforce intro:same_proc_call_unique_target)"], ["proof (state)\nthis:\n  m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_SDG_node_parent_Entry:\n  assumes \"valid_SDG_node n\" and \"parent_node n = (_Entry_)\"\n  shows \"n = CFG_node (_Entry_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = CFG_node (_Entry_)", "proof(cases n)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1. n = CFG_node x1 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 5. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "case CFG_node"], ["proof (state)\nthis:\n  n = CFG_node x1_\n\ngoal (5 subgoals):\n 1. \\<And>x1. n = CFG_node x1 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 5. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>parent_node n = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Entry_)\n  n = CFG_node x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  parent_node n = (_Entry_)\n  n = CFG_node x1_\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Entry_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Entry_)\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "case (Formal_in z)"], ["proof (state)\nthis:\n  n = Formal_in z\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>parent_node n = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Entry_)\n  n = Formal_in z", "obtain x \n    where [simp]:\"z = ((_Entry_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Entry_)\n  n = Formal_in z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Entry_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Entry_), x)\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>valid_SDG_node n\\<close> Formal_in"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_in z\n  z = ((_Entry_), x)", "obtain a where \"valid_edge a\"\n    and \"targetnode a = (_Entry_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_in z\n  z = ((_Entry_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; targetnode a = (_Entry_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge a\n  targetnode a = (_Entry_)\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "hence False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by -(rule Entry_target,simp+)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Entry_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Entry_)\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "case (Formal_out z)"], ["proof (state)\nthis:\n  n = Formal_out z\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>parent_node n = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Entry_)\n  n = Formal_out z", "obtain x \n    where [simp]:\"z = ((_Entry_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Entry_)\n  n = Formal_out z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Entry_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Entry_), x)\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>valid_SDG_node n\\<close> Formal_out"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_out z\n  z = ((_Entry_), x)", "obtain a Q p f where \"valid_edge a\"\n    and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and  \"sourcenode a = (_Entry_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_out z\n  z = ((_Entry_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q p f.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         sourcenode a = (_Entry_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode a = (_Entry_)\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>sourcenode a = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (_Entry_)\n  get_proc (sourcenode a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  sourcenode a = (_Entry_)\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by(auto simp:get_proc_Entry)"], ["proof (state)\nthis:\n  p = Main\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Entry_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Entry_)\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "case (Actual_in z)"], ["proof (state)\nthis:\n  n = Actual_in z\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>parent_node n = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Entry_)\n  n = Actual_in z", "obtain x \n    where [simp]:\"z = ((_Entry_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Entry_)\n  n = Actual_in z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Entry_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Entry_), x)\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>valid_SDG_node n\\<close> Actual_in"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_in z\n  z = ((_Entry_), x)", "obtain a Q r p fs where \"valid_edge a\"\n    and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"sourcenode a = (_Entry_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_in z\n  z = ((_Entry_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q r p fs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         sourcenode a = (_Entry_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = (_Entry_)\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "hence False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by -(rule Entry_no_call_source,auto)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Entry_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Entry_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "case (Actual_out z)"], ["proof (state)\nthis:\n  n = Actual_out z\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>parent_node n = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Entry_)\n  n = Actual_out z", "obtain x \n    where [simp]:\"z = ((_Entry_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Entry_)\n  n = Actual_out z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Entry_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Entry_), x)\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "with \\<open>valid_SDG_node n\\<close> Actual_out"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_out z\n  z = ((_Entry_), x)", "obtain a where \"valid_edge a\"\n    \"targetnode a = (_Entry_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_out z\n  z = ((_Entry_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; targetnode a = (_Entry_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge a\n  targetnode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "hence False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by -(rule Entry_target,simp+)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Entry_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Entry_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_SDG_node_parent_Exit:\n  assumes \"valid_SDG_node n\" and \"parent_node n = (_Exit_)\"\n  shows \"n = CFG_node (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = CFG_node (_Exit_)", "proof(cases n)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1. n = CFG_node x1 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 5. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "case CFG_node"], ["proof (state)\nthis:\n  n = CFG_node x1_\n\ngoal (5 subgoals):\n 1. \\<And>x1. n = CFG_node x1 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 5. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>parent_node n = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Exit_)\n  n = CFG_node x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  parent_node n = (_Exit_)\n  n = CFG_node x1_\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Exit_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Exit_)\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "case (Formal_in z)"], ["proof (state)\nthis:\n  n = Formal_in z\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>parent_node n = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Exit_)\n  n = Formal_in z", "obtain x \n    where [simp]:\"z = ((_Exit_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Exit_)\n  n = Formal_in z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Exit_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Exit_), x)\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>valid_SDG_node n\\<close> Formal_in"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_in z\n  z = ((_Exit_), x)", "obtain a Q r p fs where \"valid_edge a\"\n    and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_in z\n  z = ((_Exit_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q r p fs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         targetnode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = (_Exit_)\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>targetnode a = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (_Exit_)\n  get_proc (targetnode a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by(auto simp:get_proc_Exit)"], ["proof (state)\nthis:\n  p = Main\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>x2. n = Formal_in x2 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 4. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Exit_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "case (Formal_out z)"], ["proof (state)\nthis:\n  n = Formal_out z\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>parent_node n = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Exit_)\n  n = Formal_out z", "obtain x \n    where [simp]:\"z = ((_Exit_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Exit_)\n  n = Formal_out z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Exit_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Exit_), x)\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>valid_SDG_node n\\<close> Formal_out"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_out z\n  z = ((_Exit_), x)", "obtain a where \"valid_edge a\"\n    and \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_out z\n  z = ((_Exit_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "hence False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(rule Exit_source,simp+)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>x3. n = Formal_out x3 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 3. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Exit_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "case (Actual_in z)"], ["proof (state)\nthis:\n  n = Actual_in z\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>parent_node n = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Exit_)\n  n = Actual_in z", "obtain x \n    where [simp]:\"z = ((_Exit_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Exit_)\n  n = Actual_in z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Exit_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Exit_), x)\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>valid_SDG_node n\\<close> Actual_in"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_in z\n  z = ((_Exit_), x)", "obtain a where \"valid_edge a\"\n    and \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_in z\n  z = ((_Exit_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "hence False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(rule Exit_source,simp+)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x4. n = Actual_in x4 \\<Longrightarrow> n = CFG_node (_Exit_)\n 2. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Exit_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "case (Actual_out z)"], ["proof (state)\nthis:\n  n = Actual_out z\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>parent_node n = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Exit_)\n  n = Actual_out z", "obtain x \n    where [simp]:\"z = ((_Exit_),x)\""], ["proof (prove)\nusing this:\n  parent_node n = (_Exit_)\n  n = Actual_out z\n\ngoal (1 subgoal):\n 1. (\\<And>x. z = ((_Exit_), x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = ((_Exit_), x)\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "with \\<open>valid_SDG_node n\\<close> Actual_out"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_out z\n  z = ((_Exit_), x)", "obtain a Q p f where \"valid_edge a\"\n    and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_out z\n  z = ((_Exit_), x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q p f.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         targetnode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "hence False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(erule Exit_no_return_target,auto)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x5. n = Actual_out x5 \\<Longrightarrow> n = CFG_node (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Exit_)", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Data dependence\\<close>"], ["", "inductive SDG_Use :: \"'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" (\"_ \\<in> Use\\<^bsub>SDG\\<^esub> _\")\nwhere CFG_Use_SDG_Use:\n  \"\\<lbrakk>valid_node m; V \\<in> Use m; n = CFG_node m\\<rbrakk> \\<Longrightarrow> V \\<in> Use\\<^bsub>SDG\\<^esub> n\"\n  | Actual_in_SDG_Use:\n  \"\\<lbrakk>valid_SDG_node n; n = Actual_in (m,x); V \\<in> (ParamUses m)!x\\<rbrakk> \\<Longrightarrow> V \\<in> Use\\<^bsub>SDG\\<^esub> n\"\n  | Formal_out_SDG_Use:\n  \"\\<lbrakk>valid_SDG_node n; n = Formal_out (m,x); get_proc m = p; (p,ins,outs) \\<in> set procs;\n    V = outs!x\\<rbrakk> \\<Longrightarrow> V \\<in> Use\\<^bsub>SDG\\<^esub> n\""], ["", "abbreviation notin_SDG_Use :: \"'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"  (\"_ \\<notin> Use\\<^bsub>SDG\\<^esub> _\")\n  where \"V \\<notin> Use\\<^bsub>SDG\\<^esub> n \\<equiv> \\<not> V \\<in> Use\\<^bsub>SDG\\<^esub> n\""], ["", "lemma in_Use_valid_SDG_node:\n  \"V \\<in> Use\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> valid_SDG_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> Use\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> valid_SDG_node n", "by(induct rule:SDG_Use.induct,auto intro:valid_SDG_CFG_node)"], ["", "lemma SDG_Use_parent_Use: \n  \"V \\<in> Use\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> V \\<in> Use (parent_node n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> Use\\<^bsub>SDG\\<^esub> n \\<Longrightarrow>\n    V \\<in> Use (parent_node n)", "proof(induct rule:SDG_Use.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m V n.\n       \\<lbrakk>valid_node m; V \\<in> Use m; n = CFG_node m\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 3. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "case CFG_Use_SDG_Use"], ["proof (state)\nthis:\n  valid_node m_\n  V_ \\<in> Use m_\n  n_ = CFG_node m_\n\ngoal (3 subgoals):\n 1. \\<And>m V n.\n       \\<lbrakk>valid_node m; V \\<in> Use m; n = CFG_node m\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 3. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node m_\n  V_ \\<in> Use m_\n  n_ = CFG_node m_\n\ngoal (1 subgoal):\n 1. V_ \\<in> Use (parent_node n_)", "by simp"], ["proof (state)\nthis:\n  V_ \\<in> Use (parent_node n_)\n\ngoal (2 subgoals):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "case (Actual_in_SDG_Use n m x V)"], ["proof (state)\nthis:\n  valid_SDG_node n\n  n = Actual_in (m, x)\n  V \\<in> ParamUses m ! x\n\ngoal (2 subgoals):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "from \\<open>valid_SDG_node n\\<close> \\<open>n = Actual_in (m, x)\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_in (m, x)", "obtain a Q r p fs ins outs\n    where \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"sourcenode a = m\"\n    and \"(p,ins,outs) \\<in> set procs\" and \"x < length ins\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_in (m, x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q r p fs ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; sourcenode a = m;\n         (p, ins, outs) \\<in> set procs; x < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n\ngoal (2 subgoals):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have \"length(ParamUses (sourcenode a)) = length ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (ParamUses (sourcenode a)) = length ins", "by(fastforce intro:ParamUses_call_source_length)"], ["proof (state)\nthis:\n  length (ParamUses (sourcenode a)) = length ins\n\ngoal (2 subgoals):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "with \\<open>x < length ins\\<close>"], ["proof (chain)\npicking this:\n  x < length ins\n  length (ParamUses (sourcenode a)) = length ins", "have \"(ParamUses (sourcenode a))!x \\<in> set (ParamUses (sourcenode a))\""], ["proof (prove)\nusing this:\n  x < length ins\n  length (ParamUses (sourcenode a)) = length ins\n\ngoal (1 subgoal):\n 1. ParamUses (sourcenode a) ! x \\<in> set (ParamUses (sourcenode a))", "by simp"], ["proof (state)\nthis:\n  ParamUses (sourcenode a) ! x \\<in> set (ParamUses (sourcenode a))\n\ngoal (2 subgoals):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "with \\<open>V \\<in> (ParamUses m)!x\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> ParamUses m ! x\n  sourcenode a = m\n  ParamUses (sourcenode a) ! x \\<in> set (ParamUses (sourcenode a))", "have \"V \\<in> Union (set (ParamUses m))\""], ["proof (prove)\nusing this:\n  V \\<in> ParamUses m ! x\n  sourcenode a = m\n  ParamUses (sourcenode a) ! x \\<in> set (ParamUses (sourcenode a))\n\ngoal (1 subgoal):\n 1. V \\<in> \\<Union> (set (ParamUses m))", "by fastforce"], ["proof (state)\nthis:\n  V \\<in> \\<Union> (set (ParamUses m))\n\ngoal (2 subgoals):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_in (m, x);\n        V \\<in> ParamUses m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close> \\<open>n = Actual_in (m, x)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  n = Actual_in (m, x)\n  V \\<in> \\<Union> (set (ParamUses m))", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  n = Actual_in (m, x)\n  V \\<in> \\<Union> (set (ParamUses m))\n\ngoal (1 subgoal):\n 1. V \\<in> Use (parent_node n)", "by(fastforce intro:ParamUses_in_Use)"], ["proof (state)\nthis:\n  V \\<in> Use (parent_node n)\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "case (Formal_out_SDG_Use n m x p ins outs V)"], ["proof (state)\nthis:\n  valid_SDG_node n\n  n = Formal_out (m, x)\n  get_proc m = p\n  (p, ins, outs) \\<in> set procs\n  V = outs ! x\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "from \\<open>valid_SDG_node n\\<close> \\<open>n = Formal_out (m, x)\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_out (m, x)", "obtain a Q p' f ins' outs'\n    where \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f\" and \"sourcenode a = m\"\n    and \"(p',ins',outs') \\<in> set procs\" and \"x < length outs'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_out (m, x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q p' f ins' outs'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f; sourcenode a = m;\n         (p', ins', outs') \\<in> set procs; x < length outs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f\n  sourcenode a = m\n  (p', ins', outs') \\<in> set procs\n  x < length outs'\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f", "have \"get_proc (sourcenode a) = p'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p'", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p'\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "with \\<open>get_proc m = p\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  get_proc m = p\n  sourcenode a = m\n  get_proc (sourcenode a) = p'", "have [simp]:\"p = p'\""], ["proof (prove)\nusing this:\n  get_proc m = p\n  sourcenode a = m\n  get_proc (sourcenode a) = p'\n\ngoal (1 subgoal):\n 1. p = p'", "by simp"], ["proof (state)\nthis:\n  p = p'\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "with \\<open>(p',ins',outs') \\<in> set procs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> unique_callers"], ["proof (chain)\npicking this:\n  (p', ins', outs') \\<in> set procs\n  (p, ins, outs) \\<in> set procs\n  distinct_fst procs\n  p = p'", "have [simp]:\"ins' = ins\" \"outs' = outs\""], ["proof (prove)\nusing this:\n  (p', ins', outs') \\<in> set procs\n  (p, ins, outs) \\<in> set procs\n  distinct_fst procs\n  p = p'\n\ngoal (1 subgoal):\n 1. ins' = ins &&& outs' = outs", "by(auto dest:distinct_fst_isin_same_fst)"], ["proof (state)\nthis:\n  ins' = ins\n  outs' = outs\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "from \\<open>x < length outs'\\<close> \\<open>V = outs ! x\\<close>"], ["proof (chain)\npicking this:\n  x < length outs'\n  V = outs ! x", "have \"V \\<in> set outs\""], ["proof (prove)\nusing this:\n  x < length outs'\n  V = outs ! x\n\ngoal (1 subgoal):\n 1. V \\<in> set outs", "by fastforce"], ["proof (state)\nthis:\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set outs", "have \"V \\<in> Use (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p'\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. V \\<in> Use (sourcenode a)", "by(fastforce intro:outs_in_Use)"], ["proof (state)\nthis:\n  V \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_out (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = outs ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use (parent_node n)", "with \\<open>sourcenode a = m\\<close> \\<open>valid_SDG_node n\\<close> \\<open>n = Formal_out (m, x)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = m\n  valid_SDG_node n\n  n = Formal_out (m, x)\n  V \\<in> Use (sourcenode a)", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = m\n  valid_SDG_node n\n  n = Formal_out (m, x)\n  V \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. V \\<in> Use (parent_node n)", "by simp"], ["proof (state)\nthis:\n  V \\<in> Use (parent_node n)\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive SDG_Def :: \"'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" (\"_ \\<in> Def\\<^bsub>SDG\\<^esub> _\")\nwhere CFG_Def_SDG_Def:\n  \"\\<lbrakk>valid_node m; V \\<in> Def m; n = CFG_node m\\<rbrakk> \\<Longrightarrow> V \\<in> Def\\<^bsub>SDG\\<^esub> n\"\n  | Formal_in_SDG_Def:\n  \"\\<lbrakk>valid_SDG_node n; n = Formal_in (m,x); get_proc m = p; (p,ins,outs) \\<in> set procs;\n    V = ins!x\\<rbrakk> \\<Longrightarrow> V \\<in> Def\\<^bsub>SDG\\<^esub> n\"\n  | Actual_out_SDG_Def:\n  \"\\<lbrakk>valid_SDG_node n; n = Actual_out (m,x); V = (ParamDefs m)!x\\<rbrakk> \\<Longrightarrow> V \\<in> Def\\<^bsub>SDG\\<^esub> n\""], ["", "abbreviation notin_SDG_Def :: \"'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"  (\"_ \\<notin> Def\\<^bsub>SDG\\<^esub> _\")\n  where \"V \\<notin> Def\\<^bsub>SDG\\<^esub> n \\<equiv> \\<not> V \\<in> Def\\<^bsub>SDG\\<^esub> n\""], ["", "lemma in_Def_valid_SDG_node:\n  \"V \\<in> Def\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> valid_SDG_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> Def\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> valid_SDG_node n", "by(induct rule:SDG_Def.induct,auto intro:valid_SDG_CFG_node)"], ["", "lemma SDG_Def_parent_Def: \n  \"V \\<in> Def\\<^bsub>SDG\\<^esub> n \\<Longrightarrow> V \\<in> Def (parent_node n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> Def\\<^bsub>SDG\\<^esub> n \\<Longrightarrow>\n    V \\<in> Def (parent_node n)", "proof(induct rule:SDG_Def.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m V n.\n       \\<lbrakk>valid_node m; V \\<in> Def m; n = CFG_node m\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 3. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "case CFG_Def_SDG_Def"], ["proof (state)\nthis:\n  valid_node m_\n  V_ \\<in> Def m_\n  n_ = CFG_node m_\n\ngoal (3 subgoals):\n 1. \\<And>m V n.\n       \\<lbrakk>valid_node m; V \\<in> Def m; n = CFG_node m\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 3. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node m_\n  V_ \\<in> Def m_\n  n_ = CFG_node m_\n\ngoal (1 subgoal):\n 1. V_ \\<in> Def (parent_node n_)", "by simp"], ["proof (state)\nthis:\n  V_ \\<in> Def (parent_node n_)\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "case (Formal_in_SDG_Def n m x p ins outs V)"], ["proof (state)\nthis:\n  valid_SDG_node n\n  n = Formal_in (m, x)\n  get_proc m = p\n  (p, ins, outs) \\<in> set procs\n  V = ins ! x\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "from \\<open>valid_SDG_node n\\<close> \\<open>n = Formal_in (m, x)\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_in (m, x)", "obtain a Q r p' fs ins' outs'\n    where \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\" and \"targetnode a = m\"\n    and \"(p',ins',outs') \\<in> set procs\" and \"x < length ins'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_in (m, x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q r p' fs ins' outs'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs;\n         targetnode a = m; (p', ins', outs') \\<in> set procs;\n         x < length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  targetnode a = m\n  (p', ins', outs') \\<in> set procs\n  x < length ins'\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs", "have \"get_proc (targetnode a) = p'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p'", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p'\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "with \\<open>get_proc m = p\\<close> \\<open>targetnode a = m\\<close>"], ["proof (chain)\npicking this:\n  get_proc m = p\n  targetnode a = m\n  get_proc (targetnode a) = p'", "have [simp]:\"p = p'\""], ["proof (prove)\nusing this:\n  get_proc m = p\n  targetnode a = m\n  get_proc (targetnode a) = p'\n\ngoal (1 subgoal):\n 1. p = p'", "by simp"], ["proof (state)\nthis:\n  p = p'\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "with \\<open>(p',ins',outs') \\<in> set procs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> unique_callers"], ["proof (chain)\npicking this:\n  (p', ins', outs') \\<in> set procs\n  (p, ins, outs) \\<in> set procs\n  distinct_fst procs\n  p = p'", "have [simp]:\"ins' = ins\" \"outs' = outs\""], ["proof (prove)\nusing this:\n  (p', ins', outs') \\<in> set procs\n  (p, ins, outs) \\<in> set procs\n  distinct_fst procs\n  p = p'\n\ngoal (1 subgoal):\n 1. ins' = ins &&& outs' = outs", "by(auto dest:distinct_fst_isin_same_fst)"], ["proof (state)\nthis:\n  ins' = ins\n  outs' = outs\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "from \\<open>x < length ins'\\<close> \\<open>V = ins ! x\\<close>"], ["proof (chain)\npicking this:\n  x < length ins'\n  V = ins ! x", "have \"V \\<in> set ins\""], ["proof (prove)\nusing this:\n  x < length ins'\n  V = ins ! x\n\ngoal (1 subgoal):\n 1. V \\<in> set ins", "by fastforce"], ["proof (state)\nthis:\n  V \\<in> set ins\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set ins", "have \"V \\<in> Def (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. V \\<in> Def (targetnode a)", "by(fastforce intro:ins_in_Def)"], ["proof (state)\nthis:\n  V \\<in> Def (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>n m x p ins outs V.\n       \\<lbrakk>valid_SDG_node n; n = Formal_in (m, x); get_proc m = p;\n        (p, ins, outs) \\<in> set procs; V = ins ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)\n 2. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "with \\<open>targetnode a = m\\<close> \\<open>valid_SDG_node n\\<close> \\<open>n = Formal_in (m, x)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = m\n  valid_SDG_node n\n  n = Formal_in (m, x)\n  V \\<in> Def (targetnode a)", "show ?case"], ["proof (prove)\nusing this:\n  targetnode a = m\n  valid_SDG_node n\n  n = Formal_in (m, x)\n  V \\<in> Def (targetnode a)\n\ngoal (1 subgoal):\n 1. V \\<in> Def (parent_node n)", "by simp"], ["proof (state)\nthis:\n  V \\<in> Def (parent_node n)\n\ngoal (1 subgoal):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "case (Actual_out_SDG_Def n m x V)"], ["proof (state)\nthis:\n  valid_SDG_node n\n  n = Actual_out (m, x)\n  V = ParamDefs m ! x\n\ngoal (1 subgoal):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "from \\<open>valid_SDG_node n\\<close> \\<open>n = Actual_out (m, x)\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_out (m, x)", "obtain a Q p f ins outs\n    where \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"targetnode a = m\"\n    and \"(p,ins,outs) \\<in> set procs\" and \"x < length outs\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_out (m, x)\n\ngoal (1 subgoal):\n 1. (\\<And>a Q p f ins outs.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         targetnode a = m; (p, ins, outs) \\<in> set procs;\n         x < length outs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = m\n  (p, ins, outs) \\<in> set procs\n  x < length outs\n\ngoal (1 subgoal):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs", "have \"length(ParamDefs (targetnode a)) = length outs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (ParamDefs (targetnode a)) = length outs", "by(rule ParamDefs_return_target_length)"], ["proof (state)\nthis:\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "with \\<open>x < length outs\\<close> \\<open>V = ParamDefs m ! x\\<close> \\<open>targetnode a = m\\<close>"], ["proof (chain)\npicking this:\n  x < length outs\n  V = ParamDefs m ! x\n  targetnode a = m\n  length (ParamDefs (targetnode a)) = length outs", "have \"V \\<in> set (ParamDefs (targetnode a))\""], ["proof (prove)\nusing this:\n  x < length outs\n  V = ParamDefs m ! x\n  targetnode a = m\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. V \\<in> set (ParamDefs (targetnode a))", "by(fastforce simp:set_conv_nth)"], ["proof (state)\nthis:\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>n m x V.\n       \\<lbrakk>valid_SDG_node n; n = Actual_out (m, x);\n        V = ParamDefs m ! x\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def (parent_node n)", "with \\<open>n = Actual_out (m, x)\\<close> \\<open>targetnode a = m\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  n = Actual_out (m, x)\n  targetnode a = m\n  valid_edge a\n  V \\<in> set (ParamDefs (targetnode a))", "show ?case"], ["proof (prove)\nusing this:\n  n = Actual_out (m, x)\n  targetnode a = m\n  valid_edge a\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<in> Def (parent_node n)", "by(fastforce intro:ParamDefs_in_Def)"], ["proof (state)\nthis:\n  V \\<in> Def (parent_node n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition data_dependence :: \"'node SDG_node \\<Rightarrow> 'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n(\"_ influences _ in _\" [51,0,0])\n  where \"n influences V in n' \\<equiv> \\<exists>as. (V \\<in> Def\\<^bsub>SDG\\<^esub> n) \\<and> (V \\<in> Use\\<^bsub>SDG\\<^esub> n') \\<and> \n  (parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n') \\<and>\n  (\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes (tl as))\n         \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n'')\""], ["", "subsection \\<open>Control dependence\\<close>"], ["", "definition control_dependence :: \"'node \\<Rightarrow> 'node \\<Rightarrow> bool\" \n  (\"_ controls _\" [51,0])\nwhere \"n controls n' \\<equiv> \\<exists>a a' as. n -a#as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> n' \\<notin> set(sourcenodes (a#as)) \\<and>\n    intra_kind(kind a) \\<and> n' postdominates (targetnode a) \\<and> \n    valid_edge a' \\<and> intra_kind(kind a') \\<and> sourcenode a' = n \\<and> \n    \\<not> n' postdominates (targetnode a')\""], ["", "lemma control_dependence_path:\n  assumes \"n controls n'\" obtains as where \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"as \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* n';\n         as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>n controls n'\\<close>"], ["proof (prove)\nusing this:\n  n controls n'\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* n';\n         as \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:control_dependence_def)"], ["", "lemma Exit_does_not_control [dest]:\n  assumes \"(_Exit_) controls n'\" shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>(_Exit_) controls n'\\<close>"], ["proof (chain)\npicking this:\n  (_Exit_) controls n'", "obtain a where \"valid_edge a\"\n    and \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  (_Exit_) controls n'\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:control_dependence_def)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_not_control_dependent: \n  assumes \"n controls n'\" shows \"n' \\<noteq> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "from \\<open>n controls n'\\<close>"], ["proof (chain)\npicking this:\n  n controls n'", "obtain a as where \"n -a#as\\<rightarrow>\\<^sub>\\<iota>* n'\"\n    and \"n' postdominates (targetnode a)\""], ["proof (prove)\nusing this:\n  n controls n'\n\ngoal (1 subgoal):\n 1. (\\<And>a as.\n        \\<lbrakk>n -a # as\\<rightarrow>\\<^sub>\\<iota>* n';\n         n' postdominates targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:control_dependence_def)"], ["proof (state)\nthis:\n  n -a # as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' postdominates targetnode a\n\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "from \\<open>n -a#as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"valid_edge a\""], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. valid_edge a", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "hence \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "with \\<open>n' postdominates (targetnode a)\\<close> \\<open>n -a#as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates targetnode a\n  n -a # as\\<rightarrow>\\<^sub>\\<iota>* n'\n  valid_node (targetnode a)", "show ?thesis"], ["proof (prove)\nusing this:\n  n' postdominates targetnode a\n  n -a # as\\<rightarrow>\\<^sub>\\<iota>* n'\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. n' \\<noteq> (_Exit_)", "by(fastforce elim:Exit_no_postdominator)"], ["proof (state)\nthis:\n  n' \\<noteq> (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma which_node_intra_standard_control_dependence_source:\n  assumes \"nx -as@a#as'\\<rightarrow>\\<^sub>\\<iota>* n\" and \"sourcenode a = n'\" and \"sourcenode a' = n'\"\n  and \"n \\<notin> set(sourcenodes (a#as'))\" and \"valid_edge a'\" and \"intra_kind(kind a')\"\n  and \"inner_node n\" and \"\\<not> method_exit n\" and \"\\<not> n postdominates (targetnode a')\"\n  and last:\"\\<forall>ax ax'. ax \\<in> set as' \\<and> sourcenode ax = sourcenode ax' \\<and>\n    valid_edge ax' \\<and> intra_kind(kind ax') \\<longrightarrow> n postdominates targetnode ax'\"\n  shows \"n' controls n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' controls n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n' controls n", "from \\<open>nx -as@a#as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close> \\<open>sourcenode a = n'\\<close>"], ["proof (chain)\npicking this:\n  nx -as @ a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  sourcenode a = n'", "have \"n' -a#as'\\<rightarrow>\\<^sub>\\<iota>* n\""], ["proof (prove)\nusing this:\n  nx -as @ a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  sourcenode a = n'\n\ngoal (1 subgoal):\n 1. n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n", "by(fastforce dest:path_split_second simp:intra_path_def)"], ["proof (state)\nthis:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. n' controls n", "from \\<open>nx -as@a#as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  nx -as @ a # as'\\<rightarrow>\\<^sub>\\<iota>* n", "have \"valid_edge a\""], ["proof (prove)\nusing this:\n  nx -as @ a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. valid_edge a", "by(fastforce intro:path_split simp:intra_path_def)"], ["proof (state)\nthis:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. n' controls n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n' controls n", "proof(cases \"n postdominates (targetnode a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n postdominates targetnode a \\<Longrightarrow> n' controls n\n 2. \\<not> n postdominates targetnode a \\<Longrightarrow> n' controls n", "case True"], ["proof (state)\nthis:\n  n postdominates targetnode a\n\ngoal (2 subgoals):\n 1. n postdominates targetnode a \\<Longrightarrow> n' controls n\n 2. \\<not> n postdominates targetnode a \\<Longrightarrow> n' controls n", "with \\<open>n' -a#as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close> \\<open>n \\<notin> set(sourcenodes (a#as'))\\<close>\n      \\<open>valid_edge a'\\<close> \\<open>intra_kind(kind a')\\<close> \\<open>sourcenode a' = n'\\<close> \n      \\<open>\\<not> n postdominates (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  n \\<notin> set (sourcenodes (a # as'))\n  valid_edge a'\n  intra_kind (kind a')\n  sourcenode a' = n'\n  \\<not> n postdominates targetnode a'\n  n postdominates targetnode a", "show ?thesis"], ["proof (prove)\nusing this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  n \\<notin> set (sourcenodes (a # as'))\n  valid_edge a'\n  intra_kind (kind a')\n  sourcenode a' = n'\n  \\<not> n postdominates targetnode a'\n  n postdominates targetnode a\n\ngoal (1 subgoal):\n 1. n' controls n", "by(fastforce simp:control_dependence_def intra_path_def)"], ["proof (state)\nthis:\n  n' controls n\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates targetnode a \\<Longrightarrow> n' controls n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n postdominates targetnode a \\<Longrightarrow> n' controls n", "case False"], ["proof (state)\nthis:\n  \\<not> n postdominates targetnode a\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates targetnode a \\<Longrightarrow> n' controls n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n' controls n", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> n' controls n\n 2. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> n' controls n\n 2. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "with \\<open>n' -a#as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' = []", "have \"targetnode a = n\""], ["proof (prove)\nusing this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' = []\n\ngoal (1 subgoal):\n 1. targetnode a = n", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a = n\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> n' controls n\n 2. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "with \\<open>inner_node n\\<close> \\<open>\\<not> method_exit n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  \\<not> method_exit n\n  targetnode a = n", "have \"n postdominates (targetnode a)\""], ["proof (prove)\nusing this:\n  inner_node n\n  \\<not> method_exit n\n  targetnode a = n\n\ngoal (1 subgoal):\n 1. n postdominates targetnode a", "by(fastforce dest:inner_is_valid intro:postdominate_refl)"], ["proof (state)\nthis:\n  n postdominates targetnode a\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> n' controls n\n 2. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "with \\<open>\\<not> n postdominates (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> n postdominates targetnode a\n  n postdominates targetnode a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n postdominates targetnode a\n  n postdominates targetnode a\n\ngoal (1 subgoal):\n 1. n' controls n", "by simp"], ["proof (state)\nthis:\n  n' controls n\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "with \\<open>nx -as@a#as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  nx -as @ a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' \\<noteq> []", "have \"targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\""], ["proof (prove)\nusing this:\n  nx -as @ a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n", "by(fastforce intro:path_split simp:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "with \\<open>\\<not> n postdominates (targetnode a)\\<close> \\<open>valid_edge a\\<close> \\<open>inner_node n\\<close>\n        \\<open>targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  \\<not> n postdominates targetnode a\n  valid_edge a\n  inner_node n\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n", "obtain asx pex where \"targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\"\n        and \"n \\<notin> set (sourcenodes asx)\""], ["proof (prove)\nusing this:\n  \\<not> n postdominates targetnode a\n  valid_edge a\n  inner_node n\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. (\\<And>asx pex.\n        \\<lbrakk>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex; n \\<notin> set (sourcenodes asx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:inner_is_valid simp:postdominate_def)"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  n \\<notin> set (sourcenodes asx)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> n' controls n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n' controls n", "proof(cases \"\\<exists>asx'. asx = as'@asx'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n\n 2. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "case True"], ["proof (state)\nthis:\n  \\<exists>asx'. asx = as' @ asx'\n\ngoal (2 subgoals):\n 1. \\<exists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n\n 2. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "then"], ["proof (chain)\npicking this:\n  \\<exists>asx'. asx = as' @ asx'", "obtain asx' where [simp]:\"asx = as'@asx'\""], ["proof (prove)\nusing this:\n  \\<exists>asx'. asx = as' @ asx'\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        asx = as' @ asx' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  asx = as' @ asx'\n\ngoal (2 subgoals):\n 1. \\<exists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n\n 2. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close> \\<open>targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close>\n          \\<open>as' \\<noteq> []\\<close> \\<open>method_exit pex\\<close> \\<open>\\<not> method_exit n\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' \\<noteq> []\n  method_exit pex\n  \\<not> method_exit n", "obtain a'' as'' where \"asx' = a''#as'' \\<and> sourcenode a'' = n\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' \\<noteq> []\n  method_exit pex\n  \\<not> method_exit n\n\ngoal (1 subgoal):\n 1. (\\<And>a'' as''.\n        asx' = a'' # as'' \\<and> sourcenode a'' = n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases asx')(auto dest:path_split path_det simp:intra_path_def)"], ["proof (state)\nthis:\n  asx' = a'' # as'' \\<and> sourcenode a'' = n\n\ngoal (2 subgoals):\n 1. \\<exists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n\n 2. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "hence \"n \\<in> set(sourcenodes asx)\""], ["proof (prove)\nusing this:\n  asx' = a'' # as'' \\<and> sourcenode a'' = n\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n \\<in> set (sourcenodes asx)\n\ngoal (2 subgoals):\n 1. \\<exists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n\n 2. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "with \\<open>n \\<notin> set (sourcenodes asx)\\<close>"], ["proof (chain)\npicking this:\n  n \\<notin> set (sourcenodes asx)\n  n \\<in> set (sourcenodes asx)", "have False"], ["proof (prove)\nusing this:\n  n \\<notin> set (sourcenodes asx)\n  n \\<in> set (sourcenodes asx)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<exists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n\n 2. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n' controls n", "by simp"], ["proof (state)\nthis:\n  n' controls n\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "case False"], ["proof (state)\nthis:\n  \\<nexists>asx'. asx = as' @ asx'\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "hence \"\\<forall>asx'. asx \\<noteq> as'@asx'\""], ["proof (prove)\nusing this:\n  \\<nexists>asx'. asx = as' @ asx'\n\ngoal (1 subgoal):\n 1. \\<forall>asx'. asx \\<noteq> as' @ asx'", "by simp"], ["proof (state)\nthis:\n  \\<forall>asx'. asx \\<noteq> as' @ asx'\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "then"], ["proof (chain)\npicking this:\n  \\<forall>asx'. asx \\<noteq> as' @ asx'", "obtain j asx' where \"asx = (take j as')@asx'\"\n          and \"j < length as'\" and \"\\<forall>k > j. \\<forall>asx''. asx \\<noteq> (take k as')@asx''\""], ["proof (prove)\nusing this:\n  \\<forall>asx'. asx \\<noteq> as' @ asx'\n\ngoal (1 subgoal):\n 1. (\\<And>j asx'.\n        \\<lbrakk>asx = take j as' @ asx'; j < length as';\n         \\<forall>k>j.\n            \\<forall>asx''. asx \\<noteq> take k as' @ asx''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:path_split_general)"], ["proof (state)\nthis:\n  asx = take j as' @ asx'\n  j < length as'\n  \\<forall>k>j. \\<forall>asx''. asx \\<noteq> take k as' @ asx''\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>asx = (take j as')@asx'\\<close> \\<open>j < length as'\\<close>"], ["proof (chain)\npicking this:\n  asx = take j as' @ asx'\n  j < length as'", "have \"\\<exists>as'1 as'2. asx = as'1@asx' \\<and> \n          as' = as'1@as'2 \\<and> as'2 \\<noteq> [] \\<and> as'1 = take j as'\""], ["proof (prove)\nusing this:\n  asx = take j as' @ asx'\n  j < length as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'1 as'2.\n       asx = as'1 @ asx' \\<and>\n       as' = as'1 @ as'2 \\<and> as'2 \\<noteq> [] \\<and> as'1 = take j as'", "by simp(rule_tac x= \"drop j as'\" in exI,simp)"], ["proof (state)\nthis:\n  \\<exists>as'1 as'2.\n     asx = as'1 @ asx' \\<and>\n     as' = as'1 @ as'2 \\<and> as'2 \\<noteq> [] \\<and> as'1 = take j as'\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'1 as'2.\n     asx = as'1 @ asx' \\<and>\n     as' = as'1 @ as'2 \\<and> as'2 \\<noteq> [] \\<and> as'1 = take j as'", "obtain as'1 as'' where \"asx = as'1@asx'\"\n          and \"as'1 = take j as'\"\n          and \"as' = as'1@as''\" and \"as'' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>as'1 as'2.\n     asx = as'1 @ asx' \\<and>\n     as' = as'1 @ as'2 \\<and> as'2 \\<noteq> [] \\<and> as'1 = take j as'\n\ngoal (1 subgoal):\n 1. (\\<And>as'1 as''.\n        \\<lbrakk>asx = as'1 @ asx'; as'1 = take j as'; as' = as'1 @ as'';\n         as'' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  asx = as'1 @ asx'\n  as'1 = take j as'\n  as' = as'1 @ as''\n  as'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>as' = as'1@as''\\<close> \\<open>as'' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as' = as'1 @ as''\n  as'' \\<noteq> []", "obtain a1 as'2 \n          where \"as' = as'1@a1#as'2\" and \"as'' = a1#as'2\""], ["proof (prove)\nusing this:\n  as' = as'1 @ as''\n  as'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a1 as'2.\n        \\<lbrakk>as' = as'1 @ a1 # as'2; as'' = a1 # as'2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases as'') auto"], ["proof (state)\nthis:\n  as' = as'1 @ a1 # as'2\n  as'' = a1 # as'2\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "have \"asx' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asx' \\<noteq> []", "proof(cases \"asx' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "case True"], ["proof (state)\nthis:\n  asx' = []\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "with \\<open>asx = as'1@asx'\\<close> \\<open>as' = as'1@as''\\<close> \\<open>as'' = a1#as'2\\<close>"], ["proof (chain)\npicking this:\n  asx = as'1 @ asx'\n  as' = as'1 @ as''\n  as'' = a1 # as'2\n  asx' = []", "have \"as' = asx@a1#as'2\""], ["proof (prove)\nusing this:\n  asx = as'1 @ asx'\n  as' = as'1 @ as''\n  as'' = a1 # as'2\n  asx' = []\n\ngoal (1 subgoal):\n 1. as' = asx @ a1 # as'2", "by simp"], ["proof (state)\nthis:\n  as' = asx @ a1 # as'2\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "with \\<open>n' -a#as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' = asx @ a1 # as'2", "have \"n' -(a#asx)@a1#as'2\\<rightarrow>\\<^sub>\\<iota>* n\""], ["proof (prove)\nusing this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' = asx @ a1 # as'2\n\ngoal (1 subgoal):\n 1. n' -(a # asx) @ a1 # as'2\\<rightarrow>\\<^sub>\\<iota>* n", "by simp"], ["proof (state)\nthis:\n  n' -(a # asx) @ a1 # as'2\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "hence \"n' -(a#asx)@a1#as'2\\<rightarrow>* n\" \n            and \"\\<forall>ax \\<in> set((a#asx)@a1#as'2). intra_kind(kind ax)\""], ["proof (prove)\nusing this:\n  n' -(a # asx) @ a1 # as'2\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. n' -(a # asx) @ a1 # as'2\\<rightarrow>* n &&&\n    \\<forall>ax\\<in>set ((a # asx) @ a1 # as'2). intra_kind (kind ax)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  n' -(a # asx) @ a1 # as'2\\<rightarrow>* n\n  \\<forall>ax\\<in>set ((a # asx) @ a1 # as'2). intra_kind (kind ax)\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "from \\<open>n' -(a#asx)@a1#as'2\\<rightarrow>* n\\<close>"], ["proof (chain)\npicking this:\n  n' -(a # asx) @ a1 # as'2\\<rightarrow>* n", "have \"n' -a#asx\\<rightarrow>* sourcenode a1\" and \"valid_edge a1\""], ["proof (prove)\nusing this:\n  n' -(a # asx) @ a1 # as'2\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. n' -a # asx\\<rightarrow>* sourcenode a1 &&& valid_edge a1", "by -(erule path_split)+"], ["proof (state)\nthis:\n  n' -a # asx\\<rightarrow>* sourcenode a1\n  valid_edge a1\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "from \\<open>\\<forall>ax \\<in> set((a#asx)@a1#as'2). intra_kind(kind ax)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ax\\<in>set ((a # asx) @ a1 # as'2). intra_kind (kind ax)", "have \"\\<forall>ax \\<in> set(a#asx). intra_kind(kind ax)\""], ["proof (prove)\nusing this:\n  \\<forall>ax\\<in>set ((a # asx) @ a1 # as'2). intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<forall>ax\\<in>set (a # asx). intra_kind (kind ax)", "by simp"], ["proof (state)\nthis:\n  \\<forall>ax\\<in>set (a # asx). intra_kind (kind ax)\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "with \\<open>n' -a#asx\\<rightarrow>* sourcenode a1\\<close>"], ["proof (chain)\npicking this:\n  n' -a # asx\\<rightarrow>* sourcenode a1\n  \\<forall>ax\\<in>set (a # asx). intra_kind (kind ax)", "have \"n' -a#asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\""], ["proof (prove)\nusing this:\n  n' -a # asx\\<rightarrow>* sourcenode a1\n  \\<forall>ax\\<in>set (a # asx). intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "hence \"targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\""], ["proof (prove)\nusing this:\n  n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (1 subgoal):\n 1. targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1", "by(fastforce intro:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "with \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1", "have \"pex = sourcenode a1\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (1 subgoal):\n 1. pex = sourcenode a1", "by(fastforce intro:path_det simp:intra_path_def)"], ["proof (state)\nthis:\n  pex = sourcenode a1\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "from \\<open>\\<forall>ax \\<in> set((a#asx)@a1#as'2). intra_kind(kind ax)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ax\\<in>set ((a # asx) @ a1 # as'2). intra_kind (kind ax)", "have \"intra_kind (kind a1)\""], ["proof (prove)\nusing this:\n  \\<forall>ax\\<in>set ((a # asx) @ a1 # as'2). intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a1)", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a1)\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "from \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  method_exit pex", "have False"], ["proof (prove)\nusing this:\n  method_exit pex\n\ngoal (1 subgoal):\n 1. False", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"pex = (_Exit_)\""], ["proof (state)\nthis:\n  pex = (_Exit_)\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>pex = sourcenode a1\\<close>"], ["proof (chain)\npicking this:\n  pex = sourcenode a1\n  pex = (_Exit_)", "have \"sourcenode a1 = (_Exit_)\""], ["proof (prove)\nusing this:\n  pex = sourcenode a1\n  pex = (_Exit_)\n\ngoal (1 subgoal):\n 1. sourcenode a1 = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a1 = (_Exit_)\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a1\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a1\n  sourcenode a1 = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  valid_edge a1\n  sourcenode a1 = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "fix a Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"pex = sourcenode a\" and \"valid_edge a\"\n              and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  pex = sourcenode a\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>pex = sourcenode a\\<close> \n              \\<open>pex = sourcenode a1\\<close> \\<open>valid_edge a1\\<close> \\<open>intra_kind (kind a1)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  pex = sourcenode a\n  pex = sourcenode a1\n  valid_edge a1\n  intra_kind (kind a1)", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  pex = sourcenode a\n  pex = sourcenode a1\n  valid_edge a1\n  intra_kind (kind a1)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. asx' = [] \\<Longrightarrow> asx' \\<noteq> []\n 2. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. asx' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  asx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. asx' \\<noteq> [] \\<Longrightarrow> asx' \\<noteq> []", "qed simp"], ["proof (state)\nthis:\n  asx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "with \\<open>asx = as'1@asx'\\<close>"], ["proof (chain)\npicking this:\n  asx = as'1 @ asx'\n  asx' \\<noteq> []", "obtain a2 asx'1 \n          where \"asx = as'1@a2#asx'1\"\n          and \"asx' = a2#asx'1\""], ["proof (prove)\nusing this:\n  asx = as'1 @ asx'\n  asx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a2 asx'1.\n        \\<lbrakk>asx = as'1 @ a2 # asx'1; asx' = a2 # asx'1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases asx') auto"], ["proof (state)\nthis:\n  asx = as'1 @ a2 # asx'1\n  asx' = a2 # asx'1\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>n' -a#as'\\<rightarrow>\\<^sub>\\<iota>* n\\<close> \\<open>as' = as'1@a1#as'2\\<close>"], ["proof (chain)\npicking this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' = as'1 @ a1 # as'2", "have \"n' -(a#as'1)@a1#as'2\\<rightarrow>\\<^sub>\\<iota>* n\""], ["proof (prove)\nusing this:\n  n' -a # as'\\<rightarrow>\\<^sub>\\<iota>* n\n  as' = as'1 @ a1 # as'2\n\ngoal (1 subgoal):\n 1. n' -(a # as'1) @ a1 # as'2\\<rightarrow>\\<^sub>\\<iota>* n", "by simp"], ["proof (state)\nthis:\n  n' -(a # as'1) @ a1 # as'2\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "hence \"n' -(a#as'1)@a1#as'2\\<rightarrow>* n\" \n          and \"\\<forall>ax \\<in> set((a#as'1)@a1#as'2). intra_kind(kind ax)\""], ["proof (prove)\nusing this:\n  n' -(a # as'1) @ a1 # as'2\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. n' -(a # as'1) @ a1 # as'2\\<rightarrow>* n &&&\n    \\<forall>ax\\<in>set ((a # as'1) @ a1 # as'2). intra_kind (kind ax)", "by(simp_all add: intra_path_def)"], ["proof (state)\nthis:\n  n' -(a # as'1) @ a1 # as'2\\<rightarrow>* n\n  \\<forall>ax\\<in>set ((a # as'1) @ a1 # as'2). intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>n' -(a#as'1)@a1#as'2\\<rightarrow>* n\\<close>"], ["proof (chain)\npicking this:\n  n' -(a # as'1) @ a1 # as'2\\<rightarrow>* n", "have \"n' -a#as'1\\<rightarrow>* sourcenode a1\"\n          and \"valid_edge a1\""], ["proof (prove)\nusing this:\n  n' -(a # as'1) @ a1 # as'2\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. n' -a # as'1\\<rightarrow>* sourcenode a1 &&& valid_edge a1", "by -(erule path_split)+"], ["proof (state)\nthis:\n  n' -a # as'1\\<rightarrow>* sourcenode a1\n  valid_edge a1\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>\\<forall>ax \\<in> set((a#as'1)@a1#as'2). intra_kind(kind ax)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ax\\<in>set ((a # as'1) @ a1 # as'2). intra_kind (kind ax)", "have \"\\<forall>ax \\<in> set(a#as'1). intra_kind(kind ax)\""], ["proof (prove)\nusing this:\n  \\<forall>ax\\<in>set ((a # as'1) @ a1 # as'2). intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<forall>ax\\<in>set (a # as'1). intra_kind (kind ax)", "by simp"], ["proof (state)\nthis:\n  \\<forall>ax\\<in>set (a # as'1). intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "with \\<open>n' -a#as'1\\<rightarrow>* sourcenode a1\\<close>"], ["proof (chain)\npicking this:\n  n' -a # as'1\\<rightarrow>* sourcenode a1\n  \\<forall>ax\\<in>set (a # as'1). intra_kind (kind ax)", "have \"n' -a#as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\""], ["proof (prove)\nusing this:\n  n' -a # as'1\\<rightarrow>* sourcenode a1\n  \\<forall>ax\\<in>set (a # as'1). intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. n' -a # as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  n' -a # as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "hence \"targetnode a -as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\""], ["proof (prove)\nusing this:\n  n' -a # as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (1 subgoal):\n 1. targetnode a -as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1", "by(fastforce intro:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a -as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close> \\<open>asx = as'1@a2#asx'1\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = as'1 @ a2 # asx'1", "have \"targetnode a -as'1@a2#asx'1\\<rightarrow>* pex\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = as'1 @ a2 # asx'1\n\ngoal (1 subgoal):\n 1. targetnode a -as'1 @ a2 # asx'1\\<rightarrow>* pex", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a -as'1 @ a2 # asx'1\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "hence \"targetnode a -as'1\\<rightarrow>* sourcenode a2\" and \"valid_edge a2\"\n          and \"targetnode a2 -asx'1\\<rightarrow>* pex\""], ["proof (prove)\nusing this:\n  targetnode a -as'1 @ a2 # asx'1\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. targetnode a -as'1\\<rightarrow>* sourcenode a2 &&&\n    valid_edge a2 &&& targetnode a2 -asx'1\\<rightarrow>* pex", "by(auto intro:path_split)"], ["proof (state)\nthis:\n  targetnode a -as'1\\<rightarrow>* sourcenode a2\n  valid_edge a2\n  targetnode a2 -asx'1\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>targetnode a2 -asx'1\\<rightarrow>* pex\\<close> \\<open>asx = as'1@a2#asx'1\\<close>\n          \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  targetnode a2 -asx'1\\<rightarrow>* pex\n  asx = as'1 @ a2 # asx'1\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"targetnode a2 -asx'1\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  targetnode a2 -asx'1\\<rightarrow>* pex\n  asx = as'1 @ a2 # asx'1\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. targetnode a2 -asx'1\\<rightarrow>\\<^sub>\\<iota>* pex", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a2 -asx'1\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>targetnode a -as'1\\<rightarrow>* sourcenode a2\\<close> \n          \\<open>targetnode a -as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as'1\\<rightarrow>* sourcenode a2\n  targetnode a -as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1", "have \"sourcenode a1 = sourcenode a2\""], ["proof (prove)\nusing this:\n  targetnode a -as'1\\<rightarrow>* sourcenode a2\n  targetnode a -as'1\\<rightarrow>\\<^sub>\\<iota>* sourcenode a1\n\ngoal (1 subgoal):\n 1. sourcenode a1 = sourcenode a2", "by(fastforce intro:path_det simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a1 = sourcenode a2\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>asx = as'1@a2#asx'1\\<close> \\<open>n \\<notin> set (sourcenodes asx)\\<close>"], ["proof (chain)\npicking this:\n  asx = as'1 @ a2 # asx'1\n  n \\<notin> set (sourcenodes asx)", "have \"n \\<notin> set (sourcenodes asx'1)\""], ["proof (prove)\nusing this:\n  asx = as'1 @ a2 # asx'1\n  n \\<notin> set (sourcenodes asx)\n\ngoal (1 subgoal):\n 1. n \\<notin> set (sourcenodes asx'1)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n \\<notin> set (sourcenodes asx'1)\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "with \\<open>targetnode a2 -asx'1\\<rightarrow>\\<^sub>\\<iota>* pex\\<close> \\<open>method_exit pex\\<close>\n          \\<open>asx = as'1@a2#asx'1\\<close>"], ["proof (chain)\npicking this:\n  targetnode a2 -asx'1\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  asx = as'1 @ a2 # asx'1\n  n \\<notin> set (sourcenodes asx'1)", "have \"\\<not> n postdominates targetnode a2\""], ["proof (prove)\nusing this:\n  targetnode a2 -asx'1\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  asx = as'1 @ a2 # asx'1\n  n \\<notin> set (sourcenodes asx'1)\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates targetnode a2", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  \\<not> n postdominates targetnode a2\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>asx = as'1@a2#asx'1\\<close> \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  asx = as'1 @ a2 # asx'1\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"intra_kind (kind a2)\""], ["proof (prove)\nusing this:\n  asx = as'1 @ a2 # asx'1\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. intra_kind (kind a2)", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  intra_kind (kind a2)\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "from \\<open>as' = as'1@a1#as'2\\<close>"], ["proof (chain)\npicking this:\n  as' = as'1 @ a1 # as'2", "have \"a1 \\<in> set as'\""], ["proof (prove)\nusing this:\n  as' = as'1 @ a1 # as'2\n\ngoal (1 subgoal):\n 1. a1 \\<in> set as'", "by simp"], ["proof (state)\nthis:\n  a1 \\<in> set as'\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "with \\<open>sourcenode a1 = sourcenode a2\\<close> last \\<open>valid_edge a2\\<close> \n          \\<open>intra_kind (kind a2)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a1 = sourcenode a2\n  \\<forall>ax ax'.\n     ax \\<in> set as' \\<and>\n     sourcenode ax = sourcenode ax' \\<and>\n     valid_edge ax' \\<and> intra_kind (kind ax') \\<longrightarrow>\n     n postdominates targetnode ax'\n  valid_edge a2\n  intra_kind (kind a2)\n  a1 \\<in> set as'", "have \"n postdominates targetnode a2\""], ["proof (prove)\nusing this:\n  sourcenode a1 = sourcenode a2\n  \\<forall>ax ax'.\n     ax \\<in> set as' \\<and>\n     sourcenode ax = sourcenode ax' \\<and>\n     valid_edge ax' \\<and> intra_kind (kind ax') \\<longrightarrow>\n     n postdominates targetnode ax'\n  valid_edge a2\n  intra_kind (kind a2)\n  a1 \\<in> set as'\n\ngoal (1 subgoal):\n 1. n postdominates targetnode a2", "by blast"], ["proof (state)\nthis:\n  n postdominates targetnode a2\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "with \\<open>\\<not> n postdominates targetnode a2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> n postdominates targetnode a2\n  n postdominates targetnode a2", "have False"], ["proof (prove)\nusing this:\n  \\<not> n postdominates targetnode a2\n  n postdominates targetnode a2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>asx'. asx = as' @ asx' \\<Longrightarrow> n' controls n", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n' controls n", "by simp"], ["proof (state)\nthis:\n  n' controls n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' controls n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' controls n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' controls n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>SDG without summary edges\\<close>"], ["", "inductive cdep_edge :: \"'node SDG_node \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n    (\"_ \\<longrightarrow>\\<^bsub>cd\\<^esub> _\" [51,0] 80)\n  and ddep_edge :: \"'node SDG_node \\<Rightarrow> 'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n    (\"_ -_\\<rightarrow>\\<^sub>d\\<^sub>d _\" [51,0,0] 80)\n  and call_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n    (\"_ -_\\<rightarrow>\\<^bsub>call\\<^esub> _\" [51,0,0] 80)\n  and return_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n    (\"_ -_\\<rightarrow>\\<^bsub>ret\\<^esub> _\" [51,0,0] 80)\n  and param_in_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n    (\"_ -_:_\\<rightarrow>\\<^bsub>in\\<^esub> _\" [51,0,0,0] 80)\n  and param_out_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n    (\"_ -_:_\\<rightarrow>\\<^bsub>out\\<^esub> _\" [51,0,0,0] 80)\n  and SDG_edge :: \"'node SDG_node \\<Rightarrow> 'var option \\<Rightarrow> \n                          ('pname \\<times> bool) option \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n\nwhere\n    (* Syntax *)\n  \"n \\<longrightarrow>\\<^bsub>cd\\<^esub> n' == SDG_edge n None None n'\"\n  | \"n -V\\<rightarrow>\\<^sub>d\\<^sub>d n' == SDG_edge n (Some V) None n'\"\n  | \"n -p\\<rightarrow>\\<^bsub>call\\<^esub> n' == SDG_edge n None (Some(p,True)) n'\"\n  | \"n -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' == SDG_edge n None (Some(p,False)) n'\"\n  | \"n -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n' == SDG_edge n (Some V) (Some(p,True)) n'\"\n  | \"n -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n' == SDG_edge n (Some V) (Some(p,False)) n'\"\n\n    (* Rules *)\n  | SDG_cdep_edge:\n    \"\\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m'\\<rbrakk> \\<Longrightarrow> n \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\"\n  | SDG_proc_entry_exit_cdep:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; n = CFG_node (targetnode a);\n      a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk> \\<Longrightarrow> n \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\"\n  | SDG_parent_cdep_edge:\n    \"\\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m; n \\<noteq> n'\\<rbrakk> \n      \\<Longrightarrow> n \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\"\n  | SDG_ddep_edge:\"n influences V in n' \\<Longrightarrow> n -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\"\n  | SDG_call_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; n = CFG_node (sourcenode a); \n      n' = CFG_node (targetnode a)\\<rbrakk> \\<Longrightarrow> n -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\"\n  | SDG_return_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; n = CFG_node (sourcenode a); \n      n' = CFG_node (targetnode a)\\<rbrakk> \\<Longrightarrow> n -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\"\n  | SDG_param_in_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; (p,ins,outs) \\<in> set procs; V = ins!x;\n      x < length ins; n = Actual_in (sourcenode a,x); n' = Formal_in (targetnode a,x)\\<rbrakk>\n      \\<Longrightarrow> n -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\"\n  | SDG_param_out_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; (p,ins,outs) \\<in> set procs; V = outs!x;\n      x < length outs; n = Formal_out (sourcenode a,x); \n      n' = Actual_out (targetnode a,x)\\<rbrakk>\n      \\<Longrightarrow> n -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\""], ["", "lemma cdep_edge_cases:\n  \"\\<lbrakk>n \\<longrightarrow>\\<^bsub>cd\\<^esub> n'; (parent_node n) controls (parent_node n') \\<Longrightarrow> P;\n    \\<And>a Q r p fs a'. \\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a;\n                  parent_node n = targetnode a; parent_node n' = sourcenode a'\\<rbrakk> \\<Longrightarrow> P;\n    \\<And>m. \\<lbrakk>n = CFG_node m; m = parent_node n'; n \\<noteq> n'\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n     parent_node n controls parent_node n' \\<Longrightarrow> P;\n     \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a; parent_node n = targetnode a;\n         parent_node n' = sourcenode a'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>m.\n        \\<lbrakk>n = CFG_node m; m = parent_node n'; n \\<noteq> n'\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by -(erule SDG_edge.cases,auto)"], ["", "lemma SDG_edge_valid_SDG_node:\n  assumes \"SDG_edge n Vopt popt n'\" \n  shows \"valid_SDG_node n\" and \"valid_SDG_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "using \\<open>SDG_edge n Vopt popt n'\\<close>"], ["proof (prove)\nusing this:\n  SDG_edge n Vopt popt n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "proof(induct rule:SDG_edge.induct)"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q r p fs n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 16 subgoals...", "case (SDG_cdep_edge n m n' m')"], ["proof (state)\nthis:\n  n = CFG_node m\n  n' = CFG_node m'\n  m controls m'\n\ngoal (16 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q r p fs n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 16 subgoals...", "thus \"valid_SDG_node n\" \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n = CFG_node m\n  n' = CFG_node m'\n  m controls m'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "by(fastforce elim:control_dependence_path elim:path_valid_node \n                simp:intra_path_def)+"], ["proof (state)\nthis:\n  valid_SDG_node n\n  valid_SDG_node n'\n\ngoal (14 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q p f n n'.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q p f n n'.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 14 subgoals...", "case (SDG_proc_entry_exit_cdep a Q r p f n a' n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  n = CFG_node (targetnode a)\n  a' \\<in> get_return_edges a\n  n' = CFG_node (sourcenode a')\n\ngoal (14 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q p f n n'.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 14 subgoals...", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (14 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q p f n n'.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 14 subgoals...", "from \\<open>valid_edge a\\<close> \\<open>n = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = CFG_node (targetnode a)", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  n = CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n\nA total of 13 subgoals...", "case (SDG_proc_entry_exit_cdep a Q r p f n a' n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  n = CFG_node (targetnode a)\n  a' \\<in> get_return_edges a\n  n' = CFG_node (sourcenode a')\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n\nA total of 13 subgoals...", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n\nA total of 13 subgoals...", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 5. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 7. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 9. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n\nA total of 13 subgoals...", "with \\<open>n' = CFG_node (sourcenode a')\\<close>"], ["proof (chain)\npicking this:\n  n' = CFG_node (sourcenode a')\n  valid_edge a'", "show ?case"], ["proof (prove)\nusing this:\n  n' = CFG_node (sourcenode a')\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (12 subgoals):\n 1. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 12 subgoals...", "case (SDG_ddep_edge n V n')"], ["proof (state)\nthis:\n  n influences V in n'\n\ngoal (12 subgoals):\n 1. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>n V n'. n influences V in n' \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q r p fs ins outs V x n n'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n         n = Actual_in (sourcenode a, x);\n         n' = Formal_in (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'\nA total of 12 subgoals...", "thus \"valid_SDG_node n\" \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n influences V in n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "by(auto intro:in_Use_valid_SDG_node in_Def_valid_SDG_node\n             simp:data_dependence_def)"], ["proof (state)\nthis:\n  valid_SDG_node n\n  valid_SDG_node n'\n\ngoal (10 subgoals):\n 1. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 2. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 3. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 4. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 5. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 6. \\<And>a Q p f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 8. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n'\n 9. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n\n 10. \\<And>a Q p f ins outs V x n n'.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n         n = Formal_out (sourcenode a, x);\n         n' = Actual_out (targetnode a, x)\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n'", "qed(fastforce intro:valid_SDG_CFG_node)+"], ["", "lemma valid_SDG_node_cases: \n  assumes \"valid_SDG_node n\"\n  shows \"n = CFG_node (parent_node n) \\<or> CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = CFG_node (parent_node n) \\<or>\n    CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "proof(cases n)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       n = CFG_node x1 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x2.\n       n = Formal_in x2 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 4. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 5. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "case (CFG_node m)"], ["proof (state)\nthis:\n  n = CFG_node m\n\ngoal (5 subgoals):\n 1. \\<And>x1.\n       n = CFG_node x1 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x2.\n       n = Formal_in x2 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 4. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 5. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = CFG_node m\n\ngoal (1 subgoal):\n 1. n = CFG_node (parent_node n) \\<or>\n    CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by simp"], ["proof (state)\nthis:\n  n = CFG_node (parent_node n) \\<or>\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (4 subgoals):\n 1. \\<And>x2.\n       n = Formal_in x2 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 4. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       n = Formal_in x2 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 4. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "case (Formal_in z)"], ["proof (state)\nthis:\n  n = Formal_in z\n\ngoal (4 subgoals):\n 1. \\<And>x2.\n       n = Formal_in x2 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 4. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "from \\<open>n = Formal_in z\\<close>"], ["proof (chain)\npicking this:\n  n = Formal_in z", "obtain m x where \"z = (m,x)\""], ["proof (prove)\nusing this:\n  n = Formal_in z\n\ngoal (1 subgoal):\n 1. (\\<And>m x. z = (m, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = (m, x)\n\ngoal (4 subgoals):\n 1. \\<And>x2.\n       n = Formal_in x2 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 4. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "with \\<open>valid_SDG_node n\\<close> \\<open>n = Formal_in z\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_in z\n  z = (m, x)", "have \"CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_in z\n  z = (m, x)\n\ngoal (1 subgoal):\n 1. CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by -(rule SDG_parent_cdep_edge,auto)"], ["proof (state)\nthis:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (4 subgoals):\n 1. \\<And>x2.\n       n = Formal_in x2 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 4. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. n = CFG_node (parent_node n) \\<or>\n    CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by fastforce"], ["proof (state)\nthis:\n  n = CFG_node (parent_node n) \\<or>\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "case (Formal_out z)"], ["proof (state)\nthis:\n  n = Formal_out z\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "from \\<open>n = Formal_out z\\<close>"], ["proof (chain)\npicking this:\n  n = Formal_out z", "obtain m x where \"z = (m,x)\""], ["proof (prove)\nusing this:\n  n = Formal_out z\n\ngoal (1 subgoal):\n 1. (\\<And>m x. z = (m, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = (m, x)\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "with \\<open>valid_SDG_node n\\<close> \\<open>n = Formal_out z\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Formal_out z\n  z = (m, x)", "have \"CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Formal_out z\n  z = (m, x)\n\ngoal (1 subgoal):\n 1. CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by -(rule SDG_parent_cdep_edge,auto)"], ["proof (state)\nthis:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       n = Formal_out x3 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 3. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. n = CFG_node (parent_node n) \\<or>\n    CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by fastforce"], ["proof (state)\nthis:\n  n = CFG_node (parent_node n) \\<or>\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (2 subgoals):\n 1. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "case (Actual_in z)"], ["proof (state)\nthis:\n  n = Actual_in z\n\ngoal (2 subgoals):\n 1. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "from \\<open>n = Actual_in z\\<close>"], ["proof (chain)\npicking this:\n  n = Actual_in z", "obtain m x where \"z = (m,x)\""], ["proof (prove)\nusing this:\n  n = Actual_in z\n\ngoal (1 subgoal):\n 1. (\\<And>m x. z = (m, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = (m, x)\n\ngoal (2 subgoals):\n 1. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "with \\<open>valid_SDG_node n\\<close> \\<open>n = Actual_in z\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_in z\n  z = (m, x)", "have \"CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_in z\n  z = (m, x)\n\ngoal (1 subgoal):\n 1. CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by -(rule SDG_parent_cdep_edge,auto)"], ["proof (state)\nthis:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (2 subgoals):\n 1. \\<And>x4.\n       n = Actual_in x4 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n 2. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. n = CFG_node (parent_node n) \\<or>\n    CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by fastforce"], ["proof (state)\nthis:\n  n = CFG_node (parent_node n) \\<or>\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "case (Actual_out z)"], ["proof (state)\nthis:\n  n = Actual_out z\n\ngoal (1 subgoal):\n 1. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "from \\<open>n = Actual_out z\\<close>"], ["proof (chain)\npicking this:\n  n = Actual_out z", "obtain m x where \"z = (m,x)\""], ["proof (prove)\nusing this:\n  n = Actual_out z\n\ngoal (1 subgoal):\n 1. (\\<And>m x. z = (m, x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases z) auto"], ["proof (state)\nthis:\n  z = (m, x)\n\ngoal (1 subgoal):\n 1. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "with \\<open>valid_SDG_node n\\<close> \\<open>n = Actual_out z\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = Actual_out z\n  z = (m, x)", "have \"CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = Actual_out z\n  z = (m, x)\n\ngoal (1 subgoal):\n 1. CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by -(rule SDG_parent_cdep_edge,auto)"], ["proof (state)\nthis:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. \\<And>x5.\n       n = Actual_out x5 \\<Longrightarrow>\n       n = CFG_node (parent_node n) \\<or>\n       CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. n = CFG_node (parent_node n) \\<or>\n    CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by fastforce"], ["proof (state)\nthis:\n  n = CFG_node (parent_node n) \\<or>\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SDG_cdep_edge_CFG_node: \"n \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow> \\<exists>m. n = CFG_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>m. n = CFG_node m", "by(induct n Vopt\\<equiv>\"None::'var option\" popt\\<equiv>\"None::('pname \\<times> bool) option\" n' \n   rule:SDG_edge.induct) auto"], ["", "lemma SDG_call_edge_CFG_node: \"n -p\\<rightarrow>\\<^bsub>call\\<^esub> n' \\<Longrightarrow> \\<exists>m. n = CFG_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -p\\<rightarrow>\\<^bsub>call\\<^esub> n' \\<Longrightarrow>\n    \\<exists>m. n = CFG_node m", "by(induct n Vopt\\<equiv>\"None::'var option\" popt\\<equiv>\"Some(p,True)\" n' \n   rule:SDG_edge.induct) auto"], ["", "lemma SDG_return_edge_CFG_node: \"n -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<Longrightarrow> \\<exists>m. n = CFG_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<Longrightarrow>\n    \\<exists>m. n = CFG_node m", "by(induct n Vopt\\<equiv>\"None::'var option\" popt\\<equiv>\"Some(p,False)\" n' \n   rule:SDG_edge.induct) auto"], ["", "lemma SDG_call_or_param_in_edge_unique_CFG_call_edge:\n  \"SDG_edge n Vopt (Some(p,True)) n'\n  \\<Longrightarrow> \\<exists>!a. valid_edge a \\<and> sourcenode a = parent_node n \\<and> \n          targetnode a = parent_node n' \\<and> (\\<exists>Q r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG_edge n Vopt (Some (p, True)) n' \\<Longrightarrow>\n    \\<exists>!a.\n       valid_edge a \\<and>\n       sourcenode a = parent_node n \\<and>\n       targetnode a = parent_node n' \\<and>\n       (\\<exists>Q r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "proof(induct n Vopt \"Some(p,True)\" n' rule:SDG_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "case (SDG_call_edge a Q r fs n n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "{"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "fix a'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "assume \"valid_edge a'\" and \"sourcenode a' = parent_node n\"\n      and \"targetnode a' = parent_node n'\""], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = parent_node n\n  targetnode a' = parent_node n'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "from \\<open>sourcenode a' = parent_node n\\<close> \\<open>n = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = parent_node n\n  n = CFG_node (sourcenode a)", "have \"sourcenode a' = sourcenode a\""], ["proof (prove)\nusing this:\n  sourcenode a' = parent_node n\n  n = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a' = sourcenode a", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "moreover"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "from \\<open>targetnode a' = parent_node n'\\<close> \\<open>n' = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = parent_node n'\n  n' = CFG_node (targetnode a)", "have \"targetnode a' = targetnode a\""], ["proof (prove)\nusing this:\n  targetnode a' = parent_node n'\n  n' = CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. targetnode a' = targetnode a", "by fastforce"], ["proof (state)\nthis:\n  targetnode a' = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "ultimately"], ["proof (chain)\npicking this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a", "have \"a' = a\""], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n\ngoal (1 subgoal):\n 1. a' = a", "using \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n  valid_edge a'\n  valid_edge a\n\ngoal (1 subgoal):\n 1. a' = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a' = a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "with \\<open>valid_edge a\\<close> \\<open>n = CFG_node (sourcenode a)\\<close> \\<open>n' = CFG_node (targetnode a)\\<close>\n    \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (1 subgoal):\n 1. \\<exists>!a.\n       valid_edge a \\<and>\n       sourcenode a = parent_node n \\<and>\n       targetnode a = parent_node n' \\<and>\n       (\\<exists>Q r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "by(fastforce intro!:ex1I[of _ a])"], ["proof (state)\nthis:\n  \\<exists>!a.\n     valid_edge a \\<and>\n     sourcenode a = parent_node n \\<and>\n     targetnode a = parent_node n' \\<and>\n     (\\<exists>Q r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "case (SDG_param_in_edge a Q r fs ins outs V x n n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V = ins ! x\n  x < length ins\n  n = Actual_in (sourcenode a, x)\n  n' = Formal_in (targetnode a, x)\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "{"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V = ins ! x\n  x < length ins\n  n = Actual_in (sourcenode a, x)\n  n' = Formal_in (targetnode a, x)\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "fix a'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "assume \"valid_edge a'\" and \"sourcenode a' = parent_node n\"\n      and \"targetnode a' = parent_node n'\""], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = parent_node n\n  targetnode a' = parent_node n'\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "from \\<open>sourcenode a' = parent_node n\\<close> \\<open>n = Actual_in (sourcenode a,x)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = parent_node n\n  n = Actual_in (sourcenode a, x)", "have \"sourcenode a' = sourcenode a\""], ["proof (prove)\nusing this:\n  sourcenode a' = parent_node n\n  n = Actual_in (sourcenode a, x)\n\ngoal (1 subgoal):\n 1. sourcenode a' = sourcenode a", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "moreover"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "from \\<open>targetnode a' = parent_node n'\\<close> \\<open>n' = Formal_in (targetnode a,x)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = parent_node n'\n  n' = Formal_in (targetnode a, x)", "have \"targetnode a' = targetnode a\""], ["proof (prove)\nusing this:\n  targetnode a' = parent_node n'\n  n' = Formal_in (targetnode a, x)\n\ngoal (1 subgoal):\n 1. targetnode a' = targetnode a", "by fastforce"], ["proof (state)\nthis:\n  targetnode a' = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "ultimately"], ["proof (chain)\npicking this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a", "have \"a' = a\""], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n\ngoal (1 subgoal):\n 1. a' = a", "using \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n  valid_edge a'\n  valid_edge a\n\ngoal (1 subgoal):\n 1. a' = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a' = a\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (3 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "with \\<open>valid_edge a\\<close> \\<open>n = Actual_in (sourcenode a,x)\\<close> \n    \\<open>n' = Formal_in (targetnode a,x)\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = Actual_in (sourcenode a, x)\n  n' = Formal_in (targetnode a, x)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  n = Actual_in (sourcenode a, x)\n  n' = Formal_in (targetnode a, x)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (1 subgoal):\n 1. \\<exists>!a.\n       valid_edge a \\<and>\n       sourcenode a = parent_node n \\<and>\n       targetnode a = parent_node n' \\<and>\n       (\\<exists>Q r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "by(fastforce intro!:ex1I[of _ a])"], ["proof (state)\nthis:\n  \\<exists>!a.\n     valid_edge a \\<and>\n     sourcenode a = parent_node n \\<and>\n     targetnode a = parent_node n' \\<and>\n     (\\<exists>Q r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (2 subgoals):\n 1. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n 2. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "qed simp_all"], ["", "lemma SDG_return_or_param_out_edge_unique_CFG_return_edge:\n  \"SDG_edge n Vopt (Some(p,False)) n'\n  \\<Longrightarrow> \\<exists>!a. valid_edge a \\<and> sourcenode a = parent_node n \\<and> \n          targetnode a = parent_node n' \\<and> (\\<exists>Q f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG_edge n Vopt (Some (p, False)) n' \\<Longrightarrow>\n    \\<exists>!a.\n       valid_edge a \\<and>\n       sourcenode a = parent_node n \\<and>\n       targetnode a = parent_node n' \\<and>\n       (\\<exists>Q f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "proof(induct n Vopt \"Some(p,False)\" n' rule:SDG_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "case (SDG_return_edge a Q f n n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "{"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "fix a'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "assume \"valid_edge a'\" and \"sourcenode a' = parent_node n\" \n      and \"targetnode a' = parent_node n'\""], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = parent_node n\n  targetnode a' = parent_node n'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "from \\<open>sourcenode a' = parent_node n\\<close> \\<open>n = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = parent_node n\n  n = CFG_node (sourcenode a)", "have \"sourcenode a' = sourcenode a\""], ["proof (prove)\nusing this:\n  sourcenode a' = parent_node n\n  n = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a' = sourcenode a", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "moreover"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "from \\<open>targetnode a' = parent_node n'\\<close> \\<open>n' = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = parent_node n'\n  n' = CFG_node (targetnode a)", "have \"targetnode a' = targetnode a\""], ["proof (prove)\nusing this:\n  targetnode a' = parent_node n'\n  n' = CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. targetnode a' = targetnode a", "by fastforce"], ["proof (state)\nthis:\n  targetnode a' = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "ultimately"], ["proof (chain)\npicking this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a", "have \"a' = a\""], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n\ngoal (1 subgoal):\n 1. a' = a", "using \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n  valid_edge a'\n  valid_edge a\n\ngoal (1 subgoal):\n 1. a' = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a' = a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q f n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 4. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "with \\<open>valid_edge a\\<close> \\<open>n = CFG_node (sourcenode a)\\<close> \\<open>n' = CFG_node (targetnode a)\\<close>\n    \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (1 subgoal):\n 1. \\<exists>!a.\n       valid_edge a \\<and>\n       sourcenode a = parent_node n \\<and>\n       targetnode a = parent_node n' \\<and>\n       (\\<exists>Q f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by(fastforce intro!:ex1I[of _ a])"], ["proof (state)\nthis:\n  \\<exists>!a.\n     valid_edge a \\<and>\n     sourcenode a = parent_node n \\<and>\n     targetnode a = parent_node n' \\<and>\n     (\\<exists>Q f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "case (SDG_param_out_edge a Q f ins outs V x n n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V = outs ! x\n  x < length outs\n  n = Formal_out (sourcenode a, x)\n  n' = Actual_out (targetnode a, x)\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "{"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V = outs ! x\n  x < length outs\n  n = Formal_out (sourcenode a, x)\n  n' = Actual_out (targetnode a, x)\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "fix a'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "assume \"valid_edge a'\" and \"sourcenode a' = parent_node n\"\n      and \"targetnode a' = parent_node n'\""], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = parent_node n\n  targetnode a' = parent_node n'\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "from \\<open>sourcenode a' = parent_node n\\<close> \\<open>n = Formal_out (sourcenode a,x)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = parent_node n\n  n = Formal_out (sourcenode a, x)", "have \"sourcenode a' = sourcenode a\""], ["proof (prove)\nusing this:\n  sourcenode a' = parent_node n\n  n = Formal_out (sourcenode a, x)\n\ngoal (1 subgoal):\n 1. sourcenode a' = sourcenode a", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "moreover"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "from \\<open>targetnode a' = parent_node n'\\<close> \\<open>n' = Actual_out (targetnode a,x)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = parent_node n'\n  n' = Actual_out (targetnode a, x)", "have \"targetnode a' = targetnode a\""], ["proof (prove)\nusing this:\n  targetnode a' = parent_node n'\n  n' = Actual_out (targetnode a, x)\n\ngoal (1 subgoal):\n 1. targetnode a' = targetnode a", "by fastforce"], ["proof (state)\nthis:\n  targetnode a' = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "ultimately"], ["proof (chain)\npicking this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a", "have \"a' = a\""], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n\ngoal (1 subgoal):\n 1. a' = a", "using \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  targetnode a' = targetnode a\n  valid_edge a'\n  valid_edge a\n\ngoal (1 subgoal):\n 1. a' = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a' = a\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 3. \\<And>a Q f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "with \\<open>valid_edge a\\<close> \\<open>n = Formal_out (sourcenode a,x)\\<close>\n    \\<open>n' = Actual_out (targetnode a,x)\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = Formal_out (sourcenode a, x)\n  n' = Actual_out (targetnode a, x)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  n = Formal_out (sourcenode a, x)\n  n' = Actual_out (targetnode a, x)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<lbrakk>valid_edge ?a'2; sourcenode ?a'2 = parent_node n;\n   targetnode ?a'2 = parent_node n'\\<rbrakk>\n  \\<Longrightarrow> ?a'2 = a\n\ngoal (1 subgoal):\n 1. \\<exists>!a.\n       valid_edge a \\<and>\n       sourcenode a = parent_node n \\<and>\n       targetnode a = parent_node n' \\<and>\n       (\\<exists>Q f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by(fastforce intro!:ex1I[of _ a])"], ["proof (state)\nthis:\n  \\<exists>!a.\n     valid_edge a \\<and>\n     sourcenode a = parent_node n \\<and>\n     targetnode a = parent_node n' \\<and>\n     (\\<exists>Q f. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n 2. \\<And>a Q r fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        True = False\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            valid_edge a \\<and>\n                            sourcenode a = parent_node n \\<and>\n                            targetnode a = parent_node n' \\<and>\n                            (\\<exists>Q f.\n                                kind a =\n                                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "qed simp_all"], ["", "lemma Exit_no_SDG_edge_source:\n  \"SDG_edge (CFG_node (_Exit_)) Vopt popt n' \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG_edge (CFG_node (_Exit_)) Vopt popt n' \\<Longrightarrow> False", "proof(induct \"CFG_node (_Exit_)\" Vopt popt n' rule:SDG_edge.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "case (SDG_cdep_edge m n' m')"], ["proof (state)\nthis:\n  CFG_node (_Exit_) = CFG_node m\n  n' = CFG_node m'\n  m controls m'\n\ngoal (8 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(_Exit_) controls m'\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node m\n  n' = CFG_node m'\n  m controls m'\n\ngoal (1 subgoal):\n 1. (_Exit_) controls m'", "by simp"], ["proof (state)\nthis:\n  (_Exit_) controls m'\n\ngoal (8 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  (_Exit_) controls m'\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "case (SDG_proc_entry_exit_cdep a Q r p fs a' n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  CFG_node (_Exit_) = CFG_node (targetnode a)\n  a' \\<in> get_return_edges a\n  n' = CFG_node (sourcenode a')\n\ngoal (7 subgoals):\n 1. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (targetnode a)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (7 subgoals):\n 1. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (7 subgoals):\n 1. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>targetnode a = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (_Exit_)\n  get_proc (targetnode a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by(auto simp:get_proc_Exit)"], ["proof (state)\nthis:\n  p = Main\n\ngoal (7 subgoals):\n 1. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "case (SDG_parent_cdep_edge n' m)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n  m = parent_node n'\n  CFG_node (_Exit_) = CFG_node m\n  CFG_node (_Exit_) \\<noteq> n'\n\ngoal (6 subgoals):\n 1. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node m", "have [simp]:\"m = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node m\n\ngoal (1 subgoal):\n 1. m = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  m = (_Exit_)\n\ngoal (6 subgoals):\n 1. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_SDG_node n'\\<close> \\<open>m = parent_node n'\\<close> \\<open>CFG_node (_Exit_) \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n'\n  m = parent_node n'\n  CFG_node (_Exit_) \\<noteq> n'\n  m = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n  m = parent_node n'\n  CFG_node (_Exit_) \\<noteq> n'\n  m = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule valid_SDG_node_parent_Exit,simp+)"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m;\n        CFG_node (_Exit_) \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "case (SDG_ddep_edge V n')"], ["proof (state)\nthis:\n  CFG_node (_Exit_) influences V in n'\n\ngoal (5 subgoals):\n 1. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(CFG_node (_Exit_)) influences V in n'\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) influences V in n'\n\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) influences V in n'", "by simp"], ["proof (state)\nthis:\n  CFG_node (_Exit_) influences V in n'\n\ngoal (5 subgoals):\n 1. \\<And>V n'. CFG_node (_Exit_) influences V in n' \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "with Exit_empty"], ["proof (chain)\npicking this:\n  Def (_Exit_) = {} \\<and> Use (_Exit_) = {}\n  CFG_node (_Exit_) influences V in n'", "show ?case"], ["proof (prove)\nusing this:\n  Def (_Exit_) = {} \\<and> Use (_Exit_) = {}\n  CFG_node (_Exit_) influences V in n'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:path_Exit_source SDG_Def_parent_Def \n                simp:data_dependence_def intra_path_def)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "case (SDG_call_edge a Q r p fs n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  CFG_node (_Exit_) = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a)", "have \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a = (_Exit_)\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Exit_)", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "case (SDG_return_edge a Q p f n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  CFG_node (_Exit_) = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a)", "have \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a = (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<And>a Q p f n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Exit_)", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False", "qed simp_all"], ["", "subsection \\<open>Intraprocedural paths in the SDG\\<close>"], ["", "inductive intra_SDG_path :: \n  \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n(\"_ i-_\\<rightarrow>\\<^sub>d* _\" [51,0,0] 80) \n\nwhere iSp_Nil:\n  \"valid_SDG_node n \\<Longrightarrow> n i-[]\\<rightarrow>\\<^sub>d* n\"\n\n  | iSp_Append_cdep:\n  \"\\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n''; n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n i-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | iSp_Append_ddep:\n  \"\\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n''; n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk> \\<Longrightarrow> n i-ns@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["", "lemma intra_SDG_path_Append:\n  \"\\<lbrakk>n'' i-ns'\\<rightarrow>\\<^sub>d* n'; n i-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n i-ns@ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' i-ns'\\<rightarrow>\\<^sub>d* n';\n     n i-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n    \\<Longrightarrow> n i-ns @ ns'\\<rightarrow>\\<^sub>d* n'", "by(induct rule:intra_SDG_path.induct,\n   auto intro:intra_SDG_path.intros simp:append_assoc[THEN sym] simp del:append_assoc)"], ["", "lemma intra_SDG_path_valid_SDG_node:\n  assumes \"n i-ns\\<rightarrow>\\<^sub>d* n'\" shows \"valid_SDG_node n\" and \"valid_SDG_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "using \\<open>n i-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (prove)\nusing this:\n  n i-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "by(induct rule:intra_SDG_path.induct,\n   auto intro:SDG_edge_valid_SDG_node valid_SDG_CFG_node)"], ["", "lemma intra_SDG_path_intra_CFG_path:\n  assumes \"n i-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "from \\<open>n i-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n i-ns\\<rightarrow>\\<^sub>d* n'", "show \"\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n i-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(induct rule:intra_SDG_path.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (iSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"valid_node (parent_node n)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n)", "by(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node n)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "hence \"parent_node n -[]\\<rightarrow>* parent_node n\""], ["proof (prove)\nusing this:\n  valid_node (parent_node n)\n\ngoal (1 subgoal):\n 1. parent_node n -[]\\<rightarrow>* parent_node n", "by(rule empty_path)"], ["proof (state)\nthis:\n  parent_node n -[]\\<rightarrow>* parent_node n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -[]\\<rightarrow>* parent_node n\n\ngoal (1 subgoal):\n 1. \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "by(auto simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (iSp_Append_cdep n ns n'' n')"], ["proof (state)\nthis:\n  n i-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "show ?case"], ["proof (prove)\nusing this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(rule cdep_edge_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"parent_node n'' controls parent_node n'\""], ["proof (state)\nthis:\n  parent_node n'' controls parent_node n'\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  parent_node n'' controls parent_node n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" and \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  parent_node n'' controls parent_node n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>parent_node\n                  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         as' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule control_dependence_path)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "fix a Q r p fs a'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a' \\<in> get_return_edges a\"\n        and \"parent_node n'' = targetnode a\" and \"parent_node n' = sourcenode a'\""], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = targetnode a\"\n        and \"targetnode a'' = sourcenode a'\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = targetnode a;\n         targetnode a'' = sourcenode a';\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:intra_proc_additional_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "hence \"targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "by(fastforce dest:path_edge simp:intra_path_def intra_kind_def)"], ["proof (state)\nthis:\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n'' = targetnode a\\<close> \\<open>parent_node n' = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "have \"\\<exists>as'. parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and> as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       parent_node\n        n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n       as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" and \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>parent_node\n                  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         as' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"n'' = CFG_node m\" and \"m = parent_node n'\""], ["proof (state)\nthis:\n  n'' = CFG_node m\n  m = parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' = CFG_node m\n  m = parent_node n'", "show ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' = CFG_node m\n  m = parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (iSp_Append_ddep n ns n'' V n')"], ["proof (state)\nthis:\n  n i-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "have \"n'' influences V in n'\""], ["proof (prove)\nusing this:\n  n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. n'' influences V in n'", "by(fastforce elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  n'' influences V in n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  n'' influences V in n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n'' influences V in n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n         n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:data_dependence_def)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n i-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' -V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Control dependence paths in the SDG\\<close>"], ["", "inductive cdep_SDG_path :: \n  \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n(\"_ cd-_\\<rightarrow>\\<^sub>d* _\" [51,0,0] 80) \n\nwhere cdSp_Nil:\n  \"valid_SDG_node n \\<Longrightarrow> n cd-[]\\<rightarrow>\\<^sub>d* n\"\n\n  | cdSp_Append_cdep:\n  \"\\<lbrakk>n cd-ns\\<rightarrow>\\<^sub>d* n''; n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n cd-ns@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["", "lemma cdep_SDG_path_intra_SDG_path:\n  \"n cd-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n i-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n cd-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n i-ns\\<rightarrow>\\<^sub>d* n'", "by(induct rule:cdep_SDG_path.induct,auto intro:intra_SDG_path.intros)"], ["", "lemma Entry_cdep_SDG_path:\n  assumes \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"inner_node n'\" and \"\\<not> method_exit n'\"\n  obtains ns where \"CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'\"\n  and \"ns \\<noteq> []\" and \"\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n';\n         ns \\<noteq> [];\n         \\<forall>n''\\<in>set ns.\n            parent_node n'' \\<in> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>inner_node n'\\<close> \\<open>\\<not> method_exit n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  inner_node n'\n  \\<not> method_exit n'", "show \"\\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and> ns \\<noteq> [] \\<and>\n    (\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as))\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  inner_node n'\n  \\<not> method_exit n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(induct as arbitrary:n' rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<iota>* x \\<longrightarrow>\n                       inner_node x \\<longrightarrow>\n                       \\<not> method_exit x \\<longrightarrow>\n                       (\\<exists>ns.\n                           CFG_node\n                            (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                             x \\<and>\n                           ns \\<noteq> [] \\<and>\n                           (\\<forall>n''\\<in>set ns.\n                               parent_node n''\n                               \\<in> set (sourcenodes ys))));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'; inner_node n';\n        \\<not> method_exit n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                              n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes xs))", "fix as n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<iota>* x \\<longrightarrow>\n                       inner_node x \\<longrightarrow>\n                       \\<not> method_exit x \\<longrightarrow>\n                       (\\<exists>ns.\n                           CFG_node\n                            (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                             x \\<and>\n                           ns \\<noteq> [] \\<and>\n                           (\\<forall>n''\\<in>set ns.\n                               parent_node n''\n                               \\<in> set (sourcenodes ys))));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'; inner_node n';\n        \\<not> method_exit n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                              n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes xs))", "assume IH:\"\\<forall>as'. length as' < length as \\<longrightarrow>\n      (\\<forall>n''. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow> inner_node n'' \\<longrightarrow> \\<not> method_exit n'' \\<longrightarrow>\n        (\\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and> ns \\<noteq> [] \\<and>\n              (\\<forall>nx\\<in>set ns. parent_node nx \\<in> set (sourcenodes as'))))\"\n      and \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"inner_node n'\" and \"\\<not> method_exit n'\""], ["proof (state)\nthis:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n         inner_node n'' \\<longrightarrow>\n         \\<not> method_exit n'' \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node\n              (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and>\n             ns \\<noteq> [] \\<and>\n             (\\<forall>nx\\<in>set ns.\n                 parent_node nx \\<in> set (sourcenodes as'))))\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  inner_node n'\n  \\<not> method_exit n'\n\ngoal (1 subgoal):\n 1. \\<And>xs n'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<iota>* x \\<longrightarrow>\n                       inner_node x \\<longrightarrow>\n                       \\<not> method_exit x \\<longrightarrow>\n                       (\\<exists>ns.\n                           CFG_node\n                            (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                             x \\<and>\n                           ns \\<noteq> [] \\<and>\n                           (\\<forall>n''\\<in>set ns.\n                               parent_node n''\n                               \\<in> set (sourcenodes ys))));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'; inner_node n';\n        \\<not> method_exit n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                              n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes xs))", "thus \"\\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and> ns \\<noteq> [] \\<and>\n      (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\""], ["proof (prove)\nusing this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n         inner_node n'' \\<longrightarrow>\n         \\<not> method_exit n'' \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node\n              (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and>\n             ns \\<noteq> [] \\<and>\n             (\\<forall>nx\\<in>set ns.\n                 parent_node nx \\<in> set (sourcenodes as'))))\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  inner_node n'\n  \\<not> method_exit n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>as'.\n                length as' < length as \\<longrightarrow>\n                (\\<forall>n''.\n                    (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n                    inner_node n'' \\<longrightarrow>\n                    \\<not> method_exit n'' \\<longrightarrow>\n                    (\\<exists>ns.\n                        CFG_node\n                         (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                          n'' \\<and>\n                        ns \\<noteq> [] \\<and>\n                        (\\<forall>nx\\<in>set ns.\n                            parent_node nx \\<in> set (sourcenodes as'))));\n     (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'; inner_node n';\n     \\<not> method_exit n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         CFG_node\n                          (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                           n' \\<and>\n                         ns \\<noteq> [] \\<and>\n                         (\\<forall>n''\\<in>set ns.\n                             parent_node n'' \\<in> set (sourcenodes as))", "have \"\\<exists>ax asx zs. (_Entry_) -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> n' \\<notin> set (sourcenodes (ax#asx)) \\<and> \n                        as = (ax#asx)@zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "proof(cases \"n' \\<in> set (sourcenodes as)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "case True"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "hence \"\\<exists>n'' \\<in> set(sourcenodes as). n' = n''\""], ["proof (prove)\nusing this:\n  n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>n''\\<in>set (sourcenodes as). n' = n''", "by simp"], ["proof (state)\nthis:\n  \\<exists>n''\\<in>set (sourcenodes as). n' = n''\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "then"], ["proof (chain)\npicking this:\n  \\<exists>n''\\<in>set (sourcenodes as). n' = n''", "obtain ns' ns'' where \"sourcenodes as = ns'@n'#ns''\"\n          and \"\\<forall>n'' \\<in> set ns'. n' \\<noteq> n''\""], ["proof (prove)\nusing this:\n  \\<exists>n''\\<in>set (sourcenodes as). n' = n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>sourcenodes as = ns' @ n' # ns'';\n         \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_first_propE)"], ["proof (state)\nthis:\n  sourcenodes as = ns' @ n' # ns''\n  \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "from \\<open>sourcenodes as = ns'@n'#ns''\\<close>"], ["proof (chain)\npicking this:\n  sourcenodes as = ns' @ n' # ns''", "obtain xs ys ax\n          where \"sourcenodes xs = ns'\" and \"as = xs@ax#ys\"\n          and \"sourcenode ax = n'\""], ["proof (prove)\nusing this:\n  sourcenodes as = ns' @ n' # ns''\n\ngoal (1 subgoal):\n 1. (\\<And>xs ax ys.\n        \\<lbrakk>sourcenodes xs = ns'; as = xs @ ax # ys;\n         sourcenode ax = n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes xs = ns'\n  as = xs @ ax # ys\n  sourcenode ax = n'\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "from \\<open>\\<forall>n'' \\<in> set ns'. n' \\<noteq> n''\\<close> \\<open>sourcenodes xs = ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\n  sourcenodes xs = ns'", "have \"n' \\<notin> set(sourcenodes xs)\""], ["proof (prove)\nusing this:\n  \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\n  sourcenodes xs = ns'\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes xs)", "by fastforce"], ["proof (state)\nthis:\n  n' \\<notin> set (sourcenodes xs)\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>as = xs@ax#ys\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys", "have \"(_Entry_) -xs@ax#ys\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys\n\ngoal (1 subgoal):\n 1. (_Entry_) -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'", "by simp"], ["proof (state)\nthis:\n  (_Entry_) -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>sourcenode ax = n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax = n'\n  (_Entry_) -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"(_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  sourcenode ax = n'\n  (_Entry_) -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'", "by(fastforce dest:path_split simp:intra_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>inner_node n'\\<close>"], ["proof (chain)\npicking this:\n  inner_node n'\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  inner_node n'\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>n' \\<notin> set(sourcenodes xs)\\<close> \\<open>(_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>as = xs@ax#ys\\<close>"], ["proof (chain)\npicking this:\n  n' \\<notin> set (sourcenodes xs)\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys\n  xs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  n' \\<notin> set (sourcenodes xs)\n  (_Entry_) -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "by(cases xs) auto"], ["proof (state)\nthis:\n  \\<exists>ax asx zs.\n     (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "case False"], ["proof (state)\nthis:\n  n' \\<notin> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>inner_node n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  inner_node n'\n  n' \\<notin> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  inner_node n'\n  n' \\<notin> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ax asx zs.\n       (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "by(cases as)(auto elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>ax asx zs.\n     (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ax asx zs.\n     (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>as'.\n                length as' < length as \\<longrightarrow>\n                (\\<forall>n''.\n                    (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n                    inner_node n'' \\<longrightarrow>\n                    \\<not> method_exit n'' \\<longrightarrow>\n                    (\\<exists>ns.\n                        CFG_node\n                         (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                          n'' \\<and>\n                        ns \\<noteq> [] \\<and>\n                        (\\<forall>nx\\<in>set ns.\n                            parent_node nx \\<in> set (sourcenodes as'))));\n     (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'; inner_node n';\n     \\<not> method_exit n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         CFG_node\n                          (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                           n' \\<and>\n                         ns \\<noteq> [] \\<and>\n                         (\\<forall>n''\\<in>set ns.\n                             parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ax asx zs.\n     (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "obtain ax asx zs where \"(_Entry_) -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\" \n        and \"n' \\<notin> set (sourcenodes (ax#asx))\" and \"as = (ax#asx)@zs\""], ["proof (prove)\nusing this:\n  \\<exists>ax asx zs.\n     (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>ax asx zs.\n        \\<lbrakk>(_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n';\n         n' \\<notin> set (sourcenodes (ax # asx));\n         as = (ax # asx) @ zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' \\<notin> set (sourcenodes (ax # asx))\n  as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>as'.\n                length as' < length as \\<longrightarrow>\n                (\\<forall>n''.\n                    (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n                    inner_node n'' \\<longrightarrow>\n                    \\<not> method_exit n'' \\<longrightarrow>\n                    (\\<exists>ns.\n                        CFG_node\n                         (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                          n'' \\<and>\n                        ns \\<noteq> [] \\<and>\n                        (\\<forall>nx\\<in>set ns.\n                            parent_node nx \\<in> set (sourcenodes as'))));\n     (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* n'; inner_node n';\n     \\<not> method_exit n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         CFG_node\n                          (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                           n' \\<and>\n                         ns \\<noteq> [] \\<and>\n                         (\\<forall>n''\\<in>set ns.\n                             parent_node n'' \\<in> set (sourcenodes as))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(cases \"\\<forall>a' a''. a' \\<in> set asx \\<and> sourcenode a' = sourcenode a'' \\<and> \n          valid_edge a'' \\<and> intra_kind(kind a'') \\<longrightarrow> n' postdominates targetnode a''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case True"], ["proof (state)\nthis:\n  \\<forall>a' a''.\n     a' \\<in> set asx \\<and>\n     sourcenode a' = sourcenode a'' \\<and>\n     valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n     n' postdominates targetnode a''\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "have \"(_Exit_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_Exit_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  (_Exit_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"\\<not> n' postdominates (_Exit_)\""], ["proof (prove)\nusing this:\n  (_Exit_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<not> n' postdominates (_Exit_)", "by(fastforce simp:postdominate_def sourcenodes_def method_exit_def)"], ["proof (state)\nthis:\n  \\<not> n' postdominates (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>(_Entry_) -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"(_Entry_) -[]@ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. (_Entry_) -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "by simp"], ["proof (state)\nthis:\n  (_Entry_) -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>(_Entry_) -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "have [simp]:\"sourcenode ax = (_Entry_)\" \n          and \"valid_edge ax\""], ["proof (prove)\nusing this:\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. sourcenode ax = (_Entry_) &&& valid_edge ax", "by(auto intro:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode ax = (_Entry_)\n  valid_edge ax\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a' where \"sourcenode a' = (_Entry_)\"\n          and \"targetnode a' = (_Exit_)\" and \"valid_edge a'\" \n          and \"intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>sourcenode a' = (_Entry_); targetnode a' = (_Exit_);\n         valid_edge a'; intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_Exit_)\n  valid_edge a'\n  intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>(_Entry_) -[]@ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>\\<not> n' postdominates (_Exit_)\\<close>\n          \\<open>valid_edge ax\\<close> True \\<open>sourcenode ax = (_Entry_)\\<close> \n          \\<open>n' \\<notin> set (sourcenodes (ax#asx))\\<close> \\<open>inner_node n'\\<close> \\<open>\\<not> method_exit n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  \\<not> n' postdominates (_Exit_)\n  valid_edge ax\n  \\<forall>a' a''.\n     a' \\<in> set asx \\<and>\n     sourcenode a' = sourcenode a'' \\<and>\n     valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n     n' postdominates targetnode a''\n  sourcenode ax = (_Entry_)\n  n' \\<notin> set (sourcenodes (ax # asx))\n  inner_node n'\n  \\<not> method_exit n'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_Exit_)\n  valid_edge a'\n  intra_kind (kind a')", "have \"sourcenode ax controls n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  \\<not> n' postdominates (_Exit_)\n  valid_edge ax\n  \\<forall>a' a''.\n     a' \\<in> set asx \\<and>\n     sourcenode a' = sourcenode a'' \\<and>\n     valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n     n' postdominates targetnode a''\n  sourcenode ax = (_Entry_)\n  n' \\<notin> set (sourcenodes (ax # asx))\n  inner_node n'\n  \\<not> method_exit n'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_Exit_)\n  valid_edge a'\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. sourcenode ax controls n'", "by -(erule which_node_intra_standard_control_dependence_source\n                     [of _ _ _ _ _ _ a'],auto)"], ["proof (state)\nthis:\n  sourcenode ax controls n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"CFG_node (_Entry_) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\""], ["proof (prove)\nusing this:\n  sourcenode ax controls n'\n\ngoal (1 subgoal):\n 1. CFG_node (_Entry_) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "by(fastforce intro:SDG_cdep_edge)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"CFG_node (_Entry_) cd-[]@[CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node n'\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (_Entry_) cd-[] @\n                  [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node n'", "by(fastforce intro:cdSp_Append_cdep cdSp_Nil)"], ["proof (state)\nthis:\n  CFG_node\n   (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "moreover"], ["proof (state)\nthis:\n  CFG_node\n   (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>as = (ax#asx)@zs\\<close>"], ["proof (chain)\npicking this:\n  as = (ax # asx) @ zs", "have \"(_Entry_) \\<in> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<in> set (sourcenodes as)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "ultimately"], ["proof (chain)\npicking this:\n  CFG_node\n   (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node n'\n  (_Entry_) \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node n'\n  (_Entry_) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a' a''.\n             a' \\<in> set asx \\<and>\n             sourcenode a' = sourcenode a'' \\<and>\n             valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n             n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"\\<exists>a' \\<in> set asx. \\<exists>a''. sourcenode a' = sourcenode a'' \\<and> valid_edge a'' \\<and>\n          intra_kind(kind a'') \\<and> \\<not> n' postdominates targetnode a''\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>a' a''.\n             a' \\<in> set asx \\<and>\n             sourcenode a' = sourcenode a'' \\<and>\n             valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n             n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. \\<exists>a'\\<in>set asx.\n       \\<exists>a''.\n          sourcenode a' = sourcenode a'' \\<and>\n          valid_edge a'' \\<and>\n          intra_kind (kind a'') \\<and>\n          \\<not> n' postdominates targetnode a''", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>set asx.\n     \\<exists>a''.\n        sourcenode a' = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'\\<in>set asx.\n     \\<exists>a''.\n        sourcenode a' = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''", "obtain ax' asx' asx'' where \"asx = asx'@ax'#asx'' \\<and>\n          (\\<exists>a''. sourcenode ax' = sourcenode a'' \\<and> valid_edge a'' \\<and>\n          intra_kind(kind a'') \\<and> \\<not> n' postdominates targetnode a'') \\<and>\n          (\\<forall>z \\<in> set asx''. \\<not> (\\<exists>a''. sourcenode z = sourcenode a'' \\<and> valid_edge a'' \\<and>\n          intra_kind(kind a'') \\<and> \\<not> n' postdominates targetnode a''))\""], ["proof (prove)\nusing this:\n  \\<exists>a'\\<in>set asx.\n     \\<exists>a''.\n        sourcenode a' = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n\ngoal (1 subgoal):\n 1. (\\<And>asx' ax' asx''.\n        asx = asx' @ ax' # asx'' \\<and>\n        (\\<exists>a''.\n            sourcenode ax' = sourcenode a'' \\<and>\n            valid_edge a'' \\<and>\n            intra_kind (kind a'') \\<and>\n            \\<not> n' postdominates targetnode a'') \\<and>\n        (\\<forall>z\\<in>set asx''.\n            \\<nexists>a''.\n               sourcenode z = sourcenode a'' \\<and>\n               valid_edge a'' \\<and>\n               intra_kind (kind a'') \\<and>\n               \\<not> n' postdominates targetnode a'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(blast elim!:split_list_last_propE)"], ["proof (state)\nthis:\n  asx = asx' @ ax' # asx'' \\<and>\n  (\\<exists>a''.\n      sourcenode ax' = sourcenode a'' \\<and>\n      valid_edge a'' \\<and>\n      intra_kind (kind a'') \\<and>\n      \\<not> n' postdominates targetnode a'') \\<and>\n  (\\<forall>z\\<in>set asx''.\n      \\<nexists>a''.\n         sourcenode z = sourcenode a'' \\<and>\n         valid_edge a'' \\<and>\n         intra_kind (kind a'') \\<and>\n         \\<not> n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  asx = asx' @ ax' # asx'' \\<and>\n  (\\<exists>a''.\n      sourcenode ax' = sourcenode a'' \\<and>\n      valid_edge a'' \\<and>\n      intra_kind (kind a'') \\<and>\n      \\<not> n' postdominates targetnode a'') \\<and>\n  (\\<forall>z\\<in>set asx''.\n      \\<nexists>a''.\n         sourcenode z = sourcenode a'' \\<and>\n         valid_edge a'' \\<and>\n         intra_kind (kind a'') \\<and>\n         \\<not> n' postdominates targetnode a'')", "obtain ai where \"asx = asx'@ax'#asx''\"\n          and \"sourcenode ax' = sourcenode ai\"\n          and \"valid_edge ai\" and \"intra_kind(kind ai)\"\n          and \"\\<not> n' postdominates targetnode ai\"\n          and \"\\<forall>z \\<in> set asx''. \\<not> (\\<exists>a''. sourcenode z = sourcenode a'' \\<and> \n          valid_edge a'' \\<and> intra_kind(kind a'') \\<and> \\<not> n' postdominates targetnode a'')\""], ["proof (prove)\nusing this:\n  asx = asx' @ ax' # asx'' \\<and>\n  (\\<exists>a''.\n      sourcenode ax' = sourcenode a'' \\<and>\n      valid_edge a'' \\<and>\n      intra_kind (kind a'') \\<and>\n      \\<not> n' postdominates targetnode a'') \\<and>\n  (\\<forall>z\\<in>set asx''.\n      \\<nexists>a''.\n         sourcenode z = sourcenode a'' \\<and>\n         valid_edge a'' \\<and>\n         intra_kind (kind a'') \\<and>\n         \\<not> n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. (\\<And>ai.\n        \\<lbrakk>asx = asx' @ ax' # asx''; sourcenode ax' = sourcenode ai;\n         valid_edge ai; intra_kind (kind ai);\n         \\<not> n' postdominates targetnode ai;\n         \\<forall>z\\<in>set asx''.\n            \\<nexists>a''.\n               sourcenode z = sourcenode a'' \\<and>\n               valid_edge a'' \\<and>\n               intra_kind (kind a'') \\<and>\n               \\<not> n' postdominates targetnode a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  asx = asx' @ ax' # asx''\n  sourcenode ax' = sourcenode ai\n  valid_edge ai\n  intra_kind (kind ai)\n  \\<not> n' postdominates targetnode ai\n  \\<forall>z\\<in>set asx''.\n     \\<nexists>a''.\n        sourcenode z = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>(_Entry_) -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>asx = asx'@ax'#asx''\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  asx = asx' @ ax' # asx''", "have \"(_Entry_) -(ax#asx')@ax'#asx''\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  asx = asx' @ ax' # asx''\n\ngoal (1 subgoal):\n 1. (_Entry_) -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'", "by simp"], ["proof (state)\nthis:\n  (_Entry_) -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n' \\<notin> set (sourcenodes (ax#asx))\\<close> \\<open>asx = asx'@ax'#asx''\\<close>"], ["proof (chain)\npicking this:\n  n' \\<notin> set (sourcenodes (ax # asx))\n  asx = asx' @ ax' # asx''", "have \"n' \\<notin> set (sourcenodes (ax'#asx''))\""], ["proof (prove)\nusing this:\n  n' \\<notin> set (sourcenodes (ax # asx))\n  asx = asx' @ ax' # asx''\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes (ax' # asx''))", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  n' \\<notin> set (sourcenodes (ax' # asx''))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>inner_node n'\\<close> \\<open>\\<not> n' postdominates targetnode ai\\<close>\n          \\<open>n' \\<notin> set (sourcenodes (ax'#asx''))\\<close> \\<open>sourcenode ax' = sourcenode ai\\<close>\n          \\<open>\\<forall>z \\<in> set asx''. \\<not> (\\<exists>a''. sourcenode z = sourcenode a'' \\<and> \n          valid_edge a'' \\<and> intra_kind(kind a'') \\<and> \\<not> n' postdominates targetnode a'')\\<close>\n          \\<open>valid_edge ai\\<close> \\<open>intra_kind(kind ai)\\<close> \\<open>\\<not> method_exit n'\\<close>\n          \\<open>(_Entry_) -(ax#asx')@ax'#asx''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  inner_node n'\n  \\<not> n' postdominates targetnode ai\n  n' \\<notin> set (sourcenodes (ax' # asx''))\n  sourcenode ax' = sourcenode ai\n  \\<forall>z\\<in>set asx''.\n     \\<nexists>a''.\n        sourcenode z = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n  valid_edge ai\n  intra_kind (kind ai)\n  \\<not> method_exit n'\n  (_Entry_) -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' \\<notin> set (sourcenodes (ax' # asx''))", "have \"sourcenode ax' controls n'\""], ["proof (prove)\nusing this:\n  inner_node n'\n  \\<not> n' postdominates targetnode ai\n  n' \\<notin> set (sourcenodes (ax' # asx''))\n  sourcenode ax' = sourcenode ai\n  \\<forall>z\\<in>set asx''.\n     \\<nexists>a''.\n        sourcenode z = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n  valid_edge ai\n  intra_kind (kind ai)\n  \\<not> method_exit n'\n  (_Entry_) -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' \\<notin> set (sourcenodes (ax' # asx''))\n\ngoal (1 subgoal):\n 1. sourcenode ax' controls n'", "by(fastforce intro!:which_node_intra_standard_control_dependence_source)"], ["proof (state)\nthis:\n  sourcenode ax' controls n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\""], ["proof (prove)\nusing this:\n  sourcenode ax' controls n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "by(fastforce intro:SDG_cdep_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>(_Entry_) -(ax#asx')@ax'#asx''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"(_Entry_) -ax#asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\" and \"valid_edge ax'\""], ["proof (prove)\nusing this:\n  (_Entry_) -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax' &&&\n    valid_edge ax'", "by(auto intro:path_split simp:intra_path_def simp del:append_Cons)"], ["proof (state)\nthis:\n  (_Entry_) -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  valid_edge ax'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>asx = asx'@ax'#asx''\\<close> \\<open>as = (ax#asx)@zs\\<close>"], ["proof (chain)\npicking this:\n  asx = asx' @ ax' # asx''\n  as = (ax # asx) @ zs", "have \"length (ax#asx') < length as\""], ["proof (prove)\nusing this:\n  asx = asx' @ ax' # asx''\n  as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. length (ax # asx') < length as", "by simp"], ["proof (state)\nthis:\n  length (ax # asx') < length as\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'", "have \"valid_node (sourcenode ax')\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode ax')", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"inner_node (sourcenode ax')\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode ax')", "proof(cases \"sourcenode ax'\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. sourcenode ax' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 3. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "case Entry"], ["proof (state)\nthis:\n  sourcenode ax' = (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode ax' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 3. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "with \\<open>(_Entry_) -ax#asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  sourcenode ax' = (_Entry_)", "have \"(_Entry_) -ax#asx'\\<rightarrow>* (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  sourcenode ax' = (_Entry_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax # asx'\\<rightarrow>* (_Entry_)", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -ax # asx'\\<rightarrow>* (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode ax' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 3. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "hence False"], ["proof (prove)\nusing this:\n  (_Entry_) -ax # asx'\\<rightarrow>* (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:path_Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. sourcenode ax' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 3. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode ax')", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode ax')\n\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "case Exit"], ["proof (state)\nthis:\n  sourcenode ax' = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "with \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  sourcenode ax' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge ax'\n  sourcenode ax' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode ax')\n 2. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode ax')", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode ax') \\<Longrightarrow>\n    inner_node (sourcenode ax')", "qed simp"], ["proof (state)\nthis:\n  inner_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>asx = asx'@ax'#asx''\\<close> \\<open>(_Entry_) -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  asx = asx' @ ax' # asx''\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"intra_kind (kind ax')\""], ["proof (prove)\nusing this:\n  asx = asx' @ ax' # asx''\n  (_Entry_) -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax')", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  intra_kind (kind ax')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "have \"\\<not> method_exit (sourcenode ax')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> method_exit (sourcenode ax')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. method_exit (sourcenode ax') \\<Longrightarrow> False", "assume \"method_exit (sourcenode ax')\""], ["proof (state)\nthis:\n  method_exit (sourcenode ax')\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode ax') \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  method_exit (sourcenode ax')\n\ngoal (1 subgoal):\n 1. False", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"sourcenode ax' = (_Exit_)\""], ["proof (state)\nthis:\n  sourcenode ax' = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  sourcenode ax' = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  valid_edge ax'\n  sourcenode ax' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "fix x Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \" sourcenode ax' = sourcenode x\"\n              and \"valid_edge x\" and \"kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  sourcenode ax' = sourcenode x\n  valid_edge x\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge x\\<close> \\<open>kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>sourcenode ax' = sourcenode x\\<close>\n            \\<open>valid_edge ax'\\<close> \\<open>intra_kind (kind ax')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode ax' = sourcenode x\n  valid_edge ax'\n  intra_kind (kind ax')", "show False"], ["proof (prove)\nusing this:\n  valid_edge x\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode ax' = sourcenode x\n  valid_edge ax'\n  intra_kind (kind ax')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> method_exit (sourcenode ax')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with IH \\<open>length (ax#asx') < length as\\<close> \\<open>(_Entry_) -ax#asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\\<close>\n          \\<open>inner_node (sourcenode ax')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n         inner_node n'' \\<longrightarrow>\n         \\<not> method_exit n'' \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node\n              (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and>\n             ns \\<noteq> [] \\<and>\n             (\\<forall>nx\\<in>set ns.\n                 parent_node nx \\<in> set (sourcenodes as'))))\n  length (ax # asx') < length as\n  (_Entry_) -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  inner_node (sourcenode ax')\n  \\<not> method_exit (sourcenode ax')", "obtain ns where \"CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\"\n          and \"ns \\<noteq> []\" \n          and \"\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes (ax#asx'))\""], ["proof (prove)\nusing this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n         inner_node n'' \\<longrightarrow>\n         \\<not> method_exit n'' \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node\n              (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and>\n             ns \\<noteq> [] \\<and>\n             (\\<forall>nx\\<in>set ns.\n                 parent_node nx \\<in> set (sourcenodes as'))))\n  length (ax # asx') < length as\n  (_Entry_) -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  inner_node (sourcenode ax')\n  \\<not> method_exit (sourcenode ax')\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>CFG_node\n                  (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                   (sourcenode ax');\n         ns \\<noteq> [];\n         \\<forall>n''\\<in>set ns.\n            parent_node n'' \\<in> set (sourcenodes (ax # asx'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns.\n     parent_node n'' \\<in> set (sourcenodes (ax # asx'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\\<close>\n          \\<open>CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "have \"CFG_node (_Entry_) cd-ns@[CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (_Entry_) cd-ns @\n                  [CFG_node\n                    (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'", "by(fastforce intro:cdSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (_Entry_) cd-ns @\n                [CFG_node\n                  (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>as = (ax#asx)@zs\\<close> \\<open>asx = asx'@ax'#asx''\\<close>"], ["proof (chain)\npicking this:\n  as = (ax # asx) @ zs\n  asx = asx' @ ax' # asx''", "have \"sourcenode ax' \\<in> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  as = (ax # asx) @ zs\n  asx = asx' @ ax' # asx''\n\ngoal (1 subgoal):\n 1. sourcenode ax' \\<in> set (sourcenodes as)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenode ax' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes (ax#asx'))\\<close>\n          \\<open>as = (ax#asx)@zs\\<close> \\<open>asx = asx'@ax'#asx''\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''\\<in>set ns.\n     parent_node n'' \\<in> set (sourcenodes (ax # asx'))\n  as = (ax # asx) @ zs\n  asx = asx' @ ax' # asx''\n  sourcenode ax' \\<in> set (sourcenodes as)", "have \"\\<forall>n'' \\<in> set (ns@[CFG_node (sourcenode ax')]).\n          parent_node n'' \\<in> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  \\<forall>n''\\<in>set ns.\n     parent_node n'' \\<in> set (sourcenodes (ax # asx'))\n  as = (ax # asx) @ zs\n  asx = asx' @ ax' # asx''\n  sourcenode ax' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n       parent_node n'' \\<in> set (sourcenodes as)", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>CFG_node (_Entry_) cd-ns@[CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (_Entry_) cd-ns @\n                [CFG_node\n                  (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n  \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (_Entry_) cd-ns @\n                [CFG_node\n                  (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n  \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_proc_cdep_SDG_path:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"n \\<noteq> n'\" and \"n' \\<noteq> (_Exit_)\" and \"valid_edge a\"\n  and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"targetnode a = n\"\n  obtains ns where \"CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'\"\n  and \"ns \\<noteq> []\" and \"\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n';\n         ns \\<noteq> [];\n         \\<forall>n''\\<in>set ns.\n            parent_node n'' \\<in> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "show \"\\<exists>ns. CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n             ns \\<noteq> [] \\<and> (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(cases \"\\<forall>ax. valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow> \n                    ax \\<notin> get_return_edges a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case True"], ["proof (state)\nthis:\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n     ax \\<notin> get_return_edges a\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>n \\<noteq> n'\\<close> \\<open>n' \\<noteq> (_Exit_)\\<close>\n      \\<open>\\<forall>ax. valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow> ax \\<notin> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'\n  n' \\<noteq> (_Exit_)\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n     ax \\<notin> get_return_edges a", "show \"\\<exists>ns. CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and> ns \\<noteq> [] \\<and>\n      (\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as))\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'\n  n' \\<noteq> (_Exit_)\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n     ax \\<notin> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(induct as arbitrary:n' rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n -ys\\<rightarrow>\\<^sub>\\<iota>* x \\<longrightarrow>\n                       n \\<noteq> x \\<longrightarrow>\n                       x \\<noteq> (_Exit_) \\<longrightarrow>\n                       (\\<forall>ax.\n                           valid_edge ax \\<and>\n                           sourcenode ax = x \\<longrightarrow>\n                           ax \\<notin> get_return_edges a) \\<longrightarrow>\n                       (\\<exists>ns.\n                           CFG_node\n                            n cd-ns\\<rightarrow>\\<^sub>d* CFG_node x \\<and>\n                           ns \\<noteq> [] \\<and>\n                           (\\<forall>n''\\<in>set ns.\n                               parent_node n''\n                               \\<in> set (sourcenodes ys))));\n        n -xs\\<rightarrow>\\<^sub>\\<iota>* n'; n \\<noteq> n';\n        n' \\<noteq> (_Exit_);\n        \\<forall>ax.\n           valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n           ax \\<notin> get_return_edges a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes xs))", "fix as n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n -ys\\<rightarrow>\\<^sub>\\<iota>* x \\<longrightarrow>\n                       n \\<noteq> x \\<longrightarrow>\n                       x \\<noteq> (_Exit_) \\<longrightarrow>\n                       (\\<forall>ax.\n                           valid_edge ax \\<and>\n                           sourcenode ax = x \\<longrightarrow>\n                           ax \\<notin> get_return_edges a) \\<longrightarrow>\n                       (\\<exists>ns.\n                           CFG_node\n                            n cd-ns\\<rightarrow>\\<^sub>d* CFG_node x \\<and>\n                           ns \\<noteq> [] \\<and>\n                           (\\<forall>n''\\<in>set ns.\n                               parent_node n''\n                               \\<in> set (sourcenodes ys))));\n        n -xs\\<rightarrow>\\<^sub>\\<iota>* n'; n \\<noteq> n';\n        n' \\<noteq> (_Exit_);\n        \\<forall>ax.\n           valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n           ax \\<notin> get_return_edges a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes xs))", "assume IH:\"\\<forall>as'. length as' < length as \\<longrightarrow>\n        (\\<forall>n''. n -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow> n \\<noteq> n'' \\<longrightarrow> n'' \\<noteq> (_Exit_) \\<longrightarrow>\n          (\\<forall>ax. valid_edge ax \\<and> sourcenode ax = n'' \\<longrightarrow> ax \\<notin> get_return_edges a) \\<longrightarrow>\n            (\\<exists>ns. CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and> ns \\<noteq> [] \\<and>\n                  (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as'))))\"\n        and \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"n \\<noteq> n'\" and \"n' \\<noteq> (_Exit_)\"\n        and \"\\<forall>ax. valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow> ax \\<notin> get_return_edges a\""], ["proof (state)\nthis:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n         n \\<noteq> n'' \\<longrightarrow>\n         n'' \\<noteq> (_Exit_) \\<longrightarrow>\n         (\\<forall>ax.\n             valid_edge ax \\<and> sourcenode ax = n'' \\<longrightarrow>\n             ax \\<notin> get_return_edges a) \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and>\n             ns \\<noteq> [] \\<and>\n             (\\<forall>n''\\<in>set ns.\n                 parent_node n'' \\<in> set (sourcenodes as'))))\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'\n  n' \\<noteq> (_Exit_)\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n     ax \\<notin> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<And>xs n'.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n -ys\\<rightarrow>\\<^sub>\\<iota>* x \\<longrightarrow>\n                       n \\<noteq> x \\<longrightarrow>\n                       x \\<noteq> (_Exit_) \\<longrightarrow>\n                       (\\<forall>ax.\n                           valid_edge ax \\<and>\n                           sourcenode ax = x \\<longrightarrow>\n                           ax \\<notin> get_return_edges a) \\<longrightarrow>\n                       (\\<exists>ns.\n                           CFG_node\n                            n cd-ns\\<rightarrow>\\<^sub>d* CFG_node x \\<and>\n                           ns \\<noteq> [] \\<and>\n                           (\\<forall>n''\\<in>set ns.\n                               parent_node n''\n                               \\<in> set (sourcenodes ys))));\n        n -xs\\<rightarrow>\\<^sub>\\<iota>* n'; n \\<noteq> n';\n        n' \\<noteq> (_Exit_);\n        \\<forall>ax.\n           valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n           ax \\<notin> get_return_edges a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes xs))", "show \"\\<exists>ns. CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and> ns \\<noteq> [] \\<and>\n                 (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(cases \"method_exit n'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case True"], ["proof (state)\nthis:\n  method_exit n'\n\ngoal (2 subgoals):\n 1. method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "thus ?thesis"], ["proof (prove)\nusing this:\n  method_exit n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "assume \"n' = (_Exit_)\""], ["proof (state)\nthis:\n  n' = (_Exit_)\n\ngoal (2 subgoals):\n 1. n' = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>n' \\<noteq> (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n' \\<noteq> (_Exit_)\n  n' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  n' \\<noteq> (_Exit_)\n  n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n' = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by simp"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "fix a' Q' f' p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "assume \"n' = sourcenode a'\" and \"valid_edge a'\" and \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (state)\nthis:\n  n' = sourcenode a'\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc(targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"get_proc n = get_proc n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc n'", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc n = get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>get_proc(targetnode a) = p\\<close> \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  get_proc (targetnode a) = p\n  targetnode a = n\n  get_proc n = get_proc n'", "have \"get_proc (targetnode a) = get_proc n'\""], ["proof (prove)\nusing this:\n  get_proc (targetnode a) = p\n  targetnode a = n\n  get_proc n = get_proc n'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc n'", "by simp"], ["proof (state)\nthis:\n  get_proc (targetnode a) = get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'", "have \"get_proc (sourcenode a') = p'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p'", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>n' = sourcenode a'\\<close> \\<open>get_proc (targetnode a) = get_proc n'\\<close> \n            \\<open>get_proc (targetnode a) = p\\<close>"], ["proof (chain)\npicking this:\n  n' = sourcenode a'\n  get_proc (targetnode a) = get_proc n'\n  get_proc (targetnode a) = p\n  get_proc (sourcenode a') = p'", "have \"p = p'\""], ["proof (prove)\nusing this:\n  n' = sourcenode a'\n  get_proc (targetnode a) = get_proc n'\n  get_proc (targetnode a) = p\n  get_proc (sourcenode a') = p'\n\ngoal (1 subgoal):\n 1. p = p'", "by simp"], ["proof (state)\nthis:\n  p = p'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  p = p'", "obtain ax where \"valid_edge ax\" and \"\\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n            and \"a' \\<in> get_return_edges ax\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  p = p'\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax;\n         \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges ax\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:return_needs_call)"], ["proof (state)\nthis:\n  valid_edge ax\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "hence \"CFG_node (targetnode ax) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       ax) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')", "by(fastforce intro:SDG_proc_entry_exit_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     ax) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  CFG_node\n   (targetnode\n     ax) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')", "have \"CFG_node (targetnode ax) cd-[]@[CFG_node (targetnode ax)]\\<rightarrow>\\<^sub>d* \n            CFG_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  CFG_node\n   (targetnode\n     ax) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       ax) cd-[] @\n              [CFG_node\n                (targetnode\n                  ax)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')", "by(fastforce intro:cdep_SDG_path.intros)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     ax) cd-[] @\n            [CFG_node\n              (targetnode\n                ax)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge ax\\<close> \n            \\<open>\\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge ax\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"targetnode a = targetnode ax\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge ax\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. targetnode a = targetnode ax", "by(fastforce intro:same_proc_call_unique_target)"], ["proof (state)\nthis:\n  targetnode a = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>n \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as \\<noteq> []", "have \"hd (sourcenodes as) = n\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as) = n", "by(fastforce intro:path_sourcenode simp:intra_path_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as) = n\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "moreover"], ["proof (state)\nthis:\n  hd (sourcenodes as) = n\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []", "have \"hd (sourcenodes as) \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as) \\<in> set (sourcenodes as)", "by(fastforce intro:hd_in_set simp:sourcenodes_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "ultimately"], ["proof (chain)\npicking this:\n  hd (sourcenodes as) = n\n  hd (sourcenodes as) \\<in> set (sourcenodes as)", "have \"n \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  hd (sourcenodes as) = n\n  hd (sourcenodes as) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes as)", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node\n                             n cd-ns\\<rightarrow>\\<^sub>d* CFG_node\n                      n' \\<and>\n                            ns \\<noteq> [] \\<and>\n                            (\\<forall>n''\\<in>set ns.\n                                parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>n' = sourcenode a'\\<close> \\<open>targetnode a = targetnode ax\\<close>\n            \\<open>targetnode a = n\\<close>\n            \\<open>CFG_node (targetnode ax) cd-[]@[CFG_node (targetnode ax)]\\<rightarrow>\\<^sub>d* \n            CFG_node (sourcenode a')\\<close>"], ["proof (chain)\npicking this:\n  n' = sourcenode a'\n  targetnode a = targetnode ax\n  targetnode a = n\n  CFG_node\n   (targetnode\n     ax) cd-[] @\n            [CFG_node\n              (targetnode\n                ax)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')\n  n \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  n' = sourcenode a'\n  targetnode a = targetnode ax\n  targetnode a = n\n  CFG_node\n   (targetnode\n     ax) cd-[] @\n            [CFG_node\n              (targetnode\n                ax)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')\n  n \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case False"], ["proof (state)\nthis:\n  \\<not> method_exit n'\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain a' \n          where \"a' \\<in> get_return_edges a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        a' \\<in> get_return_edges a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:get_return_edge_call)"], ["proof (state)\nthis:\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "obtain a''\n          where \"valid_edge a''\" and \"sourcenode a'' = targetnode a\" \n          and \"targetnode a'' = sourcenode a'\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = targetnode a;\n         targetnode a'' = sourcenode a';\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule intra_proc_additional_edge,auto)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "have \"\\<exists>ax asx zs. n -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> n' \\<notin> set (sourcenodes (ax#asx)) \\<and> \n                          as = (ax#asx)@zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "proof(cases \"n' \\<in> set (sourcenodes as)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "case True"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "hence \"\\<exists>n'' \\<in> set(sourcenodes as). n' = n''\""], ["proof (prove)\nusing this:\n  n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>n''\\<in>set (sourcenodes as). n' = n''", "by simp"], ["proof (state)\nthis:\n  \\<exists>n''\\<in>set (sourcenodes as). n' = n''\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "then"], ["proof (chain)\npicking this:\n  \\<exists>n''\\<in>set (sourcenodes as). n' = n''", "obtain ns' ns'' where \"sourcenodes as = ns'@n'#ns''\"\n            and \"\\<forall>n'' \\<in> set ns'. n' \\<noteq> n''\""], ["proof (prove)\nusing this:\n  \\<exists>n''\\<in>set (sourcenodes as). n' = n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>sourcenodes as = ns' @ n' # ns'';\n         \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_first_propE)"], ["proof (state)\nthis:\n  sourcenodes as = ns' @ n' # ns''\n  \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "from \\<open>sourcenodes as = ns'@n'#ns''\\<close>"], ["proof (chain)\npicking this:\n  sourcenodes as = ns' @ n' # ns''", "obtain xs ys ax\n            where \"sourcenodes xs = ns'\" and \"as = xs@ax#ys\"\n            and \"sourcenode ax = n'\""], ["proof (prove)\nusing this:\n  sourcenodes as = ns' @ n' # ns''\n\ngoal (1 subgoal):\n 1. (\\<And>xs ax ys.\n        \\<lbrakk>sourcenodes xs = ns'; as = xs @ ax # ys;\n         sourcenode ax = n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes xs = ns'\n  as = xs @ ax # ys\n  sourcenode ax = n'\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "from \\<open>\\<forall>n'' \\<in> set ns'. n' \\<noteq> n''\\<close> \\<open>sourcenodes xs = ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\n  sourcenodes xs = ns'", "have \"n' \\<notin> set(sourcenodes xs)\""], ["proof (prove)\nusing this:\n  \\<forall>n''\\<in>set ns'. n' \\<noteq> n''\n  sourcenodes xs = ns'\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes xs)", "by fastforce"], ["proof (state)\nthis:\n  n' \\<notin> set (sourcenodes xs)\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>as = xs@ax#ys\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys", "have \"n -xs@ax#ys\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys\n\ngoal (1 subgoal):\n 1. n -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'", "by simp"], ["proof (state)\nthis:\n  n -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>sourcenode ax = n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax = n'\n  n -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -xs\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  sourcenode ax = n'\n  n -xs @ ax # ys\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -xs\\<rightarrow>\\<^sub>\\<iota>* n'", "by(fastforce dest:path_split simp:intra_path_def)"], ["proof (state)\nthis:\n  n -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>n \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> n'\n  n -xs\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  n \\<noteq> n'\n  n -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. n' \\<in> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n 2. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>n' \\<notin> set(sourcenodes xs)\\<close> \\<open>n -xs\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>as = xs@ax#ys\\<close>"], ["proof (chain)\npicking this:\n  n' \\<notin> set (sourcenodes xs)\n  n -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys\n  xs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  n' \\<notin> set (sourcenodes xs)\n  n -xs\\<rightarrow>\\<^sub>\\<iota>* n'\n  as = xs @ ax # ys\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "by(cases xs) auto"], ["proof (state)\nthis:\n  \\<exists>ax asx zs.\n     n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "case False"], ["proof (state)\nthis:\n  n' \\<notin> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes as) \\<Longrightarrow>\n    \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>n \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'\n  n' \\<notin> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'\n  n' \\<notin> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ax asx zs.\n       n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "by(cases as)(auto simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>ax asx zs.\n     n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ax asx zs.\n     n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ax asx zs.\n     n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs", "obtain ax asx zs where \"n -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\" \n          and \"n' \\<notin> set (sourcenodes (ax#asx))\" and \"as = (ax#asx)@zs\""], ["proof (prove)\nusing this:\n  \\<exists>ax asx zs.\n     n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes (ax # asx)) \\<and> as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>ax asx zs.\n        \\<lbrakk>n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n';\n         n' \\<notin> set (sourcenodes (ax # asx));\n         as = (ax # asx) @ zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' \\<notin> set (sourcenodes (ax # asx))\n  as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>n' \\<noteq> (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' \\<noteq> (_Exit_)", "have \"inner_node n'\""], ["proof (prove)\nusing this:\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  n' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. inner_node n'", "by(fastforce intro:path_valid_node simp:inner_node_def intra_path_def)"], ["proof (state)\nthis:\n  inner_node n'\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a\\<close> \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = n", "have \"valid_node n\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = n\n\ngoal (1 subgoal):\n 1. valid_node n", "by fastforce"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<not> method_exit n' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(cases \"\\<forall>a' a''. a' \\<in> set asx \\<and> sourcenode a' = sourcenode a'' \\<and> \n            valid_edge a'' \\<and> intra_kind(kind a'') \\<longrightarrow> \n            n' postdominates targetnode a''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case True"], ["proof (state)\nthis:\n  \\<forall>a' a''.\n     a' \\<in> set asx \\<and>\n     sourcenode a' = sourcenode a'' \\<and>\n     valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n     n' postdominates targetnode a''\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>targetnode a = n\\<close> \\<open>sourcenode a'' = targetnode a\\<close> \n            \\<open>kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = n\n  sourcenode a'' = targetnode a\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"sourcenode a'' = n\" and \"intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  targetnode a = n\n  sourcenode a'' = targetnode a\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sourcenode a'' = n &&& intra_kind (kind a'')", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a'' = n\n  intra_kind (kind a'')\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "{"], ["proof (state)\nthis:\n  sourcenode a'' = n\n  intra_kind (kind a'')\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "fix as'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "assume \"targetnode a'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (state)\nthis:\n  targetnode a'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a'\\<close> \\<open>targetnode a'' = sourcenode a'\\<close> \n              \\<open>a' \\<in> get_return_edges a\\<close> \n              \\<open>\\<forall>ax. valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow> ax \\<notin> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  targetnode a'' = sourcenode a'\n  a' \\<in> get_return_edges a\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n     ax \\<notin> get_return_edges a", "have \"targetnode a'' \\<noteq> n'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  targetnode a'' = sourcenode a'\n  a' \\<in> get_return_edges a\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n     ax \\<notin> get_return_edges a\n\ngoal (1 subgoal):\n 1. targetnode a'' \\<noteq> n'", "by fastforce"], ["proof (state)\nthis:\n  targetnode a'' \\<noteq> n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>targetnode a'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\n  targetnode a'' \\<noteq> n'", "obtain ax' where \"valid_edge ax'\"\n              and \"targetnode a'' = sourcenode ax'\" and \"intra_kind(kind ax')\""], ["proof (prove)\nusing this:\n  targetnode a'' -as'\\<rightarrow>\\<^sub>\\<iota>* n'\n  targetnode a'' \\<noteq> n'\n\ngoal (1 subgoal):\n 1. (\\<And>ax'.\n        \\<lbrakk>valid_edge ax'; targetnode a'' = sourcenode ax';\n         intra_kind (kind ax')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp:intra_path_def)(erule path.cases,fastforce+)"], ["proof (state)\nthis:\n  valid_edge ax'\n  targetnode a'' = sourcenode ax'\n  intra_kind (kind ax')\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>valid_edge ax'\\<close>\n              \\<open>targetnode a'' = sourcenode a'\\<close> \\<open>targetnode a'' = sourcenode ax'\\<close>\n              \\<open>intra_kind(kind ax')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge ax'\n  targetnode a'' = sourcenode a'\n  targetnode a'' = sourcenode ax'\n  intra_kind (kind ax')", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge ax'\n  targetnode a'' = sourcenode a'\n  targetnode a'' = sourcenode ax'\n  intra_kind (kind ax')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "}"], ["proof (state)\nthis:\n  targetnode a'' -?as'2\\<rightarrow>\\<^sub>\\<iota>* n' \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"\\<not> n' postdominates targetnode a''\""], ["proof (prove)\nusing this:\n  targetnode a'' -?as'2\\<rightarrow>\\<^sub>\\<iota>* n' \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> n' postdominates targetnode a''", "by(fastforce elim:postdominate_implies_inner_path)"], ["proof (state)\nthis:\n  \\<not> n' postdominates targetnode a''\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"sourcenode ax = n\""], ["proof (prove)\nusing this:\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. sourcenode ax = n", "by(auto intro:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode ax = n\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -[]@ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "by simp"], ["proof (state)\nthis:\n  n -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from this \\<open>sourcenode a'' = n\\<close> \\<open>sourcenode ax = n\\<close> True\n            \\<open>n' \\<notin> set (sourcenodes (ax#asx))\\<close> \\<open>valid_edge a''\\<close> \\<open>intra_kind(kind a'')\\<close>\n            \\<open>inner_node n'\\<close> \\<open>\\<not> method_exit n'\\<close> \\<open>\\<not> n' postdominates targetnode a''\\<close>"], ["proof (chain)\npicking this:\n  n -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  sourcenode a'' = n\n  sourcenode ax = n\n  \\<forall>a' a''.\n     a' \\<in> set asx \\<and>\n     sourcenode a' = sourcenode a'' \\<and>\n     valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n     n' postdominates targetnode a''\n  n' \\<notin> set (sourcenodes (ax # asx))\n  valid_edge a''\n  intra_kind (kind a'')\n  inner_node n'\n  \\<not> method_exit n'\n  \\<not> n' postdominates targetnode a''", "have \"n controls n'\""], ["proof (prove)\nusing this:\n  n -[] @ ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n  sourcenode a'' = n\n  sourcenode ax = n\n  \\<forall>a' a''.\n     a' \\<in> set asx \\<and>\n     sourcenode a' = sourcenode a'' \\<and>\n     valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n     n' postdominates targetnode a''\n  n' \\<notin> set (sourcenodes (ax # asx))\n  valid_edge a''\n  intra_kind (kind a'')\n  inner_node n'\n  \\<not> method_exit n'\n  \\<not> n' postdominates targetnode a''\n\ngoal (1 subgoal):\n 1. n controls n'", "by(fastforce intro!:which_node_intra_standard_control_dependence_source)"], ["proof (state)\nthis:\n  n controls n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\""], ["proof (prove)\nusing this:\n  n controls n'\n\ngoal (1 subgoal):\n 1. CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "by(fastforce intro:SDG_cdep_edge)"], ["proof (state)\nthis:\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "have \"CFG_node n cd-[]@[CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\""], ["proof (prove)\nusing this:\n  valid_node n\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'", "by(fastforce intro:cdSp_Append_cdep cdSp_Nil)"], ["proof (state)\nthis:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "moreover"], ["proof (state)\nthis:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>as = (ax#asx)@zs\\<close> \\<open>sourcenode ax = n\\<close>"], ["proof (chain)\npicking this:\n  as = (ax # asx) @ zs\n  sourcenode ax = n", "have \"n \\<in> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  as = (ax # asx) @ zs\n  sourcenode ax = n\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes as)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<forall>a' a''.\n       a' \\<in> set asx \\<and>\n       sourcenode a' = sourcenode a'' \\<and>\n       valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n       n' postdominates targetnode a'' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "ultimately"], ["proof (chain)\npicking this:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n  n \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n  n \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a' a''.\n             a' \\<in> set asx \\<and>\n             sourcenode a' = sourcenode a'' \\<and>\n             valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n             n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"\\<exists>a' \\<in> set asx. \\<exists>a''. sourcenode a' = sourcenode a'' \\<and> \n            valid_edge a'' \\<and> intra_kind(kind a'') \\<and> \n            \\<not> n' postdominates targetnode a''\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>a' a''.\n             a' \\<in> set asx \\<and>\n             sourcenode a' = sourcenode a'' \\<and>\n             valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n             n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. \\<exists>a'\\<in>set asx.\n       \\<exists>a''.\n          sourcenode a' = sourcenode a'' \\<and>\n          valid_edge a'' \\<and>\n          intra_kind (kind a'') \\<and>\n          \\<not> n' postdominates targetnode a''", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>set asx.\n     \\<exists>a''.\n        sourcenode a' = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'\\<in>set asx.\n     \\<exists>a''.\n        sourcenode a' = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''", "obtain ax' asx' asx'' where \"asx = asx'@ax'#asx'' \\<and>\n            (\\<exists>a''. sourcenode ax' = sourcenode a'' \\<and> valid_edge a'' \\<and>\n            intra_kind(kind a'') \\<and> \\<not> n' postdominates targetnode a'') \\<and>\n            (\\<forall>z \\<in> set asx''. \\<not> (\\<exists>a''. sourcenode z = sourcenode a'' \\<and> \n            valid_edge a'' \\<and> intra_kind(kind a'') \\<and> \n            \\<not> n' postdominates targetnode a''))\""], ["proof (prove)\nusing this:\n  \\<exists>a'\\<in>set asx.\n     \\<exists>a''.\n        sourcenode a' = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n\ngoal (1 subgoal):\n 1. (\\<And>asx' ax' asx''.\n        asx = asx' @ ax' # asx'' \\<and>\n        (\\<exists>a''.\n            sourcenode ax' = sourcenode a'' \\<and>\n            valid_edge a'' \\<and>\n            intra_kind (kind a'') \\<and>\n            \\<not> n' postdominates targetnode a'') \\<and>\n        (\\<forall>z\\<in>set asx''.\n            \\<nexists>a''.\n               sourcenode z = sourcenode a'' \\<and>\n               valid_edge a'' \\<and>\n               intra_kind (kind a'') \\<and>\n               \\<not> n' postdominates targetnode a'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(blast elim!:split_list_last_propE)"], ["proof (state)\nthis:\n  asx = asx' @ ax' # asx'' \\<and>\n  (\\<exists>a''.\n      sourcenode ax' = sourcenode a'' \\<and>\n      valid_edge a'' \\<and>\n      intra_kind (kind a'') \\<and>\n      \\<not> n' postdominates targetnode a'') \\<and>\n  (\\<forall>z\\<in>set asx''.\n      \\<nexists>a''.\n         sourcenode z = sourcenode a'' \\<and>\n         valid_edge a'' \\<and>\n         intra_kind (kind a'') \\<and>\n         \\<not> n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  asx = asx' @ ax' # asx'' \\<and>\n  (\\<exists>a''.\n      sourcenode ax' = sourcenode a'' \\<and>\n      valid_edge a'' \\<and>\n      intra_kind (kind a'') \\<and>\n      \\<not> n' postdominates targetnode a'') \\<and>\n  (\\<forall>z\\<in>set asx''.\n      \\<nexists>a''.\n         sourcenode z = sourcenode a'' \\<and>\n         valid_edge a'' \\<and>\n         intra_kind (kind a'') \\<and>\n         \\<not> n' postdominates targetnode a'')", "obtain ai where \"asx = asx'@ax'#asx''\"\n            and \"sourcenode ax' = sourcenode ai\"\n            and \"valid_edge ai\" and \"intra_kind(kind ai)\"\n            and \"\\<not> n' postdominates targetnode ai\"\n            and \"\\<forall>z \\<in> set asx''. \\<not> (\\<exists>a''. sourcenode z = sourcenode a'' \\<and> \n            valid_edge a'' \\<and> intra_kind(kind a'') \\<and> \n            \\<not> n' postdominates targetnode a'')\""], ["proof (prove)\nusing this:\n  asx = asx' @ ax' # asx'' \\<and>\n  (\\<exists>a''.\n      sourcenode ax' = sourcenode a'' \\<and>\n      valid_edge a'' \\<and>\n      intra_kind (kind a'') \\<and>\n      \\<not> n' postdominates targetnode a'') \\<and>\n  (\\<forall>z\\<in>set asx''.\n      \\<nexists>a''.\n         sourcenode z = sourcenode a'' \\<and>\n         valid_edge a'' \\<and>\n         intra_kind (kind a'') \\<and>\n         \\<not> n' postdominates targetnode a'')\n\ngoal (1 subgoal):\n 1. (\\<And>ai.\n        \\<lbrakk>asx = asx' @ ax' # asx''; sourcenode ax' = sourcenode ai;\n         valid_edge ai; intra_kind (kind ai);\n         \\<not> n' postdominates targetnode ai;\n         \\<forall>z\\<in>set asx''.\n            \\<nexists>a''.\n               sourcenode z = sourcenode a'' \\<and>\n               valid_edge a'' \\<and>\n               intra_kind (kind a'') \\<and>\n               \\<not> n' postdominates targetnode a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  asx = asx' @ ax' # asx''\n  sourcenode ax' = sourcenode ai\n  valid_edge ai\n  intra_kind (kind ai)\n  \\<not> n' postdominates targetnode ai\n  \\<forall>z\\<in>set asx''.\n     \\<nexists>a''.\n        sourcenode z = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>asx = asx'@ax'#asx''\\<close> \\<open>n -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  asx = asx' @ ax' # asx''\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -(ax#asx')@ax'#asx''\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  asx = asx' @ ax' # asx''\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'", "by simp"], ["proof (state)\nthis:\n  n -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n' \\<notin> set (sourcenodes (ax#asx))\\<close> \\<open>asx = asx'@ax'#asx''\\<close>"], ["proof (chain)\npicking this:\n  n' \\<notin> set (sourcenodes (ax # asx))\n  asx = asx' @ ax' # asx''", "have \"n' \\<notin> set (sourcenodes (ax'#asx''))\""], ["proof (prove)\nusing this:\n  n' \\<notin> set (sourcenodes (ax # asx))\n  asx = asx' @ ax' # asx''\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes (ax' # asx''))", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  n' \\<notin> set (sourcenodes (ax' # asx''))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>inner_node n'\\<close> \\<open>\\<not> n' postdominates targetnode ai\\<close>\n            \\<open>n -(ax#asx')@ax'#asx''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>sourcenode ax' = sourcenode ai\\<close>\n            \\<open>\\<forall>z \\<in> set asx''. \\<not> (\\<exists>a''. sourcenode z = sourcenode a'' \\<and> \n            valid_edge a'' \\<and> intra_kind(kind a'') \\<and> \n            \\<not> n' postdominates targetnode a'')\\<close>\n            \\<open>valid_edge ai\\<close> \\<open>intra_kind(kind ai)\\<close> \\<open>\\<not> method_exit n'\\<close>"], ["proof (chain)\npicking this:\n  inner_node n'\n  \\<not> n' postdominates targetnode ai\n  n -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n  sourcenode ax' = sourcenode ai\n  \\<forall>z\\<in>set asx''.\n     \\<nexists>a''.\n        sourcenode z = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n  valid_edge ai\n  intra_kind (kind ai)\n  \\<not> method_exit n'\n  n' \\<notin> set (sourcenodes (ax' # asx''))", "have \"sourcenode ax' controls n'\""], ["proof (prove)\nusing this:\n  inner_node n'\n  \\<not> n' postdominates targetnode ai\n  n -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n  sourcenode ax' = sourcenode ai\n  \\<forall>z\\<in>set asx''.\n     \\<nexists>a''.\n        sourcenode z = sourcenode a'' \\<and>\n        valid_edge a'' \\<and>\n        intra_kind (kind a'') \\<and> \\<not> n' postdominates targetnode a''\n  valid_edge ai\n  intra_kind (kind ai)\n  \\<not> method_exit n'\n  n' \\<notin> set (sourcenodes (ax' # asx''))\n\ngoal (1 subgoal):\n 1. sourcenode ax' controls n'", "by(fastforce intro!:which_node_intra_standard_control_dependence_source)"], ["proof (state)\nthis:\n  sourcenode ax' controls n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "hence \"CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\""], ["proof (prove)\nusing this:\n  sourcenode ax' controls n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "by(fastforce intro:SDG_cdep_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -(ax#asx')@ax'#asx''\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -ax#asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\" and \"valid_edge ax'\""], ["proof (prove)\nusing this:\n  n -(ax # asx') @ ax' # asx''\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax' &&&\n    valid_edge ax'", "by(auto intro:path_split simp:intra_path_def simp del:append_Cons)"], ["proof (state)\nthis:\n  n -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  valid_edge ax'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>asx = asx'@ax'#asx''\\<close> \\<open>as = (ax#asx)@zs\\<close>"], ["proof (chain)\npicking this:\n  asx = asx' @ ax' # asx''\n  as = (ax # asx) @ zs", "have \"length (ax#asx') < length as\""], ["proof (prove)\nusing this:\n  asx = asx' @ ax' # asx''\n  as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. length (ax # asx') < length as", "by simp"], ["proof (state)\nthis:\n  length (ax # asx') < length as\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>as = (ax#asx)@zs\\<close> \\<open>asx = asx'@ax'#asx''\\<close>"], ["proof (chain)\npicking this:\n  as = (ax # asx) @ zs\n  asx = asx' @ ax' # asx''", "have \"sourcenode ax' \\<in> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  as = (ax # asx) @ zs\n  asx = asx' @ ax' # asx''\n\ngoal (1 subgoal):\n 1. sourcenode ax' \\<in> set (sourcenodes as)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenode ax' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a' a''.\n               a' \\<in> set asx \\<and>\n               sourcenode a' = sourcenode a'' \\<and>\n               valid_edge a'' \\<and> intra_kind (kind a'') \\<longrightarrow>\n               n' postdominates targetnode a'') \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(cases \"n = sourcenode ax'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case True"], ["proof (state)\nthis:\n  n = sourcenode ax'\n\ngoal (2 subgoals):\n 1. n = sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\\<close> \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n  valid_edge ax'\n  n = sourcenode ax'", "have \"CFG_node n cd-[]@[CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n  valid_edge ax'\n  n = sourcenode ax'\n\ngoal (1 subgoal):\n 1. CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'", "by(fastforce intro:cdSp_Append_cdep cdSp_Nil)"], ["proof (state)\nthis:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (2 subgoals):\n 1. n = sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>sourcenode ax' \\<in> set(sourcenodes as)\\<close> True"], ["proof (chain)\npicking this:\n  sourcenode ax' \\<in> set (sourcenodes as)\n  n = sourcenode ax'\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode ax' \\<in> set (sourcenodes as)\n  n = sourcenode ax'\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal (1 subgoal):\n 1. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case False"], ["proof (state)\nthis:\n  n \\<noteq> sourcenode ax'\n\ngoal (1 subgoal):\n 1. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'", "have \"sourcenode ax' \\<noteq> (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n\ngoal (1 subgoal):\n 1. sourcenode ax' \\<noteq> (_Exit_)", "by -(rule ccontr,fastforce elim!:Exit_source)"], ["proof (state)\nthis:\n  sourcenode ax' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -ax#asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\\<close>"], ["proof (chain)\npicking this:\n  n -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'", "have \"n = sourcenode ax\""], ["proof (prove)\nusing this:\n  n -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n\ngoal (1 subgoal):\n 1. n = sourcenode ax", "by(fastforce intro:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  n = sourcenode ax\n\ngoal (1 subgoal):\n 1. n \\<noteq> sourcenode ax' \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "proof(cases \"\\<forall>ax. valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n                ax \\<notin> get_return_edges a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case True"], ["proof (state)\nthis:\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n     ax \\<notin> get_return_edges a\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>asx = asx'@ax'#asx''\\<close> \\<open>n -ax#asx\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  asx = asx' @ ax' # asx''\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"intra_kind (kind ax')\""], ["proof (prove)\nusing this:\n  asx = asx' @ ax' # asx''\n  n -ax # asx\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax')", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  intra_kind (kind ax')\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "have \"\\<not> method_exit (sourcenode ax')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> method_exit (sourcenode ax')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. method_exit (sourcenode ax') \\<Longrightarrow> False", "assume \"method_exit (sourcenode ax')\""], ["proof (state)\nthis:\n  method_exit (sourcenode ax')\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode ax') \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  method_exit (sourcenode ax')\n\ngoal (1 subgoal):\n 1. False", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"sourcenode ax' = (_Exit_)\""], ["proof (state)\nthis:\n  sourcenode ax' = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode ax' = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  sourcenode ax' = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  valid_edge ax'\n  sourcenode ax' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "fix x Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \" sourcenode ax' = sourcenode x\"\n                    and \"valid_edge x\" and \"kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  sourcenode ax' = sourcenode x\n  valid_edge x\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>sourcenode ax' = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge x\\<close> \\<open>kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>sourcenode ax' = sourcenode x\\<close>\n                    \\<open>valid_edge ax'\\<close> \\<open>intra_kind (kind ax')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode ax' = sourcenode x\n  valid_edge ax'\n  intra_kind (kind ax')", "show False"], ["proof (prove)\nusing this:\n  valid_edge x\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode ax' = sourcenode x\n  valid_edge ax'\n  intra_kind (kind ax')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> method_exit (sourcenode ax')\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with IH \\<open>length (ax#asx') < length as\\<close> \\<open>n -ax#asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\\<close>\n                \\<open>n \\<noteq> sourcenode ax'\\<close> \\<open>sourcenode ax' \\<noteq> (_Exit_)\\<close> True"], ["proof (chain)\npicking this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n         n \\<noteq> n'' \\<longrightarrow>\n         n'' \\<noteq> (_Exit_) \\<longrightarrow>\n         (\\<forall>ax.\n             valid_edge ax \\<and> sourcenode ax = n'' \\<longrightarrow>\n             ax \\<notin> get_return_edges a) \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and>\n             ns \\<noteq> [] \\<and>\n             (\\<forall>n''\\<in>set ns.\n                 parent_node n'' \\<in> set (sourcenodes as'))))\n  length (ax # asx') < length as\n  n -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  n \\<noteq> sourcenode ax'\n  sourcenode ax' \\<noteq> (_Exit_)\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n     ax \\<notin> get_return_edges a\n  \\<not> method_exit (sourcenode ax')", "obtain ns where \"CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\"\n                and \"ns \\<noteq> []\" \n                and \"\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes (ax#asx'))\""], ["proof (prove)\nusing this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>n''.\n         n -as'\\<rightarrow>\\<^sub>\\<iota>* n'' \\<longrightarrow>\n         n \\<noteq> n'' \\<longrightarrow>\n         n'' \\<noteq> (_Exit_) \\<longrightarrow>\n         (\\<forall>ax.\n             valid_edge ax \\<and> sourcenode ax = n'' \\<longrightarrow>\n             ax \\<notin> get_return_edges a) \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n'' \\<and>\n             ns \\<noteq> [] \\<and>\n             (\\<forall>n''\\<in>set ns.\n                 parent_node n'' \\<in> set (sourcenodes as'))))\n  length (ax # asx') < length as\n  n -ax # asx'\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax'\n  n \\<noteq> sourcenode ax'\n  sourcenode ax' \\<noteq> (_Exit_)\n  \\<forall>ax.\n     valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n     ax \\<notin> get_return_edges a\n  \\<not> method_exit (sourcenode ax')\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>CFG_node\n                  n cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax');\n         ns \\<noteq> [];\n         \\<forall>n''\\<in>set ns.\n            parent_node n'' \\<in> set (sourcenodes (ax # asx'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns.\n     parent_node n'' \\<in> set (sourcenodes (ax # asx'))\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\\<close>\n                \\<open>CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "have \"CFG_node n cd-ns@[CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\""], ["proof (prove)\nusing this:\n  CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     n cd-ns @ [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'", "by(rule cdSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   n cd-ns @ [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "moreover"], ["proof (state)\nthis:\n  CFG_node\n   n cd-ns @ [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes (ax#asx'))\\<close>\n                \\<open>asx = asx'@ax'#asx''\\<close> \\<open>as = (ax#asx)@zs\\<close>\n                \\<open>sourcenode ax' \\<in> set(sourcenodes as)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''\\<in>set ns.\n     parent_node n'' \\<in> set (sourcenodes (ax # asx'))\n  asx = asx' @ ax' # asx''\n  as = (ax # asx) @ zs\n  sourcenode ax' \\<in> set (sourcenodes as)", "have \"\\<forall>n''\\<in>set (ns@[CFG_node (sourcenode ax')]). \n                parent_node n'' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  \\<forall>n''\\<in>set ns.\n     parent_node n'' \\<in> set (sourcenodes (ax # asx'))\n  asx = asx' @ ax' # asx''\n  as = (ax # asx) @ zs\n  sourcenode ax' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n       parent_node n'' \\<in> set (sourcenodes as)", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<forall>ax.\n       valid_edge ax \\<and> sourcenode ax = sourcenode ax' \\<longrightarrow>\n       ax \\<notin> get_return_edges a \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n 2. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "ultimately"], ["proof (chain)\npicking this:\n  CFG_node\n   n cd-ns @ [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n  \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   n cd-ns @ [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n  \\<forall>n''\\<in>set (ns @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>ax.\n             valid_edge ax \\<and>\n             sourcenode ax = sourcenode ax' \\<longrightarrow>\n             ax \\<notin> get_return_edges a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>ax.\n             valid_edge ax \\<and>\n             sourcenode ax = sourcenode ax' \\<longrightarrow>\n             ax \\<notin> get_return_edges a)", "obtain ai' where \"valid_edge ai'\" \n                and \"sourcenode ai' = sourcenode ax'\" \n                and \"ai' \\<in> get_return_edges a\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ax.\n             valid_edge ax \\<and>\n             sourcenode ax = sourcenode ax' \\<longrightarrow>\n             ax \\<notin> get_return_edges a)\n\ngoal (1 subgoal):\n 1. (\\<And>ai'.\n        \\<lbrakk>valid_edge ai'; sourcenode ai' = sourcenode ax';\n         ai' \\<in> get_return_edges a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ai'\n  sourcenode ai' = sourcenode ax'\n  ai' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = n\n  valid_edge ai'\n  sourcenode ai' = sourcenode ax'\n  ai' \\<in> get_return_edges a", "have \"CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode ax')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = n\n  valid_edge ai'\n  sourcenode ai' = sourcenode ax'\n  ai' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode ax')", "by(fastforce intro!:SDG_proc_entry_exit_cdep[of _ _ _ _ _ _ ai'])"], ["proof (state)\nthis:\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode ax')", "have \"CFG_node n cd-[]@[CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\""], ["proof (prove)\nusing this:\n  valid_node n\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. CFG_node\n     n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')", "by(fastforce intro:cdSp_Append_cdep cdSp_Nil)"], ["proof (state)\nthis:\n  CFG_node\n   n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n  CFG_node\n   n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')", "have \"CFG_node n cd-[CFG_node n]@[CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* \n                CFG_node n'\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode ax') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n  CFG_node\n   n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode ax')\n\ngoal (1 subgoal):\n 1. CFG_node\n     n cd-[CFG_node n] @\n          [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'", "by(fastforce intro:cdSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   n cd-[CFG_node n] @\n        [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "moreover"], ["proof (state)\nthis:\n  CFG_node\n   n cd-[CFG_node n] @\n        [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>sourcenode ax' \\<in> set(sourcenodes as)\\<close> \\<open>n = sourcenode ax\\<close>\n                \\<open>as = (ax#asx)@zs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax' \\<in> set (sourcenodes as)\n  n = sourcenode ax\n  as = (ax # asx) @ zs", "have \"\\<forall>n''\\<in>set ([CFG_node n]@[CFG_node (sourcenode ax')]). \n                parent_node n'' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  sourcenode ax' \\<in> set (sourcenodes as)\n  n = sourcenode ax\n  as = (ax # asx) @ zs\n\ngoal (1 subgoal):\n 1. \\<forall>n''\\<in>set ([CFG_node n] @ [CFG_node (sourcenode ax')]).\n       parent_node n'' \\<in> set (sourcenodes as)", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''\\<in>set ([CFG_node n] @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and>\n               sourcenode ax = sourcenode ax' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "ultimately"], ["proof (chain)\npicking this:\n  CFG_node\n   n cd-[CFG_node n] @\n        [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n  \\<forall>n''\\<in>set ([CFG_node n] @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   n cd-[CFG_node n] @\n        [CFG_node (sourcenode ax')]\\<rightarrow>\\<^sub>d* CFG_node n'\n  \\<forall>n''\\<in>set ([CFG_node n] @ [CFG_node (sourcenode ax')]).\n     parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>ax.\n             valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n             ax \\<notin> get_return_edges a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>ax.\n             valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n             ax \\<notin> get_return_edges a)", "obtain a' where \"valid_edge a'\" and \"sourcenode a' = n'\"\n      and \"a' \\<in> get_return_edges a\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ax.\n             valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n             ax \\<notin> get_return_edges a)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = n';\n         a' \\<in> get_return_edges a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = n'\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = n\n  valid_edge a'\n  sourcenode a' = n'\n  a' \\<in> get_return_edges a", "have \"CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = n\n  valid_edge a'\n  sourcenode a' = n'\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "by(fastforce intro:SDG_proc_entry_exit_cdep)"], ["proof (state)\nthis:\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>valid_edge a\\<close> \\<open>targetnode a = n\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = targetnode a\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'", "have \"CFG_node n cd-[]@[CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  n = targetnode a\n  CFG_node n \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n'\n\ngoal (1 subgoal):\n 1. CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'", "by(fastforce intro:cdep_SDG_path.intros)"], ["proof (state)\nthis:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>n \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as \\<noteq> []", "have \"hd (sourcenodes as) = n\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as) = n", "by(fastforce intro:path_sourcenode simp:intra_path_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as) = n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  hd (sourcenodes as) = n", "have \"n \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  hd (sourcenodes as) = n\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes as)", "by(fastforce intro:hd_in_set simp:sourcenodes_def)"], ["proof (state)\nthis:\n  n \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ax.\n               valid_edge ax \\<and> sourcenode ax = n' \\<longrightarrow>\n               ax \\<notin> get_return_edges a) \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "with \\<open>CFG_node n cd-[]@[CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n  n \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node n cd-[] @ [CFG_node n]\\<rightarrow>\\<^sub>d* CFG_node n'\n  n \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n       ns \\<noteq> [] \\<and>\n       (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))", "by auto"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node n cd-ns\\<rightarrow>\\<^sub>d* CFG_node n' \\<and>\n     ns \\<noteq> [] \\<and>\n     (\\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Paths consisting of calls and control dependences\\<close>"], ["", "inductive call_cdep_SDG_path ::\n  \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n(\"_ cc-_\\<rightarrow>\\<^sub>d* _\" [51,0,0] 80)\nwhere ccSp_Nil:\n  \"valid_SDG_node n \\<Longrightarrow> n cc-[]\\<rightarrow>\\<^sub>d* n\"\n\n  | ccSp_Append_cdep:\n  \"\\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n cc-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | ccSp_Append_call:\n  \"\\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n cc-ns@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["", "lemma cc_SDG_path_Append:\n  \"\\<lbrakk>n'' cc-ns'\\<rightarrow>\\<^sub>d* n'; n cc-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n cc-ns@ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' cc-ns'\\<rightarrow>\\<^sub>d* n';\n     n cc-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n    \\<Longrightarrow> n cc-ns @ ns'\\<rightarrow>\\<^sub>d* n'", "by(induct rule:call_cdep_SDG_path.induct,\n   auto intro:call_cdep_SDG_path.intros simp:append_assoc[THEN sym] \n                                        simp del:append_assoc)"], ["", "lemma cdep_SDG_path_cc_SDG_path:\n  \"n cd-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n cc-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n cd-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n cc-ns\\<rightarrow>\\<^sub>d* n'", "by(induct rule:cdep_SDG_path.induct,auto intro:call_cdep_SDG_path.intros)"], ["", "lemma Entry_cc_SDG_path_to_inner_node:\n  assumes \"valid_SDG_node n\" and \"parent_node n \\<noteq> (_Exit_)\"\n  obtains ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "obtain m where \"m = parent_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. m = parent_node n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  m = parent_node n\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"valid_node (parent_node n)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n)", "by(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node n)\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "thus \"\\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  valid_node (parent_node n)\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "proof(cases \"parent_node n\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. parent_node n = (_Entry_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. parent_node n = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 3. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case Entry"], ["proof (state)\nthis:\n  parent_node n = (_Entry_)\n\ngoal (3 subgoals):\n 1. parent_node n = (_Entry_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. parent_node n = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 3. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  parent_node n = (_Entry_)", "have \"n = CFG_node (_Entry_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  parent_node n = (_Entry_)\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Entry_)", "by(rule valid_SDG_node_parent_Entry)"], ["proof (state)\nthis:\n  n = CFG_node (_Entry_)\n\ngoal (3 subgoals):\n 1. parent_node n = (_Entry_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. parent_node n = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 3. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = CFG_node (_Entry_)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = CFG_node (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by(fastforce intro:ccSp_Nil)"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal (2 subgoals):\n 1. parent_node n = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. parent_node n = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case Exit"], ["proof (state)\nthis:\n  parent_node n = (_Exit_)\n\ngoal (2 subgoals):\n 1. parent_node n = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>parent_node n \\<noteq> (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n \\<noteq> (_Exit_)\n  parent_node n = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  parent_node n \\<noteq> (_Exit_)\n  parent_node n = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. parent_node n = (_Exit_) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by simp"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case inner"], ["proof (state)\nthis:\n  inner_node (parent_node n)\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>m = parent_node n\\<close>"], ["proof (chain)\npicking this:\n  m = parent_node n\n  inner_node (parent_node n)", "obtain asx where \"(_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* m\""], ["proof (prove)\nusing this:\n  m = parent_node n\n  inner_node (parent_node n)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Entry_path inner_is_valid)"], ["proof (state)\nthis:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "then"], ["proof (chain)\npicking this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* m", "obtain as where \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\"\n      and \"\\<forall>a' \\<in> set as. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m;\n         \\<forall>a'\\<in>set as.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Entry_path_ascending_path,fastforce)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>inner_node (parent_node n)\\<close> \\<open>m = parent_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node (parent_node n)\n  m = parent_node n", "have \"inner_node m\""], ["proof (prove)\nusing this:\n  inner_node (parent_node n)\n  m = parent_node n\n\ngoal (1 subgoal):\n 1. inner_node m", "by simp"], ["proof (state)\nthis:\n  inner_node m\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\\<close> \\<open>m = parent_node n\\<close> \\<open>valid_SDG_node n\\<close>\n      \\<open>\\<forall>a' \\<in> set as. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  m = parent_node n\n  valid_SDG_node n\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  inner_node m", "show ?thesis"], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  m = parent_node n\n  valid_SDG_node n\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  inner_node m\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "proof(induct as arbitrary:m n rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<surd>* x \\<longrightarrow>\n                       (\\<forall>xa.\n                           x = parent_node xa \\<longrightarrow>\n                           valid_SDG_node xa \\<longrightarrow>\n                           (\\<forall>a'\\<in>set ys.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q r p fs.\n                                   kind a' =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n                           inner_node x \\<longrightarrow>\n                           (\\<exists>ns.\n                               CFG_node\n                                (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* xa)));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* m; m = parent_node n;\n        valid_SDG_node n;\n        \\<forall>a'\\<in>set xs.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n        inner_node m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "fix as m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<surd>* x \\<longrightarrow>\n                       (\\<forall>xa.\n                           x = parent_node xa \\<longrightarrow>\n                           valid_SDG_node xa \\<longrightarrow>\n                           (\\<forall>a'\\<in>set ys.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q r p fs.\n                                   kind a' =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n                           inner_node x \\<longrightarrow>\n                           (\\<exists>ns.\n                               CFG_node\n                                (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* xa)));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* m; m = parent_node n;\n        valid_SDG_node n;\n        \\<forall>a'\\<in>set xs.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n        inner_node m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "assume IH:\"\\<forall>as'. length as' < length as \\<longrightarrow>\n        (\\<forall>m'. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n        (\\<forall>n'. m' = parent_node n' \\<longrightarrow> valid_SDG_node n' \\<longrightarrow>\n        (\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n        inner_node m' \\<longrightarrow> (\\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\"\n        and \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\" \n        and \"m = parent_node n\" and \"valid_SDG_node n\" and \"inner_node m\"\n        and \"\\<forall>a' \\<in> set as. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (state)\nthis:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  m = parent_node n\n  valid_SDG_node n\n  inner_node m\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<And>xs m n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (_Entry_) -ys\\<rightarrow>\\<^sub>\\<surd>* x \\<longrightarrow>\n                       (\\<forall>xa.\n                           x = parent_node xa \\<longrightarrow>\n                           valid_SDG_node xa \\<longrightarrow>\n                           (\\<forall>a'\\<in>set ys.\n                               intra_kind (kind a') \\<or>\n                               (\\<exists>Q r p fs.\n                                   kind a' =\n                                   Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n                           inner_node x \\<longrightarrow>\n                           (\\<exists>ns.\n                               CFG_node\n                                (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* xa)));\n        (_Entry_) -xs\\<rightarrow>\\<^sub>\\<surd>* m; m = parent_node n;\n        valid_SDG_node n;\n        \\<forall>a'\\<in>set xs.\n           intra_kind (kind a') \\<or>\n           (\\<exists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n        inner_node m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "show \"\\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "proof(cases \"\\<forall>a' \\<in> set as. intra_kind(kind a')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case True"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set as. intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  \\<forall>a'\\<in>set as. intra_kind (kind a')", "have \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  \\<forall>a'\\<in>set as. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m", "by(fastforce simp:intra_path_def vp_def)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "have \"\\<not> method_exit m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> method_exit m", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. method_exit m \\<Longrightarrow> False", "assume \"method_exit m\""], ["proof (state)\nthis:\n  method_exit m\n\ngoal (1 subgoal):\n 1. method_exit m \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  method_exit m\n\ngoal (1 subgoal):\n 1. False", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m = (_Exit_)\""], ["proof (state)\nthis:\n  m = (_Exit_)\n\ngoal (2 subgoals):\n 1. m = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>inner_node m\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  m = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  inner_node m\n  m = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(simp add:inner_node_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "fix a Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"m = sourcenode a\" and \"valid_edge a\"\n              and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m", "have \"get_proc m = Main\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. get_proc m = Main", "by(fastforce dest:intra_path_get_procs simp:get_proc_Entry)"], ["proof (state)\nthis:\n  get_proc m = Main\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>get_proc m = Main\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  get_proc m = Main\n  m = sourcenode a\n  get_proc (sourcenode a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  get_proc m = Main\n  m = sourcenode a\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>m = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> method_exit m\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>inner_node m\\<close> \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\n  \\<not> method_exit m", "obtain ns where \"CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\"\n          and \"ns \\<noteq> []\" and \"\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  inner_node m\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\n  \\<not> method_exit m\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m;\n         ns \\<noteq> [];\n         \\<forall>n''\\<in>set ns.\n            parent_node n'' \\<in> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_cdep_SDG_path)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "then"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as)", "obtain n' where \"n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\"\n          and \"parent_node n' \\<in> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m;\n         parent_node n' \\<in> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule cdep_SDG_path.cases,auto)"], ["proof (state)\nthis:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>parent_node n' \\<in> set(sourcenodes as)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n' \\<in> set (sourcenodes as)", "obtain ms ms' \n          where \"sourcenodes as = ms@(parent_node n')#ms'\""], ["proof (prove)\nusing this:\n  parent_node n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. (\\<And>ms ms'.\n        sourcenodes as = ms @ parent_node n' # ms' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:split_list simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes as = ms @ parent_node n' # ms'\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "then"], ["proof (chain)\npicking this:\n  sourcenodes as = ms @ parent_node n' # ms'", "obtain as' a as'' where \"ms = sourcenodes as'\" \n          and \"ms' = sourcenodes as''\" and \"as = as'@a#as''\" \n          and \"parent_node n' = sourcenode a\""], ["proof (prove)\nusing this:\n  sourcenodes as = ms @ parent_node n' # ms'\n\ngoal (1 subgoal):\n 1. (\\<And>as' as'' a.\n        \\<lbrakk>ms = sourcenodes as'; ms' = sourcenodes as'';\n         as = as' @ a # as''; parent_node n' = sourcenode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  ms = sourcenodes as'\n  ms' = sourcenodes as''\n  as = as' @ a # as''\n  parent_node n' = sourcenode a\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\n  ms = sourcenodes as'\n  ms' = sourcenodes as''\n  as = as' @ a # as''\n  parent_node n' = sourcenode a", "have \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* m\n  ms = sourcenodes as'\n  ms' = sourcenodes as''\n  as = as' @ a # as''\n  parent_node n' = sourcenode a\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by(fastforce intro:path_split simp:intra_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(rule SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "hence n'_cases:\n          \"n' = CFG_node (parent_node n') \\<or> CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. n' = CFG_node (parent_node n') \\<or>\n    CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "by(rule valid_SDG_node_cases)"], ["proof (state)\nthis:\n  n' = CFG_node (parent_node n') \\<or>\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set as. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' = []", "have \"parent_node n' = (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' = []\n\ngoal (1 subgoal):\n 1. parent_node n' = (_Entry_)", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node n' = (_Entry_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from n'_cases"], ["proof (chain)\npicking this:\n  n' = CFG_node (parent_node n') \\<or>\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"\\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\""], ["proof (prove)\nusing this:\n  n' = CFG_node (parent_node n') \\<or>\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = CFG_node (parent_node n') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n 2. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "assume \"n' = CFG_node (parent_node n')\""], ["proof (state)\nthis:\n  n' = CFG_node (parent_node n')\n\ngoal (2 subgoals):\n 1. n' = CFG_node (parent_node n') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n 2. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close> \\<open>parent_node n' = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' = (_Entry_)\n  n' = CFG_node (parent_node n')", "have \"CFG_node (_Entry_) cd-[]@[CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node m\""], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' = (_Entry_)\n  n' = CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node m", "by -(rule cdSp_Append_cdep,rule cdSp_Nil,auto)"], ["proof (state)\nthis:\n  CFG_node\n   (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (2 subgoals):\n 1. n' = CFG_node (parent_node n') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n 2. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "assume \"CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\""], ["proof (state)\nthis:\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>parent_node n' = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n' = (_Entry_)\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"CFG_node (_Entry_) cd-[]@[CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  parent_node n' = (_Entry_)\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. CFG_node (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* n'", "by -(rule cdSp_Append_cdep,rule cdSp_Nil,auto)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  CFG_node (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* n'", "have \"CFG_node (_Entry_) cd-[CFG_node (_Entry_)]@[n']\\<rightarrow>\\<^sub>d* CFG_node m\""], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  CFG_node (_Entry_) cd-[] @ [CFG_node (_Entry_)]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (_Entry_) cd-[CFG_node (_Entry_)] @\n                  [n']\\<rightarrow>\\<^sub>d* CFG_node m", "by(fastforce intro:cdSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (_Entry_) cd-[CFG_node (_Entry_)] @ [n']\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (_Entry_) cd-[CFG_node (_Entry_)] @ [n']\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "then"], ["proof (chain)\npicking this:\n  \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m", "obtain ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\""], ["proof (prove)\nusing this:\n  \\<exists>ns. CFG_node (_Entry_) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node\n         (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce intro:cdep_SDG_path_cc_SDG_path)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "proof(cases \"n = CFG_node m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case True"], ["proof (state)\nthis:\n  n = CFG_node m\n\ngoal (2 subgoals):\n 1. n = CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  n = CFG_node m", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  n = CFG_node m\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> CFG_node m\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>inner_node m\\<close> \\<open>valid_SDG_node n\\<close> \\<open>m = parent_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  valid_SDG_node n\n  m = parent_node n\n  n \\<noteq> CFG_node m", "have \"CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  inner_node m\n  valid_SDG_node n\n  m = parent_node n\n  n \\<noteq> CFG_node m\n\ngoal (1 subgoal):\n 1. CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by(fastforce intro:SDG_parent_cdep_edge inner_is_valid)"], ["proof (state)\nthis:\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "have \"CFG_node (_Entry_) cc-ns@[CFG_node m]\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. CFG_node (_Entry_) cc-ns @ [CFG_node m]\\<rightarrow>\\<^sub>d* n", "by(fastforce intro:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns @ [CFG_node m]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns @ [CFG_node m]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''\n  as' \\<noteq> []", "have \"length as' < length as\""], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length as' < length as", "by simp"], ["proof (state)\nthis:\n  length as' < length as\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"valid_node (parent_node n')\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n')", "by(fastforce intro:path_valid_node simp:intra_path_def)"], ["proof (state)\nthis:\n  valid_node (parent_node n')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "hence \"inner_node (parent_node n')\""], ["proof (prove)\nusing this:\n  valid_node (parent_node n')\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n')", "proof(cases \"parent_node n'\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. parent_node n' = (_Entry_) \\<Longrightarrow> inner_node (parent_node n')\n 2. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 3. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "case Entry"], ["proof (state)\nthis:\n  parent_node n' = (_Entry_)\n\ngoal (3 subgoals):\n 1. parent_node n' = (_Entry_) \\<Longrightarrow> inner_node (parent_node n')\n 2. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 3. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "with \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  parent_node n' = (_Entry_)", "have \"(_Entry_) -as'\\<rightarrow>* (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  parent_node n' = (_Entry_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>* (_Entry_)", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>* (_Entry_)\n\ngoal (3 subgoals):\n 1. parent_node n' = (_Entry_) \\<Longrightarrow> inner_node (parent_node n')\n 2. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 3. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "with False"], ["proof (chain)\npicking this:\n  as' \\<noteq> []\n  (_Entry_) -as'\\<rightarrow>* (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  as' \\<noteq> []\n  (_Entry_) -as'\\<rightarrow>* (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. parent_node n' = (_Entry_) \\<Longrightarrow> inner_node (parent_node n')\n 2. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 3. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n')", "by simp"], ["proof (state)\nthis:\n  inner_node (parent_node n')\n\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 2. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 2. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "case Exit"], ["proof (state)\nthis:\n  parent_node n' = (_Exit_)\n\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 2. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "with \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' = (_Exit_)", "have \"n' = CFG_node (_Exit_)\""], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = CFG_node (_Exit_)", "by -(rule valid_SDG_node_parent_Exit,erule SDG_edge_valid_SDG_node,simp)"], ["proof (state)\nthis:\n  n' = CFG_node (_Exit_)\n\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 2. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "with \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close> Exit"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' = (_Exit_)\n  n' = CFG_node (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' = (_Exit_)\n  n' = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by simp(erule Exit_no_SDG_edge_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> inner_node (parent_node n')\n 2. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n')", "by simp"], ["proof (state)\nthis:\n  inner_node (parent_node n')\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "case inner"], ["proof (state)\nthis:\n  inner_node (parent_node n')\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow>\n    inner_node (parent_node n')", "thus ?thesis"], ["proof (prove)\nusing this:\n  inner_node (parent_node n')\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n')", "by simp"], ["proof (state)\nthis:\n  inner_node (parent_node n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inner_node (parent_node n')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>valid_node (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  valid_node (parent_node n')", "have \"valid_SDG_node (CFG_node (parent_node n'))\""], ["proof (prove)\nusing this:\n  valid_node (parent_node n')\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (parent_node n'))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (parent_node n'))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (parent_node n')\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n'", "by(rule intra_path_vp)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>\\<forall>a' \\<in> set as. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>\n            \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  as = as' @ a # as''", "have \"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set as'.\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q r p fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "by auto"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with IH \\<open>length as' < length as\\<close> \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (parent_node n')\\<close>\n            \\<open>valid_SDG_node (CFG_node (parent_node n'))\\<close> \\<open>inner_node (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\n  length as' < length as\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n  valid_SDG_node (CFG_node (parent_node n'))\n  inner_node (parent_node n')\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "obtain ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\""], ["proof (prove)\nusing this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\n  length as' < length as\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n  valid_SDG_node (CFG_node (parent_node n'))\n  inner_node (parent_node n')\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node\n         (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n          (parent_node n') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (parent_node n') \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n';\n     valid_SDG_node (CFG_node (parent_node n'));\n     inner_node (parent_node n');\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node\n                  (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (parent_node n') \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n';\n     valid_node (parent_node n'); inner_node (parent_node n');\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     \\<forall>m'.\n        (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n        (\\<forall>n'.\n            m' = parent_node n' \\<longrightarrow>\n            valid_SDG_node n' \\<longrightarrow>\n            inner_node (parent_node n') \\<longrightarrow>\n            (\\<exists>ns.\n                CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"(parent_node n')\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (parent_node n') \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n';\n     valid_node (parent_node n'); inner_node (parent_node n');\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node\n           n' \\<longrightarrow>\n     (\\<forall>n'a.\n         parent_node n' = parent_node n'a \\<longrightarrow>\n         valid_SDG_node n'a \\<longrightarrow>\n         inner_node (parent_node n'a) \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'a))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (parent_node n') \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n';\n     valid_node (parent_node n'); inner_node (parent_node n');\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     \\<forall>n'a.\n        parent_node n' = parent_node n'a \\<longrightarrow>\n        valid_SDG_node n'a \\<longrightarrow>\n        inner_node (parent_node n'a) \\<longrightarrow>\n        (\\<exists>ns.\n            CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"CFG_node (parent_node n')\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (parent_node n') \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n';\n     valid_node (parent_node n'); inner_node (parent_node n');\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     parent_node n' =\n     parent_node (CFG_node (parent_node n')) \\<longrightarrow>\n     valid_SDG_node (CFG_node (parent_node n')) \\<longrightarrow>\n     inner_node (parent_node (CFG_node (parent_node n'))) \\<longrightarrow>\n     (\\<exists>ns.\n         CFG_node\n          (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n           (parent_node n'))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by clarsimp"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from n'_cases"], ["proof (chain)\npicking this:\n  n' = CFG_node (parent_node n') \\<or>\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"\\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n' = CFG_node (parent_node n') \\<or>\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = CFG_node (parent_node n') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'\n 2. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "assume \"n' = CFG_node (parent_node n')\""], ["proof (state)\nthis:\n  n' = CFG_node (parent_node n')\n\ngoal (2 subgoals):\n 1. n' = CFG_node (parent_node n') \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'\n 2. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  n' = CFG_node (parent_node n')", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  n' = CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "assume \"CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\""], ["proof (state)\nthis:\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"CFG_node (_Entry_) cc-ns@[CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (_Entry_) cc-ns @ [CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (_Entry_) cc-ns @ [CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (_Entry_) cc-ns @ [CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "then"], ["proof (chain)\npicking this:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'", "obtain ns' where \"CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* n'", "have \"CFG_node (_Entry_) cc-ns'@[n']\\<rightarrow>\\<^sub>d* CFG_node m\""], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. CFG_node (_Entry_) cc-ns' @ [n']\\<rightarrow>\\<^sub>d* CFG_node m", "by(fastforce intro:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns' @ [n']\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "proof(cases \"n = CFG_node m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case True"], ["proof (state)\nthis:\n  n = CFG_node m\n\ngoal (2 subgoals):\n 1. n = CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>CFG_node (_Entry_) cc-ns'@[n']\\<rightarrow>\\<^sub>d* CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns' @ [n']\\<rightarrow>\\<^sub>d* CFG_node m\n  n = CFG_node m", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns' @ [n']\\<rightarrow>\\<^sub>d* CFG_node m\n  n = CFG_node m\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> CFG_node m\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>inner_node m\\<close> \\<open>valid_SDG_node n\\<close> \\<open>m = parent_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  valid_SDG_node n\n  m = parent_node n\n  n \\<noteq> CFG_node m", "have \"CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  inner_node m\n  valid_SDG_node n\n  m = parent_node n\n  n \\<noteq> CFG_node m\n\ngoal (1 subgoal):\n 1. CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by(fastforce intro:SDG_parent_cdep_edge inner_is_valid)"], ["proof (state)\nthis:\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>CFG_node (_Entry_) cc-ns'@[n']\\<rightarrow>\\<^sub>d* CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns' @ [n']\\<rightarrow>\\<^sub>d* CFG_node m\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "have \"CFG_node (_Entry_) cc-(ns'@[n'])@[CFG_node m]\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns' @ [n']\\<rightarrow>\\<^sub>d* CFG_node m\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. CFG_node\n     (_Entry_) cc-(ns' @ [n']) @ [CFG_node m]\\<rightarrow>\\<^sub>d* n", "by(fastforce intro:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-(ns' @ [n']) @ [CFG_node m]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-(ns' @ [n']) @ [CFG_node m]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "hence \"\\<exists>a' \\<in> set as. \\<not> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. \\<exists>a'\\<in>set as. \\<not> intra_kind (kind a')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>set as. \\<not> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'\\<in>set as. \\<not> intra_kind (kind a')", "obtain a as' as'' where \"as = as'@a#as''\" and \"\\<not> intra_kind (kind a)\"\n          and \"\\<forall>a' \\<in> set as''. intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  \\<exists>a'\\<in>set as. \\<not> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>as = as' @ a # as''; \\<not> intra_kind (kind a);\n         \\<forall>a'\\<in>set as''. intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_last_propE)"], ["proof (state)\nthis:\n  as = as' @ a # as''\n  \\<not> intra_kind (kind a)\n  \\<forall>a'\\<in>set as''. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>\\<forall>a' \\<in> set as. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>\n          \\<open>as = as'@a#as''\\<close> \\<open>\\<not> intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  as = as' @ a # as''\n  \\<not> intra_kind (kind a)", "obtain Q r p fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \n          and \"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  as = as' @ a # as''\n  \\<not> intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         \\<forall>a'\\<in>set as'.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''", "have \"length as' < length as\""], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. length as' < length as", "by fastforce"], ["proof (state)\nthis:\n  length as' < length as\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\\<close> \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  as = as' @ a # as''", "have \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\" and \"valid_edge a\"\n          and \"targetnode a -as''\\<rightarrow>\\<^sub>\\<surd>* m\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a &&&\n    valid_edge a &&& targetnode a -as''\\<rightarrow>\\<^sub>\\<surd>* m", "by(auto intro:vp_split)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  valid_edge a\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "hence \"valid_SDG_node (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  valid_edge a\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (sourcenode a))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "have \"\\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "proof(cases \"targetnode a = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a = m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n 2. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "case True"], ["proof (state)\nthis:\n  targetnode a = m\n\ngoal (2 subgoals):\n 1. targetnode a = m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n 2. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m", "have \"CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = m\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m", "by(fastforce intro:SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\n\ngoal (2 subgoals):\n 1. targetnode a = m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n 2. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "have \"\\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "with \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  as' = []", "have \"(_Entry_) = sourcenode a\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  as' = []\n\ngoal (1 subgoal):\n 1. (_Entry_) = sourcenode a", "by(fastforce simp:vp_def)"], ["proof (state)\nthis:\n  (_Entry_) = sourcenode a\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "with \\<open>CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\n  (_Entry_) = sourcenode a", "have \"CFG_node (_Entry_) cc-[]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\n  (_Entry_) = sourcenode a\n\ngoal (1 subgoal):\n 1. CFG_node (_Entry_) cc-[]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "by(fastforce intro:ccSp_Nil SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-[]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-[]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "hence \"inner_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a)", "proof(cases \"sourcenode a\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 3. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "case Entry"], ["proof (state)\nthis:\n  sourcenode a = (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 3. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "with \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  sourcenode a = (_Entry_)", "have \"(_Entry_) -as'\\<rightarrow>* (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  sourcenode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -as'\\<rightarrow>* (_Entry_)", "by(fastforce simp:vp_def)"], ["proof (state)\nthis:\n  (_Entry_) -as'\\<rightarrow>* (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 3. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "with False"], ["proof (chain)\npicking this:\n  as' \\<noteq> []\n  (_Entry_) -as'\\<rightarrow>* (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  as' \\<noteq> []\n  (_Entry_) -as'\\<rightarrow>* (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 3. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "case Exit"], ["proof (state)\nthis:\n  sourcenode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(erule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a)\n 2. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "case inner"], ["proof (state)\nthis:\n  inner_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a) \\<Longrightarrow> inner_node (sourcenode a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inner_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inner_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "with IH \\<open>length as' < length as\\<close> \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\\<close>\n              \\<open>valid_SDG_node (CFG_node (sourcenode a))\\<close> \n              \\<open>\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\n  length as' < length as\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  valid_SDG_node (CFG_node (sourcenode a))\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  inner_node (sourcenode a)", "obtain ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\n  length as' < length as\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a\n  valid_SDG_node (CFG_node (sourcenode a))\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  inner_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node\n         (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n          (sourcenode a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a) \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a;\n     valid_SDG_node (CFG_node (sourcenode a));\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     inner_node (sourcenode a);\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node\n                  (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a) \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a;\n     valid_node (sourcenode a);\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     inner_node (sourcenode a);\n     \\<forall>m'.\n        (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n        (\\<forall>n'.\n            m' = parent_node n' \\<longrightarrow>\n            valid_SDG_node n' \\<longrightarrow>\n            inner_node (parent_node n') \\<longrightarrow>\n            (\\<exists>ns.\n                CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"sourcenode a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a) \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a;\n     valid_node (sourcenode a);\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     inner_node (sourcenode a);\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode\n           a \\<longrightarrow>\n     (\\<forall>n'.\n         sourcenode a = parent_node n' \\<longrightarrow>\n         valid_SDG_node n' \\<longrightarrow>\n         inner_node (parent_node n') \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a) \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a;\n     valid_node (sourcenode a);\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     inner_node (sourcenode a);\n     \\<forall>n'.\n        sourcenode a = parent_node n' \\<longrightarrow>\n        valid_SDG_node n' \\<longrightarrow>\n        inner_node (parent_node n') \\<longrightarrow>\n        (\\<exists>ns.\n            CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"CFG_node (sourcenode a)\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a) \\<Longrightarrow>\n                thesis;\n     length as' < length as;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a;\n     valid_node (sourcenode a);\n     \\<forall>a'\\<in>set as'.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     inner_node (sourcenode a);\n     sourcenode a = parent_node (CFG_node (sourcenode a)) \\<longrightarrow>\n     valid_SDG_node (CFG_node (sourcenode a)) \\<longrightarrow>\n     inner_node (parent_node (CFG_node (sourcenode a))) \\<longrightarrow>\n     (\\<exists>ns.\n         CFG_node\n          (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n           (sourcenode a))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by clarsimp"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       CFG_node\n        (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. targetnode a = m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n 2. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "then"], ["proof (chain)\npicking this:\n  \\<exists>ns.\n     CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "obtain ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  \\<exists>ns.\n     CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node\n         (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n          (sourcenode a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. targetnode a = m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n 2. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node m\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "by(fastforce intro:ccSp_Append_call)"], ["proof (state)\nthis:\n  \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq> m\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>targetnode a -as''\\<rightarrow>\\<^sub>\\<surd>* m\\<close> \\<open>\\<forall>a' \\<in> set as''. intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<surd>* m\n  \\<forall>a'\\<in>set as''. intra_kind (kind a')", "have \"targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m\""], ["proof (prove)\nusing this:\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<surd>* m\n  \\<forall>a'\\<in>set as''. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m", "by(fastforce simp:vp_def intra_path_def)"], ["proof (state)\nthis:\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "hence \"get_proc (targetnode a) = get_proc m\""], ["proof (prove)\nusing this:\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc m", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = get_proc m\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>inner_node m\\<close> \\<open>valid_edge a\\<close> \\<open>targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m\\<close>\n            \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>targetnode a \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  valid_edge a\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a \\<noteq> m", "obtain ns where \"CFG_node (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\"\n            and \"ns \\<noteq> []\" \n            and \"\\<forall>n'' \\<in> set ns. parent_node n'' \\<in> set(sourcenodes as'')\""], ["proof (prove)\nusing this:\n  inner_node m\n  valid_edge a\n  targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* m\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a \\<noteq> m\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>CFG_node\n                  (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m;\n         ns \\<noteq> [];\n         \\<forall>n''\\<in>set ns.\n            parent_node n'' \\<in> set (sourcenodes as'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:in_proc_cdep_SDG_path)"], ["proof (state)\nthis:\n  CFG_node (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as'')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "then"], ["proof (chain)\npicking this:\n  CFG_node (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as'')", "obtain n' where \"n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\"\n            and \"parent_node n' \\<in> set(sourcenodes as'')\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a) cd-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  ns \\<noteq> []\n  \\<forall>n''\\<in>set ns. parent_node n'' \\<in> set (sourcenodes as'')\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m;\n         parent_node n' \\<in> set (sourcenodes as'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule cdep_SDG_path.cases,auto)"], ["proof (state)\nthis:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  parent_node n' \\<in> set (sourcenodes as'')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>(parent_node n') \\<in> set(sourcenodes as'')\\<close>"], ["proof (chain)\npicking this:\n  parent_node n' \\<in> set (sourcenodes as'')", "obtain ms ms' \n            where \"sourcenodes as'' = ms@(parent_node n')#ms'\""], ["proof (prove)\nusing this:\n  parent_node n' \\<in> set (sourcenodes as'')\n\ngoal (1 subgoal):\n 1. (\\<And>ms ms'.\n        sourcenodes as'' = ms @ parent_node n' # ms' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:split_list simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes as'' = ms @ parent_node n' # ms'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "then"], ["proof (chain)\npicking this:\n  sourcenodes as'' = ms @ parent_node n' # ms'", "obtain xs a' ys where \"ms = sourcenodes xs\" \n            and \"ms' = sourcenodes ys\" and \"as'' = xs@a'#ys\"\n            and \"parent_node n' = sourcenode a'\""], ["proof (prove)\nusing this:\n  sourcenodes as'' = ms @ parent_node n' # ms'\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys a'.\n        \\<lbrakk>ms = sourcenodes xs; ms' = sourcenodes ys;\n         as'' = xs @ a' # ys; parent_node n' = sourcenode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  ms = sourcenodes xs\n  ms' = sourcenodes ys\n  as'' = xs @ a' # ys\n  parent_node n' = sourcenode a'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\\<close> \\<open>as = as'@a#as''\\<close> \\<open>as'' = xs@a'#ys\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  as = as' @ a # as''\n  as'' = xs @ a' # ys", "have \"(_Entry_) -(as'@a#xs)@a'#ys\\<rightarrow>\\<^sub>\\<surd>* m\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* m\n  as = as' @ a # as''\n  as'' = xs @ a' # ys\n\ngoal (1 subgoal):\n 1. (_Entry_) -(as' @ a # xs) @ a' # ys\\<rightarrow>\\<^sub>\\<surd>* m", "by simp"], ["proof (state)\nthis:\n  (_Entry_) -(as' @ a # xs) @ a' # ys\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "hence \"(_Entry_) -as'@a#xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\"\n            and \"valid_edge a'\""], ["proof (prove)\nusing this:\n  (_Entry_) -(as' @ a # xs) @ a' # ys\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a' &&&\n    valid_edge a'", "by(auto intro:vp_split)"], ["proof (state)\nthis:\n  (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>as = as'@a#as''\\<close> \\<open>as'' = xs@a'#ys\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ a # as''\n  as'' = xs @ a' # ys", "have \"length (as'@a#xs) < length as\""], ["proof (prove)\nusing this:\n  as = as' @ a # as''\n  as'' = xs @ a' # ys\n\ngoal (1 subgoal):\n 1. length (as' @ a # xs) < length as", "by simp"], ["proof (state)\nthis:\n  length (as' @ a # xs) < length as\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'", "have \"valid_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a')", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "hence \"inner_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a')", "proof(cases \"sourcenode a'\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 3. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "case Entry"], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 3. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "with \\<open>(_Entry_) -as'@a#xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  sourcenode a' = (_Entry_)", "have \"(_Entry_) -as'@a#xs\\<rightarrow>* (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -as' @ a # xs\\<rightarrow>* (_Entry_)", "by(fastforce simp:vp_def)"], ["proof (state)\nthis:\n  (_Entry_) -as' @ a # xs\\<rightarrow>* (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 3. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "hence False"], ["proof (prove)\nusing this:\n  (_Entry_) -as' @ a # xs\\<rightarrow>* (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 3. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a')", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode a')\n\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "case Exit"], ["proof (state)\nthis:\n  sourcenode a' = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(erule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow> inner_node (sourcenode a')\n 2. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a')", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "case inner"], ["proof (state)\nthis:\n  inner_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a') \\<Longrightarrow> inner_node (sourcenode a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  inner_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a')", "by simp"], ["proof (state)\nthis:\n  inner_node (sourcenode a')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inner_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'", "have \"valid_SDG_node (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (sourcenode a'))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>\\<forall>a' \\<in> set as. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>\n            \\<open>as = as'@a#as''\\<close> \\<open>as'' = xs@a'#ys\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  as = as' @ a # as''\n  as'' = xs @ a' # ys", "have \"\\<forall>a' \\<in> set (as'@a#xs). \n            intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set as.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  as = as' @ a # as''\n  as'' = xs @ a' # ys\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set (as' @ a # xs).\n       intra_kind (kind a') \\<or>\n       (\\<exists>Q r p fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "by auto"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set (as' @ a # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "with IH \\<open>length (as'@a#xs) < length as\\<close> \n            \\<open>(_Entry_) -as'@a#xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\\<close>\n            \\<open>valid_SDG_node (CFG_node (sourcenode a'))\\<close>\n            \\<open>inner_node (sourcenode a')\\<close> \\<open>parent_node n' = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\n  length (as' @ a # xs) < length as\n  (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  valid_SDG_node (CFG_node (sourcenode a'))\n  inner_node (sourcenode a')\n  parent_node n' = sourcenode a'\n  \\<forall>a'\\<in>set (as' @ a # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "obtain ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\""], ["proof (prove)\nusing this:\n  \\<forall>as'.\n     length as' < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set as'.\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\n  length (as' @ a # xs) < length as\n  (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  valid_SDG_node (CFG_node (sourcenode a'))\n  inner_node (sourcenode a')\n  parent_node n' = sourcenode a'\n  \\<forall>a'\\<in>set (as' @ a # xs).\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node\n         (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n          (parent_node n') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(erule_tac x=\"as'@a#xs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (parent_node n') \\<Longrightarrow>\n                thesis;\n     length (as' @ a # xs) < length as;\n     (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n     valid_SDG_node (CFG_node (sourcenode a')); inner_node (sourcenode a');\n     parent_node n' = sourcenode a';\n     \\<forall>a'\\<in>set (as' @ a # xs).\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     length (as' @ a # xs) < length as \\<longrightarrow>\n     (\\<forall>m'.\n         (_Entry_) -as' @\n                    a # xs\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n         (\\<forall>n'.\n             m' = parent_node n' \\<longrightarrow>\n             valid_SDG_node n' \\<longrightarrow>\n             (\\<forall>a'\\<in>set (as' @ a # xs).\n                 intra_kind (kind a') \\<or>\n                 (\\<exists>Q r p fs.\n                     kind a' =\n                     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)) \\<longrightarrow>\n             inner_node m' \\<longrightarrow>\n             (\\<exists>ns.\n                 CFG_node\n                  (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a') \\<Longrightarrow>\n                thesis;\n     Suc (length as' + length xs) < length as;\n     (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n     valid_node (sourcenode a'); inner_node (sourcenode a');\n     parent_node n' = sourcenode a';\n     \\<forall>m'.\n        (_Entry_) -as' @\n                   a # xs\\<rightarrow>\\<^sub>\\<surd>* m' \\<longrightarrow>\n        (\\<forall>n'.\n            m' = parent_node n' \\<longrightarrow>\n            valid_SDG_node n' \\<longrightarrow>\n            inner_node (parent_node n') \\<longrightarrow>\n            (\\<exists>ns.\n                CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'));\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     \\<forall>a'\\<in>set as' \\<union> set xs.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"sourcenode a'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a') \\<Longrightarrow>\n                thesis;\n     Suc (length as' + length xs) < length as;\n     (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n     valid_node (sourcenode a'); inner_node (sourcenode a');\n     parent_node n' = sourcenode a';\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     \\<forall>a'\\<in>set as' \\<union> set xs.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     (_Entry_) -as' @\n                a #\n                xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode\n          a' \\<longrightarrow>\n     (\\<forall>n'.\n         sourcenode a' = parent_node n' \\<longrightarrow>\n         valid_SDG_node n' \\<longrightarrow>\n         inner_node (parent_node n') \\<longrightarrow>\n         (\\<exists>ns.\n             CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n'))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a') \\<Longrightarrow>\n                thesis;\n     Suc (length as' + length xs) < length as;\n     (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n     valid_node (sourcenode a'); inner_node (sourcenode a');\n     parent_node n' = sourcenode a';\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     \\<forall>a'\\<in>set as' \\<union> set xs.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     \\<forall>n'.\n        sourcenode a' = parent_node n' \\<longrightarrow>\n        valid_SDG_node n' \\<longrightarrow>\n        inner_node (parent_node n') \\<longrightarrow>\n        (\\<exists>ns.\n            CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"CFG_node (sourcenode a')\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                CFG_node\n                 (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n                  (sourcenode a') \\<Longrightarrow>\n                thesis;\n     Suc (length as' + length xs) < length as;\n     (_Entry_) -as' @ a # xs\\<rightarrow>\\<^sub>\\<surd>* sourcenode a';\n     valid_node (sourcenode a'); inner_node (sourcenode a');\n     parent_node n' = sourcenode a';\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     \\<forall>a'\\<in>set as' \\<union> set xs.\n        intra_kind (kind a') \\<or>\n        (\\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs);\n     sourcenode a' =\n     parent_node (CFG_node (sourcenode a')) \\<longrightarrow>\n     valid_SDG_node (CFG_node (sourcenode a')) \\<longrightarrow>\n     inner_node (parent_node (CFG_node (sourcenode a'))) \\<longrightarrow>\n     (\\<exists>ns.\n         CFG_node\n          (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node\n           (sourcenode a'))\\<rbrakk>\n    \\<Longrightarrow> thesis", "by clarsimp"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "from \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(rule SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "hence \"n' = CFG_node (parent_node n') \\<or> CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. n' = CFG_node (parent_node n') \\<or>\n    CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "by(rule valid_SDG_node_cases)"], ["proof (state)\nthis:\n  n' = CFG_node (parent_node n') \\<or>\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> m \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "thus ?thesis"], ["proof (prove)\nusing this:\n  n' = CFG_node (parent_node n') \\<or>\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = CFG_node (parent_node n') \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n 2. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "assume \"n' = CFG_node (parent_node n')\""], ["proof (state)\nthis:\n  n' = CFG_node (parent_node n')\n\ngoal (2 subgoals):\n 1. n' = CFG_node (parent_node n') \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n 2. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\\<close>\n              \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  n' = CFG_node (parent_node n')", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  n' = CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "by(fastforce intro:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "assume \"CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\""], ["proof (state)\nthis:\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"CFG_node (_Entry_) cc-ns@[CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node (parent_node n')\n  CFG_node (parent_node n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (_Entry_) cc-ns @ [CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (_Entry_) cc-ns @ [CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n') \\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<Longrightarrow>\n    \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "with \\<open>n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  CFG_node\n   (_Entry_) cc-ns @ [CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n' \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node m\n  CFG_node\n   (_Entry_) cc-ns @ [CFG_node (parent_node n')]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "by(fastforce intro:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "then"], ["proof (chain)\npicking this:\n  \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m", "obtain ns where \"CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. CFG_node (_Entry_) cc-ns'\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        CFG_node\n         (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set as. intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "proof(cases \"n = CFG_node m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case True"], ["proof (state)\nthis:\n  n = CFG_node m\n\ngoal (2 subgoals):\n 1. n = CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n 2. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  n = CFG_node m", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  n = CFG_node m\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> CFG_node m\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>inner_node m\\<close> \\<open>valid_SDG_node n\\<close> \\<open>m = parent_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  valid_SDG_node n\n  m = parent_node n\n  n \\<noteq> CFG_node m", "have \"CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  inner_node m\n  valid_SDG_node n\n  m = parent_node n\n  n \\<noteq> CFG_node m\n\ngoal (1 subgoal):\n 1. CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by(fastforce intro:SDG_parent_cdep_edge inner_is_valid)"], ["proof (state)\nthis:\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. n \\<noteq> CFG_node m \\<Longrightarrow>\n    \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "with \\<open>CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* CFG_node m\n  CFG_node m \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n", "by(fastforce dest:ccSp_Append_cdep)"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns. CFG_node (_Entry_) cc-ns\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Same level paths in the SDG\\<close>"], ["", "inductive matched :: \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n  where matched_Nil:\n  \"valid_SDG_node n \\<Longrightarrow> matched n [] n\"\n  | matched_Append_intra_SDG_path:\n  \"\\<lbrakk>matched n ns n''; n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk> \\<Longrightarrow> matched n (ns@ns') n'\"\n  | matched_bracket_call:\n  \"\\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1; n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2; matched n\\<^sub>2 ns' n\\<^sub>3; \n    (n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or> n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4); valid_edge a; a' \\<in> get_return_edges a;\n    sourcenode a = parent_node n\\<^sub>1; targetnode a = parent_node n\\<^sub>2; \n    sourcenode a' = parent_node n\\<^sub>3; targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n  \\<Longrightarrow> matched n\\<^sub>0 (ns@n\\<^sub>1#ns'@[n\\<^sub>3]) n\\<^sub>4\"\n  | matched_bracket_param:\n  \"\\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1; n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2; matched n\\<^sub>2 ns' n\\<^sub>3; \n    n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4; valid_edge a; a' \\<in> get_return_edges a;\n    sourcenode a = parent_node n\\<^sub>1; targetnode a = parent_node n\\<^sub>2; \n    sourcenode a' = parent_node n\\<^sub>3; targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n  \\<Longrightarrow> matched n\\<^sub>0 (ns@n\\<^sub>1#ns'@[n\\<^sub>3]) n\\<^sub>4\""], ["", "lemma matched_Append:\n  \"\\<lbrakk>matched n'' ns' n'; matched n ns n''\\<rbrakk> \\<Longrightarrow> matched n (ns@ns') n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>matched n'' ns' n'; matched n ns n''\\<rbrakk>\n    \\<Longrightarrow> matched n (ns @ ns') n'", "by(induct rule:matched.induct,\n   auto intro:matched.intros simp:append_assoc[THEN sym] simp del:append_assoc)"], ["", "lemma intra_SDG_path_matched:\n  assumes \"n i-ns\\<rightarrow>\\<^sub>d* n'\" shows \"matched n ns n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matched n ns n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matched n ns n'", "from \\<open>n i-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n i-ns\\<rightarrow>\\<^sub>d* n'", "have \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  n i-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by(rule intra_SDG_path_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. matched n ns n'", "hence \"matched n [] n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. matched n [] n", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n [] n\n\ngoal (1 subgoal):\n 1. matched n ns n'", "with \\<open>n i-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n i-ns\\<rightarrow>\\<^sub>d* n'\n  matched n [] n", "have \"matched n ([]@ns) n'\""], ["proof (prove)\nusing this:\n  n i-ns\\<rightarrow>\\<^sub>d* n'\n  matched n [] n\n\ngoal (1 subgoal):\n 1. matched n ([] @ ns) n'", "by -(rule matched_Append_intra_SDG_path)"], ["proof (state)\nthis:\n  matched n ([] @ ns) n'\n\ngoal (1 subgoal):\n 1. matched n ns n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  matched n ([] @ ns) n'\n\ngoal (1 subgoal):\n 1. matched n ns n'", "by simp"], ["proof (state)\nthis:\n  matched n ns n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intra_proc_matched:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a' \\<in> get_return_edges a\"\n  shows \"matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n                 (CFG_node (sourcenode a'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "from assms"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "have \"CFG_node (targetnode a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')", "by(fastforce intro:SDG_proc_entry_exit_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  CFG_node\n   (targetnode\n     a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')", "have \"CFG_node (targetnode a) i-[]@[CFG_node (targetnode a)]\\<rightarrow>\\<^sub>d* \n        CFG_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  CFG_node\n   (targetnode\n     a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a) i-[] @\n            [CFG_node\n              (targetnode a)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')", "by(fastforce intro:intra_SDG_path.intros)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a) i-[] @\n          [CFG_node\n            (targetnode a)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  CFG_node\n   (targetnode\n     a) i-[] @\n          [CFG_node\n            (targetnode a)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')", "have \"matched (CFG_node (targetnode a)) ([]@[CFG_node (targetnode a)])\n    (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  CFG_node\n   (targetnode\n     a) i-[] @\n          [CFG_node\n            (targetnode a)]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) ([] @ [CFG_node (targetnode a)])\n     (CFG_node (sourcenode a'))", "by(fastforce intro:matched.intros)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a)) ([] @ [CFG_node (targetnode a)])\n   (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  matched (CFG_node (targetnode a)) ([] @ [CFG_node (targetnode a)])\n   (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "by simp"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n   (CFG_node (sourcenode a'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matched_intra_CFG_path:\n  assumes \"matched n ns n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "from \\<open>matched n ns n'\\<close>"], ["proof (chain)\npicking this:\n  matched n ns n'", "show \"\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  matched n ns n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(induct rule:matched.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 4. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "case matched_Nil"], ["proof (state)\nthis:\n  valid_SDG_node n_\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 4. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n_\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n_ -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n_", "by(fastforce dest:empty_path valid_SDG_CFG_node simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n_ -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n_\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "case (matched_Append_intra_SDG_path n ns n'' ns' n')"], ["proof (state)\nthis:\n  matched n ns n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' i-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as \n      where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "from \\<open>n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n'' i-ns'\\<rightarrow>\\<^sub>d* n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n'' i-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n         n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:intra_SDG_path_intra_CFG_path)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "case (matched_bracket_call n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a')"], ["proof (state)\nthis:\n  matched n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>sourcenode a = parent_node n\\<^sub>1\\<close>\n      \\<open>targetnode a' = parent_node n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a' = parent_node n\\<^sub>4", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = parent_node n\\<^sub>1\" \n      and \"targetnode a'' = parent_node n\\<^sub>4\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = parent_node n\\<^sub>1;\n         targetnode a'' = parent_node n\\<^sub>4;\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = parent_node n\\<^sub>1\n  targetnode a'' = parent_node n\\<^sub>4\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "hence \"parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  sourcenode a'' = parent_node n\\<^sub>1\n  targetnode a'' = parent_node n\\<^sub>4\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4", "by(fastforce dest:path_edge)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "moreover"], ["proof (state)\nthis:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "from \\<open>kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"\\<forall>a \\<in> set [a'']. intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set [a'']. intra_kind (kind a)", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set [a'']. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "ultimately"], ["proof (chain)\npicking this:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n  \\<forall>a\\<in>set [a'']. intra_kind (kind a)", "have \"parent_node n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n  \\<forall>a\\<in>set [a'']. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4", "by(auto simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "with \\<open>\\<exists>as. parent_node n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node\n        n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4", "by(fastforce intro:intra_path_Append)"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "case (matched_bracket_param n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a a')"], ["proof (state)\nthis:\n  matched n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3\n  n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>sourcenode a = parent_node n\\<^sub>1\\<close>\n      \\<open>targetnode a' = parent_node n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a' = parent_node n\\<^sub>4", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = parent_node n\\<^sub>1\" \n      and \"targetnode a'' = parent_node n\\<^sub>4\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = parent_node n\\<^sub>1;\n         targetnode a'' = parent_node n\\<^sub>4;\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = parent_node n\\<^sub>1\n  targetnode a'' = parent_node n\\<^sub>4\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "hence \"parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  sourcenode a'' = parent_node n\\<^sub>1\n  targetnode a'' = parent_node n\\<^sub>4\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4", "by(fastforce dest:path_edge)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "moreover"], ["proof (state)\nthis:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "from \\<open>kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"\\<forall>a \\<in> set [a'']. intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set [a'']. intra_kind (kind a)", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set [a'']. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "ultimately"], ["proof (chain)\npicking this:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n  \\<forall>a\\<in>set [a'']. intra_kind (kind a)", "have \"parent_node n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  parent_node n\\<^sub>1 -[a'']\\<rightarrow>* parent_node n\\<^sub>4\n  \\<forall>a\\<in>set [a'']. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4", "by(auto simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                                  n\\<^sub>4", "with \\<open>\\<exists>as. parent_node n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -[a'']\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node\n        n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4", "by(fastforce intro:intra_path_Append)"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<^sub>4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matched_same_level_CFG_path:\n  assumes \"matched n ns n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n          n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'", "from \\<open>matched n ns n'\\<close>"], ["proof (chain)\npicking this:\n  matched n ns n'", "show \"\\<exists>as. parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\""], ["proof (prove)\nusing this:\n  matched n ns n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'", "proof(induct rule:matched.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\n 2. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 4. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "case matched_Nil"], ["proof (state)\nthis:\n  valid_SDG_node n_\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\n 2. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 4. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n_\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n_ -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n_", "by(fastforce dest:empty_path valid_SDG_CFG_node simp:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node n_ -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n_\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "case (matched_Append_intra_SDG_path n ns n'' ns' n')"], ["proof (state)\nthis:\n  matched n ns n''\n  \\<exists>as.\n     parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\n  n'' i-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n          n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n'' i-ns'\\<rightarrow>\\<^sub>d* n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n'' i-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n         n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule intra_SDG_path_intra_CFG_path)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'", "by(rule intra_path_slp)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'", "have \"parent_node n -as@as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'", "by(rule slp_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>as.\n           parent_node\n            n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                              n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "case (matched_bracket_call n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a')"], ["proof (state)\nthis:\n  matched n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q r p' fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p' fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>\\<exists>as. parent_node n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1", "obtain as where \"parent_node n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                  n\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>\\<exists>as. parent_node n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3", "obtain as' where \"parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                   n\\<^sub>3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3", "have \"same_level_path as'\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. same_level_path as'", "by(simp add:slp_def)"], ["proof (state)\nthis:\n  same_level_path as'\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "hence \"same_level_path_aux ([]@[a]) as'\""], ["proof (prove)\nusing this:\n  same_level_path as'\n\ngoal (1 subgoal):\n 1. same_level_path_aux ([] @ [a]) as'", "by(fastforce intro:same_level_path_aux_callstack_Append simp:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux ([] @ [a]) as'\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>same_level_path as'\\<close>"], ["proof (chain)\npicking this:\n  same_level_path as'", "have \"upd_cs ([]@[a]) as' = ([]@[a])\""], ["proof (prove)\nusing this:\n  same_level_path as'\n\ngoal (1 subgoal):\n 1. upd_cs ([] @ [a]) as' = [] @ [a]", "by(fastforce intro:same_level_path_upd_cs_callstack_Append \n                   simp:same_level_path_def)"], ["proof (state)\nthis:\n  upd_cs ([] @ [a]) as' = [] @ [a]\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>same_level_path_aux ([]@[a]) as'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>\n      \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux ([] @ [a]) as'\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  upd_cs ([] @ [a]) as' = [] @ [a]", "have \"same_level_path (a#as'@[a'])\""], ["proof (prove)\nusing this:\n  same_level_path_aux ([] @ [a]) as'\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  upd_cs ([] @ [a]) as' = [] @ [a]\n\ngoal (1 subgoal):\n 1. same_level_path (a # as' @ [a'])", "by(fastforce intro:same_level_path_aux_Append upd_cs_Append \n                   simp:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path (a # as' @ [a'])\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a'\\<close> \\<open>sourcenode a' = parent_node n\\<^sub>3\\<close>\n      \\<open>targetnode a' = parent_node n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4", "by(fastforce dest:path_edge)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>2 -as'@[a']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "by(fastforce intro:path_Append simp:slp_def)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = parent_node n\\<^sub>1\\<close>\n      \\<open>targetnode a = parent_node n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>1 -a#as'@[a']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "by -(rule Cons_path)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>same_level_path (a#as'@[a'])\\<close>"], ["proof (chain)\npicking this:\n  same_level_path (a # as' @ [a'])\n  parent_node n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>1 -a#as'@[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  same_level_path (a # as' @ [a'])\n  parent_node n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>1 -a #\n                as' @\n                [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "by(simp add:slp_def)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>1 -a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>parent_node n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>0 -as@a#as'@[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>0 -as @\n                a #\n                as' @\n                [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "by(rule slp_Append)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>0 -as @\n              a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>sourcenode a = parent_node n\\<^sub>1\\<close> \\<open>sourcenode a' = parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = parent_node n\\<^sub>1\n  sourcenode a' = parent_node n\\<^sub>3\n  parent_node\n   n\\<^sub>0 -as @\n              a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = parent_node n\\<^sub>1\n  sourcenode a' = parent_node n\\<^sub>3\n  parent_node\n   n\\<^sub>0 -as @\n              a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node\n        n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "case (matched_bracket_param n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a a')"], ["proof (state)\nthis:\n  matched n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q r p' fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p' fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>\\<exists>as. parent_node n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1", "obtain as where \"parent_node n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                  n\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>\\<exists>as. parent_node n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3", "obtain as' where \"parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                   n\\<^sub>3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3", "have \"same_level_path as'\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. same_level_path as'", "by(simp add:slp_def)"], ["proof (state)\nthis:\n  same_level_path as'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "hence \"same_level_path_aux ([]@[a]) as'\""], ["proof (prove)\nusing this:\n  same_level_path as'\n\ngoal (1 subgoal):\n 1. same_level_path_aux ([] @ [a]) as'", "by(fastforce intro:same_level_path_aux_callstack_Append simp:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path_aux ([] @ [a]) as'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>same_level_path as'\\<close>"], ["proof (chain)\npicking this:\n  same_level_path as'", "have \"upd_cs ([]@[a]) as' = ([]@[a])\""], ["proof (prove)\nusing this:\n  same_level_path as'\n\ngoal (1 subgoal):\n 1. upd_cs ([] @ [a]) as' = [] @ [a]", "by(fastforce intro:same_level_path_upd_cs_callstack_Append \n                   simp:same_level_path_def)"], ["proof (state)\nthis:\n  upd_cs ([] @ [a]) as' = [] @ [a]\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>same_level_path_aux ([]@[a]) as'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>\n      \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux ([] @ [a]) as'\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  upd_cs ([] @ [a]) as' = [] @ [a]", "have \"same_level_path (a#as'@[a'])\""], ["proof (prove)\nusing this:\n  same_level_path_aux ([] @ [a]) as'\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  upd_cs ([] @ [a]) as' = [] @ [a]\n\ngoal (1 subgoal):\n 1. same_level_path (a # as' @ [a'])", "by(fastforce intro:same_level_path_aux_Append upd_cs_Append \n                   simp:same_level_path_def)"], ["proof (state)\nthis:\n  same_level_path (a # as' @ [a'])\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "from \\<open>valid_edge a'\\<close> \\<open>sourcenode a' = parent_node n\\<^sub>3\\<close>\n      \\<open>targetnode a' = parent_node n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4", "by(fastforce dest:path_edge)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>2 -as'@[a']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  parent_node n\\<^sub>3 -[a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "by(fastforce intro:path_Append simp:slp_def)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = parent_node n\\<^sub>1\\<close>\n      \\<open>targetnode a = parent_node n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>1 -a#as'@[a']\\<rightarrow>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  parent_node n\\<^sub>2 -as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "by -(rule Cons_path)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>same_level_path (a#as'@[a'])\\<close>"], ["proof (chain)\npicking this:\n  same_level_path (a # as' @ [a'])\n  parent_node n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>1 -a#as'@[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  same_level_path (a # as' @ [a'])\n  parent_node n\\<^sub>1 -a # as' @ [a']\\<rightarrow>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>1 -a #\n                as' @\n                [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "by(simp add:slp_def)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>1 -a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>parent_node n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "have \"parent_node n\\<^sub>0 -as@a#as'@[a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>1 -a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>0 -as @\n                a #\n                as' @\n                [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "by(rule slp_Append)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>0 -as @\n              a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>2 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                     n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\nn\\<^sub>4", "with \\<open>sourcenode a = parent_node n\\<^sub>1\\<close> \\<open>sourcenode a' = parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = parent_node n\\<^sub>1\n  sourcenode a' = parent_node n\\<^sub>3\n  parent_node\n   n\\<^sub>0 -as @\n              a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = parent_node n\\<^sub>1\n  sourcenode a' = parent_node n\\<^sub>3\n  parent_node\n   n\\<^sub>0 -as @\n              a #\n              as' @\n              [a']\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node\n        n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Realizable paths in the SDG\\<close>"], ["", "inductive realizable :: \n  \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n  where realizable_matched:\"matched n ns n' \\<Longrightarrow> realizable n ns n'\"\n  | realizable_call:\n  \"\\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1; n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or> n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2; matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n  \\<Longrightarrow> realizable n\\<^sub>0 (ns@n\\<^sub>1#ns') n\\<^sub>3\""], ["", "lemma realizable_Append_matched:\n  \"\\<lbrakk>realizable n ns n''; matched n'' ns' n'\\<rbrakk> \\<Longrightarrow> realizable n (ns@ns') n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>realizable n ns n''; matched n'' ns' n'\\<rbrakk>\n    \\<Longrightarrow> realizable n (ns @ ns') n'", "proof(induct rule:realizable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'a.\n       \\<lbrakk>matched n ns n'a; matched n'a ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ ns') n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "case (realizable_matched n ns n'')"], ["proof (state)\nthis:\n  matched n ns n''\n  matched n'' ns' n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'a.\n       \\<lbrakk>matched n ns n'a; matched n'a ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ ns') n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "from \\<open>matched n'' ns' n'\\<close> \\<open>matched n ns n''\\<close>"], ["proof (chain)\npicking this:\n  matched n'' ns' n'\n  matched n ns n''", "have \"matched n (ns@ns') n'\""], ["proof (prove)\nusing this:\n  matched n'' ns' n'\n  matched n ns n''\n\ngoal (1 subgoal):\n 1. matched n (ns @ ns') n'", "by(rule matched_Append)"], ["proof (state)\nthis:\n  matched n (ns @ ns') n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'a.\n       \\<lbrakk>matched n ns n'a; matched n'a ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ ns') n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "thus ?case"], ["proof (prove)\nusing this:\n  matched n (ns @ ns') n'\n\ngoal (1 subgoal):\n 1. realizable n (ns @ ns') n'", "by(rule realizable.realizable_matched)"], ["proof (state)\nthis:\n  realizable n (ns @ ns') n'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "case (realizable_call n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'' n\\<^sub>3)"], ["proof (state)\nthis:\n  realizable n\\<^sub>0 ns n\\<^sub>1\n  matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n  realizable n\\<^sub>0 (ns @ ns') n'\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns'' n\\<^sub>3\n  matched n\\<^sub>3 ns' n'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "from \\<open>matched n\\<^sub>3 ns' n'\\<close> \\<open>matched n\\<^sub>2 ns'' n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  matched n\\<^sub>3 ns' n'\n  matched n\\<^sub>2 ns'' n\\<^sub>3", "have \"matched n\\<^sub>2 (ns''@ns') n'\""], ["proof (prove)\nusing this:\n  matched n\\<^sub>3 ns' n'\n  matched n\\<^sub>2 ns'' n\\<^sub>3\n\ngoal (1 subgoal):\n 1. matched n\\<^sub>2 (ns'' @ ns') n'", "by(rule matched_Append)"], ["proof (state)\nthis:\n  matched n\\<^sub>2 (ns'' @ ns') n'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "with \\<open>realizable n\\<^sub>0 ns n\\<^sub>1\\<close> \\<open>n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or> n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  realizable n\\<^sub>0 ns n\\<^sub>1\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 (ns'' @ ns') n'", "have \"realizable n\\<^sub>0 (ns@n\\<^sub>1#(ns''@ns')) n'\""], ["proof (prove)\nusing this:\n  realizable n\\<^sub>0 ns n\\<^sub>1\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 (ns'' @ ns') n'\n\ngoal (1 subgoal):\n 1. realizable n\\<^sub>0 (ns @ n\\<^sub>1 # ns'' @ ns') n'", "by(rule realizable.realizable_call)"], ["proof (state)\nthis:\n  realizable n\\<^sub>0 (ns @ n\\<^sub>1 # ns'' @ ns') n'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns'a n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        matched n\\<^sub>1 ns' n' \\<Longrightarrow>\n        realizable n\\<^sub>0 (ns @ ns') n';\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns'a n\\<^sub>3; matched n\\<^sub>3 ns' n'\\<rbrakk>\n       \\<Longrightarrow> realizable n\\<^sub>0\n                          ((ns @ n\\<^sub>1 # ns'a) @ ns') n'", "thus ?case"], ["proof (prove)\nusing this:\n  realizable n\\<^sub>0 (ns @ n\\<^sub>1 # ns'' @ ns') n'\n\ngoal (1 subgoal):\n 1. realizable n\\<^sub>0 ((ns @ n\\<^sub>1 # ns'') @ ns') n'", "by simp"], ["proof (state)\nthis:\n  realizable n\\<^sub>0 ((ns @ n\\<^sub>1 # ns'') @ ns') n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma realizable_valid_CFG_path:\n  assumes \"realizable n ns n'\" \n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'", "from \\<open>realizable n ns n'\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns n'", "show \"\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\""], ["proof (prove)\nusing this:\n  realizable n ns n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'", "proof(induct rule:realizable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'.\n       matched n ns n' \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "case (realizable_matched n ns n')"], ["proof (state)\nthis:\n  matched n ns n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'.\n       matched n ns n' \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "from \\<open>matched n ns n'\\<close>"], ["proof (chain)\npicking this:\n  matched n ns n'", "obtain as where \"parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\""], ["proof (prove)\nusing this:\n  matched n ns n'\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n          n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule matched_same_level_CFG_path)"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'.\n       matched n ns n' \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'", "by(fastforce intro:slp_vp)"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "case (realizable_call n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3)"], ["proof (state)\nthis:\n  realizable n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "from \\<open>\\<exists>as. parent_node n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1", "obtain as where \"parent_node n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n              n\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "from \\<open>matched n\\<^sub>2 ns' n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  matched n\\<^sub>2 ns' n\\<^sub>3", "obtain as' where \"parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\""], ["proof (prove)\nusing this:\n  matched n\\<^sub>2 ns' n\\<^sub>3\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n                   n\\<^sub>3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule matched_same_level_CFG_path)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "from \\<open>n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or> n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2", "obtain a Q r fs where \"valid_edge a\"\n      and \"sourcenode a = parent_node n\\<^sub>1\" and \"targetnode a = parent_node n\\<^sub>2\"\n      and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>a Q r fs.\n        \\<lbrakk>valid_edge a; sourcenode a = parent_node n\\<^sub>1;\n         targetnode a = parent_node n\\<^sub>2;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:SDG_edge.cases)+"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "hence \"parent_node n\\<^sub>1 -[a]\\<rightarrow>* parent_node n\\<^sub>2\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>1 -[a]\\<rightarrow>* parent_node n\\<^sub>2", "by(fastforce dest:path_edge)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>1 -[a]\\<rightarrow>* parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "from \\<open>parent_node n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1", "have \"parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1\" and \"valid_path as\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1 &&&\n    valid_path as", "by(simp_all add:vp_def)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1\n  valid_path as\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1\n  valid_path as", "have \"valid_path (as@[a])\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1\n  valid_path as\n\ngoal (1 subgoal):\n 1. valid_path (as @ [a])", "by(fastforce elim:valid_path_aux_Append simp:valid_path_def)"], ["proof (state)\nthis:\n  valid_path (as @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "moreover"], ["proof (state)\nthis:\n  valid_path (as @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "from \\<open>parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1\\<close> \\<open>parent_node n\\<^sub>1 -[a]\\<rightarrow>* parent_node n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1\n  parent_node n\\<^sub>1 -[a]\\<rightarrow>* parent_node n\\<^sub>2", "have \"parent_node n\\<^sub>0 -as@[a]\\<rightarrow>* parent_node n\\<^sub>2\""], ["proof (prove)\nusing this:\n  parent_node n\\<^sub>0 -as\\<rightarrow>* parent_node n\\<^sub>1\n  parent_node n\\<^sub>1 -[a]\\<rightarrow>* parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. parent_node n\\<^sub>0 -as @ [a]\\<rightarrow>* parent_node n\\<^sub>2", "by(rule path_Append)"], ["proof (state)\nthis:\n  parent_node n\\<^sub>0 -as @ [a]\\<rightarrow>* parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "ultimately"], ["proof (chain)\npicking this:\n  valid_path (as @ [a])\n  parent_node n\\<^sub>0 -as @ [a]\\<rightarrow>* parent_node n\\<^sub>2", "have \"parent_node n\\<^sub>0 -as@[a]\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>2\""], ["proof (prove)\nusing this:\n  valid_path (as @ [a])\n  parent_node n\\<^sub>0 -as @ [a]\\<rightarrow>* parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>0 -as @ [a]\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>2", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>0 -as @ [a]\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "with \\<open>parent_node n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  parent_node\n   n\\<^sub>0 -as @ [a]\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>2", "have \"parent_node n\\<^sub>0 -(as@[a])@as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>3\""], ["proof (prove)\nusing this:\n  parent_node\n   n\\<^sub>2 -as'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n\\<^sub>3\n  parent_node\n   n\\<^sub>0 -as @ [a]\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. parent_node\n     n\\<^sub>0 -(as @ [a]) @\n                as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>3", "by -(rule vp_slp_Append)"], ["proof (state)\nthis:\n  parent_node\n   n\\<^sub>0 -(as @ [a]) @\n              as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>as.\n           parent_node\n            n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node\n                                  n\\<^sub>3", "with \\<open>sourcenode a = parent_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>0 -(as @ [a]) @\n              as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>3", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = parent_node n\\<^sub>1\n  parent_node\n   n\\<^sub>0 -(as @ [a]) @\n              as'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node\n        n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>3", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     parent_node\n      n\\<^sub>0 -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<^sub>3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<surd>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cdep_SDG_path_realizable:\n  \"n cc-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> realizable n ns n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n cc-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> realizable n ns n'", "proof(induct rule:call_cdep_SDG_path.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n. valid_SDG_node n \\<Longrightarrow> realizable n [] n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "case (ccSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (3 subgoals):\n 1. \\<And>n. valid_SDG_node n \\<Longrightarrow> realizable n [] n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "show ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. realizable n [] n", "by(fastforce intro:realizable_matched matched_Nil)"], ["proof (state)\nthis:\n  realizable n [] n\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "case (ccSp_Append_cdep n ns n'' n')"], ["proof (state)\nthis:\n  n cc-ns\\<rightarrow>\\<^sub>d* n''\n  realizable n ns n''\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "from \\<open>n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"valid_SDG_node n''\""], ["proof (prove)\nusing this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n''", "by(rule SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n''\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "hence \"matched n'' [] n''\""], ["proof (prove)\nusing this:\n  valid_SDG_node n''\n\ngoal (1 subgoal):\n 1. matched n'' [] n''", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n'' [] n''\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "from \\<open>n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close> \\<open>valid_SDG_node n''\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  valid_SDG_node n''", "have \"n'' i-[]@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  valid_SDG_node n''\n\ngoal (1 subgoal):\n 1. n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:iSp_Append_cdep iSp_Nil)"], ["proof (state)\nthis:\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "with \\<open>matched n'' [] n''\\<close>"], ["proof (chain)\npicking this:\n  matched n'' [] n''\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "have \"matched n'' ([]@[n'']) n'\""], ["proof (prove)\nusing this:\n  matched n'' [] n''\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. matched n'' ([] @ [n'']) n'", "by(fastforce intro:matched_Append_intra_SDG_path)"], ["proof (state)\nthis:\n  matched n'' ([] @ [n'']) n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "with \\<open>realizable n ns n''\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns n''\n  matched n'' ([] @ [n'']) n'", "show ?case"], ["proof (prove)\nusing this:\n  realizable n ns n''\n  matched n'' ([] @ [n'']) n'\n\ngoal (1 subgoal):\n 1. realizable n (ns @ [n'']) n'", "by(fastforce intro:realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n (ns @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "case (ccSp_Append_call n ns n'' p n')"], ["proof (state)\nthis:\n  n cc-ns\\<rightarrow>\\<^sub>d* n''\n  realizable n ns n''\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "from \\<open>n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(rule SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "hence \"matched n' [] n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. matched n' [] n'", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n cc-ns\\<rightarrow>\\<^sub>d* n''; realizable n ns n'';\n        n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> realizable n (ns @ [n'']) n'", "with \\<open>realizable n ns n''\\<close> \\<open>n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns n''\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  matched n' [] n'", "show ?case"], ["proof (prove)\nusing this:\n  realizable n ns n''\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. realizable n (ns @ [n'']) n'", "by(fastforce intro:realizable_call)"], ["proof (state)\nthis:\n  realizable n (ns @ [n'']) n'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>SDG with summary edges\\<close>"], ["", "inductive sum_cdep_edge :: \"'node SDG_node \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n    (\"_ s\\<longrightarrow>\\<^bsub>cd\\<^esub> _\" [51,0] 80)\n  and sum_ddep_edge :: \"'node SDG_node \\<Rightarrow> 'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n    (\"_ s-_\\<rightarrow>\\<^sub>d\\<^sub>d _\" [51,0,0] 80)\n  and sum_call_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n    (\"_ s-_\\<rightarrow>\\<^bsub>call\\<^esub> _\" [51,0,0] 80)\n  and sum_return_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n    (\"_ s-_\\<rightarrow>\\<^bsub>ret\\<^esub> _\" [51,0,0] 80)\n  and sum_param_in_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n    (\"_ s-_:_\\<rightarrow>\\<^bsub>in\\<^esub> _\" [51,0,0,0] 80)\n  and sum_param_out_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'var \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n    (\"_ s-_:_\\<rightarrow>\\<^bsub>out\\<^esub> _\" [51,0,0,0] 80)\n  and sum_summary_edge :: \"'node SDG_node \\<Rightarrow> 'pname \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\" \n    (\"_ s-_\\<rightarrow>\\<^bsub>sum\\<^esub> _\" [51,0] 80)\n  and sum_SDG_edge :: \"'node SDG_node \\<Rightarrow> 'var option \\<Rightarrow> \n                          ('pname \\<times> bool) option \\<Rightarrow> bool \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n\nwhere\n    (* Syntax *)\n  \"n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' == sum_SDG_edge n None None False n'\"\n  | \"n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' == sum_SDG_edge n (Some V) None False n'\"\n  | \"n s-p\\<rightarrow>\\<^bsub>call\\<^esub> n' == sum_SDG_edge n None (Some(p,True)) False n'\"\n  | \"n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' == sum_SDG_edge n None (Some(p,False)) False n'\"\n  | \"n s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n' == sum_SDG_edge n (Some V) (Some(p,True)) False n'\"\n  | \"n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n' == sum_SDG_edge n (Some V) (Some(p,False)) False n'\"\n  | \"n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n' == sum_SDG_edge n None (Some(p,True)) True n'\"\n\n    (* Rules *)\n  | sum_SDG_cdep_edge:\n    \"\\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m'\\<rbrakk> \\<Longrightarrow> n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\"\n  | sum_SDG_proc_entry_exit_cdep:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; n = CFG_node (targetnode a);\n      a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a')\\<rbrakk> \\<Longrightarrow> n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\"\n  | sum_SDG_parent_cdep_edge:\n    \"\\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m; n \\<noteq> n'\\<rbrakk> \n      \\<Longrightarrow> n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\"\n  | sum_SDG_ddep_edge:\"n influences V in n' \\<Longrightarrow> n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\"\n  | sum_SDG_call_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; n = CFG_node (sourcenode a); \n      n' = CFG_node (targetnode a)\\<rbrakk> \\<Longrightarrow> n s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\"\n  | sum_SDG_return_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs; n = CFG_node (sourcenode a); \n      n' = CFG_node (targetnode a)\\<rbrakk> \\<Longrightarrow> n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\"\n  | sum_SDG_param_in_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; (p,ins,outs) \\<in> set procs; V = ins!x;\n      x < length ins; n = Actual_in (sourcenode a,x); n' = Formal_in (targetnode a,x)\\<rbrakk>\n      \\<Longrightarrow> n s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\"\n  | sum_SDG_param_out_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; (p,ins,outs) \\<in> set procs; V = outs!x;\n      x < length outs; n = Formal_out (sourcenode a,x); \n      n' = Actual_out (targetnode a,x)\\<rbrakk>\n      \\<Longrightarrow> n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\"\n  | sum_SDG_call_summary_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a; \n      n = CFG_node (sourcenode a); n' = CFG_node (targetnode a')\\<rbrakk>\n      \\<Longrightarrow> n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\"\n  | sum_SDG_param_summary_edge:\n    \"\\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a;\n      matched (Formal_in (targetnode a,x)) ns (Formal_out (sourcenode a',x'));\n      n = Actual_in (sourcenode a,x); n' = Actual_out (targetnode a',x');\n      (p,ins,outs) \\<in> set procs; x < length ins; x' < length outs\\<rbrakk>\n      \\<Longrightarrow> n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\""], ["", "lemma sum_edge_cases:\n  \"\\<lbrakk>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'; \n    \\<And>a Q r fs a'. \\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a;\n                n = CFG_node (sourcenode a); n' = CFG_node (targetnode a')\\<rbrakk> \\<Longrightarrow> P;\n    \\<And>a Q p r fs a' ns x x' ins outs.\n      \\<lbrakk>valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges a;\n       matched (Formal_in (targetnode a,x)) ns (Formal_out (sourcenode a',x'));\n       n = Actual_in (sourcenode a,x); n' = Actual_out (targetnode a',x');\n       (p,ins,outs) \\<in> set procs; x < length ins; x' < length outs\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n  \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n     \\<And>a Q r fs a'.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n         n' = CFG_node (targetnode a')\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>a Q p r fs a' ns x x' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins;\n         x' < length outs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by -(erule sum_SDG_edge.cases,auto)"], ["", "lemma SDG_edge_sum_SDG_edge:\n  \"SDG_edge n Vopt popt n' \\<Longrightarrow> sum_SDG_edge n Vopt popt False n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG_edge n Vopt popt n' \\<Longrightarrow>\n    sum_SDG_edge n Vopt popt False n'", "by(induct rule:SDG_edge.induct,auto intro:sum_SDG_edge.intros)"], ["", "lemma sum_SDG_edge_SDG_edge:\n  \"sum_SDG_edge n Vopt popt False n' \\<Longrightarrow> SDG_edge n Vopt popt n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_SDG_edge n Vopt popt False n' \\<Longrightarrow>\n    SDG_edge n Vopt popt n'", "by(induct n Vopt popt x\\<equiv>\"False\" n' rule:sum_SDG_edge.induct,\n   auto intro:SDG_edge.intros)"], ["", "lemma sum_SDG_edge_valid_SDG_node:\n  assumes \"sum_SDG_edge n Vopt popt b n'\" \n  shows \"valid_SDG_node n\" and \"valid_SDG_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_SDG_node n\n 2. valid_SDG_node n'", "have \"valid_SDG_node n \\<and> valid_SDG_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node n \\<and> valid_SDG_node n'", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<not> b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "case True"], ["proof (state)\nthis:\n  b\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<not> b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "with \\<open>sum_SDG_edge n Vopt popt b n'\\<close>"], ["proof (chain)\npicking this:\n  sum_SDG_edge n Vopt popt b n'\n  b", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_SDG_edge n Vopt popt b n'\n  b\n\ngoal (1 subgoal):\n 1. valid_SDG_node n \\<and> valid_SDG_node n'", "proof(induct rule:sum_SDG_edge.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 10. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "case (sum_SDG_call_summary_edge a Q r p f a' n n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n  True\n\ngoal (10 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 10. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "from \\<open>valid_edge a\\<close> \\<open>n = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = CFG_node (sourcenode a)", "have \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  valid_edge a\n  n = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by fastforce"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (10 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 10. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (10 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 10. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "with \\<open>n' = CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  n' = CFG_node (targetnode a')\n  valid_edge a'", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n' = CFG_node (targetnode a')\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by fastforce"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (10 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 10. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "with \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  valid_SDG_node n'", "show ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n \\<and> valid_SDG_node n'", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node n \\<and> valid_SDG_node n'\n\ngoal (9 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "case (sum_SDG_param_summary_edge a Q r p fs a' x ns x' n n' ins outs)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  matched (Formal_in (targetnode a, x)) ns (Formal_out (sourcenode a', x'))\n  n = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  x' < length outs\n  True\n\ngoal (9 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>n = Actual_in (sourcenode a,x)\\<close>\n        \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>x < length ins\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n = Actual_in (sourcenode a, x)\n  (p, ins, outs) \\<in> set procs\n  x < length ins", "have \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n = Actual_in (sourcenode a, x)\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by fastforce"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (9 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (9 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (9 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "with \\<open>valid_edge a'\\<close> \\<open>n' = Actual_out (targetnode a',x')\\<close>\n        \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>x' < length outs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x' < length outs\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x' < length outs\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by fastforce"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (9 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 9. \\<And>a Q r p fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "with \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  valid_SDG_node n'", "show ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n \\<and> valid_SDG_node n'", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node n \\<and> valid_SDG_node n'\n\ngoal (8 subgoals):\n 1. \\<And>n m n' m'.\n       \\<lbrakk>n = CFG_node m; n' = CFG_node m'; m controls m';\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 2. \\<And>a Q r p fs n a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        n' = CFG_node (sourcenode a'); False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 3. \\<And>n' m n.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n'; n = CFG_node m;\n        n \\<noteq> n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 4. \\<And>n V n'.\n       \\<lbrakk>n influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 5. \\<And>a Q r p fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 6. \\<And>a Q p fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 7. \\<And>a Q r p fs ins outs V x n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x); n' = Formal_in (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'\n 8. \\<And>a Q p f ins outs V x n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x); n' = Actual_out (targetnode a, x);\n        False\\<rbrakk>\n       \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "qed simp_all"], ["proof (state)\nthis:\n  valid_SDG_node n \\<and> valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "case False"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "with \\<open>sum_SDG_edge n Vopt popt b n'\\<close>"], ["proof (chain)\npicking this:\n  sum_SDG_edge n Vopt popt b n'\n  \\<not> b", "have \"SDG_edge n Vopt popt n'\""], ["proof (prove)\nusing this:\n  sum_SDG_edge n Vopt popt b n'\n  \\<not> b\n\ngoal (1 subgoal):\n 1. SDG_edge n Vopt popt n'", "by(fastforce intro:sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  SDG_edge n Vopt popt n'\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> valid_SDG_node n \\<and> valid_SDG_node n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  SDG_edge n Vopt popt n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n \\<and> valid_SDG_node n'", "by(fastforce intro:SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n \\<and> valid_SDG_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_SDG_node n \\<and> valid_SDG_node n'\n\ngoal (2 subgoals):\n 1. valid_SDG_node n\n 2. valid_SDG_node n'", "thus \"valid_SDG_node n\" and \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n \\<and> valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "by simp_all"], ["proof (state)\nthis:\n  valid_SDG_node n\n  valid_SDG_node n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_no_sum_SDG_edge_source:\n  assumes \"sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\" shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> False\n 2. \\<not> b \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  b\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> False\n 2. \\<not> b \\<Longrightarrow> False", "with \\<open>sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\\<close>"], ["proof (chain)\npicking this:\n  sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\n  b", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\n  b\n\ngoal (1 subgoal):\n 1. False", "proof(induct \"CFG_node (_Exit_)\" Vopt popt b n' rule:sum_SDG_edge.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a');\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m; CFG_node (_Exit_) \\<noteq> n';\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a Q r p fs a' x ns x' n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> False", "case (sum_SDG_call_summary_edge a Q r p f a' n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges a\n  CFG_node (_Exit_) = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n  True\n\ngoal (10 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a');\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m; CFG_node (_Exit_) \\<noteq> n';\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a Q r p fs a' x ns x' n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a)", "have \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a = (_Exit_)\n\ngoal (10 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a');\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m; CFG_node (_Exit_) \\<noteq> n';\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a'); True\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a Q r p fs a' x ns x' n' ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n         n' = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins; x' < length outs;\n         True\\<rbrakk>\n        \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Exit_)", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (9 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a');\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m; CFG_node (_Exit_) \\<noteq> n';\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a');\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m; CFG_node (_Exit_) \\<noteq> n';\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> False", "case (sum_SDG_param_summary_edge a Q r p f a' x ns x' n' ins outs)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges a\n  matched (Formal_in (targetnode a, x)) ns (Formal_out (sourcenode a', x'))\n  CFG_node (_Exit_) = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  x' < length outs\n  True\n\ngoal (9 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a');\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m; CFG_node (_Exit_) \\<noteq> n';\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs; True\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  a' \\<in> get_return_edges a\n  matched (Formal_in (targetnode a, x)) ns (Formal_out (sourcenode a', x'))\n  CFG_node (_Exit_) = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  x' < length outs\n  True\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (8 subgoals):\n 1. \\<And>m n' m'.\n       \\<lbrakk>CFG_node (_Exit_) = CFG_node m; n' = CFG_node m';\n        m controls m'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs a' n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (targetnode a);\n        a' \\<in> get_return_edges a; n' = CFG_node (sourcenode a');\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n' m.\n       \\<lbrakk>valid_SDG_node n'; m = parent_node n';\n        CFG_node (_Exit_) = CFG_node m; CFG_node (_Exit_) \\<noteq> n';\n        False\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) influences V in n'; False\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        CFG_node (_Exit_) = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a); False\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        CFG_node (_Exit_) = Actual_in (sourcenode a, x);\n        n' = Formal_in (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        CFG_node (_Exit_) = Formal_out (sourcenode a, x);\n        n' = Actual_out (targetnode a, x); False\\<rbrakk>\n       \\<Longrightarrow> False", "qed simp_all"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> False", "with \\<open>sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\\<close>"], ["proof (chain)\npicking this:\n  sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\n  \\<not> b", "have \"SDG_edge (CFG_node (_Exit_)) Vopt popt n'\""], ["proof (prove)\nusing this:\n  sum_SDG_edge (CFG_node (_Exit_)) Vopt popt b n'\n  \\<not> b\n\ngoal (1 subgoal):\n 1. SDG_edge (CFG_node (_Exit_)) Vopt popt n'", "by(fastforce intro:sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  SDG_edge (CFG_node (_Exit_)) Vopt popt n'\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  SDG_edge (CFG_node (_Exit_)) Vopt popt n'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Exit_no_SDG_edge_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_no_sum_SDG_edge_target:\n  \"sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)) \\<Longrightarrow> False", "proof(induct \"CFG_node (_Exit_)\" rule:sum_SDG_edge.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n m m'.\n       \\<lbrakk>n = CFG_node m; CFG_node (_Exit_) = CFG_node m';\n        m controls m'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a Q r p fs a' x ns x' n ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         CFG_node (_Exit_) = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins;\n         x' < length outs\\<rbrakk>\n        \\<Longrightarrow> False", "case (sum_SDG_cdep_edge n m m')"], ["proof (state)\nthis:\n  n = CFG_node m\n  CFG_node (_Exit_) = CFG_node m'\n  m controls m'\n\ngoal (10 subgoals):\n 1. \\<And>n m m'.\n       \\<lbrakk>n = CFG_node m; CFG_node (_Exit_) = CFG_node m';\n        m controls m'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a Q r p fs a' x ns x' n ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         CFG_node (_Exit_) = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins;\n         x' < length outs\\<rbrakk>\n        \\<Longrightarrow> False", "from \\<open>m controls m'\\<close> \\<open>CFG_node (_Exit_) = CFG_node m'\\<close>"], ["proof (chain)\npicking this:\n  m controls m'\n  CFG_node (_Exit_) = CFG_node m'", "have \"m controls (_Exit_)\""], ["proof (prove)\nusing this:\n  m controls m'\n  CFG_node (_Exit_) = CFG_node m'\n\ngoal (1 subgoal):\n 1. m controls (_Exit_)", "by simp"], ["proof (state)\nthis:\n  m controls (_Exit_)\n\ngoal (10 subgoals):\n 1. \\<And>n m m'.\n       \\<lbrakk>n = CFG_node m; CFG_node (_Exit_) = CFG_node m';\n        m controls m'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a Q r p fs a' x ns x' n ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         CFG_node (_Exit_) = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins;\n         x' < length outs\\<rbrakk>\n        \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  m controls (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Exit_not_control_dependent)"], ["proof (state)\nthis:\n  False\n\ngoal (10 subgoals):\n 1. \\<And>n m m'.\n       \\<lbrakk>n = CFG_node m; CFG_node (_Exit_) = CFG_node m';\n        m controls m'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 5. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>a Q r p fs a' x ns x' n ins outs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges a;\n         matched (Formal_in (targetnode a, x)) ns\n          (Formal_out (sourcenode a', x'));\n         n = Actual_in (sourcenode a, x);\n         CFG_node (_Exit_) = Actual_out (targetnode a', x');\n         (p, ins, outs) \\<in> set procs; x < length ins;\n         x' < length outs\\<rbrakk>\n        \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (9 subgoals):\n 1. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "case (sum_SDG_proc_entry_exit_cdep a Q r p f n a')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>f\n  n = CFG_node (targetnode a)\n  a' \\<in> get_return_edges a\n  CFG_node (_Exit_) = CFG_node (sourcenode a')\n\ngoal (9 subgoals):\n 1. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (9 subgoals):\n 1. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (9 subgoals):\n 1. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (sourcenode a')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a')", "have \"sourcenode a' = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. sourcenode a' = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a' = (_Exit_)\n\ngoal (9 subgoals):\n 1. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (9 subgoals):\n 1. \\<And>a Q r p fs n a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (targetnode a); a' \\<in> get_return_edges a;\n        CFG_node (_Exit_) = CFG_node (sourcenode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 4. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (8 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "case (sum_SDG_ddep_edge n V)"], ["proof (state)\nthis:\n  n influences V in CFG_node (_Exit_)\n\ngoal (8 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n V. n influences V in CFG_node (_Exit_) \\<Longrightarrow> False\n 3. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  n influences V in CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:SDG_Use.cases simp:data_dependence_def)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "case (sum_SDG_call_edge a Q r p fs n)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n = CFG_node (sourcenode a)\n  CFG_node (_Exit_) = CFG_node (targetnode a)\n\ngoal (7 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (targetnode a)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (7 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = (_Exit_)", "have \"get_proc (_Exit_) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. get_proc (_Exit_) = p", "by(fastforce intro:get_proc_call)"], ["proof (state)\nthis:\n  get_proc (_Exit_) = p\n\ngoal (7 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"p = Main\""], ["proof (prove)\nusing this:\n  get_proc (_Exit_) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by(simp add:get_proc_Exit)"], ["proof (state)\nthis:\n  p = Main\n\ngoal (7 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "case (sum_SDG_return_edge a Q p f n)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  n = CFG_node (sourcenode a)\n  CFG_node (_Exit_) = CFG_node (targetnode a)\n\ngoal (6 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (targetnode a)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (6 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_no_return_target)"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q p fs n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "case (sum_SDG_call_summary_edge a Q r p fs a' n)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  n = CFG_node (sourcenode a)\n  CFG_node (_Exit_) = CFG_node (targetnode a')\n\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CFG_node (_Exit_) = CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) = CFG_node (targetnode a')", "have \"targetnode a' = (_Exit_)\""], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) = CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. targetnode a' = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  targetnode a' = (_Exit_)\n\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  targetnode a' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_no_return_target)"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        CFG_node (_Exit_) = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>valid_SDG_node (CFG_node (_Exit_));\n        m = parent_node (CFG_node (_Exit_)); n = CFG_node m;\n        n \\<noteq> CFG_node (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs ins outs V x n.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V = ins ! x; x < length ins;\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Formal_in (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q p f ins outs V x n.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V = outs ! x; x < length outs;\n        n = Formal_out (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a, x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs a' x ns x' n ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        CFG_node (_Exit_) = Actual_out (targetnode a', x');\n        (p, ins, outs) \\<in> set procs; x < length ins;\n        x' < length outs\\<rbrakk>\n       \\<Longrightarrow> False", "qed simp+"], ["", "lemma sum_SDG_summary_edge_matched:\n  assumes \"n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\" \n  obtains ns where \"matched n ns n'\" and \"n \\<in> set ns\"\n  and \"get_proc (parent_node(last ns)) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>matched n ns n'; n \\<in> set ns;\n         get_proc (parent_node (last ns)) = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       matched n ns n' \\<and>\n       n \\<in> set ns \\<and> get_proc (parent_node (last ns)) = p", "from \\<open>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "show \"\\<exists>ns. matched n ns n' \\<and> n \\<in> set ns \\<and> get_proc (parent_node(last ns)) = p\""], ["proof (prove)\nusing this:\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       matched n ns n' \\<and>\n       n \\<in> set ns \\<and> get_proc (parent_node (last ns)) = p", "proof(induct n \"None::'var option\" \"Some(p,True)\" \"True\" n'\n               rule:sum_SDG_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "case (sum_SDG_call_summary_edge a Q r fs a' n n')"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>n = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n = CFG_node (sourcenode a)", "have \"n -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. n -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)", "by(fastforce intro:SDG_call_edge)"], ["proof (state)\nthis:\n  n -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "hence \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  n -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by(rule SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "hence \"matched n [] n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. matched n [] n", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n [] n\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "have matched:\"matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n      (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "by(rule intra_proc_matched)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n   (CFG_node (sourcenode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>n' = CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n' = CFG_node (targetnode a')", "have \"CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n' = CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'", "by(fastforce intro:SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>matched n [] n\\<close> \\<open>n -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\\<close> matched\n      \\<open>CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>\n      \\<open>n = CFG_node (sourcenode a)\\<close> \\<open>n' = CFG_node (targetnode a')\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  matched n [] n\n  n -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n  matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n   (CFG_node (sourcenode a'))\n  CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\n  a' \\<in> get_return_edges a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n  valid_edge a", "have \"matched n ([]@n#[CFG_node (targetnode a)]@[CFG_node (sourcenode a')]) n'\""], ["proof (prove)\nusing this:\n  matched n [] n\n  n -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n  matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n   (CFG_node (sourcenode a'))\n  CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\n  a' \\<in> get_return_edges a\n  n = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n  valid_edge a\n\ngoal (1 subgoal):\n 1. matched n\n     ([] @ n # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'", "by(fastforce intro:matched_bracket_call)"], ["proof (state)\nthis:\n  matched n\n   ([] @ n # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 4. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "with \\<open>get_proc (sourcenode a') = p\\<close>"], ["proof (chain)\npicking this:\n  get_proc (sourcenode a') = p\n  matched n\n   ([] @ n # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'", "show ?case"], ["proof (prove)\nusing this:\n  get_proc (sourcenode a') = p\n  matched n\n   ([] @ n # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       matched n ns n' \\<and>\n       n \\<in> set ns \\<and> get_proc (parent_node (last ns)) = p", "by auto"], ["proof (state)\nthis:\n  \\<exists>ns.\n     matched n ns n' \\<and>\n     n \\<in> set ns \\<and> get_proc (parent_node (last ns)) = p\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "case (sum_SDG_param_summary_edge a Q r fs a' x ns x' n n' ins outs)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  matched (Formal_in (targetnode a, x)) ns (Formal_out (sourcenode a', x'))\n  n = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  x' < length outs\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>\n      \\<open>x < length ins\\<close> \\<open>n = Actual_in (sourcenode a,x)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  n = Actual_in (sourcenode a, x)", "have \"n -p:ins!x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a,x)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  n = Actual_in (sourcenode a, x)\n\ngoal (1 subgoal):\n 1. n -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)", "by(fastforce intro:SDG_param_in_edge)"], ["proof (state)\nthis:\n  n -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "hence \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  n -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by(rule SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "hence \"matched n [] n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. matched n [] n", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n [] n\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>\n      \\<open>x' < length outs\\<close> \\<open>n' = Actual_out (targetnode a',x')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  x' < length outs\n  n' = Actual_out (targetnode a', x')", "have \"Formal_out (sourcenode a',x') -p:outs!x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  x' < length outs\n  n' = Actual_out (targetnode a', x')\n\ngoal (1 subgoal):\n 1. Formal_out\n     (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'", "by(fastforce intro:SDG_param_out_edge)"], ["proof (state)\nthis:\n  Formal_out\n   (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "from \\<open>matched n [] n\\<close> \\<open>n -p:ins!x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a,x)\\<close>\n      \\<open>matched (Formal_in (targetnode a,x)) ns (Formal_out (sourcenode a',x'))\\<close>\n      \\<open>Formal_out (sourcenode a',x') -p:outs!x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close> \n      \\<open>a' \\<in> get_return_edges a\\<close> \\<open>n = Actual_in (sourcenode a,x)\\<close>\n      \\<open>n' = Actual_out (targetnode a',x')\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  matched n [] n\n  n -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n  matched (Formal_in (targetnode a, x)) ns (Formal_out (sourcenode a', x'))\n  Formal_out\n   (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  a' \\<in> get_return_edges a\n  n = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  valid_edge a", "have \"matched n ([]@n#ns@[Formal_out (sourcenode a',x')]) n'\""], ["proof (prove)\nusing this:\n  matched n [] n\n  n -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n  matched (Formal_in (targetnode a, x)) ns (Formal_out (sourcenode a', x'))\n  Formal_out\n   (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  a' \\<in> get_return_edges a\n  n = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  valid_edge a\n\ngoal (1 subgoal):\n 1. matched n ([] @ n # ns @ [Formal_out (sourcenode a', x')]) n'", "by(fastforce intro:matched_bracket_param)"], ["proof (state)\nthis:\n  matched n ([] @ n # ns @ [Formal_out (sourcenode a', x')]) n'\n\ngoal (3 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 3. \\<And>a Q r fs a' x ns x' n n' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "with \\<open>get_proc (sourcenode a') = p\\<close>"], ["proof (chain)\npicking this:\n  get_proc (sourcenode a') = p\n  matched n ([] @ n # ns @ [Formal_out (sourcenode a', x')]) n'", "show ?case"], ["proof (prove)\nusing this:\n  get_proc (sourcenode a') = p\n  matched n ([] @ n # ns @ [Formal_out (sourcenode a', x')]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       matched n ns n' \\<and>\n       n \\<in> set ns \\<and> get_proc (parent_node (last ns)) = p", "by auto"], ["proof (state)\nthis:\n  \\<exists>ns.\n     matched n ns n' \\<and>\n     n \\<in> set ns \\<and> get_proc (parent_node (last ns)) = p\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs n n'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p\n 2. \\<And>a Q fs n n'.\n       \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>fs;\n        n = CFG_node (sourcenode a); n' = CFG_node (targetnode a);\n        False = True; False = True\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            matched n ns n' \\<and>\n                            n \\<in> set ns \\<and>\n                            get_proc (parent_node (last ns)) = p", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>ns.\n     matched n ns n' \\<and>\n     n \\<in> set ns \\<and> get_proc (parent_node (last ns)) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma return_edge_determines_call_and_sum_edge:\n  assumes \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n  obtains a' Q' r' fs' where \"a \\<in> get_return_edges a'\" and \"valid_edge a'\"\n  and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\" \n  and \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' Q' r' fs'.\n        \\<lbrakk>a \\<in> get_return_edges a'; valid_edge a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         CFG_node\n          (sourcenode\n            a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n               (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)", "by(fastforce intro:sum_SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain a' Q' r' fs' where \"valid_edge a'\" and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\"\n    and \"a \\<in> get_return_edges a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' r' fs'.\n        \\<lbrakk>valid_edge a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         a \\<in> get_return_edges a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest:return_needs_call)"], ["proof (state)\nthis:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "hence \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:sum_SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close> \\<open>valid_edge a\\<close> \\<open>a \\<in> get_return_edges a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  valid_edge a\n  a \\<in> get_return_edges a'", "have \"CFG_node (targetnode a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  valid_edge a\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a)", "by(fastforce intro!:SDG_proc_entry_exit_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "hence \"valid_SDG_node (CFG_node (targetnode a'))\""], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (targetnode a'))", "by(rule SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "with \\<open>CFG_node (targetnode a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (targetnode\n     a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a)\n  valid_SDG_node (CFG_node (targetnode a'))", "have \"CFG_node (targetnode a') i-[]@[CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* \n        CFG_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a)\n  valid_SDG_node (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a') i-[] @\n             [CFG_node\n               (targetnode\n                 a')]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)", "by(fastforce intro:iSp_Append_cdep iSp_Nil)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a') i-[] @\n           [CFG_node\n             (targetnode a')]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "from \\<open>valid_SDG_node (CFG_node (targetnode a'))\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (CFG_node (targetnode a'))", "have \"matched (CFG_node (targetnode a')) [] (CFG_node (targetnode a'))\""], ["proof (prove)\nusing this:\n  valid_SDG_node (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) [] (CFG_node (targetnode a'))", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) [] (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "with \\<open>CFG_node (targetnode a') i-[]@[CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* \n        CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (targetnode\n     a') i-[] @\n           [CFG_node\n             (targetnode a')]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n  matched (CFG_node (targetnode a')) [] (CFG_node (targetnode a'))", "have \"matched (CFG_node (targetnode a')) ([]@[CFG_node (targetnode a')])\n                (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') i-[] @\n           [CFG_node\n             (targetnode a')]\\<rightarrow>\\<^sub>d* CFG_node (sourcenode a)\n  matched (CFG_node (targetnode a')) [] (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) ([] @ [CFG_node (targetnode a')])\n     (CFG_node (sourcenode a))", "by(fastforce intro:matched_Append_intra_SDG_path)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) ([] @ [CFG_node (targetnode a')])\n   (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "with \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n    \\<open>a \\<in> get_return_edges a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges a'\n  matched (CFG_node (targetnode a')) ([] @ [CFG_node (targetnode a')])\n   (CFG_node (sourcenode a))", "have \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  a \\<in> get_return_edges a'\n  matched (CFG_node (targetnode a')) ([] @ [CFG_node (targetnode a')])\n   (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "by(fastforce intro!:sum_SDG_call_summary_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "with \\<open>a \\<in> get_return_edges a'\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> get_return_edges a'\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "show \"\\<exists>a' Q' r' fs'. a \\<in> get_return_edges a' \\<and> valid_edge a' \\<and> \n    kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and> CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  a \\<in> get_return_edges a'\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<exists>a' Q' r' fs'.\n       a \\<in> get_return_edges a' \\<and>\n       valid_edge a' \\<and>\n       kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n       CFG_node\n        (sourcenode\n          a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a' Q' r' fs'.\n     a \\<in> get_return_edges a' \\<and>\n     valid_edge a' \\<and>\n     kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' \\<and>\n     CFG_node\n      (sourcenode\n        a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Paths consisting of intraprocedural and summary edges in the SDG\\<close>"], ["", "inductive intra_sum_SDG_path ::\n  \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n(\"_ is-_\\<rightarrow>\\<^sub>d* _\" [51,0,0] 80)\nwhere isSp_Nil:\n  \"valid_SDG_node n \\<Longrightarrow> n is-[]\\<rightarrow>\\<^sub>d* n\"\n\n  | isSp_Append_cdep:\n  \"\\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n''; n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n is-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | isSp_Append_ddep:\n  \"\\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n''; n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk> \\<Longrightarrow> n is-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | isSp_Append_sum:\n  \"\\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n''; n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n is-ns@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["", "lemma is_SDG_path_Append:\n  \"\\<lbrakk>n'' is-ns'\\<rightarrow>\\<^sub>d* n'; n is-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n is-ns@ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' is-ns'\\<rightarrow>\\<^sub>d* n';\n     n is-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n    \\<Longrightarrow> n is-ns @ ns'\\<rightarrow>\\<^sub>d* n'", "by(induct rule:intra_sum_SDG_path.induct,\n   auto intro:intra_sum_SDG_path.intros simp:append_assoc[THEN sym] \n                                        simp del:append_assoc)"], ["", "lemma is_SDG_path_valid_SDG_node:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\" shows \"valid_SDG_node n\" and \"valid_SDG_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "using \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "by(induct rule:intra_sum_SDG_path.induct,\n   auto intro:sum_SDG_edge_valid_SDG_node valid_SDG_CFG_node)"], ["", "lemma intra_SDG_path_is_SDG_path:\n  \"n i-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n is-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n i-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-ns\\<rightarrow>\\<^sub>d* n'", "by(induct rule:intra_SDG_path.induct,\n   auto intro:intra_sum_SDG_path.intros SDG_edge_sum_SDG_edge)"], ["", "lemma is_SDG_path_hd:\"\\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'; ns \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd ns = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'; ns \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd ns = n", "apply(induct rule:intra_sum_SDG_path.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_SDG_node n; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd [] = n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        ns \\<noteq> [] \\<Longrightarrow> hd ns = n;\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (ns @ [n'']) = n\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        ns \\<noteq> [] \\<Longrightarrow> hd ns = n;\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (ns @ [n'']) = n\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        ns \\<noteq> [] \\<Longrightarrow> hd ns = n;\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (ns @ [n'']) = n", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        ns \\<noteq> [] \\<Longrightarrow> hd ns = n;\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (ns @ [n'']) = n\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        ns \\<noteq> [] \\<Longrightarrow> hd ns = n;\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (ns @ [n'']) = n\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        ns \\<noteq> [] \\<Longrightarrow> hd ns = n;\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (ns @ [n'']) = n", "by(case_tac ns,auto elim:intra_sum_SDG_path.cases)+"], ["", "lemma intra_sum_SDG_path_rev_induct [consumes 1, case_names \"isSp_Nil\" \n  \"isSp_Cons_cdep\"  \"isSp_Cons_ddep\"  \"isSp_Cons_sum\"]: \n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  and refl:\"\\<And>n. valid_SDG_node n \\<Longrightarrow> P n [] n\"\n  and step_cdep:\"\\<And>n ns n' n''. \\<lbrakk>n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''; n'' is-ns\\<rightarrow>\\<^sub>d* n'; P n'' ns n'\\<rbrakk> \n                 \\<Longrightarrow> P n (n#ns) n'\"\n  and step_ddep:\"\\<And>n ns n' V n''. \\<lbrakk>n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''; n'' is-ns\\<rightarrow>\\<^sub>d* n'; \n                                  P n'' ns n'\\<rbrakk> \\<Longrightarrow> P n (n#ns) n'\"\n  and step_sum:\"\\<And>n ns n' p n''. \\<lbrakk>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''; n'' is-ns\\<rightarrow>\\<^sub>d* n'; P n'' ns n'\\<rbrakk> \n                 \\<Longrightarrow> P n (n#ns) n'\"\n  shows \"P n ns n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n ns n'", "using \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. P n ns n'", "proof(induct ns arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. n is-[]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> P n [] n'\n 2. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "case Nil"], ["proof (state)\nthis:\n  n is-[]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n. n is-[]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> P n [] n'\n 2. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "thus ?case"], ["proof (prove)\nusing this:\n  n is-[]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. P n [] n'", "by(fastforce elim:intra_sum_SDG_path.cases intro:refl)"], ["proof (state)\nthis:\n  P n [] n'\n\ngoal (1 subgoal):\n 1. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "case (Cons nx nsx)"], ["proof (state)\nthis:\n  ?n is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> P ?n nsx n'\n  n is-nx # nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "note IH = \\<open>\\<And>n. n is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> P n nsx n'\\<close>"], ["proof (state)\nthis:\n  ?n is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> P ?n nsx n'\n\ngoal (1 subgoal):\n 1. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "from \\<open>n is-nx#nsx\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-nx # nsx\\<rightarrow>\\<^sub>d* n'", "have [simp]:\"n = nx\""], ["proof (prove)\nusing this:\n  n is-nx # nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n = nx", "by(fastforce dest:is_SDG_path_hd)"], ["proof (state)\nthis:\n  n = nx\n\ngoal (1 subgoal):\n 1. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "from \\<open>n is-nx#nsx\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-nx # nsx\\<rightarrow>\\<^sub>d* n'", "have \"((\\<exists>n''. n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n') \\<or>\n    (\\<exists>n'' V. n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p. n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n')\""], ["proof (prove)\nusing this:\n  n is-nx # nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. ((\\<exists>n''.\n         n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n         n'' is-nsx\\<rightarrow>\\<^sub>d* n') \\<or>\n     (\\<exists>n'' V.\n         n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n         n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p.\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n        n'' is-nsx\\<rightarrow>\\<^sub>d* n')", "proof(induct nsx arbitrary:n' rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       n is-[nx]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n       ((\\<exists>n''.\n            n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n            n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V.\n            n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n            n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n       (\\<exists>n'' p.\n           n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n           n'' is-[]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "case Nil"], ["proof (state)\nthis:\n  n is-[nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       n is-[nx]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n       ((\\<exists>n''.\n            n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n            n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V.\n            n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n            n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n       (\\<exists>n'' p.\n           n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n           n'' is-[]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>n is-[nx]\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-[nx]\\<rightarrow>\\<^sub>d* n'", "have \"n is-[]\\<rightarrow>\\<^sub>d* nx\" \n      and disj:\"nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<or> (\\<exists>V. nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<and> nx \\<noteq> n') \\<or> (\\<exists>p. nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n')\""], ["proof (prove)\nusing this:\n  n is-[nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n is-[]\\<rightarrow>\\<^sub>d* nx &&&\n    nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<or>\n    (\\<exists>V.\n        nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<and> nx \\<noteq> n') \\<or>\n    (\\<exists>p. nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n')", "by(induct n ns\\<equiv>\"[nx]\" n' rule:intra_sum_SDG_path.induct,auto)"], ["proof (state)\nthis:\n  n is-[]\\<rightarrow>\\<^sub>d* nx\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<or>\n  (\\<exists>V.\n      nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<and> nx \\<noteq> n') \\<or>\n  (\\<exists>p. nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n')\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       n is-[nx]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n       ((\\<exists>n''.\n            n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n            n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V.\n            n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n            n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n       (\\<exists>n'' p.\n           n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n           n'' is-[]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>n is-[]\\<rightarrow>\\<^sub>d* nx\\<close>"], ["proof (chain)\npicking this:\n  n is-[]\\<rightarrow>\\<^sub>d* nx", "have [simp]:\"n = nx\""], ["proof (prove)\nusing this:\n  n is-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n = nx", "by(fastforce elim:intra_sum_SDG_path.cases)"], ["proof (state)\nthis:\n  n = nx\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       n is-[nx]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n       ((\\<exists>n''.\n            n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n            n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V.\n            n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n            n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n       (\\<exists>n'' p.\n           n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n           n'' is-[]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from disj"], ["proof (chain)\npicking this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<or>\n  (\\<exists>V.\n      nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<and> nx \\<noteq> n') \\<or>\n  (\\<exists>p. nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n')", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<or>\n  (\\<exists>V.\n      nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<and> nx \\<noteq> n') \\<or>\n  (\\<exists>p. nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n')\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(fastforce intro:sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       n is-[nx]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n       ((\\<exists>n''.\n            n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n            n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V.\n            n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n            n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n       (\\<exists>n'' p.\n           n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n           n'' is-[]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "hence \"n' is-[]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. n' is-[]\\<rightarrow>\\<^sub>d* n'", "by(rule isSp_Nil)"], ["proof (state)\nthis:\n  n' is-[]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       n is-[nx]\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n       ((\\<exists>n''.\n            n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n            n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V.\n            n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n            n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n       (\\<exists>n'' p.\n           n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n           n'' is-[]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "with disj"], ["proof (chain)\npicking this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<or>\n  (\\<exists>V.\n      nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<and> nx \\<noteq> n') \\<or>\n  (\\<exists>p. nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n')\n  n' is-[]\\<rightarrow>\\<^sub>d* n'", "show ?case"], ["proof (prove)\nusing this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n' \\<or>\n  (\\<exists>V.\n      nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n' \\<and> nx \\<noteq> n') \\<or>\n  (\\<exists>p. nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n')\n  n' is-[]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. ((\\<exists>n''.\n         n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n         n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n     (\\<exists>n'' V.\n         n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n         n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p.\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n        n'' is-[]\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-[]\\<rightarrow>\\<^sub>d* n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and> n'' is-[]\\<rightarrow>\\<^sub>d* n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-[]\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "case (snoc x xs)"], ["proof (state)\nthis:\n  n is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n  n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "note \\<open>\\<And>n'. n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n      ((\\<exists>n''. n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n      (\\<exists>n'' V. n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> n \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n      (\\<exists>n'' p. n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (state)\nthis:\n  n is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (1 subgoal):\n 1. \\<And>x xs n'.\n       \\<lbrakk>\\<And>n'.\n                   n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   ((\\<exists>n''.\n                        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n                    (\\<exists>n'' V.\n                        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                        n \\<noteq> n'' \\<and>\n                        n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n                   (\\<exists>n'' p.\n                       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                       n'' is-xs\\<rightarrow>\\<^sub>d* n');\n        n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "with \\<open>n is-nx#xs@[x]\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\n  n is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')", "show ?case"], ["proof (prove)\nusing this:\n  n is-nx # xs @ [x]\\<rightarrow>\\<^sub>d* n'\n  n is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (1 subgoal):\n 1. ((\\<exists>n''.\n         n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n     (\\<exists>n'' V.\n         n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n         n \\<noteq> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p.\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n        n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "proof(induct n \"nx#xs@[x]\" n' rule:intra_sum_SDG_path.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "case (isSp_Append_cdep m ms m'' n')"], ["proof (state)\nthis:\n  m is-ms\\<rightarrow>\\<^sub>d* m''\n  \\<lbrakk>ms = nx # xs @ [x];\n   \\<And>n'.\n      m is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n      ((\\<exists>n''.\n           m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n           n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n       (\\<exists>n'' V.\n           m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n           m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n      (\\<exists>n'' p.\n          m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n          n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>n''.\n                         m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'') \\<or>\n                     (\\<exists>n'' V.\n                         m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                         m \\<noteq> n'' \\<and>\n                         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'')) \\<or>\n                    (\\<exists>n'' p.\n                        m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                        n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'')\n  m'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  ms @ [m''] = nx # xs @ [x]\n  m is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "note IH = \\<open>\\<And>n'. m is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n        ((\\<exists>n''. m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n        (\\<exists>n'' p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (state)\nthis:\n  m is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>ms @ [m''] = nx#xs@[x]\\<close>"], ["proof (chain)\npicking this:\n  ms @ [m''] = nx # xs @ [x]", "have [simp]:\"ms = nx#xs\"\n        and [simp]:\"m'' = x\""], ["proof (prove)\nusing this:\n  ms @ [m''] = nx # xs @ [x]\n\ngoal (1 subgoal):\n 1. ms = nx # xs &&& m'' = x", "by simp_all"], ["proof (state)\nthis:\n  ms = nx # xs\n  m'' = x\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>m is-ms\\<rightarrow>\\<^sub>d* m''\\<close>"], ["proof (chain)\npicking this:\n  m is-ms\\<rightarrow>\\<^sub>d* m''", "have \"m is-nx#xs\\<rightarrow>\\<^sub>d* m''\""], ["proof (prove)\nusing this:\n  m is-ms\\<rightarrow>\\<^sub>d* m''\n\ngoal (1 subgoal):\n 1. m is-nx # xs\\<rightarrow>\\<^sub>d* m''", "by simp"], ["proof (state)\nthis:\n  m is-nx # xs\\<rightarrow>\\<^sub>d* m''\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from IH[OF this]"], ["proof (chain)\npicking this:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* m'') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* m'')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* m'')", "obtain n'' where \"n'' is-xs\\<rightarrow>\\<^sub>d* m''\"\n        and \"(m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or> (\\<exists>V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or> (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\""], ["proof (prove)\nusing this:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* m'') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* m'')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* m'')\n\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        \\<lbrakk>n'' is-xs\\<rightarrow>\\<^sub>d* m'';\n         (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n          (\\<exists>V.\n              m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n              m \\<noteq> n'')) \\<or>\n         (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-xs\\<rightarrow>\\<^sub>d* m''\\<close> \\<open>m'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  m'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"n'' is-xs@[m'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  m'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'", "by(rule intra_sum_SDG_path.intros)"], ["proof (state)\nthis:\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "with \\<open>(m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or> (\\<exists>V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or> (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\\<close>"], ["proof (chain)\npicking this:\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'", "show ?case"], ["proof (prove)\nusing this:\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. ((\\<exists>n''.\n         m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n     (\\<exists>n'' V.\n         m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n         m \\<noteq> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p.\n        m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n        n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "case (isSp_Append_ddep m ms m'' V n')"], ["proof (state)\nthis:\n  m is-ms\\<rightarrow>\\<^sub>d* m''\n  \\<lbrakk>ms = nx # xs @ [x];\n   \\<And>n'.\n      m is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n      ((\\<exists>n''.\n           m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n           n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n       (\\<exists>n'' V.\n           m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n           m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n      (\\<exists>n'' p.\n          m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n          n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>n''.\n                         m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'') \\<or>\n                     (\\<exists>n'' V.\n                         m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                         m \\<noteq> n'' \\<and>\n                         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'')) \\<or>\n                    (\\<exists>n'' p.\n                        m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                        n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'')\n  m'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  m'' \\<noteq> n'\n  ms @ [m''] = nx # xs @ [x]\n  m is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "note IH = \\<open>\\<And>n'. m is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n        ((\\<exists>n''. m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n        (\\<exists>n'' p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (state)\nthis:\n  m is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>ms @ [m''] = nx#xs@[x]\\<close>"], ["proof (chain)\npicking this:\n  ms @ [m''] = nx # xs @ [x]", "have [simp]:\"ms = nx#xs\"\n        and [simp]:\"m'' = x\""], ["proof (prove)\nusing this:\n  ms @ [m''] = nx # xs @ [x]\n\ngoal (1 subgoal):\n 1. ms = nx # xs &&& m'' = x", "by simp_all"], ["proof (state)\nthis:\n  ms = nx # xs\n  m'' = x\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>m is-ms\\<rightarrow>\\<^sub>d* m''\\<close>"], ["proof (chain)\npicking this:\n  m is-ms\\<rightarrow>\\<^sub>d* m''", "have \"m is-nx#xs\\<rightarrow>\\<^sub>d* m''\""], ["proof (prove)\nusing this:\n  m is-ms\\<rightarrow>\\<^sub>d* m''\n\ngoal (1 subgoal):\n 1. m is-nx # xs\\<rightarrow>\\<^sub>d* m''", "by simp"], ["proof (state)\nthis:\n  m is-nx # xs\\<rightarrow>\\<^sub>d* m''\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from IH[OF this]"], ["proof (chain)\npicking this:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* m'') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* m'')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* m'')", "obtain n'' where \"n'' is-xs\\<rightarrow>\\<^sub>d* m''\"\n        and \"(m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or> (\\<exists>V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or> (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\""], ["proof (prove)\nusing this:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* m'') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* m'')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* m'')\n\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        \\<lbrakk>n'' is-xs\\<rightarrow>\\<^sub>d* m'';\n         (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n          (\\<exists>V.\n              m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n              m \\<noteq> n'')) \\<or>\n         (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-xs\\<rightarrow>\\<^sub>d* m''\\<close> \\<open>m'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>m'' \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  m'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  m'' \\<noteq> n'", "have \"n'' is-xs@[m'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  m'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  m'' \\<noteq> n'\n\ngoal (1 subgoal):\n 1. n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'", "by(rule intra_sum_SDG_path.intros)"], ["proof (state)\nthis:\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "with \\<open>(m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or> (\\<exists>V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or> (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\\<close>"], ["proof (chain)\npicking this:\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'", "show ?case"], ["proof (prove)\nusing this:\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. ((\\<exists>n''.\n         m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n     (\\<exists>n'' V.\n         m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n         m \\<noteq> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p.\n        m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n        n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "case (isSp_Append_sum m ms m'' p n')"], ["proof (state)\nthis:\n  m is-ms\\<rightarrow>\\<^sub>d* m''\n  \\<lbrakk>ms = nx # xs @ [x];\n   \\<And>n'.\n      m is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n      ((\\<exists>n''.\n           m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n           n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n       (\\<exists>n'' V.\n           m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n           m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n      (\\<exists>n'' p.\n          m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n          n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>n''.\n                         m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'') \\<or>\n                     (\\<exists>n'' V.\n                         m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                         m \\<noteq> n'' \\<and>\n                         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'')) \\<or>\n                    (\\<exists>n'' p.\n                        m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                        n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* m'')\n  m'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n  ms @ [m''] = nx # xs @ [x]\n  m is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "note IH = \\<open>\\<And>n'. m is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n        ((\\<exists>n''. m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n        (\\<exists>n'' V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n        (\\<exists>n'' p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (state)\nthis:\n  m is-nx # xs\\<rightarrow>\\<^sub>d* ?n' \\<Longrightarrow>\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* ?n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* ?n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* ?n')\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>ms @ [m''] = nx#xs@[x]\\<close>"], ["proof (chain)\npicking this:\n  ms @ [m''] = nx # xs @ [x]", "have [simp]:\"ms = nx#xs\"\n        and [simp]:\"m'' = x\""], ["proof (prove)\nusing this:\n  ms @ [m''] = nx # xs @ [x]\n\ngoal (1 subgoal):\n 1. ms = nx # xs &&& m'' = x", "by simp_all"], ["proof (state)\nthis:\n  ms = nx # xs\n  m'' = x\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>m is-ms\\<rightarrow>\\<^sub>d* m''\\<close>"], ["proof (chain)\npicking this:\n  m is-ms\\<rightarrow>\\<^sub>d* m''", "have \"m is-nx#xs\\<rightarrow>\\<^sub>d* m''\""], ["proof (prove)\nusing this:\n  m is-ms\\<rightarrow>\\<^sub>d* m''\n\ngoal (1 subgoal):\n 1. m is-nx # xs\\<rightarrow>\\<^sub>d* m''", "by simp"], ["proof (state)\nthis:\n  m is-nx # xs\\<rightarrow>\\<^sub>d* m''\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from IH[OF this]"], ["proof (chain)\npicking this:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* m'') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* m'')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* m'')", "obtain n'' where \"n'' is-xs\\<rightarrow>\\<^sub>d* m''\"\n        and \"(m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or> (\\<exists>V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or> (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\""], ["proof (prove)\nusing this:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs\\<rightarrow>\\<^sub>d* m'') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and> n'' is-xs\\<rightarrow>\\<^sub>d* m'')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs\\<rightarrow>\\<^sub>d* m'')\n\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        \\<lbrakk>n'' is-xs\\<rightarrow>\\<^sub>d* m'';\n         (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n          (\\<exists>V.\n              m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n              m \\<noteq> n'')) \\<or>\n         (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-xs\\<rightarrow>\\<^sub>d* m''\\<close> \\<open>m'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  m'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "have \"n'' is-xs@[m'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' is-xs\\<rightarrow>\\<^sub>d* m''\n  m'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'", "by(rule intra_sum_SDG_path.intros)"], ["proof (state)\nthis:\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<lbrakk>ns = nx # xs @ [x];\n         \\<And>n'.\n            n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n            ((\\<exists>n''.\n                 n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n             (\\<exists>n'' V.\n                 n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                 n \\<noteq> n'' \\<and>\n                 n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n            (\\<exists>n'' p.\n                n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n        \\<Longrightarrow> ((\\<exists>n''a.\n                               n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'') \\<or>\n                           (\\<exists>n''a V.\n                               n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''a \\<and>\n                               n \\<noteq> n''a \\<and>\n                               n''a is-xs @\n [x]\\<rightarrow>\\<^sub>d* n'')) \\<or>\n                          (\\<exists>n''a p.\n                              n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''a \\<and>\n                              n''a is-xs @ [x]\\<rightarrow>\\<^sub>d* n'');\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        ns @ [n''] = nx # xs @ [x];\n        \\<And>n'.\n           n is-nx # xs\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n           ((\\<exists>n''.\n                n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n') \\<or>\n            (\\<exists>n'' V.\n                n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                n \\<noteq> n'' \\<and>\n                n'' is-xs\\<rightarrow>\\<^sub>d* n')) \\<or>\n           (\\<exists>n'' p.\n               n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n               n'' is-xs\\<rightarrow>\\<^sub>d* n')\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>n''.\n                              n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n                          (\\<exists>n'' V.\n                              n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n                              n \\<noteq> n'' \\<and>\n                              n'' is-xs @\n                                     [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n                         (\\<exists>n'' p.\n                             n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n                             n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "with \\<open>(m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or> (\\<exists>V. m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or> (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\\<close>"], ["proof (chain)\npicking this:\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'", "show ?case"], ["proof (prove)\nusing this:\n  (m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<or>\n   (\\<exists>V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> m \\<noteq> n'')) \\<or>\n  (\\<exists>p. m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'')\n  n'' is-xs @ [m'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. ((\\<exists>n''.\n         m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n     (\\<exists>n'' V.\n         m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n         m \\<noteq> n'' \\<and>\n         n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p.\n        m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n        n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  ((\\<exists>n''.\n       m s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n   (\\<exists>n'' V.\n       m s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       m \\<noteq> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n  (\\<exists>n'' p.\n      m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-xs @ [x]\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-nsx\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<And>a ns n.\n       \\<lbrakk>\\<And>n.\n                   n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n                   P n ns n';\n        n is-a # ns\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> P n (a # ns) n'", "thus ?case"], ["proof (prove)\nusing this:\n  ((\\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n') \\<or>\n   (\\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n')) \\<or>\n  (\\<exists>n'' p.\n      n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n      n'' is-nsx\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. P n (nx # nsx) n'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>n''.\n         n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n         n'' is-nsx\\<rightarrow>\\<^sub>d* n') \\<or>\n     (\\<exists>n'' V.\n         n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n         n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n')) \\<or>\n    (\\<exists>n'' p.\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n        n'' is-nsx\\<rightarrow>\\<^sub>d* n') \\<Longrightarrow>\n    P n (nx # nsx) n'", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 3. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "assume \"\\<exists>n''. n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>n''.\n     n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n     n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 3. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>n''.\n     n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n     n'' is-nsx\\<rightarrow>\\<^sub>d* n'", "obtain n'' where \"n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\" and \"n'' is-nsx\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>n''.\n     n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n     n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        \\<lbrakk>n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'';\n         n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n  n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 3. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "from IH[OF \\<open>n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<close>]"], ["proof (chain)\npicking this:\n  P n'' nsx n'", "have \"P n'' nsx n'\""], ["proof (prove)\nusing this:\n  P n'' nsx n'\n\ngoal (1 subgoal):\n 1. P n'' nsx n'", "."], ["proof (state)\nthis:\n  P n'' nsx n'\n\ngoal (3 subgoals):\n 1. \\<exists>n''.\n       n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 3. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "from step_cdep[OF \\<open>n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<close> \\<open>n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<close> this]"], ["proof (chain)\npicking this:\n  P n (n # nsx) n'", "show ?thesis"], ["proof (prove)\nusing this:\n  P n (n # nsx) n'\n\ngoal (1 subgoal):\n 1. P n (nx # nsx) n'", "by simp"], ["proof (state)\nthis:\n  P n (nx # nsx) n'\n\ngoal (2 subgoals):\n 1. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "assume \"\\<exists>n'' V. n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and> n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>n'' V.\n     n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n     n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>n'' V.\n     n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n     n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n'", "obtain n'' V where \"n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\" and \"n \\<noteq> n''\" and \"n'' is-nsx\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>n'' V.\n     n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n     n \\<noteq> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>V n''.\n        \\<lbrakk>n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n'';\n         n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\n  n \\<noteq> n''\n  n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "from IH[OF \\<open>n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<close>]"], ["proof (chain)\npicking this:\n  P n'' nsx n'", "have \"P n'' nsx n'\""], ["proof (prove)\nusing this:\n  P n'' nsx n'\n\ngoal (1 subgoal):\n 1. P n'' nsx n'", "."], ["proof (state)\nthis:\n  P n'' nsx n'\n\ngoal (2 subgoals):\n 1. \\<exists>n'' V.\n       n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'' \\<and>\n       n \\<noteq> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'\n 2. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "from step_ddep[OF \\<open>n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\\<close> \\<open>n \\<noteq> n''\\<close> \\<open>n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<close> this]"], ["proof (chain)\npicking this:\n  P n (n # nsx) n'", "show ?thesis"], ["proof (prove)\nusing this:\n  P n (n # nsx) n'\n\ngoal (1 subgoal):\n 1. P n (nx # nsx) n'", "by simp"], ["proof (state)\nthis:\n  P n (nx # nsx) n'\n\ngoal (1 subgoal):\n 1. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "assume \"\\<exists>n'' p. n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and> n'' is-nsx\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>n'' p.\n     n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n     n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>n'' p.\n     n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n     n'' is-nsx\\<rightarrow>\\<^sub>d* n'", "obtain n'' p where \"n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\" and \"n'' is-nsx\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>n'' p.\n     n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n     n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>p n''.\n        \\<lbrakk>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'';\n         n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\n  n'' is-nsx\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "from IH[OF \\<open>n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<close>]"], ["proof (chain)\npicking this:\n  P n'' nsx n'", "have \"P n'' nsx n'\""], ["proof (prove)\nusing this:\n  P n'' nsx n'\n\ngoal (1 subgoal):\n 1. P n'' nsx n'", "."], ["proof (state)\nthis:\n  P n'' nsx n'\n\ngoal (1 subgoal):\n 1. \\<exists>n'' p.\n       n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'' \\<and>\n       n'' is-nsx\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    P n (nx # nsx) n'", "from step_sum[OF \\<open>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<close> \\<open>n'' is-nsx\\<rightarrow>\\<^sub>d* n'\\<close> this]"], ["proof (chain)\npicking this:\n  P n (n # nsx) n'", "show ?thesis"], ["proof (prove)\nusing this:\n  P n (n # nsx) n'\n\ngoal (1 subgoal):\n 1. P n (nx # nsx) n'", "by simp"], ["proof (state)\nthis:\n  P n (nx # nsx) n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P n (nx # nsx) n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_SDG_path_CFG_path:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'", "show \"\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(induct rule:intra_sum_SDG_path.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"valid_node (parent_node n)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n)", "by(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node n)\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "hence \"parent_node n -[]\\<rightarrow>* parent_node n\""], ["proof (prove)\nusing this:\n  valid_node (parent_node n)\n\ngoal (1 subgoal):\n 1. parent_node n -[]\\<rightarrow>* parent_node n", "by(rule empty_path)"], ["proof (state)\nthis:\n  parent_node n -[]\\<rightarrow>* parent_node n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -[]\\<rightarrow>* parent_node n\n\ngoal (1 subgoal):\n 1. \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "by(auto simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Append_cdep n ns n'' n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\""], ["proof (prove)\nusing this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "by(rule sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(rule cdep_edge_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"parent_node n'' controls parent_node n'\""], ["proof (state)\nthis:\n  parent_node n'' controls parent_node n'\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  parent_node n'' controls parent_node n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" and \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  parent_node n'' controls parent_node n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>parent_node\n                  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         as' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule control_dependence_path)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "fix a Q r p fs a'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a' \\<in> get_return_edges a\"\n        and \"parent_node n'' = targetnode a\" and \"parent_node n' = sourcenode a'\""], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = targetnode a\"\n        and \"targetnode a'' = sourcenode a'\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = targetnode a;\n         targetnode a'' = sourcenode a';\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:intra_proc_additional_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "hence \"targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "by(fastforce dest:path_edge simp:intra_path_def intra_kind_def)"], ["proof (state)\nthis:\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n'' = targetnode a\\<close> \\<open>parent_node n' = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "have \"\\<exists>as'. parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and> as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       parent_node\n        n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n       as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" and \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>parent_node\n                  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         as' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"n'' = CFG_node m\" and \"m = parent_node n'\""], ["proof (state)\nthis:\n  n'' = CFG_node m\n  m = parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' = CFG_node m\n  m = parent_node n'", "show ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' = CFG_node m\n  m = parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Append_ddep n ns n'' V n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "have \"n'' influences V in n'\""], ["proof (prove)\nusing this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. n'' influences V in n'", "by(fastforce elim:sum_SDG_edge.cases)"], ["proof (state)\nthis:\n  n'' influences V in n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  n'' influences V in n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n'' influences V in n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n         n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:data_dependence_def)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Append_sum n ns n'' p n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "have \"\\<exists>as'. parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(rule sum_edge_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "fix a Q fs a'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "assume \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n        and \"n'' = CFG_node (sourcenode a)\" and \"n' = CFG_node (targetnode a')\""], ["proof (state)\nthis:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  n'' = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where \"sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        sourcenode\n         a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n         a' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a''.\n                sourcenode\n                 a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n                 a' \\<Longrightarrow>\n                thesis;\n     valid_edge a; a' \\<in> get_return_edges a\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(drule call_return_node_edge)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a''.\n                sourcenode\n                 a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n                 a' \\<Longrightarrow>\n                thesis;\n     a' \\<in> get_return_edges a\\<rbrakk>\n    \\<Longrightarrow> ?a'4 \\<in> get_return_edges a\n 2. \\<lbrakk>\\<And>a''.\n                sourcenode\n                 a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n                 a' \\<Longrightarrow>\n                thesis;\n     a' \\<in> get_return_edges a;\n     \\<exists>a''.\n        valid_edge a'' \\<and>\n        sourcenode a'' = sourcenode a \\<and>\n        targetnode a'' = targetnode ?a'4 \\<and>\n        kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(auto simp:intra_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a''.\n       \\<lbrakk>\\<And>a''.\n                   sourcenode a -[a'']\\<rightarrow>* targetnode a' \\<and>\n                   intra_kind (kind a'') \\<Longrightarrow>\n                   thesis;\n        a' \\<in> get_return_edges a; valid_edge a'';\n        sourcenode a'' = sourcenode a; targetnode a'' = targetnode a';\n        kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule path_edge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a''.\n       \\<lbrakk>\\<And>a''.\n                   sourcenode a -[a'']\\<rightarrow>* targetnode a' \\<and>\n                   intra_kind (kind a'') \\<Longrightarrow>\n                   thesis;\n        a' \\<in> get_return_edges a; sourcenode a'' = sourcenode a;\n        targetnode a'' = targetnode a';\n        kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>;\n        sourcenode a'' -[a'']\\<rightarrow>* targetnode a''\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "with \\<open>n'' = CFG_node (sourcenode a)\\<close> \\<open>n' = CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  n'' = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n  sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'", "show ?thesis"], ["proof (prove)\nusing this:\n  n'' = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n  sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "fix a Q p fs a' ns x x' ins outs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "assume \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n        and \"n'' = Actual_in (sourcenode a, x)\" \n        and \"n' = Actual_out (targetnode a', x')\""], ["proof (state)\nthis:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  n'' = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where \"sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        sourcenode\n         a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n         a' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a''.\n                sourcenode\n                 a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n                 a' \\<Longrightarrow>\n                thesis;\n     valid_edge a; a' \\<in> get_return_edges a\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(drule call_return_node_edge)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a''.\n                sourcenode\n                 a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n                 a' \\<Longrightarrow>\n                thesis;\n     a' \\<in> get_return_edges a\\<rbrakk>\n    \\<Longrightarrow> ?a'4 \\<in> get_return_edges a\n 2. \\<lbrakk>\\<And>a''.\n                sourcenode\n                 a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode\n                 a' \\<Longrightarrow>\n                thesis;\n     a' \\<in> get_return_edges a;\n     \\<exists>a''.\n        valid_edge a'' \\<and>\n        sourcenode a'' = sourcenode a \\<and>\n        targetnode a'' = targetnode ?a'4 \\<and>\n        kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(auto simp:intra_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a''.\n       \\<lbrakk>\\<And>a''.\n                   sourcenode a -[a'']\\<rightarrow>* targetnode a' \\<and>\n                   intra_kind (kind a'') \\<Longrightarrow>\n                   thesis;\n        a' \\<in> get_return_edges a; valid_edge a'';\n        sourcenode a'' = sourcenode a; targetnode a'' = targetnode a';\n        kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule path_edge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a''.\n       \\<lbrakk>\\<And>a''.\n                   sourcenode a -[a'']\\<rightarrow>* targetnode a' \\<and>\n                   intra_kind (kind a'') \\<Longrightarrow>\n                   thesis;\n        a' \\<in> get_return_edges a; sourcenode a'' = sourcenode a;\n        targetnode a'' = targetnode a';\n        kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>;\n        sourcenode a'' -[a'']\\<rightarrow>* targetnode a''\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            parent_node\n                             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                             n'", "with \\<open>n'' = Actual_in (sourcenode a, x)\\<close> \\<open>n' = Actual_out (targetnode a', x')\\<close>"], ["proof (chain)\npicking this:\n  n'' = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'", "show ?thesis"], ["proof (prove)\nusing this:\n  n'' = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  sourcenode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* targetnode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n         n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matched_is_SDG_path:\n  assumes \"matched n ns n'\" obtains ns' where \"n is-ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        n is-ns'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'", "from \\<open>matched n ns n'\\<close>"], ["proof (chain)\npicking this:\n  matched n ns n'", "show \"\\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  matched n ns n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'", "proof(induct rule:matched.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n\n 2. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 4. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "case matched_Nil"], ["proof (state)\nthis:\n  valid_SDG_node n_\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n\n 2. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 4. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n_\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n_ is-ns'\\<rightarrow>\\<^sub>d* n_", "by(fastforce intro:isSp_Nil)"], ["proof (state)\nthis:\n  \\<exists>ns'. n_ is-ns'\\<rightarrow>\\<^sub>d* n_\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "case matched_Append_intra_SDG_path"], ["proof (state)\nthis:\n  matched n_ ns_ n''_\n  \\<exists>ns'. n_ is-ns'\\<rightarrow>\\<^sub>d* n''_\n  n''_ i-ns'_\\<rightarrow>\\<^sub>d* n'_\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' ns' n'.\n       \\<lbrakk>matched n ns n'';\n        \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'';\n        n'' i-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 3. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  matched n_ ns_ n''_\n  \\<exists>ns'. n_ is-ns'\\<rightarrow>\\<^sub>d* n''_\n  n''_ i-ns'_\\<rightarrow>\\<^sub>d* n'_\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n_ is-ns'\\<rightarrow>\\<^sub>d* n'_", "by(fastforce intro:is_SDG_path_Append intra_SDG_path_is_SDG_path)"], ["proof (state)\nthis:\n  \\<exists>ns'. n_ is-ns'\\<rightarrow>\\<^sub>d* n'_\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "case (matched_bracket_call n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a')"], ["proof (state)\nthis:\n  matched n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>\\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1", "obtain nsx where \"n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\\<close> \\<open>sourcenode a = parent_node n\\<^sub>1\\<close> \\<open>targetnode a = parent_node n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2", "have \"n\\<^sub>1 = CFG_node (sourcenode a)\" and \"n\\<^sub>2 = CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 = CFG_node (sourcenode a) &&&\n    n\\<^sub>2 = CFG_node (targetnode a)", "by(auto elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  n\\<^sub>1 = CFG_node (sourcenode a)\n  n\\<^sub>2 = CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q r p' fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p' fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\\<close> \\<open>valid_edge a\\<close>\n      \\<open>n\\<^sub>1 = CFG_node (sourcenode a)\\<close> \\<open>n\\<^sub>2 = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\n  valid_edge a\n  n\\<^sub>1 = CFG_node (sourcenode a)\n  n\\<^sub>2 = CFG_node (targetnode a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2\n  valid_edge a\n  n\\<^sub>1 = CFG_node (sourcenode a)\n  n\\<^sub>2 = CFG_node (targetnode a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. p' = p", "by -(erule SDG_edge.cases,(fastforce dest:edge_det)+)"], ["proof (state)\nthis:\n  p' = p\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 ns' n\\<^sub>3 n\\<^sub>4 V a a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n        n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or> n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4", "show ?case"], ["proof (prove)\nusing this:\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "assume \"n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4\""], ["proof (state)\nthis:\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4\n\ngoal (2 subgoals):\n 1. n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "then"], ["proof (chain)\npicking this:\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4", "obtain ax Q' f' where \"valid_edge ax\" and \"kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n        and \"n\\<^sub>3 = CFG_node (sourcenode ax)\" and \"n\\<^sub>4 = CFG_node (targetnode ax)\""], ["proof (prove)\nusing this:\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>ax Q' f'.\n        \\<lbrakk>valid_edge ax;\n         kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         n\\<^sub>3 = CFG_node (sourcenode ax);\n         n\\<^sub>4 = CFG_node (targetnode ax)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = CFG_node (sourcenode ax)\n  n\\<^sub>4 = CFG_node (targetnode ax)\n\ngoal (2 subgoals):\n 1. n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>sourcenode a' = parent_node n\\<^sub>3\\<close> \\<open>targetnode a' = parent_node n\\<^sub>4\\<close> \n        \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n  valid_edge a'\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = CFG_node (sourcenode ax)\n  n\\<^sub>4 = CFG_node (targetnode ax)", "have [simp]:\"ax = a'\""], ["proof (prove)\nusing this:\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n  valid_edge a'\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = CFG_node (sourcenode ax)\n  n\\<^sub>4 = CFG_node (targetnode ax)\n\ngoal (1 subgoal):\n 1. ax = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  ax = a'\n\ngoal (2 subgoals):\n 1. n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close> \\<open>valid_edge ax\\<close> \\<open>kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n        \\<open>a' \\<in> get_return_edges a\\<close> \\<open>matched n\\<^sub>2 ns' n\\<^sub>3\\<close>\n        \\<open>n\\<^sub>1 = CFG_node (sourcenode a)\\<close> \\<open>n\\<^sub>2 = CFG_node (targetnode a)\\<close>\n        \\<open>n\\<^sub>3 = CFG_node (sourcenode ax)\\<close> \\<open>n\\<^sub>4 = CFG_node (targetnode ax)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  a' \\<in> get_return_edges a\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  n\\<^sub>1 = CFG_node (sourcenode a)\n  n\\<^sub>2 = CFG_node (targetnode a)\n  n\\<^sub>3 = CFG_node (sourcenode ax)\n  n\\<^sub>4 = CFG_node (targetnode ax)", "have \"n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  a' \\<in> get_return_edges a\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  n\\<^sub>1 = CFG_node (sourcenode a)\n  n\\<^sub>2 = CFG_node (targetnode a)\n  n\\<^sub>3 = CFG_node (sourcenode ax)\n  n\\<^sub>4 = CFG_node (targetnode ax)\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4", "by(fastforce intro!:sum_SDG_call_summary_edge[of a _ _ _ _ ax])"], ["proof (state)\nthis:\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4\n\ngoal (2 subgoals):\n 1. n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4", "have \"n\\<^sub>0 is-nsx@[n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4\""], ["proof (prove)\nusing this:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 is-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4", "by(rule isSp_Append_sum)"], ["proof (state)\nthis:\n  n\\<^sub>0 is-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (2 subgoals):\n 1. n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n 2. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  n\\<^sub>0 is-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "by blast"], ["proof (state)\nthis:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "assume \"n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\""], ["proof (state)\nthis:\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "then"], ["proof (chain)\npicking this:\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4", "obtain ax Q' f' x where \"valid_edge ax\" and \"kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n        and \"n\\<^sub>3 = Formal_out (sourcenode ax,x)\" \n        and \"n\\<^sub>4 = Actual_out (targetnode ax,x)\""], ["proof (prove)\nusing this:\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>ax Q' f' x.\n        \\<lbrakk>valid_edge ax;\n         kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         n\\<^sub>3 = Formal_out (sourcenode ax, x);\n         n\\<^sub>4 = Actual_out (targetnode ax, x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x)\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>sourcenode a' = parent_node n\\<^sub>3\\<close> \\<open>targetnode a' = parent_node n\\<^sub>4\\<close> \n        \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n  valid_edge a'\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x)\n  n\\<^sub>4 = Actual_out (targetnode ax, x)", "have [simp]:\"ax = a'\""], ["proof (prove)\nusing this:\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n  valid_edge a'\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x)\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n\ngoal (1 subgoal):\n 1. ax = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  ax = a'\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>n\\<^sub>3 = Formal_out (sourcenode ax,x)\\<close>\n        \\<open>n\\<^sub>4 = Actual_out (targetnode ax,x)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x)\n  n\\<^sub>4 = Actual_out (targetnode ax, x)", "have \"CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x)\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close> \\<open>valid_edge a'\\<close> \n        \\<open>a' \\<in> get_return_edges a\\<close> \\<open>n\\<^sub>4 = Actual_out (targetnode ax,x)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  n\\<^sub>4 = Actual_out (targetnode ax, x)", "have \"CFG_node (targetnode a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')", "by(fastforce intro!:SDG_proc_entry_exit_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>n\\<^sub>2 = CFG_node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>2 = CFG_node (targetnode a)\n  CFG_node\n   (targetnode\n     a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')", "have \"matched n\\<^sub>2 ([]@([]@[n\\<^sub>2])) (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  n\\<^sub>2 = CFG_node (targetnode a)\n  CFG_node\n   (targetnode\n     a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. matched n\\<^sub>2 ([] @ [] @ [n\\<^sub>2]) (CFG_node (sourcenode a'))", "by(fastforce intro:matched.intros intra_SDG_path.intros \n                          SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  matched n\\<^sub>2 ([] @ [] @ [n\\<^sub>2]) (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close> \\<open>valid_edge a'\\<close> \\<open>kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n        \\<open>a' \\<in> get_return_edges a\\<close> \\<open>n\\<^sub>1 = CFG_node (sourcenode a)\\<close> \n        \\<open>n\\<^sub>2 = CFG_node (targetnode a)\\<close> \\<open>n\\<^sub>4 = Actual_out (targetnode ax,x)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge a'\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  a' \\<in> get_return_edges a\n  n\\<^sub>1 = CFG_node (sourcenode a)\n  n\\<^sub>2 = CFG_node (targetnode a)\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n  matched n\\<^sub>2 ([] @ [] @ [n\\<^sub>2]) (CFG_node (sourcenode a'))", "have \"n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge a'\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  a' \\<in> get_return_edges a\n  n\\<^sub>1 = CFG_node (sourcenode a)\n  n\\<^sub>2 = CFG_node (targetnode a)\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n  matched n\\<^sub>2 ([] @ [] @ [n\\<^sub>2]) (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')", "by(fastforce intro!:sum_SDG_call_summary_edge[of a _ _ _ _ a'])"], ["proof (state)\nthis:\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')", "have \"n\\<^sub>0 is-nsx@[n\\<^sub>1]\\<rightarrow>\\<^sub>d* CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 is-nsx @\n                 [n\\<^sub>1]\\<rightarrow>\\<^sub>d* CFG_node (targetnode a')", "by(rule isSp_Append_sum)"], ["proof (state)\nthis:\n  n\\<^sub>0 is-nsx @\n               [n\\<^sub>1]\\<rightarrow>\\<^sub>d* CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>n\\<^sub>4 = Actual_out (targetnode ax,x)\\<close> \\<open>n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4", "have \"CFG_node (targetnode a') s\\<longrightarrow>\\<^bsub>cd\\<^esub> n\\<^sub>4\""], ["proof (prove)\nusing this:\n  n\\<^sub>4 = Actual_out (targetnode ax, x)\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a') s\\<longrightarrow>\\<^bsub>cd\\<^esub> n\\<^sub>4", "by(fastforce intro:sum_SDG_parent_cdep_edge SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') s\\<longrightarrow>\\<^bsub>cd\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>n\\<^sub>0 is-nsx@[n\\<^sub>1]\\<rightarrow>\\<^sub>d* CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>0 is-nsx @\n               [n\\<^sub>1]\\<rightarrow>\\<^sub>d* CFG_node (targetnode a')\n  CFG_node (targetnode a') s\\<longrightarrow>\\<^bsub>cd\\<^esub> n\\<^sub>4", "have \"n\\<^sub>0 is-(nsx@[n\\<^sub>1])@[CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* n\\<^sub>4\""], ["proof (prove)\nusing this:\n  n\\<^sub>0 is-nsx @\n               [n\\<^sub>1]\\<rightarrow>\\<^sub>d* CFG_node (targetnode a')\n  CFG_node (targetnode a') s\\<longrightarrow>\\<^bsub>cd\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 is-(nsx @ [n\\<^sub>1]) @\n                 [CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* n\\<^sub>4", "by(rule isSp_Append_cdep)"], ["proof (state)\nthis:\n  n\\<^sub>0 is-(nsx @ [n\\<^sub>1]) @\n               [CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (1 subgoal):\n 1. n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4 \\<Longrightarrow>\n    \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  n\\<^sub>0 is-(nsx @ [n\\<^sub>1]) @\n               [CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "by blast"], ["proof (state)\nthis:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "case (matched_bracket_param n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a a')"], ["proof (state)\nthis:\n  matched n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n  n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n  valid_edge a\n  a' \\<in> get_return_edges a\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>\\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1", "obtain nsx where \"n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\\<close> \\<open>sourcenode a = parent_node n\\<^sub>1\\<close>\n      \\<open>targetnode a = parent_node n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2", "obtain x ins outs\n      where \"n\\<^sub>1 = Actual_in (sourcenode a,x)\" and \"n\\<^sub>2 = Formal_in (targetnode a,x)\"\n      and \"(p,ins,outs) \\<in> set procs\" and \"V = ins!x\" and \"x < length ins\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  sourcenode a = parent_node n\\<^sub>1\n  targetnode a = parent_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>x ins outs.\n        \\<lbrakk>n\\<^sub>1 = Actual_in (sourcenode a, x);\n         n\\<^sub>2 = Formal_in (targetnode a, x);\n         (p, ins, outs) \\<in> set procs; V = ins ! x;\n         x < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  n\\<^sub>1 = Actual_in (sourcenode a, x)\n  n\\<^sub>2 = Formal_in (targetnode a, x)\n  (p, ins, outs) \\<in> set procs\n  V = ins ! x\n  x < length ins\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q r p' fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p' fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\\<close> \\<open>valid_edge a\\<close>\n      \\<open>n\\<^sub>1 = Actual_in (sourcenode a,x)\\<close> \\<open>n\\<^sub>2 = Formal_in (targetnode a,x)\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  valid_edge a\n  n\\<^sub>1 = Actual_in (sourcenode a, x)\n  n\\<^sub>2 = Formal_in (targetnode a, x)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  valid_edge a\n  n\\<^sub>1 = Actual_in (sourcenode a, x)\n  n\\<^sub>2 = Formal_in (targetnode a, x)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n\ngoal (1 subgoal):\n 1. p' = p", "by -(erule SDG_edge.cases,(fastforce dest:edge_det)+)"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4", "obtain ax Q' f' x' ins' outs' where \"valid_edge ax\" \n      and \"kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\" and \"n\\<^sub>3 = Formal_out (sourcenode ax,x')\" \n      and \"n\\<^sub>4 = Actual_out (targetnode ax,x')\" and \"(p,ins',outs') \\<in> set procs\"\n      and \"V' = outs'!x'\" and \"x' < length outs'\""], ["proof (prove)\nusing this:\n  n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>ax Q' f' x' ins' outs'.\n        \\<lbrakk>valid_edge ax;\n         kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         n\\<^sub>3 = Formal_out (sourcenode ax, x');\n         n\\<^sub>4 = Actual_out (targetnode ax, x');\n         (p, ins', outs') \\<in> set procs; V' = outs' ! x';\n         x' < length outs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x')\n  n\\<^sub>4 = Actual_out (targetnode ax, x')\n  (p, ins', outs') \\<in> set procs\n  V' = outs' ! x'\n  x' < length outs'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>sourcenode a' = parent_node n\\<^sub>3\\<close> \\<open>targetnode a' = parent_node n\\<^sub>4\\<close>\n      \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n  valid_edge a'\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x')\n  n\\<^sub>4 = Actual_out (targetnode ax, x')\n  (p, ins', outs') \\<in> set procs\n  V' = outs' ! x'\n  x' < length outs'", "have [simp]:\"ax = a'\""], ["proof (prove)\nusing this:\n  sourcenode a' = parent_node n\\<^sub>3\n  targetnode a' = parent_node n\\<^sub>4\n  valid_edge a'\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n\\<^sub>3 = Formal_out (sourcenode ax, x')\n  n\\<^sub>4 = Actual_out (targetnode ax, x')\n  (p, ins', outs') \\<in> set procs\n  V' = outs' ! x'\n  x' < length outs'\n\ngoal (1 subgoal):\n 1. ax = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  ax = a'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from unique_callers \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>(p,ins',outs') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  distinct_fst procs\n  (p, ins, outs) \\<in> set procs\n  (p, ins', outs') \\<in> set procs", "have [simp]:\"ins = ins'\" \"outs = outs'\""], ["proof (prove)\nusing this:\n  distinct_fst procs\n  (p, ins, outs) \\<in> set procs\n  (p, ins', outs') \\<in> set procs\n\ngoal (1 subgoal):\n 1. ins = ins' &&& outs = outs'", "by(auto dest:distinct_fst_isin_same_fst)"], ["proof (state)\nthis:\n  ins = ins'\n  outs = outs'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\\<close> \\<open>valid_edge a'\\<close> \\<open>kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n      \\<open>a' \\<in> get_return_edges a\\<close> \\<open>matched n\\<^sub>2 ns' n\\<^sub>3\\<close> \\<open>n\\<^sub>1 = Actual_in (sourcenode a,x)\\<close> \n      \\<open>n\\<^sub>2 = Formal_in (targetnode a,x)\\<close> \\<open>n\\<^sub>3 = Formal_out (sourcenode ax,x')\\<close>\n      \\<open>n\\<^sub>4 = Actual_out (targetnode ax,x')\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>\n      \\<open>x < length ins\\<close> \\<open>x' < length outs'\\<close> \\<open>V = ins!x\\<close> \\<open>V' = outs'!x'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge a'\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  a' \\<in> get_return_edges a\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  n\\<^sub>1 = Actual_in (sourcenode a, x)\n  n\\<^sub>2 = Formal_in (targetnode a, x)\n  n\\<^sub>3 = Formal_out (sourcenode ax, x')\n  n\\<^sub>4 = Actual_out (targetnode ax, x')\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  x' < length outs'\n  V = ins ! x\n  V' = outs' ! x'", "have \"n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs\n  valid_edge a'\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  a' \\<in> get_return_edges a\n  matched n\\<^sub>2 ns' n\\<^sub>3\n  n\\<^sub>1 = Actual_in (sourcenode a, x)\n  n\\<^sub>2 = Formal_in (targetnode a, x)\n  n\\<^sub>3 = Formal_out (sourcenode ax, x')\n  n\\<^sub>4 = Actual_out (targetnode ax, x')\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  x' < length outs'\n  V = ins ! x\n  V' = outs' ! x'\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4", "by(fastforce intro!:sum_SDG_param_summary_edge[of a _ _ _ _ a'])"], ["proof (state)\nthis:\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "with \\<open>n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4", "have \"n\\<^sub>0 is-nsx@[n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4\""], ["proof (prove)\nusing this:\n  n\\<^sub>0 is-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 is-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4", "by(rule isSp_Append_sum)"], ["proof (state)\nthis:\n  n\\<^sub>0 is-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p V n\\<^sub>2 ns' n\\<^sub>3 V' n\\<^sub>4 a\n       a'.\n       \\<lbrakk>matched n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3;\n        \\<exists>ns'. n\\<^sub>2 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3;\n        n\\<^sub>3 -p:V'\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4;\n        valid_edge a; a' \\<in> get_return_edges a;\n        sourcenode a = parent_node n\\<^sub>1;\n        targetnode a = parent_node n\\<^sub>2;\n        sourcenode a' = parent_node n\\<^sub>3;\n        targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "thus ?case"], ["proof (prove)\nusing this:\n  n\\<^sub>0 is-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4", "by blast"], ["proof (state)\nthis:\n  \\<exists>ns'. n\\<^sub>0 is-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'. n is-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_SDG_path_matched:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\" obtains ns' where \"matched n ns' n'\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>matched n ns' n'; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns'. matched n ns' n' \\<and> set ns \\<subseteq> set ns'", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'", "show \"\\<exists>ns'. matched n ns' n' \\<and> set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. matched n ns' n' \\<and> set ns \\<subseteq> set ns'", "proof(induct rule:intra_sum_SDG_path.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. matched n ns' n \\<and> set [] \\<subseteq> set ns'\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (isSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. matched n ns' n \\<and> set [] \\<subseteq> set ns'\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"matched n [] n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. matched n [] n", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n [] n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. matched n ns' n \\<and> set [] \\<subseteq> set ns'\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "thus ?case"], ["proof (prove)\nusing this:\n  matched n [] n\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. matched n ns' n \\<and> set [] \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'. matched n ns' n \\<and> set [] \\<subseteq> set ns'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (isSp_Append_cdep n ns n'' n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"matched n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>matched n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  matched n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"n'' i-[]@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:intra_SDG_path.intros sum_SDG_edge_valid_SDG_node \n                        sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>matched n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  matched n ns' n''\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "have \"matched n (ns'@[n'']) n'\""], ["proof (prove)\nusing this:\n  matched n ns' n''\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. matched n (ns' @ [n'']) n'", "by(fastforce intro!:matched_Append_intra_SDG_path)"], ["proof (state)\nthis:\n  matched n (ns' @ [n'']) n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  matched n (ns' @ [n'']) n'", "show ?case"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  matched n (ns' @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       matched n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'. matched n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (isSp_Append_ddep n ns n'' V n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"matched n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>matched n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  matched n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>n'' \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'", "have \"n'' i-[]@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (1 subgoal):\n 1. n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:intra_SDG_path.intros sum_SDG_edge_valid_SDG_node \n                        sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>matched n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  matched n ns' n''\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "have \"matched n (ns'@[n'']) n'\""], ["proof (prove)\nusing this:\n  matched n ns' n''\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. matched n (ns' @ [n'']) n'", "by(fastforce intro!:matched_Append_intra_SDG_path)"], ["proof (state)\nthis:\n  matched n (ns' @ [n'']) n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  matched n (ns' @ [n'']) n'", "show ?case"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  matched n (ns' @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       matched n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'. matched n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (isSp_Append_sum n ns n'' p n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"matched n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>matched n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  matched n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "obtain ns'' where \"matched n'' ns'' n'\" and \"n'' \\<in> set ns''\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        \\<lbrakk>matched n'' ns'' n'; n'' \\<in> set ns''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule sum_SDG_summary_edge_matched)"], ["proof (state)\nthis:\n  matched n'' ns'' n'\n  n'' \\<in> set ns''\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>matched n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  matched n ns' n''\n  matched n'' ns'' n'\n  n'' \\<in> set ns''", "have \"matched n (ns'@ns'') n'\""], ["proof (prove)\nusing this:\n  matched n ns' n''\n  matched n'' ns'' n'\n  n'' \\<in> set ns''\n\ngoal (1 subgoal):\n 1. matched n (ns' @ ns'') n'", "by -(rule matched_Append)"], ["proof (state)\nthis:\n  matched n (ns' @ ns'') n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'. matched n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            matched n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close> \\<open>n'' \\<in> set ns''\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  n'' \\<in> set ns''\n  matched n (ns' @ ns'') n'", "show ?case"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  n'' \\<in> set ns''\n  matched n (ns' @ ns'') n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       matched n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'. matched n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'. matched n ns' n' \\<and> set ns \\<subseteq> set ns'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_SDG_path_intra_CFG_path:\n  assumes \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'", "show \"\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(induct rule:intra_sum_SDG_path.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"parent_node n -[]\\<rightarrow>* parent_node n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. parent_node n -[]\\<rightarrow>* parent_node n", "by(fastforce intro:empty_path valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  parent_node n -[]\\<rightarrow>* parent_node n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>as.\n          parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -[]\\<rightarrow>* parent_node n\n\ngoal (1 subgoal):\n 1. \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "by(auto simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Append_cdep n ns n'' n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\""], ["proof (prove)\nusing this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "by(rule sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  n'' \\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "proof(rule cdep_edge_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"parent_node n'' controls parent_node n'\""], ["proof (state)\nthis:\n  parent_node n'' controls parent_node n'\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  parent_node n'' controls parent_node n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" and \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  parent_node n'' controls parent_node n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>parent_node\n                  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         as' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule control_dependence_path)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (3 subgoals):\n 1. parent_node n'' controls parent_node n' \\<Longrightarrow>\n    \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 3. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "fix a Q r p fs a'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \"a' \\<in> get_return_edges a\"\n        and \"parent_node n'' = targetnode a\" and \"parent_node n' = sourcenode a'\""], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = targetnode a\"\n        and \"targetnode a'' = sourcenode a'\" and \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = targetnode a;\n         targetnode a'' = sourcenode a';\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:intra_proc_additional_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "hence \"targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  sourcenode a'' = targetnode a\n  targetnode a'' = sourcenode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "by(fastforce dest:path_edge simp:intra_path_def intra_kind_def)"], ["proof (state)\nthis:\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n'' = targetnode a\\<close> \\<open>parent_node n' = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "have \"\\<exists>as'. parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and> as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  parent_node n'' = targetnode a\n  parent_node n' = sourcenode a'\n  targetnode a -[a'']\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       parent_node\n        n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n       as' \\<noteq> []", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" and \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<and>\n     as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>parent_node\n                  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         as' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; parent_node n'' = targetnode a;\n        parent_node n' = sourcenode a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "assume \"n'' = CFG_node m\" and \"m = parent_node n'\""], ["proof (state)\nthis:\n  n'' = CFG_node m\n  m = parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n'' = CFG_node m; m = parent_node n';\n        n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' = CFG_node m\n  m = parent_node n'", "show ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' = CFG_node m\n  m = parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Append_ddep n ns n'' V n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "have \"n'' influences V in n'\""], ["proof (prove)\nusing this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. n'' influences V in n'", "by(fastforce elim:sum_SDG_edge.cases)"], ["proof (state)\nthis:\n  n'' influences V in n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  n'' influences V in n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n'' influences V in n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n         n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:data_dependence_def)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by -(rule intra_path_Append)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "case (isSp_Append_sum n ns n'' p n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>\\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "obtain ns' where \"matched n'' ns' n'\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        matched n'' ns' n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule sum_SDG_summary_edge_matched)"], ["proof (state)\nthis:\n  matched n'' ns' n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "then"], ["proof (chain)\npicking this:\n  matched n'' ns' n'", "obtain as' where \"parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  matched n'' ns' n'\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        parent_node\n         n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n         n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule matched_intra_CFG_path)"], ["proof (state)\nthis:\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n -as@as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node n'' -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by(fastforce intro:path_Append simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>as.\n           parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            parent_node\n                             n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'", "thus ?case"], ["proof (prove)\nusing this:\n  parent_node n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>SDG paths without return edges\\<close>"], ["", "inductive intra_call_sum_SDG_path ::\n  \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n(\"_ ics-_\\<rightarrow>\\<^sub>d* _\" [51,0,0] 80)\nwhere icsSp_Nil:\n  \"valid_SDG_node n \\<Longrightarrow> n ics-[]\\<rightarrow>\\<^sub>d* n\"\n\n  | icsSp_Append_cdep:\n  \"\\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''; n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n ics-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | icsSp_Append_ddep:\n  \"\\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''; n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk> \\<Longrightarrow> n ics-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | icsSp_Append_sum:\n  \"\\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''; n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n ics-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | icsSp_Append_call:\n  \"\\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''; n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n ics-ns@[n'']\\<rightarrow>\\<^sub>d* n'\"\n\n  | icsSp_Append_param_in:\n  \"\\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''; n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk> \\<Longrightarrow> n ics-ns@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["", "lemma ics_SDG_path_valid_SDG_node:\n  assumes \"n ics-ns\\<rightarrow>\\<^sub>d* n'\" shows \"valid_SDG_node n\" and \"valid_SDG_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "using \\<open>n ics-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "by(induct rule:intra_call_sum_SDG_path.induct,\n   auto intro:sum_SDG_edge_valid_SDG_node valid_SDG_CFG_node)"], ["", "lemma ics_SDG_path_Append:\n  \"\\<lbrakk>n'' ics-ns'\\<rightarrow>\\<^sub>d* n'; n ics-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk> \\<Longrightarrow> n ics-ns@ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' ics-ns'\\<rightarrow>\\<^sub>d* n';\n     n ics-ns\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n    \\<Longrightarrow> n ics-ns @ ns'\\<rightarrow>\\<^sub>d* n'", "by(induct rule:intra_call_sum_SDG_path.induct,\n   auto intro:intra_call_sum_SDG_path.intros simp:append_assoc[THEN sym] \n                                        simp del:append_assoc)"], ["", "lemma is_SDG_path_ics_SDG_path:\n  \"n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n ics-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n ics-ns\\<rightarrow>\\<^sub>d* n'", "by(induct rule:intra_sum_SDG_path.induct,auto intro:intra_call_sum_SDG_path.intros)"], ["", "lemma cc_SDG_path_ics_SDG_path:\n  \"n cc-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n ics-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n cc-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n ics-ns\\<rightarrow>\\<^sub>d* n'", "by(induct rule:call_cdep_SDG_path.induct,\n  auto intro:intra_call_sum_SDG_path.intros SDG_edge_sum_SDG_edge)"], ["", "lemma ics_SDG_path_split:\n  assumes \"n ics-ns\\<rightarrow>\\<^sub>d* n'\" and \"n'' \\<in> set ns\" \n  obtains ns' ns'' where \"ns = ns'@ns''\" and \"n ics-ns'\\<rightarrow>\\<^sub>d* n''\" \n  and \"n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>ns = ns' @ ns''; n ics-ns'\\<rightarrow>\\<^sub>d* n'';\n         n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n ics-ns\\<rightarrow>\\<^sub>d* n'\\<close> \\<open>n'' \\<in> set ns\\<close>"], ["proof (chain)\npicking this:\n  n ics-ns\\<rightarrow>\\<^sub>d* n'\n  n'' \\<in> set ns", "show \"\\<exists>ns' ns''. ns = ns'@ns'' \\<and> n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and> n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* n'\n  n'' \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "proof(induct rule:intra_call_sum_SDG_path.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_SDG_node n; n'' \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            [] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n\n 2. \\<And>n ns n''a n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 5. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 6. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "case icsSp_Nil"], ["proof (state)\nthis:\n  valid_SDG_node n_\n  n'' \\<in> set []\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_SDG_node n; n'' \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            [] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n\n 2. \\<And>n ns n''a n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 5. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 6. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "thus ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n_\n  n'' \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       [] = ns' @ ns'' \\<and>\n       n_ ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n_", "by simp"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     [] = ns' @ ns'' \\<and>\n     n_ ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n_\n\ngoal (5 subgoals):\n 1. \\<And>n ns n''a n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 5. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n ns n''a n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 5. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "case (icsSp_Append_cdep n ns nx n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  n'' \\<in> set (ns @ [nx])\n\ngoal (5 subgoals):\n 1. \\<And>n ns n''a n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 5. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "note IH = \\<open>n'' \\<in> set ns \\<Longrightarrow>\n      \\<exists>ns' ns''. ns = ns' @ ns'' \\<and> n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and> n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close>"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (5 subgoals):\n 1. \\<And>n ns n''a n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 5. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' \\<in> set (ns@[nx])\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<in> set (ns @ [nx])", "have \"n'' \\<in> set ns \\<or> n'' = nx\""], ["proof (prove)\nusing this:\n  n'' \\<in> set (ns @ [nx])\n\ngoal (1 subgoal):\n 1. n'' \\<in> set ns \\<or> n'' = nx", "by fastforce"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (5 subgoals):\n 1. \\<And>n ns n''a n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 5. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' \\<in> set ns\""], ["proof (state)\nthis:\n  n'' \\<in> set ns\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx", "obtain ns' ns'' where \"ns = ns' @ ns''\"\n        and \"n ics-ns'\\<rightarrow>\\<^sub>d* n''\" and \"n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>ns = ns' @ ns''; n ics-ns'\\<rightarrow>\\<^sub>d* n'';\n         n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"n'' ics-ns''@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "by(rule intra_call_sum_SDG_path.icsSp_Append_cdep)"], ["proof (state)\nthis:\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>ns = ns'@ns''\\<close> \\<open>n ics-ns'\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' = nx\""], ["proof (state)\nthis:\n  n'' = nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"nx ics-[]\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. nx ics-[]\\<rightarrow>\\<^sub>d* nx", "by(fastforce intro:icsSp_Nil SDG_edge_valid_SDG_node sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx", "have \"nx ics-[]@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "by -(rule intra_call_sum_SDG_path.icsSp_Append_cdep)"], ["proof (state)\nthis:\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>n ics-ns\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n'' = nx\\<close>"], ["proof (chain)\npicking this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (4 subgoals):\n 1. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "case (icsSp_Append_ddep n ns nx V n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  n'' \\<in> set (ns @ [nx])\n\ngoal (4 subgoals):\n 1. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "note IH = \\<open>n'' \\<in> set ns \\<Longrightarrow>\n      \\<exists>ns' ns''. ns = ns' @ ns'' \\<and> n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and> n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close>"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (4 subgoals):\n 1. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' \\<in> set (ns@[nx])\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<in> set (ns @ [nx])", "have \"n'' \\<in> set ns \\<or> n'' = nx\""], ["proof (prove)\nusing this:\n  n'' \\<in> set (ns @ [nx])\n\ngoal (1 subgoal):\n 1. n'' \\<in> set ns \\<or> n'' = nx", "by fastforce"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (4 subgoals):\n 1. \\<And>n ns n''a V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n''a \\<noteq> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' \\<in> set ns\""], ["proof (state)\nthis:\n  n'' \\<in> set ns\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx", "obtain ns' ns'' where \"ns = ns' @ ns''\"\n        and \"n ics-ns'\\<rightarrow>\\<^sub>d* n''\" and \"n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>ns = ns' @ ns''; n ics-ns'\\<rightarrow>\\<^sub>d* n'';\n         n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>nx \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'", "have \"n'' ics-ns''@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n\ngoal (1 subgoal):\n 1. n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "by(rule intra_call_sum_SDG_path.icsSp_Append_ddep)"], ["proof (state)\nthis:\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>ns = ns'@ns''\\<close> \\<open>n ics-ns'\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' = nx\""], ["proof (state)\nthis:\n  n'' = nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "have \"nx ics-[]\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. nx ics-[]\\<rightarrow>\\<^sub>d* nx", "by(fastforce intro:icsSp_Nil SDG_edge_valid_SDG_node sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>nx \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx", "have \"nx ics-[]@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "by -(rule intra_call_sum_SDG_path.icsSp_Append_ddep)"], ["proof (state)\nthis:\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>n ics-ns\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n'' = nx\\<close>"], ["proof (chain)\npicking this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "case (icsSp_Append_sum n ns nx p n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n  n'' \\<in> set (ns @ [nx])\n\ngoal (3 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "note IH = \\<open>n'' \\<in> set ns \\<Longrightarrow>\n      \\<exists>ns' ns''. ns = ns' @ ns'' \\<and> n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and> n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close>"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (3 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' \\<in> set (ns@[nx])\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<in> set (ns @ [nx])", "have \"n'' \\<in> set ns \\<or> n'' = nx\""], ["proof (prove)\nusing this:\n  n'' \\<in> set (ns @ [nx])\n\ngoal (1 subgoal):\n 1. n'' \\<in> set ns \\<or> n'' = nx", "by fastforce"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (3 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' \\<in> set ns\""], ["proof (state)\nthis:\n  n'' \\<in> set ns\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx", "obtain ns' ns'' where \"ns = ns' @ ns''\"\n        and \"n ics-ns'\\<rightarrow>\\<^sub>d* n''\" and \"n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>ns = ns' @ ns''; n ics-ns'\\<rightarrow>\\<^sub>d* n'';\n         n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "have \"n'' ics-ns''@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "by(rule intra_call_sum_SDG_path.icsSp_Append_sum)"], ["proof (state)\nthis:\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>ns = ns'@ns''\\<close> \\<open>n ics-ns'\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' = nx\""], ["proof (state)\nthis:\n  n'' = nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "have \"valid_SDG_node nx\""], ["proof (prove)\nusing this:\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node nx", "by(fastforce elim:sum_SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_SDG_node nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "hence \"nx ics-[]\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  valid_SDG_node nx\n\ngoal (1 subgoal):\n 1. nx ics-[]\\<rightarrow>\\<^sub>d* nx", "by(fastforce intro:icsSp_Nil)"], ["proof (state)\nthis:\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx", "have \"nx ics-[]@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "by -(rule intra_call_sum_SDG_path.icsSp_Append_sum)"], ["proof (state)\nthis:\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>n ics-ns\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n'' = nx\\<close>"], ["proof (chain)\npicking this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "case (icsSp_Append_call n ns nx p n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  n'' \\<in> set (ns @ [nx])\n\ngoal (2 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "note IH = \\<open>n'' \\<in> set ns \\<Longrightarrow>\n      \\<exists>ns' ns''. ns = ns' @ ns'' \\<and> n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and> n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close>"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (2 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' \\<in> set (ns@[nx])\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<in> set (ns @ [nx])", "have \"n'' \\<in> set ns \\<or> n'' = nx\""], ["proof (prove)\nusing this:\n  n'' \\<in> set (ns @ [nx])\n\ngoal (1 subgoal):\n 1. n'' \\<in> set ns \\<or> n'' = nx", "by fastforce"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (2 subgoals):\n 1. \\<And>n ns n''a p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' \\<in> set ns\""], ["proof (state)\nthis:\n  n'' \\<in> set ns\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx", "obtain ns' ns'' where \"ns = ns' @ ns''\"\n        and \"n ics-ns'\\<rightarrow>\\<^sub>d* n''\" and \"n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>ns = ns' @ ns''; n ics-ns'\\<rightarrow>\\<^sub>d* n'';\n         n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'", "have \"n'' ics-ns''@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "by(rule intra_call_sum_SDG_path.icsSp_Append_call)"], ["proof (state)\nthis:\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>ns = ns'@ns''\\<close> \\<open>n ics-ns'\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' = nx\""], ["proof (state)\nthis:\n  n'' = nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'", "have \"nx ics-[]\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n\ngoal (1 subgoal):\n 1. nx ics-[]\\<rightarrow>\\<^sub>d* nx", "by(fastforce intro:icsSp_Nil SDG_edge_valid_SDG_node sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx", "have \"nx ics-[]@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "by -(rule intra_call_sum_SDG_path.icsSp_Append_call)"], ["proof (state)\nthis:\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>n ics-ns\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n'' = nx\\<close>"], ["proof (chain)\npicking this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "case (icsSp_Append_param_in n ns nx p V n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  n'' \\<in> set (ns @ [nx])\n\ngoal (1 subgoal):\n 1. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "note IH = \\<open>n'' \\<in> set ns \\<Longrightarrow>\n      \\<exists>ns' ns''. ns = ns' @ ns'' \\<and> n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and> n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close>"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<Longrightarrow>\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' \\<in> set (ns@[nx])\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<in> set (ns @ [nx])", "have \"n'' \\<in> set ns \\<or> n'' = nx\""], ["proof (prove)\nusing this:\n  n'' \\<in> set (ns @ [nx])\n\ngoal (1 subgoal):\n 1. n'' \\<in> set ns \\<or> n'' = nx", "by fastforce"], ["proof (state)\nthis:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (1 subgoal):\n 1. \\<And>n ns n''a p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n''a;\n        n'' \\<in> set ns \\<Longrightarrow>\n        \\<exists>ns' ns''.\n           ns = ns' @ ns'' \\<and>\n           n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n           n'' ics-ns''\\<rightarrow>\\<^sub>d* n''a;\n        n''a s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n'' \\<in> set (ns @ [n''a])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns' ns''.\n                            ns @ [n''a] = ns' @ ns'' \\<and>\n                            n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n                            n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "thus ?case"], ["proof (prove)\nusing this:\n  n'' \\<in> set ns \\<or> n'' = nx\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' \\<in> set ns\""], ["proof (state)\nthis:\n  n'' \\<in> set ns\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx", "obtain ns' ns'' where \"ns = ns' @ ns''\"\n        and \"n ics-ns'\\<rightarrow>\\<^sub>d* n''\" and \"n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        \\<lbrakk>ns = ns' @ ns''; n ics-ns'\\<rightarrow>\\<^sub>d* n'';\n         n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'", "have \"n'' ics-ns''@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' ics-ns''\\<rightarrow>\\<^sub>d* nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "by(rule intra_call_sum_SDG_path.icsSp_Append_param_in)"], ["proof (state)\nthis:\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' \\<in> set ns \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n 2. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>ns = ns'@ns''\\<close> \\<open>n ics-ns'\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = ns' @ ns''\n  n ics-ns'\\<rightarrow>\\<^sub>d* n''\n  n'' ics-ns'' @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "assume \"n'' = nx\""], ["proof (state)\nthis:\n  n'' = nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "from \\<open>nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'", "have \"nx ics-[]\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n\ngoal (1 subgoal):\n 1. nx ics-[]\\<rightarrow>\\<^sub>d* nx", "by(fastforce intro:icsSp_Nil SDG_edge_valid_SDG_node sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx", "have \"nx ics-[]@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  nx ics-[]\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "by -(rule intra_call_sum_SDG_path.icsSp_Append_param_in)"], ["proof (state)\nthis:\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n'' = nx \\<Longrightarrow>\n    \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "with \\<open>n ics-ns\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n'' = nx\\<close>"], ["proof (chain)\npicking this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* nx\n  n'' = nx\n  nx ics-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns' ns''.\n       ns @ [nx] = ns' @ ns'' \\<and>\n       n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n       n'' ics-ns''\\<rightarrow>\\<^sub>d* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns @ [nx] = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns' ns''.\n     ns = ns' @ ns'' \\<and>\n     n ics-ns'\\<rightarrow>\\<^sub>d* n'' \\<and>\n     n'' ics-ns''\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma realizable_ics_SDG_path:\n  assumes \"realizable n ns n'\" obtains ns' where \"n ics-ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        n ics-ns'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'", "from \\<open>realizable n ns n'\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns n'", "show \"\\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  realizable n ns n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'", "proof(induct rule:realizable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'.\n       matched n ns n' \\<Longrightarrow>\n       \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "case (realizable_matched n ns n')"], ["proof (state)\nthis:\n  matched n ns n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'.\n       matched n ns n' \\<Longrightarrow>\n       \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "from \\<open>matched n ns n'\\<close>"], ["proof (chain)\npicking this:\n  matched n ns n'", "obtain ns' where \"n is-ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  matched n ns n'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        n is-ns'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule matched_is_SDG_path)"], ["proof (state)\nthis:\n  n is-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'.\n       matched n ns n' \\<Longrightarrow>\n       \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "thus ?case"], ["proof (prove)\nusing this:\n  n is-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:is_SDG_path_ics_SDG_path)"], ["proof (state)\nthis:\n  \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "case (realizable_call n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3)"], ["proof (state)\nthis:\n  realizable n\\<^sub>0 ns n\\<^sub>1\n  \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  matched n\\<^sub>2 ns' n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "from \\<open>\\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1", "obtain nsx where \"n\\<^sub>0 ics-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        n\\<^sub>0 ics-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n\\<^sub>0 ics-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "with \\<open>n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or> n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  n\\<^sub>0 ics-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1", "have \"n\\<^sub>0 ics-nsx@[n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>2\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n  n\\<^sub>0 ics-nsx\\<rightarrow>\\<^sub>d* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 ics-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>2", "by(fastforce intro:SDG_edge_sum_SDG_edge icsSp_Append_call icsSp_Append_param_in)"], ["proof (state)\nthis:\n  n\\<^sub>0 ics-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "from \\<open>matched n\\<^sub>2 ns' n\\<^sub>3\\<close>"], ["proof (chain)\npicking this:\n  matched n\\<^sub>2 ns' n\\<^sub>3", "obtain nsx' where \"n\\<^sub>2 is-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\""], ["proof (prove)\nusing this:\n  matched n\\<^sub>2 ns' n\\<^sub>3\n\ngoal (1 subgoal):\n 1. (\\<And>nsx'.\n        n\\<^sub>2 is-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule matched_is_SDG_path)"], ["proof (state)\nthis:\n  n\\<^sub>2 is-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "hence \"n\\<^sub>2 ics-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\""], ["proof (prove)\nusing this:\n  n\\<^sub>2 is-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n\ngoal (1 subgoal):\n 1. n\\<^sub>2 ics-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "by(rule is_SDG_path_ics_SDG_path)"], ["proof (state)\nthis:\n  n\\<^sub>2 ics-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "from \\<open>n\\<^sub>2 ics-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\\<close> \\<open>n\\<^sub>0 ics-nsx@[n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>2 ics-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n  n\\<^sub>0 ics-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>2", "have \"n\\<^sub>0 ics-(nsx@[n\\<^sub>1])@nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\""], ["proof (prove)\nusing this:\n  n\\<^sub>2 ics-nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n  n\\<^sub>0 ics-nsx @ [n\\<^sub>1]\\<rightarrow>\\<^sub>d* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 ics-(nsx @ [n\\<^sub>1]) @ nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "by(rule ics_SDG_path_Append)"], ["proof (state)\nthis:\n  n\\<^sub>0 ics-(nsx @ [n\\<^sub>1]) @ nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0 ns n\\<^sub>1 p n\\<^sub>2 V ns' n\\<^sub>3.\n       \\<lbrakk>realizable n\\<^sub>0 ns n\\<^sub>1;\n        \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>1;\n        n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n        n\\<^sub>1 -p:V\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2;\n        matched n\\<^sub>2 ns' n\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "thus ?case"], ["proof (prove)\nusing this:\n  n\\<^sub>0 ics-(nsx @ [n\\<^sub>1]) @ nsx'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3", "by blast"], ["proof (state)\nthis:\n  \\<exists>ns'. n\\<^sub>0 ics-ns'\\<rightarrow>\\<^sub>d* n\\<^sub>3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'. n ics-ns'\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ics_SDG_path_realizable:\n  assumes \"n ics-ns\\<rightarrow>\\<^sub>d* n'\" \n  obtains ns' where \"realizable n ns' n'\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>realizable n ns' n'; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns'. realizable n ns' n' \\<and> set ns \\<subseteq> set ns'", "from \\<open>n ics-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n ics-ns\\<rightarrow>\\<^sub>d* n'", "show \"\\<exists>ns'. realizable n ns' n' \\<and> set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  n ics-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. realizable n ns' n' \\<and> set ns \\<subseteq> set ns'", "proof(induct rule:intra_call_sum_SDG_path.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. realizable n ns' n \\<and> set [] \\<subseteq> set ns'\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 6. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (icsSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. realizable n ns' n \\<and> set [] \\<subseteq> set ns'\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 6. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"matched n [] n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. matched n [] n", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n [] n\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       \\<exists>ns'. realizable n ns' n \\<and> set [] \\<subseteq> set ns'\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 6. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "thus ?case"], ["proof (prove)\nusing this:\n  matched n [] n\n\ngoal (1 subgoal):\n 1. \\<exists>ns'. realizable n ns' n \\<and> set [] \\<subseteq> set ns'", "by(fastforce intro:realizable_matched)"], ["proof (state)\nthis:\n  \\<exists>ns'. realizable n ns' n \\<and> set [] \\<subseteq> set ns'\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (icsSp_Append_cdep n ns n'' n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"realizable n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>realizable n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  realizable n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"valid_SDG_node n''\""], ["proof (prove)\nusing this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n''", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n''\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"n'' i-[]\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  valid_SDG_node n''\n\ngoal (1 subgoal):\n 1. n'' i-[]\\<rightarrow>\\<^sub>d* n''", "by(rule iSp_Nil)"], ["proof (state)\nthis:\n  n'' i-[]\\<rightarrow>\\<^sub>d* n''\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  n'' i-[]\\<rightarrow>\\<^sub>d* n''", "have \"n'' i-[]@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  n'' i-[]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce elim:iSp_Append_cdep sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"matched n'' [n''] n'\""], ["proof (prove)\nusing this:\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. matched n'' [n''] n'", "by(fastforce intro:intra_SDG_path_matched)"], ["proof (state)\nthis:\n  matched n'' [n''] n'\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>realizable n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns' n''\n  matched n'' [n''] n'", "have \"realizable n (ns'@[n'']) n'\""], ["proof (prove)\nusing this:\n  realizable n ns' n''\n  matched n'' [n''] n'\n\ngoal (1 subgoal):\n 1. realizable n (ns' @ [n'']) n'", "by(rule realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n (ns' @ [n'']) n'\n\ngoal (5 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 5. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'", "show ?case"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (icsSp_Append_ddep n ns n'' V n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"realizable n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>realizable n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  realizable n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "have \"valid_SDG_node n''\""], ["proof (prove)\nusing this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n''", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n''\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"n'' i-[]\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  valid_SDG_node n''\n\ngoal (1 subgoal):\n 1. n'' i-[]\\<rightarrow>\\<^sub>d* n''", "by(rule iSp_Nil)"], ["proof (state)\nthis:\n  n'' i-[]\\<rightarrow>\\<^sub>d* n''\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>n'' \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n  n'' i-[]\\<rightarrow>\\<^sub>d* n''", "have \"n'' i-[]@[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n  n'' i-[]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce elim:iSp_Append_ddep sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"matched n'' [n''] n'\""], ["proof (prove)\nusing this:\n  n'' i-[] @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. matched n'' [n''] n'", "by(fastforce intro:intra_SDG_path_matched)"], ["proof (state)\nthis:\n  matched n'' [n''] n'\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>realizable n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns' n''\n  matched n'' [n''] n'", "have \"realizable n (ns'@[n'']) n'\""], ["proof (prove)\nusing this:\n  realizable n ns' n''\n  matched n'' [n''] n'\n\ngoal (1 subgoal):\n 1. realizable n (ns' @ [n'']) n'", "by(fastforce intro:realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n (ns' @ [n'']) n'\n\ngoal (4 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 4. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'", "show ?case"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (icsSp_Append_sum n ns n'' p n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"realizable n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>realizable n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  realizable n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 3. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "show ?case"], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "proof(rule sum_edge_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "fix a Q r fs a'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "assume \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a' \\<in> get_return_edges a\"\n        and \"n'' = CFG_node (sourcenode a)\" and \"n' = CFG_node (targetnode a')\""], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  n'' = CFG_node (sourcenode a)\n  n' = CFG_node (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "have match':\"matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n        (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n     (CFG_node (sourcenode a'))", "by(rule intra_proc_matched)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n   (CFG_node (sourcenode a'))\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>n'' = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n'' = CFG_node (sourcenode a)", "have \"n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n'' = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)", "by(fastforce intro:SDG_call_edge)"], ["proof (state)\nthis:\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"matched n'' [] n''\""], ["proof (prove)\nusing this:\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. matched n'' [] n''", "by(fastforce intro:matched_Nil SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  matched n'' [] n''\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>n' = CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n' = CFG_node (targetnode a')", "have \"CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n' = CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'", "by(fastforce intro:SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>matched n'' [] n''\\<close> \\<open>n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\\<close>\n        match' \\<open>CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\\<close> \\<open>valid_edge a\\<close> \n        \\<open>a' \\<in> get_return_edges a\\<close> \\<open>n' = CFG_node (targetnode a')\\<close> \n        \\<open>n'' = CFG_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  matched n'' [] n''\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n  matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n   (CFG_node (sourcenode a'))\n  CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\n  valid_edge a\n  a' \\<in> get_return_edges a\n  n' = CFG_node (targetnode a')\n  n'' = CFG_node (sourcenode a)", "have \"matched n'' ([]@n''#[CFG_node (targetnode a)]@[CFG_node (sourcenode a')])\n        n'\""], ["proof (prove)\nusing this:\n  matched n'' [] n''\n  n'' -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a)\n  matched (CFG_node (targetnode a)) [CFG_node (targetnode a)]\n   (CFG_node (sourcenode a'))\n  CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>ret\\<^esub> n'\n  valid_edge a\n  a' \\<in> get_return_edges a\n  n' = CFG_node (targetnode a')\n  n'' = CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. matched n''\n     ([] @ n'' # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'", "by(fastforce intro:matched_bracket_call)"], ["proof (state)\nthis:\n  matched n''\n   ([] @ n'' # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>realizable n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns' n''\n  matched n''\n   ([] @ n'' # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'", "have \"realizable n \n        (ns'@(n''#[CFG_node (targetnode a),CFG_node (sourcenode a')])) n'\""], ["proof (prove)\nusing this:\n  realizable n ns' n''\n  matched n''\n   ([] @ n'' # [CFG_node (targetnode a)] @ [CFG_node (sourcenode a')]) n'\n\ngoal (1 subgoal):\n 1. realizable n\n     (ns' @ [n'', CFG_node (targetnode a), CFG_node (sourcenode a')]) n'", "by(fastforce intro:realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n\n   (ns' @ [n'', CFG_node (targetnode a), CFG_node (sourcenode a')]) n'\n\ngoal (2 subgoals):\n 1. \\<And>a Q r fs a'.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a; n'' = CFG_node (sourcenode a);\n        n' = CFG_node (targetnode a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  realizable n\n   (ns' @ [n'', CFG_node (targetnode a), CFG_node (sourcenode a')]) n'", "show ?thesis"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  realizable n\n   (ns' @ [n'', CFG_node (targetnode a), CFG_node (sourcenode a')]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "fix a Q r p fs a' ns'' x x' ins outs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "assume \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a' \\<in> get_return_edges a\"\n        and match':\"matched (Formal_in (targetnode a,x)) ns'' \n                            (Formal_out (sourcenode a',x'))\"\n        and \"n'' = Actual_in (sourcenode a,x)\" \n        and \"n' = Actual_out (targetnode a',x')\" and \"(p,ins,outs) \\<in> set procs\" \n        and \"x < length ins\" and \"x' < length outs\""], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n  matched (Formal_in (targetnode a, x)) ns''\n   (Formal_out (sourcenode a', x'))\n  n'' = Actual_in (sourcenode a, x)\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n  x' < length outs\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>n'' = Actual_in (sourcenode a,x)\\<close>\n        \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>x < length ins\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n'' = Actual_in (sourcenode a, x)\n  (p, ins, outs) \\<in> set procs\n  x < length ins", "have \"n'' -p:ins!x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a,x)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  n'' = Actual_in (sourcenode a, x)\n  (p, ins, outs) \\<in> set procs\n  x < length ins\n\ngoal (1 subgoal):\n 1. n'' -p:ins !\n           x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)", "by(fastforce intro!:SDG_param_in_edge)"], ["proof (state)\nthis:\n  n'' -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"matched n'' [] n''\""], ["proof (prove)\nusing this:\n  n'' -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n\ngoal (1 subgoal):\n 1. matched n'' [] n''", "by(fastforce intro:matched_Nil SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  matched n'' [] n''\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>n' = Actual_out (targetnode a',x')\\<close>\n        \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>x' < length outs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x' < length outs", "have \"Formal_out (sourcenode a',x') -p:outs!x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  n' = Actual_out (targetnode a', x')\n  (p, ins, outs) \\<in> set procs\n  x' < length outs\n\ngoal (1 subgoal):\n 1. Formal_out\n     (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'", "by(fastforce intro:SDG_param_out_edge)"], ["proof (state)\nthis:\n  Formal_out\n   (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>matched n'' [] n''\\<close> \\<open>n'' -p:ins!x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a,x)\\<close>\n        match' \\<open>Formal_out (sourcenode a',x') -p:outs!x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close> \\<open>valid_edge a\\<close> \n        \\<open>a' \\<in> get_return_edges a\\<close> \\<open>n' = Actual_out (targetnode a',x')\\<close>\n        \\<open>n'' = Actual_in (sourcenode a,x)\\<close>"], ["proof (chain)\npicking this:\n  matched n'' [] n''\n  n'' -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n  matched (Formal_in (targetnode a, x)) ns''\n   (Formal_out (sourcenode a', x'))\n  Formal_out\n   (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  valid_edge a\n  a' \\<in> get_return_edges a\n  n' = Actual_out (targetnode a', x')\n  n'' = Actual_in (sourcenode a, x)", "have \"matched n'' ([]@n''#ns''@[Formal_out (sourcenode a',x')]) n'\""], ["proof (prove)\nusing this:\n  matched n'' [] n''\n  n'' -p:ins ! x\\<rightarrow>\\<^bsub>in\\<^esub> Formal_in (targetnode a, x)\n  matched (Formal_in (targetnode a, x)) ns''\n   (Formal_out (sourcenode a', x'))\n  Formal_out\n   (sourcenode a', x') -p:outs ! x'\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  valid_edge a\n  a' \\<in> get_return_edges a\n  n' = Actual_out (targetnode a', x')\n  n'' = Actual_in (sourcenode a, x)\n\ngoal (1 subgoal):\n 1. matched n'' ([] @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'", "by(fastforce intro:matched_bracket_param)"], ["proof (state)\nthis:\n  matched n'' ([] @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>realizable n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns' n''\n  matched n'' ([] @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'", "have \"realizable n (ns'@(n''#ns''@[Formal_out (sourcenode a',x')])) n'\""], ["proof (prove)\nusing this:\n  realizable n ns' n''\n  matched n'' ([] @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'\n\ngoal (1 subgoal):\n 1. realizable n (ns' @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'", "by(fastforce intro:realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n (ns' @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q p r fs a' ns x x' ins outs.\n       \\<lbrakk>valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges a;\n        matched (Formal_in (targetnode a, x)) ns\n         (Formal_out (sourcenode a', x'));\n        n'' = Actual_in (sourcenode a, x);\n        n' = Actual_out (targetnode a', x'); (p, ins, outs) \\<in> set procs;\n        x < length ins; x' < length outs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'", "show ?thesis"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ n'' # ns'' @ [Formal_out (sourcenode a', x')]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (icsSp_Append_call n ns n'' p n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"realizable n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>realizable n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  realizable n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"matched n' [] n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. matched n' [] n'", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n' [] n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>realizable n ns' n''\\<close> \\<open>n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns' n''\n  n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  matched n' [] n'", "have \"realizable n (ns'@n''#[]) n'\""], ["proof (prove)\nusing this:\n  realizable n ns' n''\n  n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. realizable n (ns' @ [n'']) n'", "by(fastforce intro:realizable_call sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  realizable n (ns' @ [n'']) n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'\n 2. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'", "show ?case"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "case (icsSp_Append_param_in n ns n'' p V n')"], ["proof (state)\nthis:\n  n ics-ns\\<rightarrow>\\<^sub>d* n''\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n  n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>\\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'", "obtain ns' where \"realizable n ns' n''\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  \\<exists>ns'. realizable n ns' n'' \\<and> set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>realizable n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  realizable n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "from \\<open>n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "hence \"matched n' [] n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. matched n' [] n'", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>realizable n ns' n''\\<close> \\<open>n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  realizable n ns' n''\n  n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  matched n' [] n'", "have \"realizable n (ns'@n''#[]) n'\""], ["proof (prove)\nusing this:\n  realizable n ns' n''\n  n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. realizable n (ns' @ [n'']) n'", "by(fastforce intro:realizable_call sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  realizable n (ns' @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p V n'.\n       \\<lbrakk>n ics-ns\\<rightarrow>\\<^sub>d* n'';\n        \\<exists>ns'.\n           realizable n ns' n'' \\<and> set ns \\<subseteq> set ns';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns'.\n                            realizable n ns' n' \\<and>\n                            set (ns @ [n'']) \\<subseteq> set ns'", "with \\<open>set ns \\<subseteq> set ns'\\<close>"], ["proof (chain)\npicking this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'", "show ?case"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set ns'\n  realizable n (ns' @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable n ns' n' \\<and> set (ns @ [n'']) \\<subseteq> set ns'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns'. realizable n ns' n' \\<and> set ns \\<subseteq> set ns'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma realizable_Append_ics_SDG_path:\n  assumes \"realizable n ns n''\" and \"n'' ics-ns'\\<rightarrow>\\<^sub>d* n'\"\n  obtains ns'' where \"realizable n (ns@ns'') n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        realizable n (ns @ ns'') n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>n'' ics-ns'\\<rightarrow>\\<^sub>d* n'\\<close> \\<open>realizable n ns n''\\<close>"], ["proof (chain)\npicking this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* n'\n  realizable n ns n''", "show \"\\<exists>ns''. realizable n (ns@ns'') n'\""], ["proof (prove)\nusing this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* n'\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n'", "proof(induct rule:intra_call_sum_SDG_path.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>valid_SDG_node na; realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') na\n 2. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 6. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "case (icsSp_Nil n'')"], ["proof (state)\nthis:\n  valid_SDG_node n''\n  realizable n ns n''\n\ngoal (6 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>valid_SDG_node na; realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') na\n 2. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 6. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "thus ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n''\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n''", "by(rule_tac x=\"[]\" in exI) fastforce"], ["proof (state)\nthis:\n  \\<exists>ns''. realizable n (ns @ ns'') n''\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "case (icsSp_Append_cdep n'' ns' nx n')"], ["proof (state)\nthis:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  realizable n ns n''\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "then"], ["proof (chain)\npicking this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  realizable n ns n''", "obtain ns'' where \"realizable n (ns@ns'') nx\""], ["proof (prove)\nusing this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        realizable n (ns @ ns'') nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  realizable n (ns @ ns'') nx\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"valid_SDG_node nx\""], ["proof (prove)\nusing this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node nx", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node nx\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "hence \"matched nx [] nx\""], ["proof (prove)\nusing this:\n  valid_SDG_node nx\n\ngoal (1 subgoal):\n 1. matched nx [] nx", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched nx [] nx\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close> \\<open>valid_SDG_node nx\\<close>"], ["proof (chain)\npicking this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  valid_SDG_node nx", "have \"nx i-[]@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  nx s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n  valid_SDG_node nx\n\ngoal (1 subgoal):\n 1. nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:iSp_Append_cdep iSp_Nil sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "with \\<open>matched nx [] nx\\<close>"], ["proof (chain)\npicking this:\n  matched nx [] nx\n  nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "have \"matched nx ([]@[nx]) n'\""], ["proof (prove)\nusing this:\n  matched nx [] nx\n  nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. matched nx ([] @ [nx]) n'", "by(fastforce intro:matched_Append_intra_SDG_path)"], ["proof (state)\nthis:\n  matched nx ([] @ [nx]) n'\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "with \\<open>realizable n (ns@ns'') nx\\<close>"], ["proof (chain)\npicking this:\n  realizable n (ns @ ns'') nx\n  matched nx ([] @ [nx]) n'", "have \"realizable n ((ns@ns'')@[nx]) n'\""], ["proof (prove)\nusing this:\n  realizable n (ns @ ns'') nx\n  matched nx ([] @ [nx]) n'\n\ngoal (1 subgoal):\n 1. realizable n ((ns @ ns'') @ [nx]) n'", "by(fastforce intro:realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (5 subgoals):\n 1. \\<And>na nsa n'' n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 5. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "thus ?case"], ["proof (prove)\nusing this:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns''. realizable n (ns @ ns'') n'\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "case (icsSp_Append_ddep n'' ns' nx V n')"], ["proof (state)\nthis:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  realizable n ns n''\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "then"], ["proof (chain)\npicking this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  realizable n ns n''", "obtain ns'' where \"realizable n (ns@ns'') nx\""], ["proof (prove)\nusing this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        realizable n (ns @ ns'') nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  realizable n (ns @ ns'') nx\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'", "have \"valid_SDG_node nx\""], ["proof (prove)\nusing this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node nx", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node nx\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "hence \"matched nx [] nx\""], ["proof (prove)\nusing this:\n  valid_SDG_node nx\n\ngoal (1 subgoal):\n 1. matched nx [] nx", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched nx [] nx\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>nx \\<noteq> n'\\<close> \\<open>valid_SDG_node nx\\<close>"], ["proof (chain)\npicking this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  valid_SDG_node nx", "have \"nx i-[]@[nx]\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  nx s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  nx \\<noteq> n'\n  valid_SDG_node nx\n\ngoal (1 subgoal):\n 1. nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:iSp_Append_ddep iSp_Nil sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "with \\<open>matched nx [] nx\\<close>"], ["proof (chain)\npicking this:\n  matched nx [] nx\n  nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'", "have \"matched nx ([]@[nx]) n'\""], ["proof (prove)\nusing this:\n  matched nx [] nx\n  nx i-[] @ [nx]\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. matched nx ([] @ [nx]) n'", "by(fastforce intro:matched_Append_intra_SDG_path)"], ["proof (state)\nthis:\n  matched nx ([] @ [nx]) n'\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "with \\<open>realizable n (ns@ns'') nx\\<close>"], ["proof (chain)\npicking this:\n  realizable n (ns @ ns'') nx\n  matched nx ([] @ [nx]) n'", "have \"realizable n ((ns@ns'')@[nx]) n'\""], ["proof (prove)\nusing this:\n  realizable n (ns @ ns'') nx\n  matched nx ([] @ [nx]) n'\n\ngoal (1 subgoal):\n 1. realizable n ((ns @ ns'') @ [nx]) n'", "by(fastforce intro:realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (4 subgoals):\n 1. \\<And>na nsa n'' V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 4. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "thus ?case"], ["proof (prove)\nusing this:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns''. realizable n (ns @ ns'') n'\n\ngoal (3 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "case (icsSp_Append_sum n'' ns' nx p n')"], ["proof (state)\nthis:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n  realizable n ns n''\n\ngoal (3 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "then"], ["proof (chain)\npicking this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n  realizable n ns n''", "obtain ns'' where \"realizable n (ns@ns'') nx\""], ["proof (prove)\nusing this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        realizable n (ns @ ns'') nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  realizable n (ns @ ns'') nx\n\ngoal (3 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "obtain nsx where \"matched nx nsx n'\""], ["proof (prove)\nusing this:\n  nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        matched nx nsx n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule sum_SDG_summary_edge_matched)"], ["proof (state)\nthis:\n  matched nx nsx n'\n\ngoal (3 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "with \\<open>realizable n (ns@ns'') nx\\<close>"], ["proof (chain)\npicking this:\n  realizable n (ns @ ns'') nx\n  matched nx nsx n'", "have \"realizable n ((ns@ns'')@nsx) n'\""], ["proof (prove)\nusing this:\n  realizable n (ns @ ns'') nx\n  matched nx nsx n'\n\ngoal (1 subgoal):\n 1. realizable n ((ns @ ns'') @ nsx) n'", "by(rule realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable n ((ns @ ns'') @ nsx) n'\n\ngoal (3 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 3. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "thus ?case"], ["proof (prove)\nusing this:\n  realizable n ((ns @ ns'') @ nsx) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns''. realizable n (ns @ ns'') n'\n\ngoal (2 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "case (icsSp_Append_call n'' ns' nx p n')"], ["proof (state)\nthis:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  realizable n ns n''\n\ngoal (2 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "then"], ["proof (chain)\npicking this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  realizable n ns n''", "obtain ns'' where \"realizable n (ns@ns'') nx\""], ["proof (prove)\nusing this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        realizable n (ns @ ns'') nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  realizable n (ns @ ns'') nx\n\ngoal (2 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (2 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "hence \"matched n' [] n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. matched n' [] n'", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n' [] n'\n\ngoal (2 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "with \\<open>realizable n (ns@ns'') nx\\<close> \\<open>nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  matched n' [] n'", "have \"realizable n ((ns@ns'')@[nx]) n'\""], ["proof (prove)\nusing this:\n  realizable n (ns @ ns'') nx\n  nx s-p\\<rightarrow>\\<^bsub>call\\<^esub> n'\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. realizable n ((ns @ ns'') @ [nx]) n'", "by(fastforce intro:realizable_call sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (2 subgoals):\n 1. \\<And>na nsa n'' p n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'\n 2. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "thus ?case"], ["proof (prove)\nusing this:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns''. realizable n (ns @ ns'') n'\n\ngoal (1 subgoal):\n 1. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "case (icsSp_Append_param_in n'' ns' nx p V n')"], ["proof (state)\nthis:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "then"], ["proof (chain)\npicking this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  realizable n ns n''", "obtain ns'' where \"realizable n (ns@ns'') nx\""], ["proof (prove)\nusing this:\n  n'' ics-ns'\\<rightarrow>\\<^sub>d* nx\n  realizable n ns n'' \\<Longrightarrow>\n  \\<exists>ns''. realizable n (ns @ ns'') nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  realizable n ns n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        realizable n (ns @ ns'') nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  realizable n (ns @ ns'') nx\n\ngoal (1 subgoal):\n 1. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "from \\<open>nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'", "have \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n'", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "hence \"matched n' [] n'\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. matched n' [] n'", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "with \\<open>realizable n (ns@ns'') nx\\<close> \\<open>nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  realizable n (ns @ ns'') nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  matched n' [] n'", "have \"realizable n ((ns@ns'')@[nx]) n'\""], ["proof (prove)\nusing this:\n  realizable n (ns @ ns'') nx\n  nx s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n'\n  matched n' [] n'\n\ngoal (1 subgoal):\n 1. realizable n ((ns @ ns'') @ [nx]) n'", "by(fastforce intro:realizable_call sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (1 subgoal):\n 1. \\<And>na nsa n'' p V n'.\n       \\<lbrakk>na ics-nsa\\<rightarrow>\\<^sub>d* n'';\n        realizable n ns na \\<Longrightarrow>\n        \\<exists>ns''. realizable n (ns @ ns'') n'';\n        n'' s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        realizable n ns na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns''. realizable n (ns @ ns'') n'", "thus ?case"], ["proof (prove)\nusing this:\n  realizable n ((ns @ ns'') @ [nx]) n'\n\ngoal (1 subgoal):\n 1. \\<exists>ns''. realizable n (ns @ ns'') n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns''. realizable n (ns @ ns'') n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns''. realizable n (ns @ ns'') n'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>SDG paths without call edges\\<close>"], ["", "inductive intra_return_sum_SDG_path ::\n  \"'node SDG_node \\<Rightarrow> 'node SDG_node list \\<Rightarrow> 'node SDG_node \\<Rightarrow> bool\"\n(\"_ irs-_\\<rightarrow>\\<^sub>d* _\" [51,0,0] 80)\nwhere irsSp_Nil:\n  \"valid_SDG_node n \\<Longrightarrow> n irs-[]\\<rightarrow>\\<^sub>d* n\"\n\n  | irsSp_Cons_cdep:\n  \"\\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n'; n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<rbrakk> \\<Longrightarrow> n irs-n#ns\\<rightarrow>\\<^sub>d* n'\"\n\n  | irsSp_Cons_ddep:\n  \"\\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n'; n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk> \\<Longrightarrow> n irs-n#ns\\<rightarrow>\\<^sub>d* n'\"\n\n  | irsSp_Cons_sum:\n  \"\\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n'; n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk> \\<Longrightarrow> n irs-n#ns\\<rightarrow>\\<^sub>d* n'\"\n\n  | irsSp_Cons_return:\n  \"\\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n'; n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk> \\<Longrightarrow> n irs-n#ns\\<rightarrow>\\<^sub>d* n'\"\n\n  | irsSp_Cons_param_out:\n  \"\\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n'; n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk> \\<Longrightarrow> n irs-n#ns\\<rightarrow>\\<^sub>d* n'\""], ["", "lemma irs_SDG_path_Append:\n  \"\\<lbrakk>n irs-ns\\<rightarrow>\\<^sub>d* n''; n'' irs-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk> \\<Longrightarrow> n irs-ns@ns'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n irs-ns\\<rightarrow>\\<^sub>d* n'';\n     n'' irs-ns'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n    \\<Longrightarrow> n irs-ns @ ns'\\<rightarrow>\\<^sub>d* n'", "by(induct rule:intra_return_sum_SDG_path.induct,\n   auto intro:intra_return_sum_SDG_path.intros)"], ["", "lemma is_SDG_path_irs_SDG_path:\n  \"n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> n irs-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n irs-ns\\<rightarrow>\\<^sub>d* n'", "proof(induct rule:intra_sum_SDG_path.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow> n irs-[]\\<rightarrow>\\<^sub>d* n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "case (isSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (4 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow> n irs-[]\\<rightarrow>\\<^sub>d* n\n 2. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 4. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "show ?case"], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. n irs-[]\\<rightarrow>\\<^sub>d* n", "by(rule irsSp_Nil)"], ["proof (state)\nthis:\n  n irs-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "case (isSp_Append_cdep n ns n'' n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'", "have \"n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:irsSp_Cons_cdep irsSp_Nil sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (3 subgoals):\n 1. \\<And>n ns n'' n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s\\<longrightarrow>\\<^bsub>cd\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 3. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "with \\<open>n irs-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'", "show ?case"], ["proof (prove)\nusing this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(rule irs_SDG_path_Append)"], ["proof (state)\nthis:\n  n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "case (isSp_Append_ddep n ns n'' V n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\\<close> \\<open>n'' \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'", "have \"n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'\n  n'' \\<noteq> n'\n\ngoal (1 subgoal):\n 1. n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:irsSp_Cons_ddep irsSp_Nil sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. \\<And>n ns n'' V n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-V\\<rightarrow>\\<^sub>d\\<^sub>d n'; n'' \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n 2. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "with \\<open>n irs-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'", "show ?case"], ["proof (prove)\nusing this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(rule irs_SDG_path_Append)"], ["proof (state)\nthis:\n  n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "case (isSp_Append_sum n ns n'' p n')"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'", "have \"n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:irsSp_Cons_sum irsSp_Nil sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>n ns n'' p n'.\n       \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n'';\n        n irs-ns\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "with \\<open>n irs-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'", "show ?case"], ["proof (prove)\nusing this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' irs-[n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'", "by(rule irs_SDG_path_Append)"], ["proof (state)\nthis:\n  n irs-ns @ [n'']\\<rightarrow>\\<^sub>d* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irs_SDG_path_split:\n  assumes \"n irs-ns\\<rightarrow>\\<^sub>d* n'\"\n  obtains \"n is-ns\\<rightarrow>\\<^sub>d* n'\"\n  | nsx nsx' nx nx' p where \"ns = nsx@nx#nsx'\" and \"n irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n  and \"nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\" and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow> thesis;\n     \\<And>nsx nx nsx' p nx'.\n        \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n         nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n         nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n irs-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n'", "show \"n is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\""], ["proof (prove)\nusing this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "proof(induct rule:intra_return_sum_SDG_path.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       n is-[]\\<rightarrow>\\<^sub>d* n \\<or>\n       (\\<exists>nsx nx nsx' p nx'.\n           [] = nsx @ nx # nsx' \\<and>\n           n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n           (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n            (\\<exists>V.\n                nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n           nx' is-nsx'\\<rightarrow>\\<^sub>d* n)\n 2. \\<And>n'' ns n' n.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 5. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 6. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "case (irsSp_Nil n)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       n is-[]\\<rightarrow>\\<^sub>d* n \\<or>\n       (\\<exists>nsx nx nsx' p nx'.\n           [] = nsx @ nx # nsx' \\<and>\n           n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n           (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n            (\\<exists>V.\n                nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n           nx' is-nsx'\\<rightarrow>\\<^sub>d* n)\n 2. \\<And>n'' ns n' n.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 5. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 6. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"n is-[]\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. n is-[]\\<rightarrow>\\<^sub>d* n", "by(rule isSp_Nil)"], ["proof (state)\nthis:\n  n is-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (6 subgoals):\n 1. \\<And>n.\n       valid_SDG_node n \\<Longrightarrow>\n       n is-[]\\<rightarrow>\\<^sub>d* n \\<or>\n       (\\<exists>nsx nx nsx' p nx'.\n           [] = nsx @ nx # nsx' \\<and>\n           n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n           (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n            (\\<exists>V.\n                nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n           nx' is-nsx'\\<rightarrow>\\<^sub>d* n)\n 2. \\<And>n'' ns n' n.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 5. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 6. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "thus ?case"], ["proof (prove)\nusing this:\n  n is-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n is-[]\\<rightarrow>\\<^sub>d* n \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        [] = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n)", "by simp"], ["proof (state)\nthis:\n  n is-[]\\<rightarrow>\\<^sub>d* n \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      [] = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n)\n\ngoal (5 subgoals):\n 1. \\<And>n'' ns n' n.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 5. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n'' ns n' n.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 5. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "case (irsSp_Cons_cdep n'' ns n' n)"], ["proof (state)\nthis:\n  n'' irs-ns\\<rightarrow>\\<^sub>d* n'\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n  n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n\ngoal (5 subgoals):\n 1. \\<And>n'' ns n' n.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 5. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or> \n      (\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "show ?case"], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"n'' is-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''", "have \"n is-[]@[n]\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n\ngoal (1 subgoal):\n 1. n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''", "by(fastforce intro:isSp_Append_cdep isSp_Nil sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''", "have \"n is-[n]@ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:is_SDG_path_Append)"], ["proof (state)\nthis:\n  n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "thus ?case"], ["proof (prove)\nusing this:\n  n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by simp"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'", "obtain nsx nsx' nx nx' p where \"ns = nsx@nx#nsx'\" and \"n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n        and \"nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\" and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>nsx nx nsx' p nx'.\n        \\<lbrakk>ns = nsx @ nx # nsx'; n'' irs-nsx\\<rightarrow>\\<^sub>d* nx;\n         nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n         nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = nsx @ nx # nsx'\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''", "have \"n irs-n#nsx\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s\\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n\ngoal (1 subgoal):\n 1. n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "by(rule intra_return_sum_SDG_path.irsSp_Cons_cdep)"], ["proof (state)\nthis:\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>ns = nsx@nx#nsx'\\<close> \\<open>nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\\<close>\n        \\<open>nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  ns = nsx @ nx # nsx'\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "show ?case"], ["proof (prove)\nusing this:\n  ns = nsx @ nx # nsx'\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (4 subgoals):\n 1. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "case (irsSp_Cons_ddep n'' ns n' n V)"], ["proof (state)\nthis:\n  n'' irs-ns\\<rightarrow>\\<^sub>d* n'\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n  n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\n  n \\<noteq> n''\n\ngoal (4 subgoals):\n 1. \\<And>n'' ns n' n V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''; n \\<noteq> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 4. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or> \n      (\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "show ?case"], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"n'' is-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\\<close> \\<open>n \\<noteq> n''\\<close>"], ["proof (chain)\npicking this:\n  n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\n  n \\<noteq> n''", "have \"n is-[]@[n]\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\n  n \\<noteq> n''\n\ngoal (1 subgoal):\n 1. n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''", "by(fastforce intro:isSp_Append_ddep isSp_Nil sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''", "have \"n is-[n]@ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:is_SDG_path_Append)"], ["proof (state)\nthis:\n  n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "thus ?case"], ["proof (prove)\nusing this:\n  n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by simp"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"\\<exists>nsx nx nsx' p nx'.  ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'", "obtain nsx nsx' nx nx' p where \"ns = nsx@nx#nsx'\" and \"n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n        and \"nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\" and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>nsx nx nsx' p nx'.\n        \\<lbrakk>ns = nsx @ nx # nsx'; n'' irs-nsx\\<rightarrow>\\<^sub>d* nx;\n         nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n         nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = nsx @ nx # nsx'\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\\<close> \\<open>n \\<noteq> n''\\<close>"], ["proof (chain)\npicking this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\n  n \\<noteq> n''", "have \"n irs-n#nsx\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-V\\<rightarrow>\\<^sub>d\\<^sub>d n''\n  n \\<noteq> n''\n\ngoal (1 subgoal):\n 1. n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "by(rule intra_return_sum_SDG_path.irsSp_Cons_ddep)"], ["proof (state)\nthis:\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>ns = nsx@nx#nsx'\\<close> \\<open>nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\\<close>\n        \\<open>nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  ns = nsx @ nx # nsx'\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "show ?case"], ["proof (prove)\nusing this:\n  ns = nsx @ nx # nsx'\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (3 subgoals):\n 1. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "case (irsSp_Cons_sum n'' ns n' n p)"], ["proof (state)\nthis:\n  n'' irs-ns\\<rightarrow>\\<^sub>d* n'\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\n\ngoal (3 subgoals):\n 1. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 3. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or> \n      (\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "show ?case"], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"n'' is-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''", "have \"n is-[]@[n]\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\n\ngoal (1 subgoal):\n 1. n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''", "by(fastforce intro:isSp_Append_sum isSp_Nil sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''", "have \"n is-[n]@ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n is-[] @ [n]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'", "by(fastforce intro:is_SDG_path_Append)"], ["proof (state)\nthis:\n  n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "thus ?case"], ["proof (prove)\nusing this:\n  n is-[n] @ ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by simp"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'", "obtain nsx nsx' nx nx' p' where \"ns = nsx@nx#nsx'\" and \"n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n        and \"nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\" \n        and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>nsx nx nsx' p' nx'.\n        \\<lbrakk>ns = nsx @ nx # nsx'; n'' irs-nsx\\<rightarrow>\\<^sub>d* nx;\n         nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n         nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = nsx @ nx # nsx'\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''", "have \"n irs-n#nsx\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n''\n\ngoal (1 subgoal):\n 1. n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "by(rule intra_return_sum_SDG_path.irsSp_Cons_sum)"], ["proof (state)\nthis:\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>ns = nsx@nx#nsx'\\<close> \\<open>nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\\<close>\n        \\<open>nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  ns = nsx @ nx # nsx'\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "show ?case"], ["proof (prove)\nusing this:\n  ns = nsx @ nx # nsx'\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (2 subgoals):\n 1. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "case (irsSp_Cons_return n'' ns n' n p)"], ["proof (state)\nthis:\n  n'' irs-ns\\<rightarrow>\\<^sub>d* n'\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n  n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\n\ngoal (2 subgoals):\n 1. \\<And>n'' ns n' n p.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or> \n      (\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "show ?case"], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"n'' is-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''", "have \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "hence \"n irs-[]\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. n irs-[]\\<rightarrow>\\<^sub>d* n", "by(rule irsSp_Nil)"], ["proof (state)\nthis:\n  n irs-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<close> \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n irs-[]\\<rightarrow>\\<^sub>d* n", "show ?thesis"], ["proof (prove)\nusing this:\n  n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n irs-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'", "obtain nsx nsx' nx nx' p' where \"ns = nsx@nx#nsx'\" and \"n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n        and \"nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\"\n        and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>nsx nx nsx' p' nx'.\n        \\<lbrakk>ns = nsx @ nx # nsx'; n'' irs-nsx\\<rightarrow>\\<^sub>d* nx;\n         nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n         nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = nsx @ nx # nsx'\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''", "have \"n irs-n#nsx\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n''\n\ngoal (1 subgoal):\n 1. n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "by(rule intra_return_sum_SDG_path.irsSp_Cons_return)"], ["proof (state)\nthis:\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>ns = nsx@nx#nsx'\\<close> \\<open>nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\\<close>\n        \\<open>nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  ns = nsx @ nx # nsx'\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = nsx @ nx # nsx'\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "case (irsSp_Cons_param_out n'' ns n' n p V)"], ["proof (state)\nthis:\n  n'' irs-ns\\<rightarrow>\\<^sub>d* n'\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n  n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>n'' ns n' n p V.\n       \\<lbrakk>n'' irs-ns\\<rightarrow>\\<^sub>d* n';\n        n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n        (\\<exists>nsx nx nsx' p nx'.\n            ns = nsx @ nx # nsx' \\<and>\n            n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n            (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             (\\<exists>V.\n                 nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n            nx' is-nsx'\\<rightarrow>\\<^sub>d* n');\n        n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<rbrakk>\n       \\<Longrightarrow> n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n                         (\\<exists>nsx nx nsx' p nx'.\n                             n # ns = nsx @ nx # nsx' \\<and>\n                             n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n                             (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n                              (\\<exists>V.\n                                  nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n                             nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or> \n      (\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\\<close>"], ["proof (chain)\npicking this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "show ?case"], ["proof (prove)\nusing this:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"n'' is-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''", "have \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "hence \"n irs-[]\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. n irs-[]\\<rightarrow>\\<^sub>d* n", "by(rule irsSp_Nil)"], ["proof (state)\nthis:\n  n irs-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (2 subgoals):\n 1. n'' is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n 2. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<close> \\<open>n'' is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n irs-[]\\<rightarrow>\\<^sub>d* n", "show ?thesis"], ["proof (prove)\nusing this:\n  n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\n  n'' is-ns\\<rightarrow>\\<^sub>d* n'\n  n irs-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "assume \"\\<exists>nsx nx nsx' p nx'. ns = nsx@nx#nsx' \\<and> n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and> \n                        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and> nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'", "obtain nsx nsx' nx nx' p' where \"ns = nsx@nx#nsx'\" and \"n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n        and \"nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\" \n        and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (prove)\nusing this:\n  \\<exists>nsx nx nsx' p nx'.\n     ns = nsx @ nx # nsx' \\<and>\n     n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n     (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n      (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n     nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>nsx nx nsx' p' nx'.\n        \\<lbrakk>ns = nsx @ nx # nsx'; n'' irs-nsx\\<rightarrow>\\<^sub>d* nx;\n         nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n         nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ns = nsx @ nx # nsx'\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "from \\<open>n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''", "have \"n irs-n#nsx\\<rightarrow>\\<^sub>d* nx\""], ["proof (prove)\nusing this:\n  n'' irs-nsx\\<rightarrow>\\<^sub>d* nx\n  n s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n''\n\ngoal (1 subgoal):\n 1. n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "by(rule intra_return_sum_SDG_path.irsSp_Cons_param_out)"], ["proof (state)\nthis:\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. \\<exists>nsx nx nsx' p nx'.\n       ns = nsx @ nx # nsx' \\<and>\n       n'' irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n       (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n       nx' is-nsx'\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "with \\<open>ns = nsx@nx#nsx'\\<close> \\<open>nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\\<close>\n        \\<open>nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  ns = nsx @ nx # nsx'\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx", "show ?thesis"], ["proof (prove)\nusing this:\n  ns = nsx @ nx # nsx'\n  nx s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p':V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n  n irs-n # nsx\\<rightarrow>\\<^sub>d* nx\n\ngoal (1 subgoal):\n 1. n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n    (\\<exists>nsx nx nsx' p nx'.\n        n # ns = nsx @ nx # nsx' \\<and>\n        n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n        (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n         (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n')", "by fastforce"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n is-n # ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      n # ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n' \\<or>\n  (\\<exists>nsx nx nsx' p nx'.\n      ns = nsx @ nx # nsx' \\<and>\n      n irs-nsx\\<rightarrow>\\<^sub>d* nx \\<and>\n      (nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n       (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')) \\<and>\n      nx' is-nsx'\\<rightarrow>\\<^sub>d* n')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irs_SDG_path_matched:\n  assumes \"n irs-ns\\<rightarrow>\\<^sub>d* n''\" and \"n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\"\n  obtains nx nsx where \"matched nx nsx n'\" and \"n \\<in> set nsx\" \n  and \"nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nx nsx.\n        \\<lbrakk>matched nx nsx n'; n \\<in> set nsx;\n         nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n           (parent_node n')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from assms"], ["proof (chain)\npicking this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'", "show \"\\<exists>nx nsx. matched nx nsx n' \\<and> n \\<in> set nsx \\<and> \n                 nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\""], ["proof (prove)\nusing this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "proof(induct ns arbitrary:n'' n' p V rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "fix ns n'' n' p V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "assume IH:\"\\<forall>ns'. length ns' < length ns \\<longrightarrow>\n      (\\<forall>n''. n irs-ns'\\<rightarrow>\\<^sub>d* n'' \\<longrightarrow> \n      (\\<forall>nx' p' V'. (n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> n'' s-p':V'\\<rightarrow>\\<^bsub>out\\<^esub> nx') \\<longrightarrow> \n        (\\<exists>nx nsx. matched nx nsx nx' \\<and> n \\<in> set nsx \\<and> \n                  nx s-p'\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx'))))\"\n      and \"n irs-ns\\<rightarrow>\\<^sub>d* n''\" and \"n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\""], ["proof (state)\nthis:\n  \\<forall>ns'.\n     length ns' < length ns \\<longrightarrow>\n     (\\<forall>n''.\n         n irs-ns'\\<rightarrow>\\<^sub>d* n'' \\<longrightarrow>\n         (\\<forall>nx' p' V'.\n             n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             n'' s-p':V'\\<rightarrow>\\<^bsub>out\\<^esub> nx' \\<longrightarrow>\n             (\\<exists>nx nsx.\n                 matched nx nsx nx' \\<and>\n                 n \\<in> set nsx \\<and>\n                 nx s-p'\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                    (parent_node nx'))))\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'", "have \"valid_SDG_node n''\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n''", "by(fastforce intro:sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n''\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'", "have \"n'' -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (1 subgoal):\n 1. n'' -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n    n'' -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'", "by(fastforce intro:sum_SDG_edge_SDG_edge SDG_edge_sum_SDG_edge)"], ["proof (state)\nthis:\n  n'' -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'", "have \"CFG_node (parent_node n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\""], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')", "by(fastforce elim:sum_SDG_edge.cases intro:sum_SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (parent_node\n     n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "then"], ["proof (chain)\npicking this:\n  CFG_node\n   (parent_node\n     n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')", "obtain a Q f where \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n      and \"parent_node n'' = sourcenode a\" and \"parent_node n' = targetnode a\""], ["proof (prove)\nusing this:\n  CFG_node\n   (parent_node\n     n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. (\\<And>a Q f.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         parent_node n'' = sourcenode a;\n         parent_node n' = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:sum_SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  parent_node n'' = sourcenode a\n  parent_node n' = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain a' Q' r' fs' \n      where \"a \\<in> get_return_edges a'\" and \"valid_edge a'\" and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\"\n      and \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' r' fs'.\n        \\<lbrakk>a \\<in> get_return_edges a'; valid_edge a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         CFG_node\n          (sourcenode\n            a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n               (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule return_edge_determines_call_and_sum_edge)"], ["proof (state)\nthis:\n  a \\<in> get_return_edges a'\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'", "have \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:sum_SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>CFG_node (parent_node n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (parent_node\n     n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')", "have \"get_proc (parent_node n'') = p\""], ["proof (prove)\nusing this:\n  CFG_node\n   (parent_node\n     n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. get_proc (parent_node n'') = p", "by(auto elim!:sum_SDG_edge.cases intro:get_proc_return)"], ["proof (state)\nthis:\n  get_proc (parent_node n'') = p\n\ngoal (1 subgoal):\n 1. \\<And>xs n'' n' p V.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       n irs-ys\\<rightarrow>\\<^sub>d* x \\<longrightarrow>\n                       (\\<forall>xa xb xc.\n                           x s-xb\\<rightarrow>\\<^bsub>ret\\<^esub> xa \\<or>\n                           x s-xb:xc\\<rightarrow>\\<^bsub>out\\<^esub> xa \\<longrightarrow>\n                           (\\<exists>nx nsx.\n                               matched nx nsx xa \\<and>\n                               n \\<in> set nsx \\<and>\n                               nx s-xb\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                                  (parent_node xa))));\n        n irs-xs\\<rightarrow>\\<^sub>d* n'';\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n        n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>n irs-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''", "show \"\\<exists>nx nsx. matched nx nsx n' \\<and> n \\<in> set nsx \\<and> \n                   nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\""], ["proof (prove)\nusing this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "proof(rule irs_SDG_path_split)"], ["proof (state)\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "assume \"n is-ns\\<rightarrow>\\<^sub>d* n''\""], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "hence \"valid_SDG_node n\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. valid_SDG_node n", "by(rule is_SDG_path_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node n\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "then"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "obtain asx where \"(_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node\n              n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:valid_SDG_CFG_node Entry_path)"], ["proof (state)\nthis:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node n\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "then"], ["proof (chain)\npicking this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node n", "obtain asx' where \"(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\"\n        and \"\\<forall>a' \\<in> set asx'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node n\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n;\n         \\<forall>a'\\<in>set asx'.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Entry_path_ascending_path)"], ["proof (state)\nthis:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule is_SDG_path_CFG_path)"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "hence \"get_proc (parent_node n) = get_proc (parent_node n'')\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. get_proc (parent_node n) = get_proc (parent_node n'')", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (parent_node n) = get_proc (parent_node n'')\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"valid_node (parent_node n)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n)", "by(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node n)\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "hence \"valid_SDG_node (CFG_node (parent_node n))\""], ["proof (prove)\nusing this:\n  valid_node (parent_node n)\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (parent_node n))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (parent_node n))\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "have \"\\<exists>a as. valid_edge a \\<and> (\\<exists>Q p r fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "proof(cases \"\\<forall>a' \\<in> set asx'. intra_kind(kind a')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "case True"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with \\<open>(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')", "have \"(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node n\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "by(fastforce simp:intra_path_def vp_def)"], ["proof (state)\nthis:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "hence \"get_proc (_Entry_) = get_proc (parent_node n)\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (1 subgoal):\n 1. get_proc (_Entry_) = get_proc (parent_node n)", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (_Entry_) = get_proc (parent_node n)\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with get_proc_Entry"], ["proof (chain)\npicking this:\n  get_proc (_Entry_) = Main\n  get_proc (_Entry_) = get_proc (parent_node n)", "have \"get_proc (parent_node n) = Main\""], ["proof (prove)\nusing this:\n  get_proc (_Entry_) = Main\n  get_proc (_Entry_) = get_proc (parent_node n)\n\ngoal (1 subgoal):\n 1. get_proc (parent_node n) = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (parent_node n) = Main\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "from \\<open>get_proc (parent_node n) = get_proc (parent_node n'')\\<close>\n          \\<open>get_proc (parent_node n) = Main\\<close>"], ["proof (chain)\npicking this:\n  get_proc (parent_node n) = get_proc (parent_node n'')\n  get_proc (parent_node n) = Main", "have \"get_proc (parent_node n'') = Main\""], ["proof (prove)\nusing this:\n  get_proc (parent_node n) = get_proc (parent_node n'')\n  get_proc (parent_node n) = Main\n\ngoal (1 subgoal):\n 1. get_proc (parent_node n'') = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (parent_node n'') = Main\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with \\<open>parent_node n'' = sourcenode a\\<close> \\<open>get_proc (parent_node n'') = Main\\<close>"], ["proof (chain)\npicking this:\n  parent_node n'' = sourcenode a\n  get_proc (parent_node n'') = Main\n  get_proc (sourcenode a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  parent_node n'' = sourcenode a\n  get_proc (parent_node n'') = Main\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "by simp"], ["proof (state)\nthis:\n  \\<exists>a as.\n     valid_edge a \\<and>\n     (\\<exists>Q p r fs.\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "assume \"\\<not> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with \\<open>\\<forall>a' \\<in> set asx'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  \\<not> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))", "have \"\\<exists>a' \\<in> set asx'. \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  \\<not> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. \\<exists>a'\\<in>set asx'.\n       \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>set asx'.\n     \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'\\<in>set asx'.\n     \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain as a' as' where \"asx' = as@a'#as'\" \n          and \"\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n          and \"\\<forall>a' \\<in> set as'. \\<not> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  \\<exists>a'\\<in>set asx'.\n     \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>as a' as'.\n        \\<lbrakk>asx' = as @ a' # as';\n         \\<exists>Q r p fs.\n            kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         \\<forall>a'\\<in>set as'.\n            \\<nexists>Q r p fs.\n               kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule split_list_last_propE)"], ["proof (state)\nthis:\n  asx' = as @ a' # as'\n  \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>a'\\<in>set as'.\n     \\<nexists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with \\<open>\\<forall>a' \\<in> set asx'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  asx' = as @ a' # as'\n  \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>a'\\<in>set as'.\n     \\<nexists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<forall>a'\\<in>set as'. intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n  asx' = as @ a' # as'\n  \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>a'\\<in>set as'.\n     \\<nexists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>a'\\<in>set as'. intra_kind (kind a')", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set as'. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "from \\<open>(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\\<close> \\<open>asx' = as@a'#as'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\n  asx' = as @ a' # as'", "have \"valid_edge a'\" and \"targetnode a' -as'\\<rightarrow>* parent_node n\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node n\n  asx' = as @ a' # as'\n\ngoal (1 subgoal):\n 1. valid_edge a' &&& targetnode a' -as'\\<rightarrow>* parent_node n", "by(auto dest:path_split simp:vp_def)"], ["proof (state)\nthis:\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* parent_node n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "with \\<open>\\<forall>a'\\<in>set as'. intra_kind (kind a')\\<close> \\<open>\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a'\\<in>set as'. intra_kind (kind a')\n  \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* parent_node n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a'\\<in>set as'. intra_kind (kind a')\n  \\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  targetnode a' -as'\\<rightarrow>* parent_node n\n\ngoal (1 subgoal):\n 1. \\<exists>a as.\n       valid_edge a \\<and>\n       (\\<exists>Q p r fs.\n           kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>a as.\n     valid_edge a \\<and>\n     (\\<exists>Q p r fs.\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a as.\n     valid_edge a \\<and>\n     (\\<exists>Q p r fs.\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>a as.\n     valid_edge a \\<and>\n     (\\<exists>Q p r fs.\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "obtain ax asx Qx rx fsx px where \"valid_edge ax\"\n        and \"kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\" and \"targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\""], ["proof (prove)\nusing this:\n  \\<exists>a as.\n     valid_edge a \\<and>\n     (\\<exists>Q p r fs.\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (1 subgoal):\n 1. (\\<And>ax Qx rx px fsx asx.\n        \\<lbrakk>valid_edge ax;\n         kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx;\n         targetnode\n          ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx", "have \"get_proc (targetnode ax) = px\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. get_proc (targetnode ax) = px", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode ax) = px\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n", "have \"get_proc (targetnode ax) = get_proc (parent_node n)\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n\ngoal (1 subgoal):\n 1. get_proc (targetnode ax) = get_proc (parent_node n)", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (targetnode ax) = get_proc (parent_node n)\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with \\<open>get_proc (parent_node n) = get_proc (parent_node n'')\\<close> \n        \\<open>get_proc (targetnode ax) = px\\<close>"], ["proof (chain)\npicking this:\n  get_proc (parent_node n) = get_proc (parent_node n'')\n  get_proc (targetnode ax) = px\n  get_proc (targetnode ax) = get_proc (parent_node n)", "have \"get_proc (parent_node n'') = px\""], ["proof (prove)\nusing this:\n  get_proc (parent_node n) = get_proc (parent_node n'')\n  get_proc (targetnode ax) = px\n  get_proc (targetnode ax) = get_proc (parent_node n)\n\ngoal (1 subgoal):\n 1. get_proc (parent_node n'') = px", "by simp"], ["proof (state)\nthis:\n  get_proc (parent_node n'') = px\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with \\<open>get_proc (parent_node n'') = p\\<close>"], ["proof (chain)\npicking this:\n  get_proc (parent_node n'') = p\n  get_proc (parent_node n'') = px", "have [simp]:\"px = p\""], ["proof (prove)\nusing this:\n  get_proc (parent_node n'') = p\n  get_proc (parent_node n'') = px\n\ngoal (1 subgoal):\n 1. px = p", "by simp"], ["proof (state)\nthis:\n  px = p\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>valid_edge a'\\<close> \\<open>valid_edge ax\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>\n        \\<open>kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge ax\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx", "have \"targetnode a' = targetnode ax\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge ax\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. targetnode a' = targetnode ax", "by simp(rule same_proc_call_unique_target)"], ["proof (state)\nthis:\n  targetnode a' = targetnode ax\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "have \"parent_node n \\<noteq> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent_node n \\<noteq> (_Exit_)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. parent_node n = (_Exit_) \\<Longrightarrow> False", "assume \"parent_node n = (_Exit_)\""], ["proof (state)\nthis:\n  parent_node n = (_Exit_)\n\ngoal (1 subgoal):\n 1. parent_node n = (_Exit_) \\<Longrightarrow> False", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule is_SDG_path_CFG_path)"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. parent_node n = (_Exit_) \\<Longrightarrow> False", "with \\<open>parent_node n = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  parent_node n = (_Exit_)\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "have \"(_Exit_) -as\\<rightarrow>* parent_node n''\""], ["proof (prove)\nusing this:\n  parent_node n = (_Exit_)\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. (_Exit_) -as\\<rightarrow>* parent_node n''", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  (_Exit_) -as\\<rightarrow>* parent_node n''\n\ngoal (1 subgoal):\n 1. parent_node n = (_Exit_) \\<Longrightarrow> False", "hence \"parent_node n'' = (_Exit_)\""], ["proof (prove)\nusing this:\n  (_Exit_) -as\\<rightarrow>* parent_node n''\n\ngoal (1 subgoal):\n 1. parent_node n'' = (_Exit_)", "by(fastforce dest:path_Exit_source)"], ["proof (state)\nthis:\n  parent_node n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. parent_node n = (_Exit_) \\<Longrightarrow> False", "from \\<open>get_proc (parent_node n'') = p\\<close> \\<open>parent_node n'' = (_Exit_)\\<close>\n          \\<open>parent_node n'' = sourcenode a\\<close> get_proc_Exit"], ["proof (chain)\npicking this:\n  get_proc (parent_node n'') = p\n  parent_node n'' = (_Exit_)\n  parent_node n'' = sourcenode a\n  get_proc (_Exit_) = Main", "have \"p = Main\""], ["proof (prove)\nusing this:\n  get_proc (parent_node n'') = p\n  parent_node n'' = (_Exit_)\n  parent_node n'' = sourcenode a\n  get_proc (_Exit_) = Main\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. parent_node n = (_Exit_) \\<Longrightarrow> False", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. parent_node n = (_Exit_) \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  parent_node n \\<noteq> (_Exit_)\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "have \"\\<exists>nsx. CFG_node (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "proof(cases \"targetnode a' = parent_node n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a' = parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n 2. targetnode a' \\<noteq> parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "case True"], ["proof (state)\nthis:\n  targetnode a' = parent_node n\n\ngoal (2 subgoals):\n 1. targetnode a' = parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n 2. targetnode a' \\<noteq> parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "with \\<open>valid_SDG_node (CFG_node (parent_node n))\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (CFG_node (parent_node n))\n  targetnode a' = parent_node n", "have \"CFG_node (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\""], ["proof (prove)\nusing this:\n  valid_SDG_node (CFG_node (parent_node n))\n  targetnode a' = parent_node n\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "by(fastforce intro:cdSp_Nil)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (2 subgoals):\n 1. targetnode a' = parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n 2. targetnode a' \\<noteq> parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>nsx.\n     CFG_node\n      (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "case False"], ["proof (state)\nthis:\n  targetnode a' \\<noteq> parent_node n\n\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "with \\<open>targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\\<close> \\<open>parent_node n \\<noteq> (_Exit_)\\<close>\n          \\<open>valid_edge ax\\<close> \\<open>kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\\<close> \\<open>targetnode a' = targetnode ax\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n  parent_node n \\<noteq> (_Exit_)\n  valid_edge ax\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n  targetnode a' = targetnode ax\n  targetnode a' \\<noteq> parent_node n", "obtain nsx \n          where \"CFG_node (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node n\n  parent_node n \\<noteq> (_Exit_)\n  valid_edge ax\n  kind ax = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n  targetnode a' = targetnode ax\n  targetnode a' \\<noteq> parent_node n\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        CFG_node\n         (targetnode\n           a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node\n       (parent_node n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:in_proc_cdep_SDG_path)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> parent_node n \\<Longrightarrow>\n    \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. \\<exists>nsx.\n       CFG_node\n        (targetnode\n          a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>nsx.\n     CFG_node\n      (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nsx.\n     CFG_node\n      (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>nsx.\n     CFG_node\n      (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "obtain nsx \n        where \"CFG_node (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\""], ["proof (prove)\nusing this:\n  \\<exists>nsx.\n     CFG_node\n      (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        CFG_node\n         (targetnode\n           a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node\n       (parent_node n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "hence \"CFG_node (targetnode a') i-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\""], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode a') cd-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode a') i-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "by(rule cdep_SDG_path_intra_SDG_path)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode a') i-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "proof(cases ns)"], ["proof (state)\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "case Nil"], ["proof (state)\nthis:\n  ns = []\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>n is-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  ns = []", "have \"n = n''\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  ns = []\n\ngoal (1 subgoal):\n 1. n = n''", "by(fastforce elim:intra_sum_SDG_path.cases)"], ["proof (state)\nthis:\n  n = n''\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close> \\<open>a \\<in> get_return_edges a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a'", "have \"matched (CFG_node (targetnode a')) [CFG_node (targetnode a')]\n          (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) [CFG_node (targetnode a')]\n     (CFG_node (sourcenode a))", "by(rule intra_proc_matched)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) [CFG_node (targetnode a')]\n   (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>valid_SDG_node n''\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n''", "have \"n'' = CFG_node (parent_node n'') \\<or> CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\""], ["proof (prove)\nusing this:\n  valid_SDG_node n''\n\ngoal (1 subgoal):\n 1. n'' = CFG_node (parent_node n'') \\<or>\n    CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''", "by(rule valid_SDG_node_cases)"], ["proof (state)\nthis:\n  n'' = CFG_node (parent_node n'') \\<or>\n  CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "hence \"\\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  n'' = CFG_node (parent_node n'') \\<or>\n  CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n'' = CFG_node (parent_node n'') \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\n 2. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "assume \"n'' = CFG_node (parent_node n'')\""], ["proof (state)\nthis:\n  n'' = CFG_node (parent_node n'')\n\ngoal (2 subgoals):\n 1. n'' = CFG_node (parent_node n'') \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\n 2. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "with \\<open>valid_SDG_node n''\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n''\n  n'' = CFG_node (parent_node n'')", "have \"CFG_node (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  valid_SDG_node n''\n  n'' = CFG_node (parent_node n'')\n\ngoal (1 subgoal):\n 1. CFG_node (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* n''", "by(fastforce intro:iSp_Nil)"], ["proof (state)\nthis:\n  CFG_node (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* n''\n\ngoal (2 subgoals):\n 1. n'' = CFG_node (parent_node n'') \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\n 2. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "by blast"], ["proof (state)\nthis:\n  \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "assume \"CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\""], ["proof (state)\nthis:\n  CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "from \\<open>valid_SDG_node n''\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n''", "have \"valid_node (parent_node n'')\""], ["proof (prove)\nusing this:\n  valid_SDG_node n''\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n'')", "by(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node n'')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "hence \"valid_SDG_node (CFG_node (parent_node n''))\""], ["proof (prove)\nusing this:\n  valid_node (parent_node n'')\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (parent_node n''))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (parent_node n''))\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "hence \"CFG_node (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n'')\""], ["proof (prove)\nusing this:\n  valid_SDG_node (CFG_node (parent_node n''))\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n'')", "by(rule iSp_Nil)"], ["proof (state)\nthis:\n  CFG_node\n   (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n'')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "with \\<open>CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n  CFG_node\n   (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n'')", "have \"CFG_node (parent_node n'') i-[]@[CFG_node (parent_node n'')]\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  CFG_node (parent_node n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n''\n  CFG_node\n   (parent_node n'') i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n'')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') i-[] @ [CFG_node (parent_node n'')]\\<rightarrow>\\<^sub>d* n''", "by(fastforce intro:iSp_Append_cdep sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (parent_node\n     n'') i-[] @ [CFG_node (parent_node n'')]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n'') \\<longrightarrow>\\<^bsub>cd\\<^esub> n'' \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (parent_node\n     n'') i-[] @ [CFG_node (parent_node n'')]\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "by blast"], ["proof (state)\nthis:\n  \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>parent_node n'' = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  parent_node n'' = sourcenode a\n  \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''", "obtain nsx where \"CFG_node (sourcenode a) i-nsx\\<rightarrow>\\<^sub>d* n''\""], ["proof (prove)\nusing this:\n  parent_node n'' = sourcenode a\n  \\<exists>nsx. CFG_node (parent_node n'') i-nsx\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        CFG_node\n         (sourcenode a) i-nsx\\<rightarrow>\\<^sub>d* n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) i-nsx\\<rightarrow>\\<^sub>d* n''\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>matched (CFG_node (targetnode a')) [CFG_node (targetnode a')]\n          (CFG_node (sourcenode a))\\<close>"], ["proof (chain)\npicking this:\n  matched (CFG_node (targetnode a')) [CFG_node (targetnode a')]\n   (CFG_node (sourcenode a))\n  CFG_node (sourcenode a) i-nsx\\<rightarrow>\\<^sub>d* n''", "have \"matched (CFG_node (targetnode a')) ([CFG_node (targetnode a')]@nsx) n''\""], ["proof (prove)\nusing this:\n  matched (CFG_node (targetnode a')) [CFG_node (targetnode a')]\n   (CFG_node (sourcenode a))\n  CFG_node (sourcenode a) i-nsx\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) ([CFG_node (targetnode a')] @ nsx)\n     n''", "by(fastforce intro:matched_Append intra_SDG_path_matched)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) ([CFG_node (targetnode a')] @ nsx) n''\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "moreover"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) ([CFG_node (targetnode a')] @ nsx) n''\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'", "have \"CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "moreover"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'", "have \"valid_SDG_node (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (sourcenode a'))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (sourcenode a'))\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "hence \"matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_SDG_node (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "ultimately"], ["proof (chain)\npicking this:\n  matched (CFG_node (targetnode a')) ([CFG_node (targetnode a')] @ nsx) n''\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))", "have \"matched (CFG_node (sourcenode a'))\n          ([]@(CFG_node (sourcenode a'))#([CFG_node (targetnode a')]@nsx)@[n'']) n'\""], ["proof (prove)\nusing this:\n  matched (CFG_node (targetnode a')) ([CFG_node (targetnode a')] @ nsx) n''\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (sourcenode a'))\n     ([] @\n      CFG_node (sourcenode a') # ([CFG_node (targetnode a')] @ nsx) @ [n''])\n     n'", "using \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close> \\<open>parent_node n' = targetnode a\\<close>\n            \\<open>parent_node n'' = sourcenode a\\<close> \\<open>valid_edge a'\\<close> \\<open>a \\<in> get_return_edges a'\\<close>"], ["proof (prove)\nusing this:\n  matched (CFG_node (targetnode a')) ([CFG_node (targetnode a')] @ nsx) n''\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  parent_node n' = targetnode a\n  parent_node n'' = sourcenode a\n  valid_edge a'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. matched (CFG_node (sourcenode a'))\n     ([] @\n      CFG_node (sourcenode a') # ([CFG_node (targetnode a')] @ nsx) @ [n''])\n     n'", "by(fastforce intro:matched_bracket_call dest:sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  matched (CFG_node (sourcenode a'))\n   ([] @\n    CFG_node (sourcenode a') # ([CFG_node (targetnode a')] @ nsx) @ [n''])\n   n'\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n 2. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>n = n''\\<close> \\<open>CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\\<close>\n          \\<open>parent_node n' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  n = n''\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n  parent_node n' = targetnode a\n  matched (CFG_node (sourcenode a'))\n   ([] @\n    CFG_node (sourcenode a') # ([CFG_node (targetnode a')] @ nsx) @ [n''])\n   n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n = n''\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n  parent_node n' = targetnode a\n  matched (CFG_node (sourcenode a'))\n   ([] @\n    CFG_node (sourcenode a') # ([CFG_node (targetnode a')] @ nsx) @ [n''])\n   n'\n\ngoal (1 subgoal):\n 1. \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>nx nsx.\n     matched nx nsx n' \\<and>\n     n \\<in> set nsx \\<and>\n     nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "case Cons"], ["proof (state)\nthis:\n  ns = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>n is-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  ns = a_ # list_", "have \"n \\<in> set ns\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n  ns = a_ # list_\n\ngoal (1 subgoal):\n 1. n \\<in> set ns", "by(induct rule:intra_sum_SDG_path_rev_induct) auto"], ["proof (state)\nthis:\n  n \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''", "obtain ns' where \"matched n ns' n''\" \n          and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>matched n ns' n''; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule is_SDG_path_matched)"], ["proof (state)\nthis:\n  matched n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>n \\<in> set ns\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> set ns\n  matched n ns' n''\n  set ns \\<subseteq> set ns'", "have \"n \\<in> set ns'\""], ["proof (prove)\nusing this:\n  n \\<in> set ns\n  matched n ns' n''\n  set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. n \\<in> set ns'", "by fastforce"], ["proof (state)\nthis:\n  n \\<in> set ns'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n", "have \"n = CFG_node (parent_node n) \\<or> CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n\ngoal (1 subgoal):\n 1. n = CFG_node (parent_node n) \\<or>\n    CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n", "by(rule valid_SDG_node_cases)"], ["proof (state)\nthis:\n  n = CFG_node (parent_node n) \\<or>\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "hence \"\\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  n = CFG_node (parent_node n) \\<or>\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n = CFG_node (parent_node n) \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\n 2. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "assume \"n = CFG_node (parent_node n)\""], ["proof (state)\nthis:\n  n = CFG_node (parent_node n)\n\ngoal (2 subgoals):\n 1. n = CFG_node (parent_node n) \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\n 2. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "with \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  n = CFG_node (parent_node n)", "have \"CFG_node (parent_node n) i-[]\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  n = CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. CFG_node (parent_node n) i-[]\\<rightarrow>\\<^sub>d* n", "by(fastforce intro:iSp_Nil)"], ["proof (state)\nthis:\n  CFG_node (parent_node n) i-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (2 subgoals):\n 1. n = CFG_node (parent_node n) \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\n 2. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (parent_node n) i-[]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "by blast"], ["proof (state)\nthis:\n  \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "assume \"CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\""], ["proof (state)\nthis:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "from \\<open>valid_SDG_node (CFG_node (parent_node n))\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (CFG_node (parent_node n))", "have \"CFG_node (parent_node n) i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\""], ["proof (prove)\nusing this:\n  valid_SDG_node (CFG_node (parent_node n))\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node n) i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "by(rule iSp_Nil)"], ["proof (state)\nthis:\n  CFG_node\n   (parent_node n) i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "with \\<open>CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n  CFG_node\n   (parent_node n) i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)", "have \"CFG_node (parent_node n) i-[]@[CFG_node (parent_node n)]\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  CFG_node (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n\n  CFG_node\n   (parent_node n) i-[]\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       n) i-[] @ [CFG_node (parent_node n)]\\<rightarrow>\\<^sub>d* n", "by(fastforce intro:iSp_Append_cdep sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (parent_node n) i-[] @ [CFG_node (parent_node n)]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node n) \\<longrightarrow>\\<^bsub>cd\\<^esub> n \\<Longrightarrow>\n    \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (parent_node n) i-[] @ [CFG_node (parent_node n)]\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "by blast"], ["proof (state)\nthis:\n  \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n", "obtain nsx' where \"CFG_node (parent_node n) i-nsx'\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  \\<exists>nsx. CFG_node (parent_node n) i-nsx\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. (\\<And>nsx'.\n        CFG_node\n         (parent_node n) i-nsx'\\<rightarrow>\\<^sub>d* n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node (parent_node n) i-nsx'\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>CFG_node (targetnode a') i-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (targetnode a') i-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n  CFG_node (parent_node n) i-nsx'\\<rightarrow>\\<^sub>d* n", "have \"CFG_node (targetnode a') i-nsx@nsx'\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode a') i-nsx\\<rightarrow>\\<^sub>d* CFG_node (parent_node n)\n  CFG_node (parent_node n) i-nsx'\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a') i-nsx @ nsx'\\<rightarrow>\\<^sub>d* n", "by -(rule intra_SDG_path_Append)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') i-nsx @ nsx'\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "hence \"matched (CFG_node (targetnode a')) (nsx@nsx') n\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a') i-nsx @ nsx'\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) (nsx @ nsx') n", "by(rule intra_SDG_path_matched)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) (nsx @ nsx') n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>matched n ns' n''\\<close>"], ["proof (chain)\npicking this:\n  matched n ns' n''\n  matched (CFG_node (targetnode a')) (nsx @ nsx') n", "have \"matched (CFG_node (targetnode a')) ((nsx@nsx')@ns') n''\""], ["proof (prove)\nusing this:\n  matched n ns' n''\n  matched (CFG_node (targetnode a')) (nsx @ nsx') n\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) ((nsx @ nsx') @ ns') n''", "by(rule matched_Append)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) ((nsx @ nsx') @ ns') n''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "moreover"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) ((nsx @ nsx') @ ns') n''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'", "have \"CFG_node (sourcenode a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "moreover"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "from \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'", "have \"valid_SDG_node (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (sourcenode a'))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "hence \"matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\""], ["proof (prove)\nusing this:\n  valid_SDG_node (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))", "by(rule matched_Nil)"], ["proof (state)\nthis:\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "ultimately"], ["proof (chain)\npicking this:\n  matched (CFG_node (targetnode a')) ((nsx @ nsx') @ ns') n''\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))", "have \"matched (CFG_node (sourcenode a')) \n          ([]@(CFG_node (sourcenode a'))#((nsx@nsx')@ns')@[n'']) n'\""], ["proof (prove)\nusing this:\n  matched (CFG_node (targetnode a')) ((nsx @ nsx') @ ns') n''\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\n\ngoal (1 subgoal):\n 1. matched (CFG_node (sourcenode a'))\n     ([] @ CFG_node (sourcenode a') # ((nsx @ nsx') @ ns') @ [n'']) n'", "using  \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close> \\<open>parent_node n' = targetnode a\\<close>\n            \\<open>parent_node n'' = sourcenode a\\<close> \\<open>valid_edge a'\\<close> \\<open>a \\<in> get_return_edges a'\\<close>"], ["proof (prove)\nusing this:\n  matched (CFG_node (targetnode a')) ((nsx @ nsx') @ ns') n''\n  CFG_node\n   (sourcenode\n     a') -p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  matched (CFG_node (sourcenode a')) [] (CFG_node (sourcenode a'))\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  parent_node n' = targetnode a\n  parent_node n'' = sourcenode a\n  valid_edge a'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. matched (CFG_node (sourcenode a'))\n     ([] @ CFG_node (sourcenode a') # ((nsx @ nsx') @ ns') @ [n'']) n'", "by(fastforce intro:matched_bracket_call dest:sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  matched (CFG_node (sourcenode a'))\n   ([] @ CFG_node (sourcenode a') # ((nsx @ nsx') @ ns') @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ns = a # list \\<Longrightarrow>\n       \\<exists>nx nsx.\n          matched nx nsx n' \\<and>\n          n \\<in> set nsx \\<and>\n          nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "with \\<open>CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\\<close>\n          \\<open>parent_node n' = targetnode a\\<close> \\<open>n \\<in> set ns'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n  parent_node n' = targetnode a\n  n \\<in> set ns'\n  matched (CFG_node (sourcenode a'))\n   ([] @ CFG_node (sourcenode a') # ((nsx @ nsx') @ ns') @ [n'']) n'", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n  parent_node n' = targetnode a\n  n \\<in> set ns'\n  matched (CFG_node (sourcenode a'))\n   ([] @ CFG_node (sourcenode a') # ((nsx @ nsx') @ ns') @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>nx nsx.\n     matched nx nsx n' \\<and>\n     n \\<in> set nsx \\<and>\n     nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nx nsx.\n     matched nx nsx n' \\<and>\n     n \\<in> set nsx \\<and>\n     nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "fix ms ms' m m' px"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "assume \"ns = ms@m#ms'\" and \"n irs-ms\\<rightarrow>\\<^sub>d* m\"\n        and \"m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or> (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\" and \"m' is-ms'\\<rightarrow>\\<^sub>d* n''\""], ["proof (state)\nthis:\n  ns = ms @ m # ms'\n  n irs-ms\\<rightarrow>\\<^sub>d* m\n  m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\n  m' is-ms'\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>ns = ms@m#ms'\\<close>"], ["proof (chain)\npicking this:\n  ns = ms @ m # ms'", "have \"length ms < length ns\""], ["proof (prove)\nusing this:\n  ns = ms @ m # ms'\n\ngoal (1 subgoal):\n 1. length ms < length ns", "by simp"], ["proof (state)\nthis:\n  length ms < length ns\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with IH \\<open>n irs-ms\\<rightarrow>\\<^sub>d* m\\<close> \\<open>m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or> (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ns'.\n     length ns' < length ns \\<longrightarrow>\n     (\\<forall>n''.\n         n irs-ns'\\<rightarrow>\\<^sub>d* n'' \\<longrightarrow>\n         (\\<forall>nx' p' V'.\n             n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             n'' s-p':V'\\<rightarrow>\\<^bsub>out\\<^esub> nx' \\<longrightarrow>\n             (\\<exists>nx nsx.\n                 matched nx nsx nx' \\<and>\n                 n \\<in> set nsx \\<and>\n                 nx s-p'\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                    (parent_node nx'))))\n  n irs-ms\\<rightarrow>\\<^sub>d* m\n  m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\n  length ms < length ns", "obtain mx msx\n        where \"matched mx msx m'\" and \"n \\<in> set msx\" \n        and \"mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\""], ["proof (prove)\nusing this:\n  \\<forall>ns'.\n     length ns' < length ns \\<longrightarrow>\n     (\\<forall>n''.\n         n irs-ns'\\<rightarrow>\\<^sub>d* n'' \\<longrightarrow>\n         (\\<forall>nx' p' V'.\n             n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n             n'' s-p':V'\\<rightarrow>\\<^bsub>out\\<^esub> nx' \\<longrightarrow>\n             (\\<exists>nx nsx.\n                 matched nx nsx nx' \\<and>\n                 n \\<in> set nsx \\<and>\n                 nx s-p'\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                    (parent_node nx'))))\n  n irs-ms\\<rightarrow>\\<^sub>d* m\n  m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\n  length ms < length ns\n\ngoal (1 subgoal):\n 1. (\\<And>mx msx.\n        \\<lbrakk>matched mx msx m'; n \\<in> set msx;\n         mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n            (parent_node m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  matched mx msx m'\n  n \\<in> set msx\n  mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>m' is-ms'\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  m' is-ms'\\<rightarrow>\\<^sub>d* n''", "obtain msx' where \"matched m' msx' n''\""], ["proof (prove)\nusing this:\n  m' is-ms'\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. (\\<And>msx'.\n        matched m' msx' n'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule is_SDG_path_matched)"], ["proof (state)\nthis:\n  matched m' msx' n''\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with \\<open>matched mx msx m'\\<close>"], ["proof (chain)\npicking this:\n  matched mx msx m'\n  matched m' msx' n''", "have \"matched mx (msx@msx') n''\""], ["proof (prove)\nusing this:\n  matched mx msx m'\n  matched m' msx' n''\n\ngoal (1 subgoal):\n 1. matched mx (msx @ msx') n''", "by -(rule matched_Append)"], ["proof (state)\nthis:\n  matched mx (msx @ msx') n''\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or> (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\\<close>"], ["proof (chain)\npicking this:\n  m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')", "have \"m -px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or> (\\<exists>V. m -px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\""], ["proof (prove)\nusing this:\n  m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\n\ngoal (1 subgoal):\n 1. m -px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n    (\\<exists>V. m -px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')", "by(auto intro:sum_SDG_edge_SDG_edge SDG_edge_sum_SDG_edge)"], ["proof (state)\nthis:\n  m -px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m -px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or> (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\\<close>"], ["proof (chain)\npicking this:\n  m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')", "have \"CFG_node (parent_node m) s-px\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node m')\""], ["proof (prove)\nusing this:\n  m s-px\\<rightarrow>\\<^bsub>ret\\<^esub> m' \\<or>\n  (\\<exists>V. m s-px:V\\<rightarrow>\\<^bsub>out\\<^esub> m')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       m) s-px\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node m')", "by(fastforce elim:sum_SDG_edge.cases intro:sum_SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (parent_node\n     m) s-px\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node m')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "then"], ["proof (chain)\npicking this:\n  CFG_node\n   (parent_node\n     m) s-px\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node m')", "obtain ax Qx fx where \"valid_edge ax\" and \"kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx\"\n      and \"parent_node m = sourcenode ax\" and \"parent_node m' = targetnode ax\""], ["proof (prove)\nusing this:\n  CFG_node\n   (parent_node\n     m) s-px\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node m')\n\ngoal (1 subgoal):\n 1. (\\<And>ax Qx fx.\n        \\<lbrakk>valid_edge ax;\n         kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx;\n         parent_node m = sourcenode ax;\n         parent_node m' = targetnode ax\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:sum_SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx\n  parent_node m = sourcenode ax\n  parent_node m' = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx", "obtain ax' Qx' rx' fsx' \n        where \"ax \\<in> get_return_edges ax'\" and \"valid_edge ax'\" \n        and \"kind ax' = Qx':rx'\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx'\"\n        and \"CFG_node (sourcenode ax') s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode ax)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx\n\ngoal (1 subgoal):\n 1. (\\<And>ax' Qx' rx' fsx'.\n        \\<lbrakk>ax \\<in> get_return_edges ax'; valid_edge ax';\n         kind ax' = Qx':rx'\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx';\n         CFG_node\n          (sourcenode\n            ax') s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                 (targetnode ax)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule return_edge_determines_call_and_sum_edge)"], ["proof (state)\nthis:\n  ax \\<in> get_return_edges ax'\n  valid_edge ax'\n  kind ax' = Qx':rx'\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx'\n  CFG_node\n   (sourcenode\n     ax') s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode ax)\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>valid_edge ax'\\<close> \\<open>kind ax' = Qx':rx'\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  kind ax' = Qx':rx'\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx'", "have \"CFG_node (sourcenode ax') s-px\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode ax')\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n  kind ax' = Qx':rx'\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       ax') s-px\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode ax')", "by(fastforce intro:sum_SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     ax') s-px\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode ax')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "from \\<open>mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\\<close>"], ["proof (chain)\npicking this:\n  mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')", "have \"valid_SDG_node mx\""], ["proof (prove)\nusing this:\n  mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\n\ngoal (1 subgoal):\n 1. valid_SDG_node mx", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node mx\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "have \"\\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "proof(cases \"targetnode a' = parent_node mx\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a' = parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. targetnode a' \\<noteq> parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "case True"], ["proof (state)\nthis:\n  targetnode a' = parent_node mx\n\ngoal (2 subgoals):\n 1. targetnode a' = parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. targetnode a' \\<noteq> parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from \\<open>valid_SDG_node mx\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node mx", "have \"mx = CFG_node (parent_node mx) \\<or> CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\""], ["proof (prove)\nusing this:\n  valid_SDG_node mx\n\ngoal (1 subgoal):\n 1. mx = CFG_node (parent_node mx) \\<or>\n    CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx", "by(rule valid_SDG_node_cases)"], ["proof (state)\nthis:\n  mx = CFG_node (parent_node mx) \\<or>\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (2 subgoals):\n 1. targetnode a' = parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. targetnode a' \\<noteq> parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  mx = CFG_node (parent_node mx) \\<or>\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mx = CFG_node (parent_node mx) \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "assume \"mx = CFG_node (parent_node mx)\""], ["proof (state)\nthis:\n  mx = CFG_node (parent_node mx)\n\ngoal (2 subgoals):\n 1. mx = CFG_node (parent_node mx) \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>valid_SDG_node mx\\<close> True"], ["proof (chain)\npicking this:\n  valid_SDG_node mx\n  targetnode a' = parent_node mx\n  mx = CFG_node (parent_node mx)", "have \"CFG_node (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* mx\""], ["proof (prove)\nusing this:\n  valid_SDG_node mx\n  targetnode a' = parent_node mx\n  mx = CFG_node (parent_node mx)\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* mx", "by(fastforce intro:cdSp_Nil)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* mx\n\ngoal (2 subgoals):\n 1. mx = CFG_node (parent_node mx) \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (targetnode a') cd-[]\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "by blast"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "assume \"CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\""], ["proof (state)\nthis:\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>valid_edge a'\\<close> True[THEN sym]"], ["proof (chain)\npicking this:\n  valid_edge a'\n  parent_node mx = targetnode a'\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx", "have \"CFG_node (targetnode a') cd-[]@[CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* mx\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  parent_node mx = targetnode a'\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a') cd-[] @ [CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* mx", "by(fastforce intro:cdep_SDG_path.intros)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a') cd-[] @ [CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') cd-[] @ [CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "by blast"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "case False"], ["proof (state)\nthis:\n  targetnode a' \\<noteq> parent_node mx\n\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> parent_node mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "proof(cases \"\\<forall>ai. valid_edge ai \\<and> sourcenode ai = parent_node mx\n            \\<longrightarrow> ai \\<notin> get_return_edges a'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "case True"], ["proof (state)\nthis:\n  \\<forall>ai.\n     valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n     ai \\<notin> get_return_edges a'\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "{"], ["proof (state)\nthis:\n  \\<forall>ai.\n     valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n     ai \\<notin> get_return_edges a'\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "assume \"parent_node mx = (_Exit_)\""], ["proof (state)\nthis:\n  parent_node mx = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\\<close>"], ["proof (chain)\npicking this:\n  mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\n  parent_node mx = (_Exit_)", "obtain ai where \"valid_edge ai\" and \"sourcenode ai = (_Exit_)\""], ["proof (prove)\nusing this:\n  mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\n  parent_node mx = (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>ai.\n        \\<lbrakk>valid_edge ai; sourcenode ai = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule sum_SDG_edge.cases,auto)"], ["proof (state)\nthis:\n  valid_edge ai\n  sourcenode ai = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "hence False"], ["proof (prove)\nusing this:\n  valid_edge ai\n  sourcenode ai = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "}"], ["proof (state)\nthis:\n  parent_node mx = (_Exit_) \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "hence \"parent_node mx \\<noteq> (_Exit_)\""], ["proof (prove)\nusing this:\n  parent_node mx = (_Exit_) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. parent_node mx \\<noteq> (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  parent_node mx \\<noteq> (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from \\<open>valid_SDG_node mx\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node mx", "have \"valid_node (parent_node mx)\""], ["proof (prove)\nusing this:\n  valid_SDG_node mx\n\ngoal (1 subgoal):\n 1. valid_node (parent_node mx)", "by(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node mx)\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "then"], ["proof (chain)\npicking this:\n  valid_node (parent_node mx)", "obtain asx where \"(_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\""], ["proof (prove)\nusing this:\n  valid_node (parent_node mx)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node\n              mx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce intro:Entry_path)"], ["proof (state)\nthis:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "then"], ["proof (chain)\npicking this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node mx", "obtain asx' where \"(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\"\n            and \"\\<forall>a' \\<in> set asx'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx;\n         \\<forall>a'\\<in>set asx'.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Entry_path_ascending_path)"], ["proof (state)\nthis:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from \\<open>mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\\<close>"], ["proof (chain)\npicking this:\n  mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')", "obtain nsi where \"matched mx nsi (CFG_node (parent_node m'))\""], ["proof (prove)\nusing this:\n  mx s-px\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node m')\n\ngoal (1 subgoal):\n 1. (\\<And>nsi.\n        matched mx nsi (CFG_node (parent_node m')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule sum_SDG_summary_edge_matched)"], ["proof (state)\nthis:\n  matched mx nsi (CFG_node (parent_node m'))\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "then"], ["proof (chain)\npicking this:\n  matched mx nsi (CFG_node (parent_node m'))", "obtain asi where \"parent_node mx -asi\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node m'\""], ["proof (prove)\nusing this:\n  matched mx nsi (CFG_node (parent_node m'))\n\ngoal (1 subgoal):\n 1. (\\<And>asi.\n        parent_node\n         mx -asi\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n            m' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:matched_same_level_CFG_path)"], ["proof (state)\nthis:\n  parent_node mx -asi\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node m'\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "hence \"get_proc (parent_node mx) = get_proc (parent_node m')\""], ["proof (prove)\nusing this:\n  parent_node mx -asi\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node m'\n\ngoal (1 subgoal):\n 1. get_proc (parent_node mx) = get_proc (parent_node m')", "by(rule slp_get_proc)"], ["proof (state)\nthis:\n  get_proc (parent_node mx) = get_proc (parent_node m')\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from \\<open>m' is-ms'\\<rightarrow>\\<^sub>d* n''\\<close>"], ["proof (chain)\npicking this:\n  m' is-ms'\\<rightarrow>\\<^sub>d* n''", "obtain nsi' where \"matched m' nsi' n''\""], ["proof (prove)\nusing this:\n  m' is-ms'\\<rightarrow>\\<^sub>d* n''\n\ngoal (1 subgoal):\n 1. (\\<And>nsi'.\n        matched m' nsi' n'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule is_SDG_path_matched)"], ["proof (state)\nthis:\n  matched m' nsi' n''\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "then"], ["proof (chain)\npicking this:\n  matched m' nsi' n''", "obtain asi' where \"parent_node m' -asi'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\""], ["proof (prove)\nusing this:\n  matched m' nsi' n''\n\ngoal (1 subgoal):\n 1. (\\<And>asi'.\n        parent_node\n         m' -asi'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node\n             n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule matched_same_level_CFG_path)"], ["proof (state)\nthis:\n  parent_node m' -asi'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "hence \"get_proc (parent_node m') = get_proc (parent_node n'')\""], ["proof (prove)\nusing this:\n  parent_node m' -asi'\\<rightarrow>\\<^bsub>sl\\<^esub>* parent_node n''\n\ngoal (1 subgoal):\n 1. get_proc (parent_node m') = get_proc (parent_node n'')", "by(rule slp_get_proc)"], ["proof (state)\nthis:\n  get_proc (parent_node m') = get_proc (parent_node n'')\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>get_proc (parent_node mx) = get_proc (parent_node m')\\<close>"], ["proof (chain)\npicking this:\n  get_proc (parent_node mx) = get_proc (parent_node m')\n  get_proc (parent_node m') = get_proc (parent_node n'')", "have \"get_proc (parent_node mx) = get_proc (parent_node n'')\""], ["proof (prove)\nusing this:\n  get_proc (parent_node mx) = get_proc (parent_node m')\n  get_proc (parent_node m') = get_proc (parent_node n'')\n\ngoal (1 subgoal):\n 1. get_proc (parent_node mx) = get_proc (parent_node n'')", "by simp"], ["proof (state)\nthis:\n  get_proc (parent_node mx) = get_proc (parent_node n'')\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from \\<open>get_proc (parent_node n'') = p\\<close> \n            \\<open>get_proc (parent_node mx) = get_proc (parent_node n'')\\<close>"], ["proof (chain)\npicking this:\n  get_proc (parent_node n'') = p\n  get_proc (parent_node mx) = get_proc (parent_node n'')", "have \"get_proc (parent_node mx) = p\""], ["proof (prove)\nusing this:\n  get_proc (parent_node n'') = p\n  get_proc (parent_node mx) = get_proc (parent_node n'')\n\ngoal (1 subgoal):\n 1. get_proc (parent_node mx) = p", "by simp"], ["proof (state)\nthis:\n  get_proc (parent_node mx) = p\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "have \"\\<exists>asx. targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "proof(cases \"\\<forall>a' \\<in> set asx'. intra_kind(kind a')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "case True"], ["proof (state)\nthis:\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "with \\<open>(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')", "have \"(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\n  \\<forall>a'\\<in>set asx'. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "by(simp add:vp_def intra_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "hence \"get_proc (_Entry_) = get_proc (parent_node mx)\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (1 subgoal):\n 1. get_proc (_Entry_) = get_proc (parent_node mx)", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (_Entry_) = get_proc (parent_node mx)\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "with \\<open>get_proc (parent_node mx) = p\\<close>"], ["proof (chain)\npicking this:\n  get_proc (parent_node mx) = p\n  get_proc (_Entry_) = get_proc (parent_node mx)", "have \"get_proc (_Entry_) = p\""], ["proof (prove)\nusing this:\n  get_proc (parent_node mx) = p\n  get_proc (_Entry_) = get_proc (parent_node mx)\n\ngoal (1 subgoal):\n 1. get_proc (_Entry_) = p", "by simp"], ["proof (state)\nthis:\n  get_proc (_Entry_) = p\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "with \\<open>CFG_node (parent_node n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (parent_node\n     n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  get_proc (_Entry_) = p", "have False"], ["proof (prove)\nusing this:\n  CFG_node\n   (parent_node\n     n'') s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  get_proc (_Entry_) = p\n\ngoal (1 subgoal):\n 1. False", "by -(erule sum_SDG_edge.cases,\n                auto intro:Main_no_return_source simp:get_proc_Entry)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<forall>a'\\<in>set asx'. intra_kind (kind a') \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n 2. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "by simp"], ["proof (state)\nthis:\n  \\<exists>asx.\n     targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "hence \"\\<exists>a' \\<in> set asx'. \\<not> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>a'\\<in>set asx'. intra_kind (kind a'))\n\ngoal (1 subgoal):\n 1. \\<exists>a'\\<in>set asx'. \\<not> intra_kind (kind a')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>set asx'. \\<not> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'\\<in>set asx'. \\<not> intra_kind (kind a')", "obtain ai as' as'' where \"asx' = as'@ai#as''\" \n              and \"\\<not> intra_kind (kind ai)\" and \"\\<forall>a' \\<in> set as''. intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  \\<exists>a'\\<in>set asx'. \\<not> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<And>as' ai as''.\n        \\<lbrakk>asx' = as' @ ai # as''; \\<not> intra_kind (kind ai);\n         \\<forall>a'\\<in>set as''. intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_last_propE)"], ["proof (state)\nthis:\n  asx' = as' @ ai # as''\n  \\<not> intra_kind (kind ai)\n  \\<forall>a'\\<in>set as''. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "from \\<open>asx' = as'@ai#as''\\<close> \\<open>\\<not> intra_kind (kind ai)\\<close>\n              \\<open>\\<forall>a' \\<in> set asx'. intra_kind(kind a') \\<or> (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<close>"], ["proof (chain)\npicking this:\n  asx' = as' @ ai # as''\n  \\<not> intra_kind (kind ai)\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)", "obtain Qi ri pi fsi where \"kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\" \n              and \"\\<forall>a' \\<in> set as'. intra_kind(kind a') \\<or> \n              (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\""], ["proof (prove)\nusing this:\n  asx' = as' @ ai # as''\n  \\<not> intra_kind (kind ai)\n  \\<forall>a'\\<in>set asx'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. (\\<And>Qi ri pi fsi.\n        \\<lbrakk>kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi;\n         \\<forall>a'\\<in>set as'.\n            intra_kind (kind a') \\<or>\n            (\\<exists>Q r p fs.\n                kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\n  \\<forall>a'\\<in>set as'.\n     intra_kind (kind a') \\<or>\n     (\\<exists>Q r p fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "from \\<open>(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\\<close> \\<open>asx' = as'@ai#as''\\<close>\n              \\<open>\\<forall>a' \\<in> set as''. intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\n  asx' = as' @ ai # as''\n  \\<forall>a'\\<in>set as''. intra_kind (kind a')", "have \"valid_edge ai\" and \"targetnode ai -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* parent_node mx\n  asx' = as' @ ai # as''\n  \\<forall>a'\\<in>set as''. intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. valid_edge ai &&&\n    targetnode ai -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "by(auto intro:path_split simp:vp_def intra_path_def)"], ["proof (state)\nthis:\n  valid_edge ai\n  targetnode ai -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "hence \"get_proc (targetnode ai) = get_proc (parent_node mx)\""], ["proof (prove)\nusing this:\n  valid_edge ai\n  targetnode ai -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (1 subgoal):\n 1. get_proc (targetnode ai) = get_proc (parent_node mx)", "by -(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (targetnode ai) = get_proc (parent_node mx)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "with \\<open>get_proc (parent_node mx) = p\\<close> \\<open>valid_edge ai\\<close>\n              \\<open>kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\\<close>"], ["proof (chain)\npicking this:\n  get_proc (parent_node mx) = p\n  valid_edge ai\n  kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\n  get_proc (targetnode ai) = get_proc (parent_node mx)", "have [simp]:\"pi = p\""], ["proof (prove)\nusing this:\n  get_proc (parent_node mx) = p\n  valid_edge ai\n  kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\n  get_proc (targetnode ai) = get_proc (parent_node mx)\n\ngoal (1 subgoal):\n 1. pi = p", "by(fastforce dest:get_proc_call)"], ["proof (state)\nthis:\n  pi = p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "from \\<open>valid_edge ai\\<close> \\<open>valid_edge a'\\<close> \n              \\<open>kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ai\n  valid_edge a'\n  kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'", "have \"targetnode ai = targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge ai\n  valid_edge a'\n  kind ai = Qi:ri\\<hookrightarrow>\\<^bsub>pi\\<^esub>fsi\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. targetnode ai = targetnode a'", "by(fastforce intro:same_proc_call_unique_target)"], ["proof (state)\nthis:\n  targetnode ai = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a'\\<in>set asx'.\n               intra_kind (kind a')) \\<Longrightarrow>\n    \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "with \\<open>targetnode ai -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\\<close>"], ["proof (chain)\npicking this:\n  targetnode ai -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n  targetnode ai = targetnode a'", "show ?thesis"], ["proof (prove)\nusing this:\n  targetnode ai -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n  targetnode ai = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<exists>asx.\n       targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>asx.\n     targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>asx.\n     targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "then"], ["proof (chain)\npicking this:\n  \\<exists>asx.\n     targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx", "obtain asx where \"targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\""], ["proof (prove)\nusing this:\n  \\<exists>asx.\n     targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        targetnode\n         a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n        mx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from this \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>\n            \\<open>parent_node mx \\<noteq> (_Exit_)\\<close> \\<open>targetnode a' \\<noteq> parent_node mx\\<close> True"], ["proof (chain)\npicking this:\n  targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  parent_node mx \\<noteq> (_Exit_)\n  targetnode a' \\<noteq> parent_node mx\n  \\<forall>ai.\n     valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n     ai \\<notin> get_return_edges a'", "obtain msi \n            where \"CFG_node(targetnode a') cd-msi\\<rightarrow>\\<^sub>d* CFG_node(parent_node mx)\""], ["proof (prove)\nusing this:\n  targetnode a' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node mx\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  parent_node mx \\<noteq> (_Exit_)\n  targetnode a' \\<noteq> parent_node mx\n  \\<forall>ai.\n     valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n     ai \\<notin> get_return_edges a'\n\ngoal (1 subgoal):\n 1. (\\<And>msi.\n        CFG_node\n         (targetnode\n           a') cd-msi\\<rightarrow>\\<^sub>d* CFG_node\n       (parent_node mx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:in_proc_cdep_SDG_path)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode a') cd-msi\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from \\<open>valid_SDG_node mx\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node mx", "have \"mx = CFG_node (parent_node mx) \\<or> CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\""], ["proof (prove)\nusing this:\n  valid_SDG_node mx\n\ngoal (1 subgoal):\n 1. mx = CFG_node (parent_node mx) \\<or>\n    CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx", "by(rule valid_SDG_node_cases)"], ["proof (state)\nthis:\n  mx = CFG_node (parent_node mx) \\<or>\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (2 subgoals):\n 1. \\<forall>ai.\n       valid_edge ai \\<and> sourcenode ai = parent_node mx \\<longrightarrow>\n       ai \\<notin> get_return_edges a' \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  mx = CFG_node (parent_node mx) \\<or>\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mx = CFG_node (parent_node mx) \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "assume \"mx = CFG_node (parent_node mx)\""], ["proof (state)\nthis:\n  mx = CFG_node (parent_node mx)\n\ngoal (2 subgoals):\n 1. mx = CFG_node (parent_node mx) \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>CFG_node(targetnode a')cd-msi\\<rightarrow>\\<^sub>d* CFG_node(parent_node mx)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (targetnode a') cd-msi\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  mx = CFG_node (parent_node mx)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode a') cd-msi\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  mx = CFG_node (parent_node mx)\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "assume \"CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\""], ["proof (state)\nthis:\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>CFG_node(targetnode a')cd-msi\\<rightarrow>\\<^sub>d* CFG_node(parent_node mx)\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (targetnode a') cd-msi\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx", "have \"CFG_node(targetnode a') cd-msi@[CFG_node(parent_node mx)]\\<rightarrow>\\<^sub>d* mx\""], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode a') cd-msi\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a') cd-msi @ [CFG_node (parent_node mx)]\\<rightarrow>\\<^sub>d* mx", "by(fastforce intro:cdSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a') cd-msi @ [CFG_node (parent_node mx)]\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') cd-msi @ [CFG_node (parent_node mx)]\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>ai.\n             valid_edge ai \\<and>\n             sourcenode ai = parent_node mx \\<longrightarrow>\n             ai \\<notin> get_return_edges a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>ai.\n             valid_edge ai \\<and>\n             sourcenode ai = parent_node mx \\<longrightarrow>\n             ai \\<notin> get_return_edges a')", "obtain ai where \"valid_edge ai\" and \"sourcenode ai = parent_node mx\"\n            and \"ai \\<in> get_return_edges a'\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ai.\n             valid_edge ai \\<and>\n             sourcenode ai = parent_node mx \\<longrightarrow>\n             ai \\<notin> get_return_edges a')\n\ngoal (1 subgoal):\n 1. (\\<And>ai.\n        \\<lbrakk>valid_edge ai; sourcenode ai = parent_node mx;\n         ai \\<in> get_return_edges a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ai\n  sourcenode ai = parent_node mx\n  ai \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  valid_edge ai\n  sourcenode ai = parent_node mx\n  ai \\<in> get_return_edges a'", "have \"CFG_node (targetnode a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (parent_node mx)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  valid_edge ai\n  sourcenode ai = parent_node mx\n  ai \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (parent_node mx)", "by(auto intro:SDG_proc_entry_exit_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (parent_node mx)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  CFG_node\n   (targetnode\n     a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (parent_node mx)", "have cd_path:\"CFG_node (targetnode a') cd-[]@[CFG_node (targetnode a')]\\<rightarrow>\\<^sub>d* \n                        CFG_node (parent_node mx)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  CFG_node\n   (targetnode\n     a') \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node (parent_node mx)\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a') cd-[] @\n              [CFG_node\n                (targetnode\n                  a')]\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)", "by(fastforce intro:cdSp_Append_cdep cdSp_Nil)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a') cd-[] @\n            [CFG_node\n              (targetnode\n                a')]\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "from \\<open>valid_SDG_node mx\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node mx", "have \"mx = CFG_node (parent_node mx) \\<or> CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\""], ["proof (prove)\nusing this:\n  valid_SDG_node mx\n\ngoal (1 subgoal):\n 1. mx = CFG_node (parent_node mx) \\<or>\n    CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx", "by(rule valid_SDG_node_cases)"], ["proof (state)\nthis:\n  mx = CFG_node (parent_node mx) \\<or>\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ai.\n               valid_edge ai \\<and>\n               sourcenode ai = parent_node mx \\<longrightarrow>\n               ai \\<notin> get_return_edges a') \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  mx = CFG_node (parent_node mx) \\<or>\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mx = CFG_node (parent_node mx) \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "assume \"mx = CFG_node (parent_node mx)\""], ["proof (state)\nthis:\n  mx = CFG_node (parent_node mx)\n\ngoal (2 subgoals):\n 1. mx = CFG_node (parent_node mx) \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n 2. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with cd_path"], ["proof (chain)\npicking this:\n  CFG_node\n   (targetnode\n     a') cd-[] @\n            [CFG_node\n              (targetnode\n                a')]\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  mx = CFG_node (parent_node mx)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') cd-[] @\n            [CFG_node\n              (targetnode\n                a')]\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  mx = CFG_node (parent_node mx)\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "assume \"CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\""], ["proof (state)\nthis:\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "with cd_path"], ["proof (chain)\npicking this:\n  CFG_node\n   (targetnode\n     a') cd-[] @\n            [CFG_node\n              (targetnode\n                a')]\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx", "have \"CFG_node (targetnode a') \n              cd-[CFG_node (targetnode a')]@[CFG_node (parent_node mx)]\\<rightarrow>\\<^sub>d* mx\""], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') cd-[] @\n            [CFG_node\n              (targetnode\n                a')]\\<rightarrow>\\<^sub>d* CFG_node (parent_node mx)\n  CFG_node (parent_node mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (targetnode\n       a') cd-[CFG_node (targetnode a')] @\n              [CFG_node (parent_node mx)]\\<rightarrow>\\<^sub>d* mx", "by(fastforce intro:cdSp_Append_cdep)"], ["proof (state)\nthis:\n  CFG_node\n   (targetnode\n     a') cd-[CFG_node (targetnode a')] @\n            [CFG_node (parent_node mx)]\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       mx) \\<longrightarrow>\\<^bsub>cd\\<^esub> mx \\<Longrightarrow>\n    \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node\n   (targetnode\n     a') cd-[CFG_node (targetnode a')] @\n            [CFG_node (parent_node mx)]\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<exists>msx''.\n       CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "then"], ["proof (chain)\npicking this:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx", "obtain msx'' \n        where \"CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\""], ["proof (prove)\nusing this:\n  \\<exists>msx''. CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. (\\<And>msx''.\n        CFG_node\n         (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "hence \"CFG_node (targetnode a') i-msx''\\<rightarrow>\\<^sub>d* mx\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a') cd-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a') i-msx''\\<rightarrow>\\<^sub>d* mx", "by(rule cdep_SDG_path_intra_SDG_path)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') i-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  CFG_node (targetnode a') i-msx''\\<rightarrow>\\<^sub>d* mx", "have \"matched (CFG_node (targetnode a')) ([]@msx'') mx\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  CFG_node (targetnode a') i-msx''\\<rightarrow>\\<^sub>d* mx\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) ([] @ msx'') mx", "by(fastforce intro:matched_Append_intra_SDG_path matched_Nil)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) ([] @ msx'') mx\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with \\<open>matched mx (msx@msx') n''\\<close>"], ["proof (chain)\npicking this:\n  matched mx (msx @ msx') n''\n  matched (CFG_node (targetnode a')) ([] @ msx'') mx", "have \"matched (CFG_node (targetnode a')) (msx''@(msx@msx')) n''\""], ["proof (prove)\nusing this:\n  matched mx (msx @ msx') n''\n  matched (CFG_node (targetnode a')) ([] @ msx'') mx\n\ngoal (1 subgoal):\n 1. matched (CFG_node (targetnode a')) (msx'' @ msx @ msx') n''", "by(fastforce intro:matched_Append)"], ["proof (state)\nthis:\n  matched (CFG_node (targetnode a')) (msx'' @ msx @ msx') n''\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with \\<open>valid_edge a'\\<close> \\<open>CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\\<close>\n        \\<open>n'' -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or> n'' -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\\<close> \\<open>a \\<in> get_return_edges a'\\<close>\n        \\<open>parent_node n'' = sourcenode a\\<close> \\<open>parent_node n' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  n'' -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  a \\<in> get_return_edges a'\n  parent_node n'' = sourcenode a\n  parent_node n' = targetnode a\n  matched (CFG_node (targetnode a')) (msx'' @ msx @ msx') n''", "have \"matched (CFG_node (sourcenode a')) \n        ([]@CFG_node (sourcenode a')#(msx''@(msx@msx'))@[n'']) n'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n  n'' -p\\<rightarrow>\\<^bsub>ret\\<^esub> n' \\<or>\n  n'' -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n'\n  a \\<in> get_return_edges a'\n  parent_node n'' = sourcenode a\n  parent_node n' = targetnode a\n  matched (CFG_node (targetnode a')) (msx'' @ msx @ msx') n''\n\ngoal (1 subgoal):\n 1. matched (CFG_node (sourcenode a'))\n     ([] @ CFG_node (sourcenode a') # (msx'' @ msx @ msx') @ [n'']) n'", "by(fastforce intro:matched_bracket_call matched_Nil sum_SDG_edge_SDG_edge)"], ["proof (state)\nthis:\n  matched (CFG_node (sourcenode a'))\n   ([] @ CFG_node (sourcenode a') # (msx'' @ msx @ msx') @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx nsx.\n                            matched nx nsx n' \\<and>\n                            n \\<in> set nsx \\<and>\n                            nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n                              (parent_node n')", "with \\<open>n \\<in> set msx\\<close> \\<open>CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\\<close>\n        \\<open>parent_node n' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> set msx\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n  parent_node n' = targetnode a\n  matched (CFG_node (sourcenode a'))\n   ([] @ CFG_node (sourcenode a') # (msx'' @ msx @ msx') @ [n'']) n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set msx\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n  parent_node n' = targetnode a\n  matched (CFG_node (sourcenode a'))\n   ([] @ CFG_node (sourcenode a') # (msx'' @ msx @ msx') @ [n'']) n'\n\ngoal (1 subgoal):\n 1. \\<exists>nx nsx.\n       matched nx nsx n' \\<and>\n       n \\<in> set nsx \\<and>\n       nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>nx nsx.\n     matched nx nsx n' \\<and>\n     n \\<in> set nsx \\<and>\n     nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nx nsx.\n     matched nx nsx n' \\<and>\n     n \\<in> set nsx \\<and>\n     nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nx nsx.\n     matched nx nsx n' \\<and>\n     n \\<in> set nsx \\<and>\n     nx s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node n')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irs_SDG_path_realizable:\n  assumes \"n irs-ns\\<rightarrow>\\<^sub>d* n'\" and \"n \\<noteq> n'\"\n  obtains ns' where \"realizable (CFG_node (_Entry_)) ns' n'\" and \"n \\<in> set ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>realizable (CFG_node (_Entry_)) ns' n';\n         n \\<in> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns'", "from \\<open>n irs-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n'", "have \"n = n' \\<or> (\\<exists>ns'. realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\""], ["proof (prove)\nusing this:\n  n irs-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "proof(rule irs_SDG_path_split)"], ["proof (state)\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "assume \"n is-ns\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (2 subgoals):\n 1. n is-ns\\<rightarrow>\\<^sub>d* n' \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n 2. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "proof(cases \"ns = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n 2. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "case True"], ["proof (state)\nthis:\n  ns = []\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n 2. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "with \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n  ns = []", "have \"n = n'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n  ns = []\n\ngoal (1 subgoal):\n 1. n = n'", "by(fastforce elim:intra_sum_SDG_path.cases)"], ["proof (state)\nthis:\n  n = n'\n\ngoal (2 subgoals):\n 1. ns = [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n 2. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = n'\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "by simp"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "case False"], ["proof (state)\nthis:\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "with \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n  ns \\<noteq> []", "have \"n \\<in> set ns\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n  ns \\<noteq> []\n\ngoal (1 subgoal):\n 1. n \\<in> set ns", "by(fastforce dest:is_SDG_path_hd)"], ["proof (state)\nthis:\n  n \\<in> set ns\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'", "have \"valid_SDG_node n\" and \"valid_SDG_node n'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. valid_SDG_node n &&& valid_SDG_node n'", "by(rule is_SDG_path_valid_SDG_node)+"], ["proof (state)\nthis:\n  valid_SDG_node n\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "hence \"valid_node (parent_node n)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  valid_SDG_node n'\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n)", "by -(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node n)\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'", "obtain ns' where \"matched n ns' n'\" and \"set ns \\<subseteq> set ns'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>matched n ns' n'; set ns \\<subseteq> set ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule is_SDG_path_matched)"], ["proof (state)\nthis:\n  matched n ns' n'\n  set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "with \\<open>n \\<in> set ns\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> set ns\n  matched n ns' n'\n  set ns \\<subseteq> set ns'", "have \"n \\<in> set ns'\""], ["proof (prove)\nusing this:\n  n \\<in> set ns\n  matched n ns' n'\n  set ns \\<subseteq> set ns'\n\ngoal (1 subgoal):\n 1. n \\<in> set ns'", "by fastforce"], ["proof (state)\nthis:\n  n \\<in> set ns'\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "from \\<open>valid_node (parent_node n)\\<close>"], ["proof (chain)\npicking this:\n  valid_node (parent_node n)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_node (parent_node n)\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "proof(cases \"parent_node n = (_Exit_)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node n); parent_node n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "case True"], ["proof (state)\nthis:\n  parent_node n = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node n); parent_node n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  parent_node n = (_Exit_)", "have \"n = CFG_node (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  parent_node n = (_Exit_)\n\ngoal (1 subgoal):\n 1. n = CFG_node (_Exit_)", "by(rule valid_SDG_node_parent_Exit)"], ["proof (state)\nthis:\n  n = CFG_node (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node n); parent_node n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "from \\<open>n is-ns\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'", "obtain as where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  n is-ns\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        parent_node\n         n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule is_SDG_path_intra_CFG_path)"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node n); parent_node n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>n = CFG_node (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n = CFG_node (_Exit_)\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"parent_node n' = (_Exit_)\""], ["proof (prove)\nusing this:\n  n = CFG_node (_Exit_)\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. parent_node n' = (_Exit_)", "by(fastforce dest:path_Exit_source simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node n' = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node n); parent_node n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>valid_SDG_node n'\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n'\n  parent_node n' = (_Exit_)", "have \"n' = CFG_node (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_SDG_node n'\n  parent_node n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = CFG_node (_Exit_)", "by(rule valid_SDG_node_parent_Exit)"], ["proof (state)\nthis:\n  n' = CFG_node (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node n); parent_node n = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>n = CFG_node (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n = CFG_node (_Exit_)\n  n' = CFG_node (_Exit_)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = CFG_node (_Exit_)\n  n' = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "by simp"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "case False"], ["proof (state)\nthis:\n  parent_node n \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>valid_SDG_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node n\n  parent_node n \\<noteq> (_Exit_)", "obtain nsx where \"CFG_node (_Entry_) cc-nsx\\<rightarrow>\\<^sub>d* n\""], ["proof (prove)\nusing this:\n  valid_SDG_node n\n  parent_node n \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>nsx.\n        CFG_node (_Entry_) cc-nsx\\<rightarrow>\\<^sub>d* n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule Entry_cc_SDG_path_to_inner_node)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-nsx\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "hence \"realizable (CFG_node (_Entry_)) nsx n\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-nsx\\<rightarrow>\\<^sub>d* n\n\ngoal (1 subgoal):\n 1. realizable (CFG_node (_Entry_)) nsx n", "by(rule cdep_SDG_path_realizable)"], ["proof (state)\nthis:\n  realizable (CFG_node (_Entry_)) nsx n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>matched n ns' n'\\<close>"], ["proof (chain)\npicking this:\n  matched n ns' n'\n  realizable (CFG_node (_Entry_)) nsx n", "have \"realizable (CFG_node (_Entry_)) (nsx@ns') n'\""], ["proof (prove)\nusing this:\n  matched n ns' n'\n  realizable (CFG_node (_Entry_)) nsx n\n\ngoal (1 subgoal):\n 1. realizable (CFG_node (_Entry_)) (nsx @ ns') n'", "by -(rule realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable (CFG_node (_Entry_)) (nsx @ ns') n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node n);\n     parent_node n \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>n \\<in> set ns'\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> set ns'\n  realizable (CFG_node (_Entry_)) (nsx @ ns') n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set ns'\n  realizable (CFG_node (_Entry_)) (nsx @ ns') n'\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "by fastforce"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "fix nsx nsx' nx nx' p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "assume \"ns = nsx@nx#nsx'\" and \"n irs-nsx\\<rightarrow>\\<^sub>d* nx\"\n      and \"nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\" and \"nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\""], ["proof (state)\nthis:\n  ns = nsx @ nx # nsx'\n  n irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "from \\<open>nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\\<close>"], ["proof (chain)\npicking this:\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')", "have \"CFG_node (parent_node nx) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node nx')\""], ["proof (prove)\nusing this:\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n\ngoal (1 subgoal):\n 1. CFG_node\n     (parent_node\n       nx) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node nx')", "by(fastforce elim:sum_SDG_edge.cases intro:sum_SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (parent_node\n     nx) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node nx')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "then"], ["proof (chain)\npicking this:\n  CFG_node\n   (parent_node\n     nx) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node nx')", "obtain a Q f where \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n      and \"parent_node nx = sourcenode a\" and \"parent_node nx' = targetnode a\""], ["proof (prove)\nusing this:\n  CFG_node\n   (parent_node\n     nx) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node nx')\n\ngoal (1 subgoal):\n 1. (\\<And>a Q f.\n        \\<lbrakk>valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         parent_node nx = sourcenode a;\n         parent_node nx' = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:sum_SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  parent_node nx = sourcenode a\n  parent_node nx' = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain a' Q' r' fs' \n      where \"a \\<in> get_return_edges a'\" and \"valid_edge a'\" and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\"\n      and \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' r' fs'.\n        \\<lbrakk>a \\<in> get_return_edges a'; valid_edge a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         CFG_node\n          (sourcenode\n            a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n               (targetnode a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule return_edge_determines_call_and_sum_edge)"], ["proof (state)\nthis:\n  a \\<in> get_return_edges a'\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'", "have \"CFG_node (sourcenode a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:sum_SDG_call_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a') s-p\\<rightarrow>\\<^bsub>call\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "from \\<open>n irs-nsx\\<rightarrow>\\<^sub>d* nx\\<close> \\<open>nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or> (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\\<close>"], ["proof (chain)\npicking this:\n  n irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')", "obtain m ms where \"matched m ms nx'\" and \"n \\<in> set ms\"\n      and \"m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')\""], ["proof (prove)\nusing this:\n  n irs-nsx\\<rightarrow>\\<^sub>d* nx\n  nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n  (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx')\n\ngoal (1 subgoal):\n 1. (\\<And>m ms.\n        \\<lbrakk>matched m ms nx'; n \\<in> set ms;\n         m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node\n          (parent_node nx')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:irs_SDG_path_matched)"], ["proof (state)\nthis:\n  matched m ms nx'\n  n \\<in> set ms\n  m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "from \\<open>nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<close>"], ["proof (chain)\npicking this:\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'", "obtain ms' where \"matched nx' ms' n'\" \n      and \"set nsx' \\<subseteq> set ms'\""], ["proof (prove)\nusing this:\n  nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\n\ngoal (1 subgoal):\n 1. (\\<And>ms'.\n        \\<lbrakk>matched nx' ms' n'; set nsx' \\<subseteq> set ms'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule is_SDG_path_matched)"], ["proof (state)\nthis:\n  matched nx' ms' n'\n  set nsx' \\<subseteq> set ms'\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "with \\<open>matched m ms nx'\\<close>"], ["proof (chain)\npicking this:\n  matched m ms nx'\n  matched nx' ms' n'\n  set nsx' \\<subseteq> set ms'", "have \"matched m (ms@ms') n'\""], ["proof (prove)\nusing this:\n  matched m ms nx'\n  matched nx' ms' n'\n  set nsx' \\<subseteq> set ms'\n\ngoal (1 subgoal):\n 1. matched m (ms @ ms') n'", "by -(rule matched_Append)"], ["proof (state)\nthis:\n  matched m (ms @ ms') n'\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "from \\<open>m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')\\<close>"], ["proof (chain)\npicking this:\n  m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')", "have \"valid_SDG_node m\""], ["proof (prove)\nusing this:\n  m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')\n\ngoal (1 subgoal):\n 1. valid_SDG_node m", "by(rule sum_SDG_edge_valid_SDG_node)"], ["proof (state)\nthis:\n  valid_SDG_node m\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "hence \"valid_node (parent_node m)\""], ["proof (prove)\nusing this:\n  valid_SDG_node m\n\ngoal (1 subgoal):\n 1. valid_node (parent_node m)", "by(rule valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  valid_node (parent_node m)\n\ngoal (1 subgoal):\n 1. \\<And>nsx nsx' nx nx' p.\n       \\<lbrakk>ns = nsx @ nx # nsx'; n irs-nsx\\<rightarrow>\\<^sub>d* nx;\n        nx s-p\\<rightarrow>\\<^bsub>ret\\<^esub> nx' \\<or>\n        (\\<exists>V. nx s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> nx');\n        nx' is-nsx'\\<rightarrow>\\<^sub>d* n'\\<rbrakk>\n       \\<Longrightarrow> n = n' \\<or>\n                         (\\<exists>ns'.\n                             realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                             n \\<in> set ns')", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_node (parent_node m)\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "proof(cases \"parent_node m = (_Exit_)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node m); parent_node m = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "case True"], ["proof (state)\nthis:\n  parent_node m = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node m); parent_node m = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "from \\<open>m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')\\<close>"], ["proof (chain)\npicking this:\n  m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')", "obtain a where \"valid_edge a\" \n        and \"sourcenode a = parent_node m\""], ["proof (prove)\nusing this:\n  m s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (parent_node nx')\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = parent_node m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:sum_SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = parent_node m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node m); parent_node m = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with True"], ["proof (chain)\npicking this:\n  parent_node m = (_Exit_)\n  valid_edge a\n  sourcenode a = parent_node m", "have False"], ["proof (prove)\nusing this:\n  parent_node m = (_Exit_)\n  valid_edge a\n  sourcenode a = parent_node m\n\ngoal (1 subgoal):\n 1. False", "by -(rule Exit_source,simp_all)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (parent_node m); parent_node m = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')\n 2. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "by simp"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "case False"], ["proof (state)\nthis:\n  parent_node m \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>valid_SDG_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node m\n  parent_node m \\<noteq> (_Exit_)", "obtain ms'' where \"CFG_node (_Entry_) cc-ms''\\<rightarrow>\\<^sub>d* m\""], ["proof (prove)\nusing this:\n  valid_SDG_node m\n  parent_node m \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>ms''.\n        CFG_node (_Entry_) cc-ms''\\<rightarrow>\\<^sub>d* m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule Entry_cc_SDG_path_to_inner_node)"], ["proof (state)\nthis:\n  CFG_node (_Entry_) cc-ms''\\<rightarrow>\\<^sub>d* m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "hence \"realizable (CFG_node (_Entry_)) ms'' m\""], ["proof (prove)\nusing this:\n  CFG_node (_Entry_) cc-ms''\\<rightarrow>\\<^sub>d* m\n\ngoal (1 subgoal):\n 1. realizable (CFG_node (_Entry_)) ms'' m", "by(rule cdep_SDG_path_realizable)"], ["proof (state)\nthis:\n  realizable (CFG_node (_Entry_)) ms'' m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>matched m (ms@ms') n'\\<close>"], ["proof (chain)\npicking this:\n  matched m (ms @ ms') n'\n  realizable (CFG_node (_Entry_)) ms'' m", "have \"realizable (CFG_node (_Entry_)) (ms''@(ms@ms')) n'\""], ["proof (prove)\nusing this:\n  matched m (ms @ ms') n'\n  realizable (CFG_node (_Entry_)) ms'' m\n\ngoal (1 subgoal):\n 1. realizable (CFG_node (_Entry_)) (ms'' @ ms @ ms') n'", "by -(rule realizable_Append_matched)"], ["proof (state)\nthis:\n  realizable (CFG_node (_Entry_)) (ms'' @ ms @ ms') n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (parent_node m);\n     parent_node m \\<noteq> (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> n = n' \\<or>\n                      (\\<exists>ns'.\n                          realizable (CFG_node (_Entry_)) ns' n' \\<and>\n                          n \\<in> set ns')", "with \\<open>n \\<in> set ms\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> set ms\n  realizable (CFG_node (_Entry_)) (ms'' @ ms @ ms') n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set ms\n  realizable (CFG_node (_Entry_)) (ms'' @ ms @ ms') n'\n\ngoal (1 subgoal):\n 1. n = n' \\<or>\n    (\\<exists>ns'.\n        realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "by fastforce"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns'", "with \\<open>n \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> n'\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')", "show \"\\<exists>ns'. realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns'\""], ["proof (prove)\nusing this:\n  n \\<noteq> n'\n  n = n' \\<or>\n  (\\<exists>ns'.\n      realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns')\n\ngoal (1 subgoal):\n 1. \\<exists>ns'.\n       realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns'", "by simp"], ["proof (state)\nthis:\n  \\<exists>ns'.\n     realizable (CFG_node (_Entry_)) ns' n' \\<and> n \\<in> set ns'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}