{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/JinjaVM_Inter/JVMInterpretation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma in_set_methodsI: \"map_of ms M = \\<lfloor>(Ts, T, mxs, mxl\\<^sub>0, is, xt)\\<rfloor>\n  \\<Longrightarrow> ((C', M), Heap # map Local [0..<length Ts] @ [Local (length Ts)], [Heap, Stack 0, Exception])\n  \\<in> set (methods C' ms)\"", "lemma in_methods_in_msD: \"((C, M), ins, outs) \\<in> set (methods D ms)\n  \\<Longrightarrow> M \\<in> set (map fst ms) \\<and> D = C\"", "lemma in_methods_in_msD': \"((C, M), ins, outs) \\<in> set (methods D ms)\n  \\<Longrightarrow> \\<exists>Ts T mb. (M, Ts, T, mb) \\<in> set ms\n  \\<and> D = C\n  \\<and> ins = Heap # (map Local [0..<Suc (length Ts)])\n  \\<and> outs = [Heap, Stack 0, Exception]\"", "lemma in_set_methodsE:\n  assumes \"((C, M), ins, outs) \\<in> set (methods D ms)\"\n  obtains Ts T mb\n  where \"(M, Ts, T, mb) \\<in> set ms\"\n  and \"D = C\"\n  and \"ins = Heap # (map Local [0..<Suc (length Ts)])\"\n  and \"outs = [Heap, Stack 0, Exception]\"", "lemma in_set_procsI:\n  assumes sees: \"P \\<turnstile> D sees M: Ts\\<rightarrow>T = mb in D\"\n  and ins_def: \"ins = Heap # map Local [0..<Suc (length Ts)]\"\n  and outs_def: \"outs = [Heap, Stack 0, Exception]\"\n  shows \"((D, M), ins, outs) \\<in> set (procs P)\"", "lemma distinct_methods: \"distinct (map fst ms) \\<Longrightarrow> distinct (map fst (methods C ms))\"", "lemma in_set_procsD:\n  \"((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow> \\<exists>D fs ms. (C, D, fs, ms) \\<in> set P \\<and> M \\<in> set (map fst ms)\"", "lemma in_set_procsE':\n  assumes \"((C, M), ins, outs) \\<in> set (procs P)\"\n  obtains D fs ms Ts T mb \n  where \"(C, D, fs, ms) \\<in> set P\"\n  and \"(M, Ts, T, mb) \\<in> set ms\"\n  and \"ins = Heap # (map (\\<lambda>n. Local n) [0..<Suc (length Ts)])\"\n  and \"outs = [Heap, Stack 0, Exception]\"", "lemma distinct_Local_vars [simp]: \"distinct (map Local [0..<n])\"", "lemma distinct_Stack_vars [simp]: \"distinct (map Stack [0..<n])\"", "lemma get_return_edgesE [elim!]:\n  assumes \"a \\<in> get_return_edges P a'\"\n  obtains Q C M pc D M' paramDefs where\n  \"kind a' = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\"\n  and \"a = ((D, M', None, Return),\n  (\\<lambda>(s, ret). ret = (C, M, pc))\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>(\\<lambda>s s'. s'(Heap := s Heap, Exception := s Exception,\n  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0))),\n  (C, M, \\<lfloor>pc\\<rfloor>, Return))\"", "lemma distinct_class_names: \"distinct_fst (PROG P)\"", "lemma distinct_method_names:\n  \"class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow> distinct_fst ms\"", "lemma distinct_fst_is_distinct_fst: \"distinct_fst = BasicDefs.distinct_fst\"", "lemma ClassMain_not_in_set_PROG [dest!]: \"(ClassMain P, D, fs, ms) \\<in> set (PROG P) \\<Longrightarrow> False\"", "lemma in_set_procsE:\n  assumes \"((C, M), ins, outs) \\<in> set (procs (PROG P))\"\n  obtains D fs ms Ts T mb \n  where \"class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\"\n  and \"PROG P \\<turnstile> C sees M:Ts\\<rightarrow>T = mb in C\"\n  and \"ins = Heap # (map (\\<lambda>n. Local n) [0..<Suc (length Ts)])\"\n  and \"outs = [Heap, Stack 0, Exception]\""], "translations": [["", "lemma in_set_methodsI: \"map_of ms M = \\<lfloor>(Ts, T, mxs, mxl\\<^sub>0, is, xt)\\<rfloor>\n  \\<Longrightarrow> ((C', M), Heap # map Local [0..<length Ts] @ [Local (length Ts)], [Heap, Stack 0, Exception])\n  \\<in> set (methods C' ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of ms M =\n    \\<lfloor>(Ts, T, mxs, mxl\\<^sub>0, is, xt)\\<rfloor> \\<Longrightarrow>\n    ((C', M), Heap # map Local [0..<length Ts] @ [Local (length Ts)],\n     [Heap, Stack 0, Exception])\n    \\<in> set (methods C' ms)", "by (induct rule: methods.induct) (auto split: if_split_asm)"], ["", "lemma in_methods_in_msD: \"((C, M), ins, outs) \\<in> set (methods D ms)\n  \\<Longrightarrow> M \\<in> set (map fst ms) \\<and> D = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((C, M), ins, outs) \\<in> set (methods D ms) \\<Longrightarrow>\n    M \\<in> set (map fst ms) \\<and> D = C", "by (induct ms) auto"], ["", "lemma in_methods_in_msD': \"((C, M), ins, outs) \\<in> set (methods D ms)\n  \\<Longrightarrow> \\<exists>Ts T mb. (M, Ts, T, mb) \\<in> set ms\n  \\<and> D = C\n  \\<and> ins = Heap # (map Local [0..<Suc (length Ts)])\n  \\<and> outs = [Heap, Stack 0, Exception]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((C, M), ins, outs) \\<in> set (methods D ms) \\<Longrightarrow>\n    \\<exists>Ts T mb.\n       (M, Ts, T, mb) \\<in> set ms \\<and>\n       D = C \\<and>\n       ins = Heap # map Local [0..<Suc (length Ts)] \\<and>\n       outs = [Heap, Stack 0, Exception]", "by (induct rule: methods.induct) fastforce+"], ["", "lemma in_set_methodsE:\n  assumes \"((C, M), ins, outs) \\<in> set (methods D ms)\"\n  obtains Ts T mb\n  where \"(M, Ts, T, mb) \\<in> set ms\"\n  and \"D = C\"\n  and \"ins = Heap # (map Local [0..<Suc (length Ts)])\"\n  and \"outs = [Heap, Stack 0, Exception]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ts T mb.\n        \\<lbrakk>(M, Ts, T, mb) \\<in> set ms; D = C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ((C, M), ins, outs) \\<in> set (methods D ms)\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mb.\n        \\<lbrakk>(M, Ts, T, mb) \\<in> set ms; D = C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct ms) fastforce+"], ["", "lemma in_set_procsI:\n  assumes sees: \"P \\<turnstile> D sees M: Ts\\<rightarrow>T = mb in D\"\n  and ins_def: \"ins = Heap # map Local [0..<Suc (length Ts)]\"\n  and outs_def: \"outs = [Heap, Stack 0, Exception]\"\n  shows \"((D, M), ins, outs) \\<in> set (procs P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((D, M), ins, outs) \\<in> set (procs P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((D, M), ins, outs) \\<in> set (procs P)", "from sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees M: Ts\\<rightarrow>T = mb in D", "obtain D' fs ms where \"map_of P D = \\<lfloor>(D', fs, ms)\\<rfloor>\" and \"map_of ms M = \\<lfloor>(Ts, T, mb)\\<rfloor>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees M: Ts\\<rightarrow>T = mb in D\n\ngoal (1 subgoal):\n 1. (\\<And>D' fs ms.\n        \\<lbrakk>map_of P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n         map_of ms M = \\<lfloor>(Ts, T, mb)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: visible_method_exists simp: class_def)"], ["proof (state)\nthis:\n  map_of P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, mb)\\<rfloor>\n\ngoal (1 subgoal):\n 1. ((D, M), ins, outs) \\<in> set (procs P)", "hence \"(D, D', fs, ms) \\<in> set P\""], ["proof (prove)\nusing this:\n  map_of P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, mb)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (D, D', fs, ms) \\<in> set P", "by -(drule map_of_SomeD)"], ["proof (state)\nthis:\n  (D, D', fs, ms) \\<in> set P\n\ngoal (1 subgoal):\n 1. ((D, M), ins, outs) \\<in> set (procs P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (D, D', fs, ms) \\<in> set P\n\ngoal (1 subgoal):\n 1. ((D, M), ins, outs) \\<in> set (procs P)", "proof (induct P)"], ["proof (state)\ngoal (2 subgoals):\n 1. (D, D', fs, ms) \\<in> set [] \\<Longrightarrow>\n    ((D, M), ins, outs) \\<in> set (procs [])\n 2. \\<And>a P.\n       \\<lbrakk>(D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n                ((D, M), ins, outs) \\<in> set (procs P);\n        (D, D', fs, ms) \\<in> set (a # P)\\<rbrakk>\n       \\<Longrightarrow> ((D, M), ins, outs) \\<in> set (procs (a # P))", "case Nil"], ["proof (state)\nthis:\n  (D, D', fs, ms) \\<in> set []\n\ngoal (2 subgoals):\n 1. (D, D', fs, ms) \\<in> set [] \\<Longrightarrow>\n    ((D, M), ins, outs) \\<in> set (procs [])\n 2. \\<And>a P.\n       \\<lbrakk>(D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n                ((D, M), ins, outs) \\<in> set (procs P);\n        (D, D', fs, ms) \\<in> set (a # P)\\<rbrakk>\n       \\<Longrightarrow> ((D, M), ins, outs) \\<in> set (procs (a # P))", "thus ?case"], ["proof (prove)\nusing this:\n  (D, D', fs, ms) \\<in> set []\n\ngoal (1 subgoal):\n 1. ((D, M), ins, outs) \\<in> set (procs [])", "by simp"], ["proof (state)\nthis:\n  ((D, M), ins, outs) \\<in> set (procs [])\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n                ((D, M), ins, outs) \\<in> set (procs P);\n        (D, D', fs, ms) \\<in> set (a # P)\\<rbrakk>\n       \\<Longrightarrow> ((D, M), ins, outs) \\<in> set (procs (a # P))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n                ((D, M), ins, outs) \\<in> set (procs P);\n        (D, D', fs, ms) \\<in> set (a # P)\\<rbrakk>\n       \\<Longrightarrow> ((D, M), ins, outs) \\<in> set (procs (a # P))", "case (Cons Class P)"], ["proof (state)\nthis:\n  (D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n  ((D, M), ins, outs) \\<in> set (procs P)\n  (D, D', fs, ms) \\<in> set (Class # P)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n                ((D, M), ins, outs) \\<in> set (procs P);\n        (D, D', fs, ms) \\<in> set (a # P)\\<rbrakk>\n       \\<Longrightarrow> ((D, M), ins, outs) \\<in> set (procs (a # P))", "with ins_def outs_def \\<open>map_of ms M = \\<lfloor>(Ts, T, mb)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  ins = Heap # map Local [0..<Suc (length Ts)]\n  outs = [Heap, Stack 0, Exception]\n  map_of ms M = \\<lfloor>(Ts, T, mb)\\<rfloor>\n  (D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n  ((D, M), ins, outs) \\<in> set (procs P)\n  (D, D', fs, ms) \\<in> set (Class # P)", "show ?case"], ["proof (prove)\nusing this:\n  ins = Heap # map Local [0..<Suc (length Ts)]\n  outs = [Heap, Stack 0, Exception]\n  map_of ms M = \\<lfloor>(Ts, T, mb)\\<rfloor>\n  (D, D', fs, ms) \\<in> set P \\<Longrightarrow>\n  ((D, M), ins, outs) \\<in> set (procs P)\n  (D, D', fs, ms) \\<in> set (Class # P)\n\ngoal (1 subgoal):\n 1. ((D, M), ins, outs) \\<in> set (procs (Class # P))", "by (cases Class, cases mb) (auto intro: in_set_methodsI)"], ["proof (state)\nthis:\n  ((D, M), ins, outs) \\<in> set (procs (Class # P))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((D, M), ins, outs) \\<in> set (procs P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_methods: \"distinct (map fst ms) \\<Longrightarrow> distinct (map fst (methods C ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ms) \\<Longrightarrow>\n    distinct (map fst (methods C ms))", "proof (induct ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (methods C []))\n 2. \\<And>a ms.\n       \\<lbrakk>distinct (map fst ms) \\<Longrightarrow>\n                distinct (map fst (methods C ms));\n        distinct (map fst (a # ms))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (methods C (a # ms)))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (methods C []))\n 2. \\<And>a ms.\n       \\<lbrakk>distinct (map fst ms) \\<Longrightarrow>\n                distinct (map fst (methods C ms));\n        distinct (map fst (a # ms))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (methods C (a # ms)))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. distinct (map fst (methods C []))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (methods C []))\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       \\<lbrakk>distinct (map fst ms) \\<Longrightarrow>\n                distinct (map fst (methods C ms));\n        distinct (map fst (a # ms))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (methods C (a # ms)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       \\<lbrakk>distinct (map fst ms) \\<Longrightarrow>\n                distinct (map fst (methods C ms));\n        distinct (map fst (a # ms))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (methods C (a # ms)))", "case (Cons M ms)"], ["proof (state)\nthis:\n  distinct (map fst ms) \\<Longrightarrow> distinct (map fst (methods C ms))\n  distinct (map fst (M # ms))\n\ngoal (1 subgoal):\n 1. \\<And>a ms.\n       \\<lbrakk>distinct (map fst ms) \\<Longrightarrow>\n                distinct (map fst (methods C ms));\n        distinct (map fst (a # ms))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (methods C (a # ms)))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst ms) \\<Longrightarrow> distinct (map fst (methods C ms))\n  distinct (map fst (M # ms))\n\ngoal (1 subgoal):\n 1. distinct (map fst (methods C (M # ms)))", "by (cases M) (auto dest: in_methods_in_msD)"], ["proof (state)\nthis:\n  distinct (map fst (methods C (M # ms)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_procsD:\n  \"((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow> \\<exists>D fs ms. (C, D, fs, ms) \\<in> set P \\<and> M \\<in> set (map fst ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n    \\<exists>D fs ms.\n       (C, D, fs, ms) \\<in> set P \\<and> M \\<in> set (map fst ms)", "proof (induct P)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((C, M), ins, out) \\<in> set (procs []) \\<Longrightarrow>\n    \\<exists>D fs ms.\n       (C, D, fs, ms) \\<in> set [] \\<and> M \\<in> set (map fst ms)\n 2. \\<And>a P.\n       \\<lbrakk>((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n                \\<exists>D fs ms.\n                   (C, D, fs, ms) \\<in> set P \\<and>\n                   M \\<in> set (map fst ms);\n        ((C, M), ins, out) \\<in> set (procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D fs ms.\n                            (C, D, fs, ms) \\<in> set (a # P) \\<and>\n                            M \\<in> set (map fst ms)", "case Nil"], ["proof (state)\nthis:\n  ((C, M), ins, out) \\<in> set (procs [])\n\ngoal (2 subgoals):\n 1. ((C, M), ins, out) \\<in> set (procs []) \\<Longrightarrow>\n    \\<exists>D fs ms.\n       (C, D, fs, ms) \\<in> set [] \\<and> M \\<in> set (map fst ms)\n 2. \\<And>a P.\n       \\<lbrakk>((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n                \\<exists>D fs ms.\n                   (C, D, fs, ms) \\<in> set P \\<and>\n                   M \\<in> set (map fst ms);\n        ((C, M), ins, out) \\<in> set (procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D fs ms.\n                            (C, D, fs, ms) \\<in> set (a # P) \\<and>\n                            M \\<in> set (map fst ms)", "thus ?case"], ["proof (prove)\nusing this:\n  ((C, M), ins, out) \\<in> set (procs [])\n\ngoal (1 subgoal):\n 1. \\<exists>D fs ms.\n       (C, D, fs, ms) \\<in> set [] \\<and> M \\<in> set (map fst ms)", "by simp"], ["proof (state)\nthis:\n  \\<exists>D fs ms.\n     (C, D, fs, ms) \\<in> set [] \\<and> M \\<in> set (map fst ms)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n                \\<exists>D fs ms.\n                   (C, D, fs, ms) \\<in> set P \\<and>\n                   M \\<in> set (map fst ms);\n        ((C, M), ins, out) \\<in> set (procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D fs ms.\n                            (C, D, fs, ms) \\<in> set (a # P) \\<and>\n                            M \\<in> set (map fst ms)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n                \\<exists>D fs ms.\n                   (C, D, fs, ms) \\<in> set P \\<and>\n                   M \\<in> set (map fst ms);\n        ((C, M), ins, out) \\<in> set (procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D fs ms.\n                            (C, D, fs, ms) \\<in> set (a # P) \\<and>\n                            M \\<in> set (map fst ms)", "case (Cons Class P)"], ["proof (state)\nthis:\n  ((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n  \\<exists>D fs ms.\n     (C, D, fs, ms) \\<in> set P \\<and> M \\<in> set (map fst ms)\n  ((C, M), ins, out) \\<in> set (procs (Class # P))\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n                \\<exists>D fs ms.\n                   (C, D, fs, ms) \\<in> set P \\<and>\n                   M \\<in> set (map fst ms);\n        ((C, M), ins, out) \\<in> set (procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D fs ms.\n                            (C, D, fs, ms) \\<in> set (a # P) \\<and>\n                            M \\<in> set (map fst ms)", "thus ?case"], ["proof (prove)\nusing this:\n  ((C, M), ins, out) \\<in> set (procs P) \\<Longrightarrow>\n  \\<exists>D fs ms.\n     (C, D, fs, ms) \\<in> set P \\<and> M \\<in> set (map fst ms)\n  ((C, M), ins, out) \\<in> set (procs (Class # P))\n\ngoal (1 subgoal):\n 1. \\<exists>D fs ms.\n       (C, D, fs, ms) \\<in> set (Class # P) \\<and> M \\<in> set (map fst ms)", "by (cases Class) (fastforce dest: in_methods_in_msD intro: rev_image_eqI)"], ["proof (state)\nthis:\n  \\<exists>D fs ms.\n     (C, D, fs, ms) \\<in> set (Class # P) \\<and> M \\<in> set (map fst ms)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_procsE':\n  assumes \"((C, M), ins, outs) \\<in> set (procs P)\"\n  obtains D fs ms Ts T mb \n  where \"(C, D, fs, ms) \\<in> set P\"\n  and \"(M, Ts, T, mb) \\<in> set ms\"\n  and \"ins = Heap # (map (\\<lambda>n. Local n) [0..<Suc (length Ts)])\"\n  and \"outs = [Heap, Stack 0, Exception]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>(C, D, fs, ms) \\<in> set P; (M, Ts, T, mb) \\<in> set ms;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ((C, M), ins, outs) \\<in> set (procs P)\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>(C, D, fs, ms) \\<in> set P; (M, Ts, T, mb) \\<in> set ms;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct P) (fastforce elim: in_set_methodsE)+"], ["", "lemma distinct_Local_vars [simp]: \"distinct (map Local [0..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map Local [0..<n])", "by (induct n) auto"], ["", "lemma distinct_Stack_vars [simp]: \"distinct (map Stack [0..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map Stack [0..<n])", "by (induct n) auto"], ["", "inductive_set get_return_edges :: \"wf_jvmprog \\<Rightarrow> cfg_edge \\<Rightarrow> cfg_edge set\"\n  for P :: \"wf_jvmprog\" \n  and a :: \"cfg_edge\"\n  where\n  \"kind a = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\n  \\<Longrightarrow> ((D, M', None, Return),\n  (\\<lambda>(s, ret). ret = (C, M, pc))\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>(\\<lambda>s s'. s'(Heap := s Heap, Exception := s Exception,\n                                                Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0))),\n      (C, M, \\<lfloor>pc\\<rfloor>, Return)) \\<in> (get_return_edges P a)\""], ["", "lemma get_return_edgesE [elim!]:\n  assumes \"a \\<in> get_return_edges P a'\"\n  obtains Q C M pc D M' paramDefs where\n  \"kind a' = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\"\n  and \"a = ((D, M', None, Return),\n  (\\<lambda>(s, ret). ret = (C, M, pc))\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>(\\<lambda>s s'. s'(Heap := s Heap, Exception := s Exception,\n  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0))),\n  (C, M, \\<lfloor>pc\\<rfloor>, Return))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q C M pc D M' paramDefs.\n        \\<lbrakk>kind a' =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> get_return_edges P a'\n\ngoal (1 subgoal):\n 1. (\\<And>Q C M pc D M' paramDefs.\n        \\<lbrakk>kind a' =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(cases a, cases a', clarsimp, erule get_return_edges.cases, fastforce)"], ["", "lemma distinct_class_names: \"distinct_fst (PROG P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.distinct_fst (PROG P)", "using wf_jvmprog_is_wf_typ [of P]"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>TYPING P\\<^esub> (PROG P)\n\ngoal (1 subgoal):\n 1. Auxiliary.distinct_fst (PROG P)", "by (clarsimp simp: wf_jvm_prog_phi_def wf_prog_def)"], ["", "lemma distinct_method_names:\n  \"class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow> distinct_fst ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n    Auxiliary.distinct_fst ms", "using wf_jvmprog_is_wf_typ [of P]"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>TYPING P\\<^esub> (PROG P)\n\ngoal (1 subgoal):\n 1. class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n    Auxiliary.distinct_fst ms", "unfolding wf_jvm_prog_phi_def"], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>Pa C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method Pa C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (TYPING P C M))\n   (PROG P)\n\ngoal (1 subgoal):\n 1. class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n    Auxiliary.distinct_fst ms", "by (fastforce dest: class_wf simp: wf_cdecl_def)"], ["", "lemma distinct_fst_is_distinct_fst: \"distinct_fst = BasicDefs.distinct_fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.distinct_fst = BasicDefs.distinct_fst", "by (simp add: distinct_fst_def BasicDefs.distinct_fst_def)"], ["", "lemma ClassMain_not_in_set_PROG [dest!]: \"(ClassMain P, D, fs, ms) \\<in> set (PROG P) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ClassMain P, D, fs, ms) \\<in> set (PROG P) \\<Longrightarrow> False", "using distinct_class_names [of P] ClassMain_is_no_class [of P]"], ["proof (prove)\nusing this:\n  Auxiliary.distinct_fst (PROG P)\n  is_class (PROG P) (ClassMain P) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (ClassMain P, D, fs, ms) \\<in> set (PROG P) \\<Longrightarrow> False", "by (fastforce intro: map_of_SomeI simp: class_def)"], ["", "lemma in_set_procsE:\n  assumes \"((C, M), ins, outs) \\<in> set (procs (PROG P))\"\n  obtains D fs ms Ts T mb \n  where \"class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\"\n  and \"PROG P \\<turnstile> C sees M:Ts\\<rightarrow>T = mb in C\"\n  and \"ins = Heap # (map (\\<lambda>n. Local n) [0..<Suc (length Ts)])\"\n  and \"outs = [Heap, Stack 0, Exception]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         PROG P \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         PROG P \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>((C, M), ins, outs) \\<in> set (procs (PROG P))\\<close>"], ["proof (chain)\npicking this:\n  ((C, M), ins, outs) \\<in> set (procs (PROG P))", "obtain D fs ms Ts T mxs mxl\\<^sub>0 \"is\" xt\n    where \"(C, D, fs, ms) \\<in> set (PROG P)\"\n    and \"(M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\"\n    and \"ins = Heap # (map (\\<lambda>n. Local n) [0..<Suc (length Ts)])\"\n    and \"outs = [Heap, Stack 0, Exception]\""], ["proof (prove)\nusing this:\n  ((C, M), ins, outs) \\<in> set (procs (PROG P))\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mxs mxl\\<^sub>0 is xt.\n        \\<lbrakk>(C, D, fs, ms) \\<in> set (PROG P);\n         (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim: in_set_procsE')"], ["proof (state)\nthis:\n  (C, D, fs, ms) \\<in> set (PROG P)\n  (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\n  ins = Heap # map Local [0..<Suc (length Ts)]\n  outs = [Heap, Stack 0, Exception]\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         PROG P \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (C, D, fs, ms) \\<in> set (PROG P)\n  (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\n  ins = Heap # map Local [0..<Suc (length Ts)]\n  outs = [Heap, Stack 0, Exception]\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         PROG P \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>(C, D, fs, ms) \\<in> set (PROG P)\\<close> distinct_class_names [of P]"], ["proof (chain)\npicking this:\n  (C, D, fs, ms) \\<in> set (PROG P)\n  Auxiliary.distinct_fst (PROG P)", "have \"class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\""], ["proof (prove)\nusing this:\n  (C, D, fs, ms) \\<in> set (PROG P)\n  Auxiliary.distinct_fst (PROG P)\n\ngoal (1 subgoal):\n 1. class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>", "by (fastforce intro: map_of_SomeI simp: class_def)"], ["proof (state)\nthis:\n  class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         PROG P \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         PROG P \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from wf_jvmprog_is_wf_typ [of P]\n    \\<open>(M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\\<close> \\<open>(C, D, fs, ms) \\<in> set (PROG P)\\<close>"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>TYPING P\\<^esub> (PROG P)\n  (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\n  (C, D, fs, ms) \\<in> set (PROG P)", "have \"PROG P \\<turnstile> C sees M:Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is, xt) in C\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>TYPING P\\<^esub> (PROG P)\n  (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\n  (C, D, fs, ms) \\<in> set (PROG P)\n\ngoal (1 subgoal):\n 1. PROG\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n            xt) in C", "by (fastforce intro: mdecl_visible simp: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  PROG\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n          xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms Ts T mb.\n        \\<lbrakk>class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         PROG P \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C;\n         ins = Heap # map Local [0..<Suc (length Ts)];\n         outs = [Heap, Stack 0, Exception]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (C, D, fs, ms) \\<in> set (PROG P)\n  (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\n  ins = Heap # map Local [0..<Suc (length Ts)]\n  outs = [Heap, Stack 0, Exception]\n  class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  PROG\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n          xt) in C", "show ?thesis"], ["proof (prove)\nusing this:\n  (C, D, fs, ms) \\<in> set (PROG P)\n  (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\n  ins = Heap # map Local [0..<Suc (length Ts)]\n  outs = [Heap, Stack 0, Exception]\n  class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  PROG\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n          xt) in C\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  (C, D, fs, ms) \\<in> set (PROG P)\n  (M, Ts, T, mxs, mxl\\<^sub>0, is, xt) \\<in> set ms\n  ins = Heap # map Local [0..<Suc (length Ts)]\n  outs = [Heap, Stack 0, Exception]\n  class (PROG P) C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  PROG\n   P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n          xt) in C\n  \\<lbrakk>class (PROG P) C = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor>;\n   PROG P \\<turnstile> C sees M: ?Ts\\<rightarrow>?T = ?mb in C;\n   ins = Heap # map Local [0..<Suc (length ?Ts)];\n   outs = [Heap, Stack 0, Exception]\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "declare has_method_def [simp]"], ["", "interpretation JVMCFG_Interpret:\n  CFG \"sourcenode\" \"targetnode\" \"kind\" \"valid_edge (P, C0, Main)\"\n  \"(ClassMain P, MethodMain P, None, Enter)\"\n  \"(\\<lambda>(C, M, pc, type). (C, M))\" \"get_return_edges P\"\n  \"((ClassMain P, MethodMain P),[],[]) # procs (PROG P)\" \"(ClassMain P, MethodMain P)\"\n  for P C0 Main"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode kind (valid_edge (P, C0, Main))\n     (ClassMain P, MethodMain P, None, Enter)\n     (\\<lambda>(C, M, pc, type). (C, M)) (get_return_edges P)\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n     (ClassMain P, MethodMain P)", "proof (unfold_locales)"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        targetnode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. (case (ClassMain P, MethodMain P, None, Enter) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> (case sourcenode a of\n                           (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                          p\nA total of 25 subgoals...", "fix e"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        targetnode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. (case (ClassMain P, MethodMain P, None, Enter) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> (case sourcenode a of\n                           (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                          p\nA total of 25 subgoals...", "assume \"valid_edge (P, C0, Main) e\"\n    and \"targetnode e = (ClassMain P, MethodMain P, None, Enter)\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) e\n  targetnode e = (ClassMain P, MethodMain P, None, Enter)\n\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        targetnode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. (case (ClassMain P, MethodMain P, None, Enter) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> (case sourcenode a of\n                           (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                          p\nA total of 25 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) e\n  targetnode e = (ClassMain P, MethodMain P, None, Enter)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: valid_edge_def)(erule JVMCFG.cases, auto)+"], ["proof (state)\nthis:\n  False\n\ngoal (24 subgoals):\n 1. (case (ClassMain P, MethodMain P, None, Enter) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<longrightarrow>\n                             (\\<exists>Qx rx fsx.\n                                 kind a' =\n                                 Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. (case (ClassMain P, MethodMain P, None, Enter) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<longrightarrow>\n                             (\\<exists>Qx rx fsx.\n                                 kind a' =\n                                 Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\nA total of 24 subgoals...", "show \"(\\<lambda>(C, M, pc, type). (C, M)) (ClassMain P, MethodMain P, None, Enter) =\n    (ClassMain P, MethodMain P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (ClassMain P, MethodMain P, None, Enter) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)", "by simp"], ["proof (state)\nthis:\n  (case (ClassMain P, MethodMain P, None, Enter) of\n   (C, M, pc, type) \\<Rightarrow> (C, M)) =\n  (ClassMain P, MethodMain P)\n\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "assume \"valid_edge (P, C0, Main) a\"\n    and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n    and \"sourcenode a = (ClassMain P, MethodMain P, None, Enter)\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = (ClassMain P, MethodMain P, None, Enter)\n\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (ClassMain P, MethodMain P, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = (ClassMain P, MethodMain P, None, Enter)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: valid_edge_def) (erule JVMCFG.cases, auto)"], ["proof (state)\nthis:\n  False\n\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges P a \\<noteq> {}\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges P a \\<noteq> {}\nA total of 22 subgoals...", "fix a a'"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges P a \\<noteq> {}\nA total of 22 subgoals...", "assume \"valid_edge (P, C0, Main) a\"\n    and \"valid_edge (P, C0, Main) a'\"\n    and \"sourcenode a = sourcenode a'\"\n    and \"targetnode a = targetnode a'\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  valid_edge (P, C0, Main) a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges P a \\<noteq> {}\nA total of 22 subgoals...", "thus \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  valid_edge (P, C0, Main) a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n\ngoal (1 subgoal):\n 1. a = a'", "by (cases a, cases a') (fastforce simp: valid_edge_def dest: JVMCFG_edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 21 subgoals...", "fix a Q r f"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 21 subgoals...", "assume \"valid_edge (P, C0, Main) a\"\n    and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P, MethodMain P)\\<^esub>f\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P, MethodMain P)\\<^esub>f\n\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P,\n                                     MethodMain P)\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 21 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>(ClassMain P, MethodMain P)\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by (clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto)"], ["proof (state)\nthis:\n  False\n\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "fix a Q' f'"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>(ClassMain P, MethodMain P)\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>(ClassMain P, MethodMain P)\\<^esub>f'\n\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a =\n        Q'\\<hookleftarrow>\\<^bsub>(ClassMain P,\n                                   MethodMain P)\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>(ClassMain P, MethodMain P)\\<^esub>f'\n\ngoal (1 subgoal):\n 1. False", "by (clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto)+"], ["proof (state)\nthis:\n  False\n\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "assume \"valid_edge (P, C0, Main) a\"\n    and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain C M pc nt C' M' pc' nt'\n    where \"(P, C0, Main) \\<turnstile> (C, M, pc, nt) -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> (C', M', pc', nt')\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>C M pc nt C' M' pc' nt'.\n         (P, C0,\n          Main) \\<turnstile> (C, M, pc,\n                              nt) -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> (C',\n             M', pc', nt') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases a) (clarsimp simp: valid_edge_def)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> (C, M, pc,\n                        nt) -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> (C',\n       M', pc', nt')\n\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "thus \"\\<exists>ins outs.\n    (p, ins, outs) \\<in> set (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> (C, M, pc,\n                        nt) -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> (C',\n       M', pc', nt')\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) # procs (PROG P))", "proof cases"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C = ClassMain P; M = MethodMain P; pc = \\<lfloor>0\\<rfloor>;\n        nt = Normal; M' = Main; pc' = None; nt' = Enter;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C';\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C',\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 43 subgoals...", "case (Main_Call T mxs mxl0 \"is\" xt initParams)"], ["proof (state)\nthis:\n  C = ClassMain P\n  M = MethodMain P\n  pc = \\<lfloor>0\\<rfloor>\n  nt = Normal\n  M' = Main\n  pc' = None\n  nt' = Enter\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in C'\n  initParams =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C', Main)\\<^esub>initParams\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C = ClassMain P; M = MethodMain P; pc = \\<lfloor>0\\<rfloor>;\n        nt = Normal; M' = Main; pc' = None; nt' = Enter;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C';\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C',\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 43 subgoals...", "hence \"((C', Main), [Heap, Local 0], [Heap, Stack 0, Exception]) \\<in> set (procs (PROG P))\"\n      and \"p = (C', Main)\""], ["proof (prove)\nusing this:\n  C = ClassMain P\n  M = MethodMain P\n  pc = \\<lfloor>0\\<rfloor>\n  nt = Normal\n  M' = Main\n  pc' = None\n  nt' = Enter\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in C'\n  initParams =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C', Main)\\<^esub>initParams\n\ngoal (1 subgoal):\n 1. ((C', Main), [Heap, Local 0], [Heap, Stack 0, Exception])\n    \\<in> set (procs (PROG P)) &&&\n    p = (C', Main)", "by (auto intro: in_set_procsI dest: sees_method_idemp)"], ["proof (state)\nthis:\n  ((C', Main), [Heap, Local 0], [Heap, Stack 0, Exception])\n  \\<in> set (procs (PROG P))\n  p = (C', Main)\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C = ClassMain P; M = MethodMain P; pc = \\<lfloor>0\\<rfloor>;\n        nt = Normal; M' = Main; pc' = None; nt' = Enter;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C';\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C',\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 43 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((C', Main), [Heap, Local 0], [Heap, Stack 0, Exception])\n  \\<in> set (procs (PROG P))\n  p = (C', Main)\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) # procs (PROG P))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ins outs.\n     (p, ins, outs)\n     \\<in> set (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n\ngoal (42 subgoals):\n 1. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca Cl.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = New Cl;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl pc'a.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Exceptional pc'a Enter;\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         pc'a =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 42 subgoals...", "next"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca Cl.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = New Cl;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl pc'a.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Exceptional pc'a Enter;\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         pc'a =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 42 subgoals...", "case (CFG_Invoke_Call _ n _ _ _ Ts)"], ["proof (state)\nthis:\n  pc = \\<lfloor>pc_\\<rfloor>\n  nt = Normal\n  pc' = None\n  nt' = Enter\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc_ = Invoke M' n\n  TYPING P C M ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M': Ts\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C, M) pc_ - Suc n);\n          C'a = cname_of (heap_of s) (the_Addr r)\n      in C' = fst (method (PROG P) C'a M'))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C, M) pc_ - Suc n))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc_ - Suc i)))\n        [0..<n])\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n  Q_:(C, M, pc_)\\<hookrightarrow>\\<^bsub>(C', M')\\<^esub>paramDefs_\n\ngoal (42 subgoals):\n 1. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca Cl.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = New Cl;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl pc'a.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Exceptional pc'a Enter;\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         pc'a =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 42 subgoals...", "hence \"((C', M'), Heap # map (\\<lambda>n. Local n) [0..<Suc (length Ts)],\n      [Heap, Stack 0, Exception]) \\<in> set (procs (PROG P))\"\n      and \"p = (C',M')\""], ["proof (prove)\nusing this:\n  pc = \\<lfloor>pc_\\<rfloor>\n  nt = Normal\n  pc' = None\n  nt' = Enter\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc_ = Invoke M' n\n  TYPING P C M ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M': Ts\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C, M) pc_ - Suc n);\n          C'a = cname_of (heap_of s) (the_Addr r)\n      in C' = fst (method (PROG P) C'a M'))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C, M) pc_ - Suc n))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc_ - Suc i)))\n        [0..<n])\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n  Q_:(C, M, pc_)\\<hookrightarrow>\\<^bsub>(C', M')\\<^esub>paramDefs_\n\ngoal (1 subgoal):\n 1. ((C', M'), Heap # map Local [0..<Suc (length Ts)],\n     [Heap, Stack 0, Exception])\n    \\<in> set (procs (PROG P)) &&&\n    p = (C', M')", "by (auto intro: in_set_procsI dest: sees_method_idemp)"], ["proof (state)\nthis:\n  ((C', M'), Heap # map Local [0..<Suc (length Ts)],\n   [Heap, Stack 0, Exception])\n  \\<in> set (procs (PROG P))\n  p = (C', M')\n\ngoal (42 subgoals):\n 1. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca Cl.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = New Cl;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl pc'a.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Exceptional pc'a Enter;\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         pc'a =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 42 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((C', M'), Heap # map Local [0..<Suc (length Ts)],\n   [Heap, Stack 0, Exception])\n  \\<in> set (procs (PROG P))\n  p = (C', M')\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) # procs (PROG P))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ins outs.\n     (p, ins, outs)\n     \\<in> set (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n\ngoal (41 subgoals):\n 1. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Load n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 2. \\<And>pca n.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Store n;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, C, M) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 3. \\<And>pca v.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Push v;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 4. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = Pop;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 5. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IAdd;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pca - 2))\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 6. \\<And>pca.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = CmpEq;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pca - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pca - 2)\n                in s(Stack (stkLength (P, C, M) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 7. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>nat (int pca + i)\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i; i \\<noteq> 1;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 8. \\<And>pca i.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>Suc pca\\<rfloor>; nt' = Enter;\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = IfFalse i;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pca - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 9. \\<And>pca Cl.\n       \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n        pc' = \\<lfloor>pca\\<rfloor>; nt' = Normal; C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pca = New Cl;\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> set (((ClassMain P, MethodMain P), [],\n  []) #\n procs (PROG P))\n 10. \\<And>pca Cl pc'a.\n        \\<lbrakk>pc = \\<lfloor>pca\\<rfloor>; nt = Enter; C' = C; M' = M;\n         pc' = \\<lfloor>pca\\<rfloor>; nt' = Exceptional pc'a Enter;\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pca = New Cl;\n         pc'a =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ins outs.\n                             (p, ins, outs)\n                             \\<in> set (((ClassMain P, MethodMain P), [],\n   []) #\n  procs (PROG P))\nA total of 41 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>ins outs.\n     (p, ins, outs)\n     \\<in> set (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges P a'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges P a'\nA total of 18 subgoals...", "fix a"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges P a'\nA total of 18 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"intra_kind (kind a)\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  intra_kind (kind a)\n\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M))\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges P a'\nA total of 18 subgoals...", "thus \"(\\<lambda>(C, M, pc, type). (C, M)) (sourcenode a) =\n    (\\<lambda>(C, M, pc, type). (C, M)) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (case sourcenode a of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (case targetnode a of (C, M, pc, type) \\<Rightarrow> (C, M))", "by (clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto simp: intra_kind_def)"], ["proof (state)\nthis:\n  (case sourcenode a of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n  (case targetnode a of (C, M, pc, type) \\<Rightarrow> (C, M))\n\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> (case targetnode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "thus \"(\\<lambda>(C, M, pc, type). (C, M)) (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (case targetnode a of (C, M, pc, type) \\<Rightarrow> (C, M)) = p", "by (clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto)"], ["proof (state)\nthis:\n  (case targetnode a of (C, M, pc, type) \\<Rightarrow> (C, M)) = p\n\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "fix a Q' p f'"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> (case sourcenode a of\n                          (C, M, pc, type) \\<Rightarrow> (C, M)) =\n                         p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         a' \\<in> get_return_edges P a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge (P, C0, Main) a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "thus \"(\\<lambda>(C, M, pc, type). (C, M)) (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (case sourcenode a of (C, M, pc, type) \\<Rightarrow> (C, M)) = p", "by (clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto)"], ["proof (state)\nthis:\n  (case sourcenode a of (C, M, pc, type) \\<Rightarrow> (C, M)) = p\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "thus \"\\<forall>a'. valid_edge (P, C0, Main) a' \\<and> targetnode a' = targetnode a\n    \\<longrightarrow> (\\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<longrightarrow>\n       (\\<exists>Qx rx fsx.\n           kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "by (cases a, clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto)+"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     targetnode a' = targetnode a \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "fix a Q' p f'"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge (P, C0, Main) a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "thus \"\\<forall>a'. valid_edge (P, C0, Main) a' \\<and> sourcenode a' = sourcenode a\n    \\<longrightarrow> (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       sourcenode a' = sourcenode a \\<longrightarrow>\n       (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "by (cases a, clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto)+"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     sourcenode a' = sourcenode a \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<exists>a'. a' \\<in> get_return_edges P a\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>a'. a' \\<in> get_return_edges P a", "by (cases p, cases r) (fastforce intro: get_return_edges.intros)"], ["proof (state)\nthis:\n  \\<exists>a'. a' \\<in> get_return_edges P a\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges P a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'. a' \\<in> get_return_edges P a", "show \"get_return_edges P a \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>a'. a' \\<in> get_return_edges P a\n\ngoal (1 subgoal):\n 1. get_return_edges P a \\<noteq> {}", "by (simp only: ex_in_conv) simp"], ["proof (state)\nthis:\n  get_return_edges P a \\<noteq> {}\n\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. BasicDefs.distinct_fst\n      (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. BasicDefs.distinct_fst\n      (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\nA total of 12 subgoals...", "fix a a'"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. BasicDefs.distinct_fst\n      (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\nA total of 12 subgoals...", "assume \"valid_edge (P, C0, Main) a\" \"a' \\<in> get_return_edges P a\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. BasicDefs.distinct_fst\n      (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a", "obtain Q C M pc D M' paramDefs\n    where \"(P, C0, Main) \\<turnstile> sourcenode a -Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rightarrow> targetnode a\"\n    and \"kind a = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\"\n    and a'_def: \"a' = ((D, M', None, nodeType.Return),\n    \\<lambda>(s, ret).\n      ret = (C, M, pc)\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>\\<lambda>s s'. s'(Heap := s Heap, Exception := s Exception,\n                           Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n    C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (1 subgoal):\n 1. (\\<And>Q C M pc D M' paramDefs.\n        \\<lbrakk> (P, C0,\n                   Main) \\<turnstile> sourcenode\n a -Q:(C, M,\n       pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rightarrow> targetnode\n                                    a;\n         kind a =\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: valid_edge_def)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q:(C, M,\n                              pc)\\<hookrightarrow>\\<^bsub>(D,\n                     M')\\<^esub>paramDefs\\<rightarrow> targetnode a\n  kind a = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\n  a' =\n  ((D, M', None, nodeType.Return),\n   \\<lambda>(s, ret).\n      ret =\n      (C, M,\n       pc)\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>\\<lambda>s s'. s'\n              (Heap := s Heap, Exception := s Exception,\n               Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n   C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. BasicDefs.distinct_fst\n      (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\nA total of 12 subgoals...", "thus \"valid_edge (P, C0, Main) a'\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q:(C, M,\n                              pc)\\<hookrightarrow>\\<^bsub>(D,\n                     M')\\<^esub>paramDefs\\<rightarrow> targetnode a\n  kind a = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\n  a' =\n  ((D, M', None, nodeType.Return),\n   \\<lambda>(s, ret).\n      ret =\n      (C, M,\n       pc)\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>\\<lambda>s s'. s'\n              (Heap := s Heap, Exception := s Exception,\n               Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n   C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. valid_edge (P, C0, Main) a'", "proof cases"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt Da initParams.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a =\n        (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (Da, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in Da;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(Da,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 43 subgoals...", "case (Main_Call T mxs mxl0 \"is\" xt D')"], ["proof (state)\nthis:\n  sourcenode a = (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  targetnode a = (D', Main, None, Enter)\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in D'\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D', Main)\\<^esub>initParams_\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt Da initParams.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a =\n        (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (Da, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in Da;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(Da,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 43 subgoals...", "hence \"D = D'\" and \"M' = Main\""], ["proof (prove)\nusing this:\n  sourcenode a = (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  targetnode a = (D', Main, None, Enter)\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in D'\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D', Main)\\<^esub>initParams_\n\ngoal (1 subgoal):\n 1. D = D' &&& M' = Main", "by simp_all"], ["proof (state)\nthis:\n  D = D'\n  M' = Main\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt Da initParams.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a =\n        (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (Da, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in Da;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(Da,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 43 subgoals...", "with \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\\<close>\n      \\<open>PROG P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in D'\\<close>"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in D'\n  D = D'\n  M' = Main", "have \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in D'\n  D = D'\n  M' = Main\n\ngoal (1 subgoal):\n 1.  (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)", "by -(rule reachable_step, fastforce, fastforce intro: JVMCFG_reachable.Main_Call)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt Da initParams.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a =\n        (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (Da, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in Da;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(Da,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 43 subgoals...", "hence \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)\n\ngoal (1 subgoal):\n 1.  (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)", "by -(rule reachable_step, fastforce, fastforce intro: JVMCFG_reachable.Method_LFalse)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt Da initParams.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a =\n        (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (Da, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in Da;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(Da,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 43 subgoals...", "with a'_def Main_Call"], ["proof (chain)\npicking this:\n  a' =\n  ((D, M', None, nodeType.Return),\n   \\<lambda>(s, ret).\n      ret =\n      (C, M,\n       pc)\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>\\<lambda>s s'. s'\n              (Heap := s Heap, Exception := s Exception,\n               Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n   C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  sourcenode a = (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  targetnode a = (D', Main, None, Enter)\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in D'\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D', Main)\\<^esub>initParams_\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)", "show ?thesis"], ["proof (prove)\nusing this:\n  a' =\n  ((D, M', None, nodeType.Return),\n   \\<lambda>(s, ret).\n      ret =\n      (C, M,\n       pc)\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>\\<lambda>s s'. s'\n              (Heap := s Heap, Exception := s Exception,\n               Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n   C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  sourcenode a = (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  targetnode a = (D', Main, None, Enter)\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl0, is, xt) in D'\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D', Main)\\<^esub>initParams_\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. valid_edge (P, C0, Main) a'", "by (fastforce intro: CFG_Return_from_Method JVMCFG_reachable.Main_Call simp: valid_edge_def)"], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a'\n\ngoal (42 subgoals):\n 1. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca Cl.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = New Cl;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl pc'.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a =\n         (Ca, Ma, \\<lfloor>pca\\<rfloor>, Exceptional pc' Enter);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) Ca Ma) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 42 subgoals...", "next"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca Cl.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = New Cl;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl pc'.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a =\n         (Ca, Ma, \\<lfloor>pca\\<rfloor>, Exceptional pc' Enter);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) Ca Ma) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 42 subgoals...", "case (CFG_Invoke_Call _ _ _ M'' _ _ _ _ _ _ _ _ _ _ D')"], ["proof (state)\nthis:\n  sourcenode a = (C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  targetnode a = (D', M'', None, Enter)\n  C_ \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C_ M_ ! pc_ = Invoke M'' n_\n  TYPING P C_ M_ ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M'': Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n                is_, xt_) in D'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C_, M_) pc_ - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D' = fst (method (PROG P) C' M''))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C_, M_) pc_ - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C_, M_) pc_ - Suc i)))\n        [0..<n_])\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  Q_:(C_, M_, pc_)\\<hookrightarrow>\\<^bsub>(D', M'')\\<^esub>paramDefs_\n\ngoal (42 subgoals):\n 1. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca Cl.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = New Cl;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl pc'.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a =\n         (Ca, Ma, \\<lfloor>pca\\<rfloor>, Exceptional pc' Enter);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) Ca Ma) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 42 subgoals...", "hence \"D = D'\" and \"M' = M''\""], ["proof (prove)\nusing this:\n  sourcenode a = (C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  targetnode a = (D', M'', None, Enter)\n  C_ \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C_ M_ ! pc_ = Invoke M'' n_\n  TYPING P C_ M_ ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M'': Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n                is_, xt_) in D'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C_, M_) pc_ - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D' = fst (method (PROG P) C' M''))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C_, M_) pc_ - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C_, M_) pc_ - Suc i)))\n        [0..<n_])\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  Q_:(C_, M_, pc_)\\<hookrightarrow>\\<^bsub>(D', M'')\\<^esub>paramDefs_\n\ngoal (1 subgoal):\n 1. D = D' &&& M' = M''", "by simp_all"], ["proof (state)\nthis:\n  D = D'\n  M' = M''\n\ngoal (42 subgoals):\n 1. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca Cl.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = New Cl;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl pc'.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a =\n         (Ca, Ma, \\<lfloor>pca\\<rfloor>, Exceptional pc' Enter);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) Ca Ma) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 42 subgoals...", "with CFG_Invoke_Call"], ["proof (chain)\npicking this:\n  sourcenode a = (C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  targetnode a = (D', M'', None, Enter)\n  C_ \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C_ M_ ! pc_ = Invoke M'' n_\n  TYPING P C_ M_ ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M'': Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n                is_, xt_) in D'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C_, M_) pc_ - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D' = fst (method (PROG P) C' M''))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C_, M_) pc_ - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C_, M_) pc_ - Suc i)))\n        [0..<n_])\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  Q_:(C_, M_, pc_)\\<hookrightarrow>\\<^bsub>(D', M'')\\<^esub>paramDefs_\n  D = D'\n  M' = M''", "have \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)\""], ["proof (prove)\nusing this:\n  sourcenode a = (C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  targetnode a = (D', M'', None, Enter)\n  C_ \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C_ M_ ! pc_ = Invoke M'' n_\n  TYPING P C_ M_ ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M'': Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n                is_, xt_) in D'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C_, M_) pc_ - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D' = fst (method (PROG P) C' M''))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C_, M_) pc_ - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C_, M_) pc_ - Suc i)))\n        [0..<n_])\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  Q_:(C_, M_, pc_)\\<hookrightarrow>\\<^bsub>(D', M'')\\<^esub>paramDefs_\n  D = D'\n  M' = M''\n\ngoal (1 subgoal):\n 1.  (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)", "by -(rule reachable_step, fastforce, fastforce intro: JVMCFG_reachable.CFG_Invoke_Call)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)\n\ngoal (42 subgoals):\n 1. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca Cl.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = New Cl;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl pc'.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a =\n         (Ca, Ma, \\<lfloor>pca\\<rfloor>, Exceptional pc' Enter);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) Ca Ma) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 42 subgoals...", "hence \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, Enter)\n\ngoal (1 subgoal):\n 1.  (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)", "by -(rule reachable_step, fastforce, fastforce intro: JVMCFG_reachable.Method_LFalse)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)\n\ngoal (42 subgoals):\n 1. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca Cl.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = New Cl;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl pc'.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a =\n         (Ca, Ma, \\<lfloor>pca\\<rfloor>, Exceptional pc' Enter);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) Ca Ma) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 42 subgoals...", "with a'_def CFG_Invoke_Call"], ["proof (chain)\npicking this:\n  a' =\n  ((D, M', None, nodeType.Return),\n   \\<lambda>(s, ret).\n      ret =\n      (C, M,\n       pc)\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>\\<lambda>s s'. s'\n              (Heap := s Heap, Exception := s Exception,\n               Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n   C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  sourcenode a = (C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  targetnode a = (D', M'', None, Enter)\n  C_ \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C_ M_ ! pc_ = Invoke M'' n_\n  TYPING P C_ M_ ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M'': Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n                is_, xt_) in D'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C_, M_) pc_ - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D' = fst (method (PROG P) C' M''))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C_, M_) pc_ - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C_, M_) pc_ - Suc i)))\n        [0..<n_])\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  Q_:(C_, M_, pc_)\\<hookrightarrow>\\<^bsub>(D', M'')\\<^esub>paramDefs_\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)", "show ?thesis"], ["proof (prove)\nusing this:\n  a' =\n  ((D, M', None, nodeType.Return),\n   \\<lambda>(s, ret).\n      ret =\n      (C, M,\n       pc)\\<hookleftarrow>\\<^bsub>(D, M')\\<^esub>\\<lambda>s s'. s'\n              (Heap := s Heap, Exception := s Exception,\n               Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n   C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  sourcenode a = (C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  targetnode a = (D', M'', None, Enter)\n  C_ \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C_, M_, \\<lfloor>pc_\\<rfloor>, Normal)\n  instrs_of (PROG P) C_ M_ ! pc_ = Invoke M'' n_\n  TYPING P C_ M_ ! pc_ = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M'': Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n                is_, xt_) in D'\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C_, M_) pc_ - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D' = fst (method (PROG P) C' M''))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C_, M_) pc_ - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C_, M_) pc_ - Suc i)))\n        [0..<n_])\n  Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n  Q_:(C_, M_, pc_)\\<hookrightarrow>\\<^bsub>(D', M'')\\<^esub>paramDefs_\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(D, M', None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. valid_edge (P, C0, Main) a'", "by (fastforce intro: CFG_Return_from_Method JVMCFG_reachable.CFG_Invoke_Call\n        simp: valid_edge_def)"], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a'\n\ngoal (41 subgoals):\n 1. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Load n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, Ca, Ma) pca) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 2. \\<And>Ca Ma pca n.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Store n;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s\n                (Local n :=\n                   s (Stack (stkLength (P, Ca, Ma) pca - 1)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 3. \\<And>Ca Ma pca v.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Push v;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, Ca, Ma) pca) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 4. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = Pop;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 5. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IAdd;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, Ca, Ma) pca - 2))\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 6. \\<And>Ca Ma pca.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = CmpEq;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, Ca, Ma) pca - 1);\n                    e2 = stkAt s (stkLength (P, Ca, Ma) pca - 2)\n                in s(Stack (stkLength (P, Ca, Ma) pca - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 7. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>nat (int pca + i)\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i; i \\<noteq> 1;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 8. \\<And>Ca Ma pca i.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>Suc pca\\<rfloor>, Enter);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = IfFalse i;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, Ca, Ma) pca - 1) \\<noteq>\n            Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 9. \\<And>Ca Ma pca Cl.\n       \\<lbrakk>kind a =\n                Q:(C, M,\n                   pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n        a' =\n        ((D, M', None, nodeType.Return),\n         \\<lambda>(s, ret).\n            ret =\n            (C, M,\n             pc)\\<hookleftarrow>\\<^bsub>(D,\n   M')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n         C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n        targetnode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Normal);\n        Ca \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) Ca Ma ! pca = New Cl;\n        Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> valid_edge (P, C0, Main) a'\n 10. \\<And>Ca Ma pca Cl pc'.\n        \\<lbrakk>kind a =\n                 Q:(C, M,\n                    pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs;\n         a' =\n         ((D, M', None, nodeType.Return),\n          \\<lambda>(s, ret).\n             ret =\n             (C, M,\n              pc)\\<hookleftarrow>\\<^bsub>(D,\n    M')\\<^esub>\\<lambda>s s'. s'\n                  (Heap := s Heap, Exception := s Exception,\n                   Stack (stkLength (P, C, M) (Suc pc) - 1) := s (Stack 0)),\n          C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         sourcenode a = (Ca, Ma, \\<lfloor>pca\\<rfloor>, Enter);\n         targetnode a =\n         (Ca, Ma, \\<lfloor>pca\\<rfloor>, Exceptional pc' Enter);\n         Ca \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(Ca, Ma, \\<lfloor>pca\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) Ca Ma ! pca = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pca\n                (ex_table_of (PROG P) Ca Ma) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> valid_edge (P, C0, Main) a'\nA total of 41 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a'\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "fix a a'"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "assume \"valid_edge (P, C0, Main) a\" and \"a' \\<in> get_return_edges P a\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "thus \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct outs", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct outs", "fix a Q r p fs a'"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct outs", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a' \\<in> get_return_edges P a\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges P a\n\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs)\n        \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                   procs (PROG P)) \\<Longrightarrow>\n        distinct outs", "thus \"\\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges P a\n\ngoal (1 subgoal):\n 1. \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "by clarsimp"], ["proof (state)\nthis:\n  \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix a Q' p f'"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges P a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "show \"\\<exists>!a'. valid_edge (P, C0, Main) a' \\<and>\n                (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges P a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges P a'", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges P a'\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges P a';\n        valid_edge (P, C0, Main) y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges P y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge (P, C0, Main) a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge (P, C0, Main) a", "have \"(P, C0, Main) \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by (clarsimp simp: valid_edge_def)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges P a'\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges P a';\n        valid_edge (P, C0, Main) y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges P y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from this \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n   (P, C0, Main) \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "show \"\\<exists>a'. valid_edge (P, C0, Main) a' \\<and> (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\n      \\<and> a \\<in> get_return_edges P a'\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges P a'", "by cases (cases a, fastforce intro: get_return_edges.intros[simplified] simp: valid_edge_def)+"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges P a'\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges P a';\n        valid_edge (P, C0, Main) y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges P y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges P a';\n        valid_edge (P, C0, Main) y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges P y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges P a';\n        valid_edge (P, C0, Main) y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges P y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge (P, C0, Main) a'\n      \\<and> (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges P a'\"\n       and \"valid_edge (P, C0, Main) a''\n      \\<and> (\\<exists>Q r fs. kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges P a''\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges P a'\n  valid_edge (P, C0, Main) a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges P a''\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges P a';\n        valid_edge (P, C0, Main) y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges P y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "thus \"a' = a''\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges P a'\n  valid_edge (P, C0, Main) a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges P a''\n\ngoal (1 subgoal):\n 1. a' = a''", "by (cases a', cases a'', clarsimp simp: valid_edge_def)\n    (erule JVMCFG.cases, simp_all, clarsimp? )+"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges P a'\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix a a'"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge (P, C0, Main) a\" and \"a' \\<in> get_return_edges P a\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "thus \"\\<exists>a''. valid_edge (P, C0, Main) a'' \\<and>\n    sourcenode a'' = targetnode a \\<and>\n    targetnode a'' = sourcenode a' \\<and> kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge (P, C0, Main) a'' \\<and>\n       sourcenode a'' = targetnode a \\<and>\n       targetnode a'' = sourcenode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by (clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto intro: JVMCFG_reachable.intros)"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge (P, C0, Main) a'' \\<and>\n     sourcenode a'' = targetnode a \\<and>\n     targetnode a'' = sourcenode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix a a'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge (P, C0, Main) a\" and \"a' \\<in> get_return_edges P a\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        a' \\<in> get_return_edges P a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge (P, C0, Main) a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "thus \"\\<exists>a''. valid_edge (P, C0, Main) a'' \\<and>\n    sourcenode a'' = sourcenode a \\<and>\n    targetnode a'' = targetnode a' \\<and> kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  a' \\<in> get_return_edges P a\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge (P, C0, Main) a'' \\<and>\n       sourcenode a'' = sourcenode a \\<and>\n       targetnode a'' = targetnode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by (clarsimp simp: valid_edge_def) (erule JVMCFG.cases, auto intro: JVMCFG_reachable.intros)"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge (P, C0, Main) a'' \\<and>\n     sourcenode a'' = sourcenode a \\<and>\n     targetnode a'' = targetnode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix a Q r p fs"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "hence call: \"(P, C0, Main) \\<turnstile> sourcenode a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> sourcenode\n                          a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n       a", "by (clarsimp simp: valid_edge_def)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n     a\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "show \"\\<exists>!a'. valid_edge (P, C0, Main) a' \\<and>\n    sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from call"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n     a", "show \"\\<exists>a'. valid_edge (P, C0, Main) a' \\<and> sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n     a\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "by cases (fastforce intro: JVMCFG_reachable.intros simp: intra_kind_def valid_edge_def)+"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge (P, C0, Main) a' \\<and> sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\"\n      and \"valid_edge (P, C0, Main) a'' \\<and> sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a' \\<and>\n  sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge (P, C0, Main) a'' \\<and>\n  sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with call"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n     a\n  valid_edge (P, C0, Main) a' \\<and>\n  sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge (P, C0, Main) a'' \\<and>\n  sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')", "show \"a' = a''\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n     a\n  valid_edge (P, C0, Main) a' \\<and>\n  sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge (P, C0, Main) a'' \\<and>\n  sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. a' = a''", "by (cases a, cases a', cases a'', clarsimp simp: valid_edge_def intra_kind_def)\n    (erule JVMCFG.cases, simp_all, clarsimp?)+"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix a Q' p f'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge (P, C0, Main) a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "hence return: \"(P, C0, Main) \\<turnstile> sourcenode a -Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> sourcenode\n                          a -Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rightarrow> targetnode\n     a", "by (clarsimp simp: valid_edge_def)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rightarrow> targetnode\n   a\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "show \"\\<exists>!a'. valid_edge (P, C0, Main) a' \\<and>\n    targetnode a' = targetnode a \\<and> intra_kind (kind a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from return"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rightarrow> targetnode\n   a", "show \"\\<exists>a'. valid_edge (P, C0, Main) a' \\<and> targetnode a' = targetnode a \\<and> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rightarrow> targetnode\n   a\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "proof cases"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt D initParams.\n       \\<lbrakk>sourcenode a =\n                (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (D, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>C M pc v.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Pop;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>C M pc Cl.\n        \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         targetnode a = (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 43 subgoals...", "case (CFG_Return_from_Method C M C' M' pc' Q'' ps Q stateUpdate)"], ["proof (state)\nthis:\n  sourcenode a = (C, M, None, nodeType.Return)\n  targetnode a = (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n  Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt D initParams.\n       \\<lbrakk>sourcenode a =\n                (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (D, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>C M pc v.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Pop;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>C M pc Cl.\n        \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         targetnode a = (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 43 subgoals...", "hence [simp]: \"Q = Q'\" and [simp]: \"p = (C, M)\" and [simp]: \"f' = stateUpdate\""], ["proof (prove)\nusing this:\n  sourcenode a = (C, M, None, nodeType.Return)\n  targetnode a = (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n  Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n\ngoal (1 subgoal):\n 1. Q = Q' &&& p = (C, M) &&& f' = stateUpdate", "by simp_all"], ["proof (state)\nthis:\n  Q = Q'\n  p = (C, M)\n  f' = stateUpdate\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt D initParams.\n       \\<lbrakk>sourcenode a =\n                (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (D, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>C M pc v.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Pop;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>C M pc Cl.\n        \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         targetnode a = (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 43 subgoals...", "from \\<open>(P, C0, Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>, Normal) -Q'':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\\<close>"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)", "have invoke_reachable: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)\n\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n Normal)", "by -(drule sourcenode_reachable)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n\ngoal (43 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt D initParams.\n       \\<lbrakk>sourcenode a =\n                (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (D, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>C M pc v.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Pop;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>C M pc Cl.\n        \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         targetnode a = (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 43 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "proof (cases \"C' = ClassMain P\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C' = ClassMain P \\<Longrightarrow>\n    \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')\n 2. C' \\<noteq> ClassMain P \\<Longrightarrow>\n    \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "case True"], ["proof (state)\nthis:\n  C' = ClassMain P\n\ngoal (2 subgoals):\n 1. C' = ClassMain P \\<Longrightarrow>\n    \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')\n 2. C' \\<noteq> ClassMain P \\<Longrightarrow>\n    \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "with invoke_reachable CFG_Return_from_Method"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  sourcenode a = (C, M, None, nodeType.Return)\n  targetnode a = (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n  Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' = ClassMain P", "show ?thesis"], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  sourcenode a = (C, M, None, nodeType.Return)\n  targetnode a = (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n  Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' = ClassMain P\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "by -(erule JVMCFG.cases, simp_all,\n            fastforce intro: Main_Call_LFalse simp: valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain P \\<Longrightarrow>\n    \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain P \\<Longrightarrow>\n    \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "case False"], ["proof (state)\nthis:\n  C' \\<noteq> ClassMain P\n\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain P \\<Longrightarrow>\n    \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "with invoke_reachable CFG_Return_from_Method"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  sourcenode a = (C, M, None, nodeType.Return)\n  targetnode a = (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n  Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' \\<noteq> ClassMain P", "show ?thesis"], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  sourcenode a = (C, M, None, nodeType.Return)\n  targetnode a = (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q'':(C', M',\npc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                      Enter)\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n  Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' \\<noteq> ClassMain P\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge (P, C0, Main) a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "by -(erule JVMCFG.cases, simp_all,\n            fastforce intro: CFG_Invoke_False simp: valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (42 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt D initParams.\n       \\<lbrakk>sourcenode a =\n                (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        targetnode a = (D, Main, None, Enter);\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>C M pc n.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>C M pc v.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = Pop;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>C M pc.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>C M pc i.\n       \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        targetnode a = (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter);\n        C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge (P, C0, Main) a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>C M pc Cl.\n        \\<lbrakk>sourcenode a = (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         targetnode a = (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a'.\n                             valid_edge (P, C0, Main) a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 42 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge (P, C0, Main) a' \\<and> targetnode a' = targetnode a \\<and> intra_kind (kind a')\"\n      and \"valid_edge (P, C0, Main) a'' \\<and> targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a' \\<and>\n  targetnode a' = targetnode a \\<and> intra_kind (kind a')\n  valid_edge (P, C0, Main) a'' \\<and>\n  targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge (P, C0, Main) a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge (P, C0, Main) y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with return"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rightarrow> targetnode\n   a\n  valid_edge (P, C0, Main) a' \\<and>\n  targetnode a' = targetnode a \\<and> intra_kind (kind a')\n  valid_edge (P, C0, Main) a'' \\<and>\n  targetnode a'' = targetnode a \\<and> intra_kind (kind a'')", "show \"a' = a''\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> sourcenode\n                        a -Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rightarrow> targetnode\n   a\n  valid_edge (P, C0, Main) a' \\<and>\n  targetnode a' = targetnode a \\<and> intra_kind (kind a')\n  valid_edge (P, C0, Main) a'' \\<and>\n  targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. a' = a''", "by (cases, auto, cases a, cases a', cases a'', clarsimp simp: valid_edge_def intra_kind_def)\n    (erule JVMCFG.cases, simp_all, clarsimp?)+"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge (P, C0, Main) a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2 fs\\<^sub>2"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge (P, C0, Main) a\" and \"valid_edge (P, C0, Main) a'\"\n    and \"kind a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\" and \"kind a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  valid_edge (P, C0, Main) a'\n  kind a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  kind a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge (P, C0, Main) a; valid_edge (P, C0, Main) a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "thus \"targetnode a = targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  valid_edge (P, C0, Main) a'\n  kind a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  kind a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. targetnode a = targetnode a'", "by (cases a, cases a', clarsimp simp: valid_edge_def)\n  (erule JVMCFG.cases, simp_all, clarsimp?)+"], ["proof (state)\nthis:\n  targetnode a = targetnode a'\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "from distinct_method_names [of P] distinct_class_names [of P]"], ["proof (chain)\npicking this:\n  class (PROG P) ?C = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n  Auxiliary.distinct_fst (PROG P)", "have \"\\<And>C D fs ms. (C, D, fs, ms) \\<in> set (PROG P) \\<Longrightarrow> distinct_fst ms\""], ["proof (prove)\nusing this:\n  class (PROG P) ?C = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor> \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n  Auxiliary.distinct_fst (PROG P)\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms.\n       (C, D, fs, ms) \\<in> set (PROG P) \\<Longrightarrow>\n       Auxiliary.distinct_fst ms", "by (fastforce intro: map_of_SomeI simp: class_def)"], ["proof (state)\nthis:\n  (?C, ?D, ?fs, ?ms) \\<in> set (PROG P) \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "moreover"], ["proof (state)\nthis:\n  (?C, ?D, ?fs, ?ms) \\<in> set (PROG P) \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "{"], ["proof (state)\nthis:\n  (?C, ?D, ?fs, ?ms) \\<in> set (PROG P) \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix P"], ["proof (state)\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"distinct_fst (P :: jvm_prog)\"\n      and \"\\<And>C D fs ms. (C, D, fs, ms) \\<in> set P \\<Longrightarrow> distinct_fst ms\""], ["proof (state)\nthis:\n  Auxiliary.distinct_fst P\n  (?C, ?D, ?fs, ?ms) \\<in> set P \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "hence \"distinct_fst (procs P)\""], ["proof (prove)\nusing this:\n  Auxiliary.distinct_fst P\n  (?C, ?D, ?fs, ?ms) \\<in> set P \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n\ngoal (1 subgoal):\n 1. Auxiliary.distinct_fst (procs P)", "by (induct P, simp)\n    (fastforce intro: equals0I rev_image_eqI dest: in_methods_in_msD in_set_procsD\n      simp: distinct_methods distinct_fst_def)"], ["proof (state)\nthis:\n  Auxiliary.distinct_fst (procs P)\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Auxiliary.distinct_fst ?Pa2;\n   \\<And>C D fs ms.\n      (C, D, fs, ms) \\<in> set ?Pa2 \\<Longrightarrow>\n      Auxiliary.distinct_fst ms\\<rbrakk>\n  \\<Longrightarrow> Auxiliary.distinct_fst (procs ?Pa2)\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "ultimately"], ["proof (chain)\npicking this:\n  (?C, ?D, ?fs, ?ms) \\<in> set (PROG P) \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n  \\<lbrakk>Auxiliary.distinct_fst ?Pa2;\n   \\<And>C D fs ms.\n      (C, D, fs, ms) \\<in> set ?Pa2 \\<Longrightarrow>\n      Auxiliary.distinct_fst ms\\<rbrakk>\n  \\<Longrightarrow> Auxiliary.distinct_fst (procs ?Pa2)", "have \"distinct_fst (procs (PROG P))\""], ["proof (prove)\nusing this:\n  (?C, ?D, ?fs, ?ms) \\<in> set (PROG P) \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n  \\<lbrakk>Auxiliary.distinct_fst ?Pa2;\n   \\<And>C D fs ms.\n      (C, D, fs, ms) \\<in> set ?Pa2 \\<Longrightarrow>\n      Auxiliary.distinct_fst ms\\<rbrakk>\n  \\<Longrightarrow> Auxiliary.distinct_fst (procs ?Pa2)\n\ngoal (1 subgoal):\n 1. Auxiliary.distinct_fst (procs (PROG P))", "using distinct_class_names [of P]"], ["proof (prove)\nusing this:\n  (?C, ?D, ?fs, ?ms) \\<in> set (PROG P) \\<Longrightarrow>\n  Auxiliary.distinct_fst ?ms\n  \\<lbrakk>Auxiliary.distinct_fst ?Pa2;\n   \\<And>C D fs ms.\n      (C, D, fs, ms) \\<in> set ?Pa2 \\<Longrightarrow>\n      Auxiliary.distinct_fst ms\\<rbrakk>\n  \\<Longrightarrow> Auxiliary.distinct_fst (procs ?Pa2)\n  Auxiliary.distinct_fst (PROG P)\n\ngoal (1 subgoal):\n 1. Auxiliary.distinct_fst (procs (PROG P))", "by blast"], ["proof (state)\nthis:\n  Auxiliary.distinct_fst (procs (PROG P))\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "hence \"BasicDefs.distinct_fst (procs (PROG P))\""], ["proof (prove)\nusing this:\n  Auxiliary.distinct_fst (procs (PROG P))\n\ngoal (1 subgoal):\n 1. BasicDefs.distinct_fst (procs (PROG P))", "by (simp add: distinct_fst_is_distinct_fst)"], ["proof (state)\nthis:\n  BasicDefs.distinct_fst (procs (PROG P))\n\ngoal (3 subgoals):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "thus \"BasicDefs.distinct_fst (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\""], ["proof (prove)\nusing this:\n  BasicDefs.distinct_fst (procs (PROG P))\n\ngoal (1 subgoal):\n 1. BasicDefs.distinct_fst\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))", "by (fastforce elim: in_set_procsE)"], ["proof (state)\nthis:\n  BasicDefs.distinct_fst\n   (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix C M P p ins outs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"(p, ins, outs) \\<in> set (((C, M), [], []) # procs P)\""], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P)\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "thus \"distinct ins\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P)\n\ngoal (1 subgoal):\n 1. distinct ins", "proof (induct P)"], ["proof (state)\ngoal (2 subgoals):\n 1. (p, ins, outs) \\<in> set (((C, M), [], []) # procs []) \\<Longrightarrow>\n    distinct ins\n 2. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct ins;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct ins", "case Nil"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs [])\n\ngoal (2 subgoals):\n 1. (p, ins, outs) \\<in> set (((C, M), [], []) # procs []) \\<Longrightarrow>\n    distinct ins\n 2. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct ins;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct ins", "thus ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs [])\n\ngoal (1 subgoal):\n 1. distinct ins", "by simp"], ["proof (state)\nthis:\n  distinct ins\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct ins;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct ins", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct ins;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct ins", "case (Cons Cl P)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n  distinct ins\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs (Cl # P))\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct ins;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct ins", "then"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n  distinct ins\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs (Cl # P))", "obtain C D fs ms where \"Cl = (C, D, fs, ms)\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n  distinct ins\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs (Cl # P))\n\ngoal (1 subgoal):\n 1. (\\<And>C D fs ms.\n        Cl = (C, D, fs, ms) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases Cl) blast"], ["proof (state)\nthis:\n  Cl = (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C__, M), [], []) # procs P) \\<Longrightarrow>\n                distinct ins;\n        (p, ins, outs)\n        \\<in> set (((C__, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct ins", "with Cons"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs P) \\<Longrightarrow>\n  distinct ins\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs (Cl # P))\n  Cl = (C, D, fs, ms)", "show ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs P) \\<Longrightarrow>\n  distinct ins\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs (Cl # P))\n  Cl = (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. distinct ins", "by hypsubst_thin (induct ms, auto)"], ["proof (state)\nthis:\n  distinct ins\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct ins\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "fix C M P p ins outs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "assume \"(p, ins, outs) \\<in> set (((C, M), [], []) # procs P)\""], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P)\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs)\n       \\<in> set (((ClassMain P, MethodMain P), [], []) #\n                  procs (PROG P)) \\<Longrightarrow>\n       distinct outs", "thus \"distinct outs\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P)\n\ngoal (1 subgoal):\n 1. distinct outs", "proof (induct \"P\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (p, ins, outs) \\<in> set (((C, M), [], []) # procs []) \\<Longrightarrow>\n    distinct outs\n 2. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct outs;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct outs", "case Nil"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs [])\n\ngoal (2 subgoals):\n 1. (p, ins, outs) \\<in> set (((C, M), [], []) # procs []) \\<Longrightarrow>\n    distinct outs\n 2. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct outs;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct outs", "thus ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs [])\n\ngoal (1 subgoal):\n 1. distinct outs", "by simp"], ["proof (state)\nthis:\n  distinct outs\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct outs;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct outs;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct outs", "case (Cons Cl P)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n  distinct outs\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs (Cl # P))\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n                distinct outs;\n        (p, ins, outs) \\<in> set (((C, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct outs", "then"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n  distinct outs\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs (Cl # P))", "obtain C D fs ms where \"Cl = (C, D, fs, ms)\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs P) \\<Longrightarrow>\n  distinct outs\n  (p, ins, outs) \\<in> set (((C, M), [], []) # procs (Cl # P))\n\ngoal (1 subgoal):\n 1. (\\<And>C D fs ms.\n        Cl = (C, D, fs, ms) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases Cl) blast"], ["proof (state)\nthis:\n  Cl = (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. \\<And>a P.\n       \\<lbrakk>(p, ins, outs)\n                \\<in> set (((C__, M), [], []) # procs P) \\<Longrightarrow>\n                distinct outs;\n        (p, ins, outs)\n        \\<in> set (((C__, M), [], []) # procs (a # P))\\<rbrakk>\n       \\<Longrightarrow> distinct outs", "with Cons"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs P) \\<Longrightarrow>\n  distinct outs\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs (Cl # P))\n  Cl = (C, D, fs, ms)", "show ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs P) \\<Longrightarrow>\n  distinct outs\n  (p, ins, outs) \\<in> set (((C__, M), [], []) # procs (Cl # P))\n  Cl = (C, D, fs, ms)\n\ngoal (1 subgoal):\n 1. distinct outs", "by hypsubst_thin (induct ms, auto)"], ["proof (state)\nthis:\n  distinct outs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct outs\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation JVMCFG_Exit_Interpret:\n  CFGExit \"sourcenode\" \"targetnode\" \"kind\" \"valid_edge (P, C0, Main)\"\n  \"(ClassMain P, MethodMain P, None, Enter)\"\n  \"(\\<lambda>(C, M, pc, type). (C, M))\" \"get_return_edges P\"\n  \"((ClassMain P, MethodMain P),[],[]) # procs (PROG P)\"\n  \"(ClassMain P, MethodMain P)\" \"(ClassMain P, MethodMain P, None, Return)\"\n  for P C0 Main"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge (P, C0, Main))\n     (ClassMain P, MethodMain P, None, Enter)\n     (\\<lambda>(C, M, pc, type). (C, M)) (get_return_edges P)\n     (((ClassMain P, MethodMain P), [], []) # procs (PROG P))\n     (ClassMain P, MethodMain P)\n     (ClassMain P, MethodMain P, None, nodeType.Return)", "proof (unfold_locales)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        sourcenode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. (case (ClassMain P, MethodMain P, None, nodeType.Return) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 3. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        sourcenode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. (case (ClassMain P, MethodMain P, None, nodeType.Return) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 3. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"valid_edge (P, C0, Main) a\"\n    and \"sourcenode a = (ClassMain P, MethodMain P, None, nodeType.Return)\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  sourcenode a = (ClassMain P, MethodMain P, None, nodeType.Return)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        sourcenode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. (case (ClassMain P, MethodMain P, None, nodeType.Return) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 3. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus False"], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  sourcenode a = (ClassMain P, MethodMain P, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. False", "by (cases a, clarsimp simp: valid_edge_def) (erule JVMCFG.cases, simp_all, clarsimp)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. (case (ClassMain P, MethodMain P, None, nodeType.Return) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 2. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (case (ClassMain P, MethodMain P, None, nodeType.Return) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)\n 2. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "show \"(\\<lambda>(C, M, pc, type). (C, M)) (ClassMain P, MethodMain P, None, nodeType.Return) =\n    (ClassMain P, MethodMain P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (ClassMain P, MethodMain P, None, nodeType.Return) of\n     (C, M, pc, type) \\<Rightarrow> (C, M)) =\n    (ClassMain P, MethodMain P)", "by simp"], ["proof (state)\nthis:\n  (case (ClassMain P, MethodMain P, None, nodeType.Return) of\n   (C, M, pc, type) \\<Rightarrow> (C, M)) =\n  (ClassMain P, MethodMain P)\n\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a Q p f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"valid_edge (P, C0, Main) a\"\n    and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n    and \"targetnode a = (ClassMain P, MethodMain P, None, nodeType.Return)\""], ["proof (state)\nthis:\n  valid_edge (P, C0, Main) a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (ClassMain P, MethodMain P, None, nodeType.Return)\n\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge (P, C0, Main) a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a =\n        (ClassMain P, MethodMain P, None, nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus False"], ["proof (prove)\nusing this:\n  valid_edge (P, C0, Main) a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (ClassMain P, MethodMain P, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. False", "by (cases a, clarsimp simp: valid_edge_def) (erule JVMCFG.cases, simp_all)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "show \"\\<exists>a. valid_edge (P, C0, Main) a \\<and>\n    sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n    targetnode a = (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n    kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge (P, C0, Main) a \\<and>\n       sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n       targetnode a =\n       (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by (fastforce intro: JVMCFG_reachable.intros simp: valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge (P, C0, Main) a \\<and>\n     sourcenode a = (ClassMain P, MethodMain P, None, Enter) \\<and>\n     targetnode a =\n     (ClassMain P, MethodMain P, None, nodeType.Return) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}