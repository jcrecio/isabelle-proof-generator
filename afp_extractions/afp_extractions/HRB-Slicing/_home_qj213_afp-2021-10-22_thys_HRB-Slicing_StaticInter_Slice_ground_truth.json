{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/Slice.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma [simp]: \"length (csppa m S x fs) = length fs\"", "lemma [simp]: \"length (cspp m S fs) = length fs\"", "lemma csppa_Formal_in_notin_slice: \n  \"\\<lbrakk>x < length fs; Formal_in(m,x + i) \\<notin> S\\<rbrakk>\n  \\<Longrightarrow> (csppa m S i fs)!x = Map.empty\"", "lemma csppa_Formal_in_in_slice: \n  \"\\<lbrakk>x < length fs; Formal_in(m,x + i) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (csppa m S i fs)!x = fs!x\"", "lemma rspp_Actual_out_in_slice:\n  assumes \"x < length (ParamDefs (targetnode a))\" and \"valid_edge a\"\n  and \"length (ParamDefs (targetnode a)) = length xs\" \n  and \"Actual_out (targetnode a,x) \\<in> S\"\n  shows \"(rspp (targetnode a) S xs f g) ((ParamDefs (targetnode a))!x) = g(xs!x)\"", "lemma rspp_Actual_out_notin_slice:\n  assumes \"x < length (ParamDefs (targetnode a))\" and \"valid_edge a\"\n  and \"length (ParamDefs (targetnode a)) = length xs\" \n  and \"Actual_out((targetnode a),x) \\<notin> S\"\n  shows \"(rspp (targetnode a) S xs f g) ((ParamDefs (targetnode a))!x) = \n  f((ParamDefs (targetnode a))!x)\"", "lemma slice_intra_kind_in_slice:\n  \"\\<lbrakk>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; intra_kind (kind a)\\<rbrakk> \n  \\<Longrightarrow> slice_kind S a = kind a\"", "lemma slice_kind_Upd:\n  \"\\<lbrakk>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = \\<Up>f\\<rbrakk> \\<Longrightarrow> slice_kind S a = \\<Up>id\"", "lemma slice_kind_Pred_empty_obs_nearer_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  and \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" \n  and \"method_exit mex\" and \"get_proc (sourcenode a) = get_proc mex\"\n  and \"distance (targetnode a) mex x\" and \"distance (sourcenode a) mex (x + 1)\"\n  and \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') mex x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                     targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_empty_obs_nearer_not_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  and \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" \n  and \"method_exit mex\" and \"get_proc (sourcenode a) = get_proc mex\"\n  and \"distance (targetnode a) mex x\" and \"distance (sourcenode a) mex (x + 1)\"\n  and \"targetnode a \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') mex x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                     targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_empty_obs_not_nearer:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  and \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" \n  and \"method_exit mex\" and \"get_proc (sourcenode a) = get_proc mex\"\n  and dist:\"distance (sourcenode a) mex (x + 1)\" \"\\<not> distance (targetnode a) mex x\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_obs_nearer_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                     distance (targetnode a') m x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and> \n                                     targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_obs_nearer_not_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a \\<noteq> (SOME nx'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                      distance (targetnode a') m x \\<and>\n                                      valid_edge a' \\<and> intra_kind(kind a') \\<and> \n                                      targetnode a' = nx')\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_obs_not_nearer:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and in_obs:\"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and dist:\"distance (sourcenode a) m (x + 1)\" \n           \"\\<not> distance (targetnode a) m x\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma kind_Predicate_notin_slice_slice_kind_Predicate:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"valid_edge a\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  obtains Q' where \"slice_kind S a = (Q')\\<^sub>\\<surd>\" and \"Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True)\"", "lemma slice_kind_Call:\n  \"\\<lbrakk>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk> \n  \\<Longrightarrow> slice_kind S a = (\\<lambda>cf. False):r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"", "lemma slice_kind_Call_in_slice:\n  \"\\<lbrakk>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk> \n  \\<Longrightarrow> slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\"", "lemma slice_kind_Call_in_slice_Formal_in_not:\n  assumes \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"\\<forall>x < length fs. Formal_in(targetnode a,x) \\<notin> HRB_slice S\" \n  shows \"slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty\"", "lemma slice_kind_Call_in_slice_Formal_in_also:\n  assumes \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"\\<forall>x < length fs. Formal_in(targetnode a,x) \\<in> HRB_slice S\" \n  shows \"slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"", "lemma slice_kind_Call_intra_notin_slice:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"valid_edge a\" \n  and \"intra_kind (kind a)\" and \"valid_edge a'\" and \"kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"sourcenode a' = sourcenode a\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma slice_kind_Return:\n  \"\\<lbrakk>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = (\\<lambda>cf. True)\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. cf')\"", "lemma slice_kind_Return_in_slice:\n  \"\\<lbrakk>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; \n   (p,ins,outs) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. rspp (targetnode a) (HRB_slice S) outs cf' cf)\"", "lemma length_transfer_kind_slice_kind:\n  assumes \"valid_edge a\" and \"length s\\<^sub>1 = length s\\<^sub>2\"\n  and \"transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\" and \"transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\"\n  shows \"length s\\<^sub>1' = length s\\<^sub>2'\"", "lemma only_one_SOME_edge:\n  assumes \"valid_edge a\" and \"intra_kind(kind a)\" and \"distance (targetnode a) mex x\"\n  shows \"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and> intra_kind(kind a') \\<and>\n               targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              distance (targetnode a') mex x \\<and>\n                                              valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                              targetnode a' = n')\"", "lemma slice_kind_only_one_True_edge:\n  assumes \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\" \n  and \"valid_edge a\" and \"valid_edge a'\" and \"intra_kind (kind a)\" \n  and \"intra_kind (kind a')\" and \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"\n  shows \"slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma slice_deterministic:\n  assumes \"valid_edge a\" and \"valid_edge a'\"\n  and \"intra_kind (kind a)\" and \"intra_kind (kind a')\"\n  and \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\"\n  obtains Q Q' where \"slice_kind S a = (Q)\\<^sub>\\<surd>\" and \"slice_kind S a' = (Q')\\<^sub>\\<surd>\"\n  and \"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], "translations": [["", "lemma [simp]: \"length (csppa m S x fs) = length fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (csppa m S x fs) = length fs", "by(induct fs arbitrary:x)(auto)"], ["", "lemma [simp]: \"length (cspp m S fs) = length fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (cspp m S fs) = length fs", "by(simp add:cspp_def)"], ["", "lemma csppa_Formal_in_notin_slice: \n  \"\\<lbrakk>x < length fs; Formal_in(m,x + i) \\<notin> S\\<rbrakk>\n  \\<Longrightarrow> (csppa m S i fs)!x = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < length fs; Formal_in (m, x + i) \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> csppa m S i fs ! x = Map.empty", "by(induct fs arbitrary:i x,auto simp:nth_Cons')"], ["", "lemma csppa_Formal_in_in_slice: \n  \"\\<lbrakk>x < length fs; Formal_in(m,x + i) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (csppa m S i fs)!x = fs!x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < length fs; Formal_in (m, x + i) \\<in> S\\<rbrakk>\n    \\<Longrightarrow> csppa m S i fs ! x = fs ! x", "by(induct fs arbitrary:i x,auto simp:nth_Cons')"], ["", "definition map_merge :: \"('var \\<rightharpoonup> 'val) \\<Rightarrow> ('var \\<rightharpoonup> 'val) \\<Rightarrow> (nat \\<Rightarrow> bool) \\<Rightarrow> \n                         'var list \\<Rightarrow> ('var \\<rightharpoonup> 'val)\"\nwhere \"map_merge f g Q xs \\<equiv> (\\<lambda>V. if (\\<exists>i. i < length xs \\<and> xs!i = V \\<and> Q i) then g V \n                                 else f V)\""], ["", "definition rspp :: \"'node \\<Rightarrow> 'node SDG_node set \\<Rightarrow> 'var list \\<Rightarrow> \n  ('var \\<rightharpoonup> 'val) \\<Rightarrow> ('var \\<rightharpoonup> 'val) \\<Rightarrow> ('var \\<rightharpoonup> 'val)\"\nwhere \"rspp m S xs f g \\<equiv> map_merge f (Map.empty(ParamDefs m [:=] map g xs))\n  (\\<lambda>i. Actual_out(m,i) \\<in> S) (ParamDefs m)\""], ["", "lemma rspp_Actual_out_in_slice:\n  assumes \"x < length (ParamDefs (targetnode a))\" and \"valid_edge a\"\n  and \"length (ParamDefs (targetnode a)) = length xs\" \n  and \"Actual_out (targetnode a,x) \\<in> S\"\n  shows \"(rspp (targetnode a) S xs f g) ((ParamDefs (targetnode a))!x) = g(xs!x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) = g (xs ! x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) = g (xs ! x)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"distinct(ParamDefs (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs (targetnode a))", "by(rule distinct_ParamDefs)"], ["proof (state)\nthis:\n  distinct (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) = g (xs ! x)", "from \\<open>x < length (ParamDefs (targetnode a))\\<close> \n    \\<open>length (ParamDefs (targetnode a)) = length xs\\<close>\n    \\<open>distinct(ParamDefs (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  x < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length xs\n  distinct (ParamDefs (targetnode a))", "have \"(Map.empty(ParamDefs (targetnode a) [:=] map g xs))\n    ((ParamDefs (targetnode a))!x) = (map g xs)!x\""], ["proof (prove)\nusing this:\n  x < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length xs\n  distinct (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n     (ParamDefs (targetnode a) ! x) =\n    map g xs ! x", "by(fastforce intro:fun_upds_nth)"], ["proof (state)\nthis:\n  Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n   (ParamDefs (targetnode a) ! x) =\n  map g xs ! x\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) = g (xs ! x)", "with \\<open>Actual_out(targetnode a,x) \\<in> S\\<close> \\<open>x < length (ParamDefs (targetnode a))\\<close>\n    \\<open>length (ParamDefs (targetnode a)) = length xs\\<close>"], ["proof (chain)\npicking this:\n  Actual_out (targetnode a, x) \\<in> S\n  x < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length xs\n  Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n   (ParamDefs (targetnode a) ! x) =\n  map g xs ! x", "show ?thesis"], ["proof (prove)\nusing this:\n  Actual_out (targetnode a, x) \\<in> S\n  x < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length xs\n  Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n   (ParamDefs (targetnode a) ! x) =\n  map g xs ! x\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) = g (xs ! x)", "by(fastforce simp:rspp_def map_merge_def)"], ["proof (state)\nthis:\n  rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) = g (xs ! x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rspp_Actual_out_notin_slice:\n  assumes \"x < length (ParamDefs (targetnode a))\" and \"valid_edge a\"\n  and \"length (ParamDefs (targetnode a)) = length xs\" \n  and \"Actual_out((targetnode a),x) \\<notin> S\"\n  shows \"(rspp (targetnode a) S xs f g) ((ParamDefs (targetnode a))!x) = \n  f((ParamDefs (targetnode a))!x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) =\n    f (ParamDefs (targetnode a) ! x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) =\n    f (ParamDefs (targetnode a) ! x)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"distinct(ParamDefs (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs (targetnode a))", "by(rule distinct_ParamDefs)"], ["proof (state)\nthis:\n  distinct (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) =\n    f (ParamDefs (targetnode a) ! x)", "from \\<open>x < length (ParamDefs (targetnode a))\\<close> \n    \\<open>length (ParamDefs (targetnode a)) = length xs\\<close>\n    \\<open>distinct(ParamDefs (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  x < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length xs\n  distinct (ParamDefs (targetnode a))", "have \"(Map.empty(ParamDefs (targetnode a) [:=] map g xs))\n    ((ParamDefs (targetnode a))!x) = (map g xs)!x\""], ["proof (prove)\nusing this:\n  x < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length xs\n  distinct (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n     (ParamDefs (targetnode a) ! x) =\n    map g xs ! x", "by(fastforce intro:fun_upds_nth)"], ["proof (state)\nthis:\n  Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n   (ParamDefs (targetnode a) ! x) =\n  map g xs ! x\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) =\n    f (ParamDefs (targetnode a) ! x)", "with \\<open>Actual_out((targetnode a),x) \\<notin> S\\<close> \\<open>distinct(ParamDefs (targetnode a))\\<close> \n    \\<open>x < length (ParamDefs (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  Actual_out (targetnode a, x) \\<notin> S\n  distinct (ParamDefs (targetnode a))\n  x < length (ParamDefs (targetnode a))\n  Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n   (ParamDefs (targetnode a) ! x) =\n  map g xs ! x", "show ?thesis"], ["proof (prove)\nusing this:\n  Actual_out (targetnode a, x) \\<notin> S\n  distinct (ParamDefs (targetnode a))\n  x < length (ParamDefs (targetnode a))\n  Map.empty(ParamDefs (targetnode a) [:=] map g xs)\n   (ParamDefs (targetnode a) ! x) =\n  map g xs ! x\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) =\n    f (ParamDefs (targetnode a) ! x)", "by(fastforce simp:rspp_def map_merge_def nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  rspp (targetnode a) S xs f g (ParamDefs (targetnode a) ! x) =\n  f (ParamDefs (targetnode a) ! x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Defining the sliced edge kinds\\<close>"], ["", "primrec slice_kind_aux :: \"'node \\<Rightarrow> 'node \\<Rightarrow> 'node SDG_node set \\<Rightarrow> \n  ('var,'val,'ret,'pname) edge_kind \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind\"\nwhere \"slice_kind_aux m m' S \\<Up>f = (if m \\<in> \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> then \\<Up>f else \\<Up>id)\"\n  | \"slice_kind_aux m m' S (Q)\\<^sub>\\<surd> = (if m \\<in> \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> then (Q)\\<^sub>\\<surd> else\n  (if obs_intra m \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> = {} then \n    (let mex = (THE mex. method_exit mex \\<and> get_proc m = get_proc mex) in\n    (if (\\<exists>x. distance m' mex x \\<and> distance m mex (x + 1) \\<and>\n        (m' = (SOME mx'. \\<exists>a'. m = sourcenode a' \\<and> \n                              distance (targetnode a') mex x \\<and>\n                              valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                              targetnode a' = mx'))) \n          then (\\<lambda>cf. True)\\<^sub>\\<surd> else (\\<lambda>cf. False)\\<^sub>\\<surd>))\n     else (let mx = THE mx. mx \\<in> obs_intra m \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> in \n       (if (\\<exists>x. distance m' mx x \\<and> distance m mx (x + 1) \\<and>\n            (m' = (SOME mx'. \\<exists>a'. m = sourcenode a' \\<and> \n                                  distance (targetnode a') mx x \\<and>\n                                  valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                  targetnode a' = mx'))) \n          then (\\<lambda>cf. True)\\<^sub>\\<surd> else (\\<lambda>cf. False)\\<^sub>\\<surd>))))\"\n  | \"slice_kind_aux m m' S (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) = (if m \\<in> \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> then (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp m' S fs))\n                           else ((\\<lambda>cf. False):r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs))\"\n  | \"slice_kind_aux m m' S (Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) = (if m \\<in> \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> then \n      (let outs = THE outs. \\<exists>ins. (p,ins,outs) \\<in> set procs in\n         (Q\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. rspp m' S outs cf' cf)))\n    else ((\\<lambda>cf. True)\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. cf')))\""], ["", "definition slice_kind :: \"'node SDG_node set \\<Rightarrow> 'edge \\<Rightarrow> \n  ('var,'val,'ret,'pname) edge_kind\"\n  where \"slice_kind S a \\<equiv> \n  slice_kind_aux (sourcenode a) (targetnode a) (HRB_slice S) (kind a)\""], ["", "definition slice_kinds :: \"'node SDG_node set \\<Rightarrow> 'edge list \\<Rightarrow> \n  ('var,'val,'ret,'pname) edge_kind list\"\n  where \"slice_kinds S as \\<equiv> map (slice_kind S) as\""], ["", "lemma slice_intra_kind_in_slice:\n  \"\\<lbrakk>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; intra_kind (kind a)\\<rbrakk> \n  \\<Longrightarrow> slice_kind S a = kind a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a = kind a", "by(fastforce simp:intra_kind_def slice_kind_def)"], ["", "lemma slice_kind_Upd:\n  \"\\<lbrakk>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = \\<Up>f\\<rbrakk> \\<Longrightarrow> slice_kind S a = \\<Up>id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     kind a = \\<Up>f\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a = \\<Up>id", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Pred_empty_obs_nearer_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  and \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" \n  and \"method_exit mex\" and \"get_proc (sourcenode a) = get_proc mex\"\n  and \"distance (targetnode a) mex x\" and \"distance (sourcenode a) mex (x + 1)\"\n  and \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') mex x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                     targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>method_exit mex\\<close> \\<open>get_proc (sourcenode a) = get_proc mex\\<close>"], ["proof (chain)\npicking this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex", "have \"mex = (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\""], ["proof (prove)\nusing this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n\ngoal (1 subgoal):\n 1. mex =\n    (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)", "by(auto intro!:the_equality[THEN sym] intro:method_exit_unique)"], ["proof (state)\nthis:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> \n    \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)", "have \"slice_kind S a = \n    (if (\\<exists>x. distance (targetnode a) mex x \\<and> distance (sourcenode a) mex (x + 1) \\<and>\n    (targetnode a = (SOME mx'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n    distance (targetnode a') mex x \\<and> valid_edge a' \\<and> intra_kind(kind a') \\<and>\n    targetnode a' = mx'))) then (\\<lambda>cf. True)\\<^sub>\\<surd> else (\\<lambda>cf. False)\\<^sub>\\<surd>)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    (if \\<exists>x.\n           distance (targetnode a) mex x \\<and>\n           distance (sourcenode a) mex (x + 1) \\<and>\n           targetnode a =\n           (SOME mx'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') mex x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and> targetnode a' = mx')\n     then (\\<lambda>cf. True)\\<^sub>\\<surd>\n     else (\\<lambda>cf. False)\\<^sub>\\<surd>)", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a =\n  (if \\<exists>x.\n         distance (targetnode a) mex x \\<and>\n         distance (sourcenode a) mex (x + 1) \\<and>\n         targetnode a =\n         (SOME mx'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx')\n   then (\\<lambda>cf. True)\\<^sub>\\<surd>\n   else (\\<lambda>cf. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>distance (targetnode a) mex x\\<close> \\<open>distance (sourcenode a) mex (x + 1)\\<close>\n    \\<open>targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') mex x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                     targetnode a' = n')\\<close>"], ["proof (chain)\npicking this:\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  slice_kind S a =\n  (if \\<exists>x.\n         distance (targetnode a) mex x \\<and>\n         distance (sourcenode a) mex (x + 1) \\<and>\n         targetnode a =\n         (SOME mx'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx')\n   then (\\<lambda>cf. True)\\<^sub>\\<surd>\n   else (\\<lambda>cf. False)\\<^sub>\\<surd>)", "show ?thesis"], ["proof (prove)\nusing this:\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  slice_kind S a =\n  (if \\<exists>x.\n         distance (targetnode a) mex x \\<and>\n         distance (sourcenode a) mex (x + 1) \\<and>\n         targetnode a =\n         (SOME mx'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx')\n   then (\\<lambda>cf. True)\\<^sub>\\<surd>\n   else (\\<lambda>cf. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by fastforce"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Pred_empty_obs_nearer_not_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  and \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" \n  and \"method_exit mex\" and \"get_proc (sourcenode a) = get_proc mex\"\n  and \"distance (targetnode a) mex x\" and \"distance (sourcenode a) mex (x + 1)\"\n  and \"targetnode a \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') mex x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                     targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>method_exit mex\\<close> \\<open>get_proc (sourcenode a) = get_proc mex\\<close>"], ["proof (chain)\npicking this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex", "have \"mex = (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\""], ["proof (prove)\nusing this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n\ngoal (1 subgoal):\n 1. mex =\n    (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)", "by(auto intro!:the_equality[THEN sym] intro:method_exit_unique)"], ["proof (state)\nthis:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> \n    \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)", "have \"slice_kind S a = \n    (if (\\<exists>x. distance (targetnode a) mex x \\<and> distance (sourcenode a) mex (x + 1) \\<and>\n    (targetnode a = (SOME mx'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n    distance (targetnode a') mex x \\<and> valid_edge a' \\<and> intra_kind(kind a') \\<and>\n    targetnode a' = mx'))) then (\\<lambda>cf. True)\\<^sub>\\<surd> else (\\<lambda>cf. False)\\<^sub>\\<surd>)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    (if \\<exists>x.\n           distance (targetnode a) mex x \\<and>\n           distance (sourcenode a) mex (x + 1) \\<and>\n           targetnode a =\n           (SOME mx'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') mex x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and> targetnode a' = mx')\n     then (\\<lambda>cf. True)\\<^sub>\\<surd>\n     else (\\<lambda>cf. False)\\<^sub>\\<surd>)", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a =\n  (if \\<exists>x.\n         distance (targetnode a) mex x \\<and>\n         distance (sourcenode a) mex (x + 1) \\<and>\n         targetnode a =\n         (SOME mx'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx')\n   then (\\<lambda>cf. True)\\<^sub>\\<surd>\n   else (\\<lambda>cf. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>distance (targetnode a) mex x\\<close> \\<open>distance (sourcenode a) mex (x + 1)\\<close>\n    \\<open>targetnode a \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') mex x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                     targetnode a' = n')\\<close>"], ["proof (chain)\npicking this:\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  slice_kind S a =\n  (if \\<exists>x.\n         distance (targetnode a) mex x \\<and>\n         distance (sourcenode a) mex (x + 1) \\<and>\n         targetnode a =\n         (SOME mx'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx')\n   then (\\<lambda>cf. True)\\<^sub>\\<surd>\n   else (\\<lambda>cf. False)\\<^sub>\\<surd>)", "show ?thesis"], ["proof (prove)\nusing this:\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  slice_kind S a =\n  (if \\<exists>x.\n         distance (targetnode a) mex x \\<and>\n         distance (sourcenode a) mex (x + 1) \\<and>\n         targetnode a =\n         (SOME mx'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx')\n   then (\\<lambda>cf. True)\\<^sub>\\<surd>\n   else (\\<lambda>cf. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto dest:distance_det)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Pred_empty_obs_not_nearer:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  and \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" \n  and \"method_exit mex\" and \"get_proc (sourcenode a) = get_proc mex\"\n  and dist:\"distance (sourcenode a) mex (x + 1)\" \"\\<not> distance (targetnode a) mex x\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>method_exit mex\\<close> \\<open>get_proc (sourcenode a) = get_proc mex\\<close>"], ["proof (chain)\npicking this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex", "have \"mex = (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\""], ["proof (prove)\nusing this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n\ngoal (1 subgoal):\n 1. mex =\n    (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)", "by(auto intro!:the_equality[THEN sym] intro:method_exit_unique)"], ["proof (state)\nthis:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "moreover"], ["proof (state)\nthis:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from dist"], ["proof (chain)\npicking this:\n  distance (sourcenode a) mex (x + 1)\n  \\<not> distance (targetnode a) mex x", "have \"\\<not> (\\<exists>x. distance (targetnode a) mex x \\<and> \n                            distance (sourcenode a) mex (x + 1))\""], ["proof (prove)\nusing this:\n  distance (sourcenode a) mex (x + 1)\n  \\<not> distance (targetnode a) mex x\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1)", "by(fastforce dest:distance_det)"], ["proof (state)\nthis:\n  \\<nexists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n  \\<nexists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n  \\<nexists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "using assms"], ["proof (prove)\nusing this:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n  \\<nexists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n  distance (sourcenode a) mex (x + 1)\n  \\<not> distance (targetnode a) mex x\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Pred_obs_nearer_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                     distance (targetnode a') m x \\<and>\n                                     valid_edge a' \\<and> intra_kind(kind a') \\<and> \n                                     targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m = (THE m. m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m =\n    (THE m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(rule obs_intra_the_element[THEN sym])"], ["proof (state)\nthis:\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with assms"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(auto simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Pred_obs_nearer_not_SOME:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a \\<noteq> (SOME nx'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                      distance (targetnode a') m x \\<and>\n                                      valid_edge a' \\<and> intra_kind(kind a') \\<and> \n                                      targetnode a' = nx')\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m = (THE m. m \\<in> obs_intra (sourcenode a) (\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>))\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m =\n    (THE m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(rule obs_intra_the_element[THEN sym])"], ["proof (state)\nthis:\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with assms"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME nx'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx')\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME nx'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx')\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto dest:distance_det simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Pred_obs_not_nearer:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and in_obs:\"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and dist:\"distance (sourcenode a) m (x + 1)\" \n           \"\\<not> distance (targetnode a) m x\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from in_obs"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have the:\"m = (THE m. m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m =\n    (THE m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(rule obs_intra_the_element[THEN sym])"], ["proof (state)\nthis:\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from dist"], ["proof (chain)\npicking this:\n  distance (sourcenode a) m (x + 1)\n  \\<not> distance (targetnode a) m x", "have \"\\<not> (\\<exists>x. distance (targetnode a) m x \\<and> \n                            distance (sourcenode a) m (x + 1))\""], ["proof (prove)\nusing this:\n  distance (sourcenode a) m (x + 1)\n  \\<not> distance (targetnode a) m x\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)", "by(fastforce dest:distance_det)"], ["proof (state)\nthis:\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> in_obs the"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kind_Predicate_notin_slice_slice_kind_Predicate:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"valid_edge a\" and \"kind a = (Q)\\<^sub>\\<surd>\"\n  obtains Q' where \"slice_kind S a = (Q')\\<^sub>\\<surd>\" and \"Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        \\<lbrakk>slice_kind S a = (Q')\\<^sub>\\<surd>;\n         Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show \"\\<exists>Q'. slice_kind S a = (Q')\\<^sub>\\<surd> \\<and> (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "then"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)", "obtain as where \"sourcenode a -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        sourcenode\n         a -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "then"], ["proof (chain)\npicking this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as' mex where \"sourcenode a -as'\\<rightarrow>\\<^sub>\\<iota>* mex\" and \"method_exit mex\""], ["proof (prove)\nusing this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as' mex.\n        \\<lbrakk>sourcenode a -as'\\<rightarrow>\\<^sub>\\<iota>* mex;\n         method_exit mex\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  sourcenode a -as'\\<rightarrow>\\<^sub>\\<iota>* mex\n  method_exit mex\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "from \\<open>sourcenode a -as'\\<rightarrow>\\<^sub>\\<iota>* mex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -as'\\<rightarrow>\\<^sub>\\<iota>* mex", "have \"get_proc (sourcenode a) = get_proc mex\""], ["proof (prove)\nusing this:\n  sourcenode a -as'\\<rightarrow>\\<^sub>\\<iota>* mex\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc mex", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc mex\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"\\<exists>x. distance (targetnode a) mex x \\<and> \n        distance (sourcenode a) mex (x + 1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  \\<exists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)", "obtain x where \"distance (targetnode a) mex x\" \n        and \"distance (sourcenode a) mex (x + 1)\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance (targetnode a) mex x;\n         distance (sourcenode a) mex (x + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                                 distance (targetnode a') mex x \\<and>\n                                                 valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                                 targetnode a' = n')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n          \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>\n          \\<open>method_exit mex\\<close> \\<open>get_proc (sourcenode a) = get_proc mex\\<close>\n          \\<open>distance (targetnode a) mex x\\<close> \\<open>distance (sourcenode a) mex (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_empty_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n          \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>\n          \\<open>method_exit mex\\<close> \\<open>get_proc (sourcenode a) = get_proc mex\\<close>\n          \\<open>distance (targetnode a) mex x\\<close> \\<open>distance (sourcenode a) mex (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_empty_obs_nearer_not_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  \\<nexists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "from \\<open>method_exit mex\\<close> \\<open>get_proc (sourcenode a) = get_proc mex\\<close>"], ["proof (chain)\npicking this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex", "have \"mex = (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\""], ["proof (prove)\nusing this:\n  method_exit mex\n  get_proc (sourcenode a) = get_proc mex\n\ngoal (1 subgoal):\n 1. mex =\n    (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)", "by(auto intro!:the_equality[THEN sym] intro:method_exit_unique)"], ["proof (state)\nthis:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n        \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close> False"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  \\<nexists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)", "have \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  \\<nexists>x.\n     distance (targetnode a) mex x \\<and>\n     distance (sourcenode a) mex (x + 1)\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) mex x \\<and>\n       distance (sourcenode a) mex (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "then"], ["proof (chain)\npicking this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}", "obtain m where \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice\n                           S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"\\<exists>x. distance (targetnode a) m x \\<and> \n        distance (sourcenode a) m (x + 1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  \\<exists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)", "obtain x where \"distance (targetnode a) m x\" \n        and \"distance (sourcenode a) m (x + 1)\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance (targetnode a) m x;\n         distance (sourcenode a) m (x + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                                 distance (targetnode a') m x \\<and>\n                                                 valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                                 targetnode a' = n')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n          \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n          \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_obs_nearer_not_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "from \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m = (THE m. m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m =\n    (THE m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(rule obs_intra_the_element[THEN sym])"], ["proof (state)\nthis:\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> False\n        \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Call:\n  \"\\<lbrakk>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk> \n  \\<Longrightarrow> slice_kind S a = (\\<lambda>cf. False):r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a =\n                      \\<lambda>cf.\n                         False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Call_in_slice:\n  \"\\<lbrakk>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk> \n  \\<Longrightarrow> slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a =\n                      Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp\n                      (targetnode a) (HRB_slice S) fs", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Call_in_slice_Formal_in_not:\n  assumes \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"\\<forall>x < length fs. Formal_in(targetnode a,x) \\<notin> HRB_slice S\" \n  shows \"slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S)\n    fs", "by(simp add:slice_kind_def)"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty", "from \\<open>\\<forall>x < length fs. Formal_in(targetnode a,x) \\<notin> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x<length fs. Formal_in (targetnode a, x) \\<notin> HRB_slice S", "have \"cspp (targetnode a) (HRB_slice S) fs = replicate (length fs) Map.empty\""], ["proof (prove)\nusing this:\n  \\<forall>x<length fs. Formal_in (targetnode a, x) \\<notin> HRB_slice S\n\ngoal (1 subgoal):\n 1. cspp (targetnode a) (HRB_slice S) fs = replicate (length fs) Map.empty", "by(fastforce intro:nth_equalityI csppa_Formal_in_notin_slice simp:cspp_def)"], ["proof (state)\nthis:\n  cspp (targetnode a) (HRB_slice S) fs = replicate (length fs) Map.empty\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty", "with \\<open>slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  cspp (targetnode a) (HRB_slice S) fs = replicate (length fs) Map.empty", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  cspp (targetnode a) (HRB_slice S) fs = replicate (length fs) Map.empty\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty", "by simp"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>replicate (length fs) Map.empty\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Call_in_slice_Formal_in_also:\n  assumes \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"\\<forall>x < length fs. Formal_in(targetnode a,x) \\<in> HRB_slice S\" \n  shows \"slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S)\n    fs", "by(simp add:slice_kind_def)"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n\ngoal (1 subgoal):\n 1. slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "from \\<open>\\<forall>x < length fs. Formal_in(targetnode a,x) \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x<length fs. Formal_in (targetnode a, x) \\<in> HRB_slice S", "have \"cspp (targetnode a) (HRB_slice S) fs = fs\""], ["proof (prove)\nusing this:\n  \\<forall>x<length fs. Formal_in (targetnode a, x) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. cspp (targetnode a) (HRB_slice S) fs = fs", "by(fastforce intro:nth_equalityI csppa_Formal_in_in_slice simp:cspp_def)"], ["proof (state)\nthis:\n  cspp (targetnode a) (HRB_slice S) fs = fs\n\ngoal (1 subgoal):\n 1. slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "with \\<open>slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  cspp (targetnode a) (HRB_slice S) fs = fs", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  cspp (targetnode a) (HRB_slice S) fs = fs\n\ngoal (1 subgoal):\n 1. slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  slice_kind S a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Call_intra_notin_slice:\n  assumes \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"valid_edge a\" \n  and \"intra_kind (kind a)\" and \"valid_edge a'\" and \"kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  and \"sourcenode a' = sourcenode a\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain a'' \n    where \"a'' \\<in> get_return_edges a'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        a'' \\<in> get_return_edges a' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:get_return_edge_call)"], ["proof (state)\nthis:\n  a'' \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  a'' \\<in> get_return_edges a'", "obtain ax where \"valid_edge ax\" \n    and \"sourcenode ax = sourcenode a'\" and \" targetnode ax = targetnode a''\"\n    and \"kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  a'' \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode ax = sourcenode a';\n         targetnode ax = targetnode a'';\n         kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax = sourcenode a'\n  targetnode ax = targetnode a''\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<exists>!a''. valid_edge a'' \\<and> sourcenode a'' = sourcenode a' \\<and> \n    intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>!a''.\n       valid_edge a'' \\<and>\n       sourcenode a'' = sourcenode a' \\<and> intra_kind (kind a'')", "by(rule call_only_one_intra_edge)"], ["proof (state)\nthis:\n  \\<exists>!a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a' = sourcenode a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a' = sourcenode a\n  intra_kind (kind a)\n  \\<exists>!a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and> intra_kind (kind a'')", "have all:\"\\<forall>a''. valid_edge a'' \\<and> sourcenode a'' = sourcenode a' \\<and> \n    intra_kind(kind a'') \\<longrightarrow> a'' = a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a' = sourcenode a\n  intra_kind (kind a)\n  \\<exists>!a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<forall>a''.\n       valid_edge a'' \\<and>\n       sourcenode a'' = sourcenode a' \\<and>\n       intra_kind (kind a'') \\<longrightarrow>\n       a'' = a", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and>\n     intra_kind (kind a'') \\<longrightarrow>\n     a'' = a\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = sourcenode a'\\<close> \\<open>kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = sourcenode a'\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  \\<forall>a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and>\n     intra_kind (kind a'') \\<longrightarrow>\n     a'' = a", "have [simp]:\"ax = a\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = sourcenode a'\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  \\<forall>a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and>\n     intra_kind (kind a'') \\<longrightarrow>\n     a'' = a\n\ngoal (1 subgoal):\n 1. ax = a", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  ax = a\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof(cases \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "then"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)", "obtain asx where \"sourcenode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        sourcenode\n         a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "then"], ["proof (chain)\npicking this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as pex where \"sourcenode a-as\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (prove)\nusing this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as pex.\n        \\<lbrakk>sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>sourcenode a-as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"get_proc (sourcenode a) = get_proc pex\""], ["proof (prove)\nusing this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc pex", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc pex\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>sourcenode a-as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* pex", "obtain x where \"distance (sourcenode a) pex x\"\n      and \"x \\<le> length as\""], ["proof (prove)\nusing this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance (sourcenode a) pex x; x \\<le> length as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule every_path_distance)"], ["proof (state)\nthis:\n  distance (sourcenode a) pex x\n  x \\<le> length as\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  method_exit pex", "have \"sourcenode a \\<noteq> pex\""], ["proof (prove)\nusing this:\n  method_exit pex\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> pex", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> sourcenode a \\<noteq> pex\n 2. \\<And>aa Q f p.\n       \\<lbrakk>pex = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> sourcenode a \\<noteq> pex", "assume \"pex = (_Exit_)\""], ["proof (state)\nthis:\n  pex = (_Exit_)\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> sourcenode a \\<noteq> pex\n 2. \\<And>aa Q f p.\n       \\<lbrakk>pex = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> sourcenode a \\<noteq> pex", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> pex", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a = pex \\<Longrightarrow> False", "assume \"sourcenode a = pex\""], ["proof (state)\nthis:\n  sourcenode a = pex\n\ngoal (1 subgoal):\n 1. sourcenode a = pex \\<Longrightarrow> False", "with \\<open>pex = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  pex = (_Exit_)\n  sourcenode a = pex", "have \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  pex = (_Exit_)\n  sourcenode a = pex\n\ngoal (1 subgoal):\n 1. sourcenode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. sourcenode a = pex \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> pex\n\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>pex = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> sourcenode a \\<noteq> pex", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>pex = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> sourcenode a \\<noteq> pex", "fix ax Qx px fx"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>pex = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> sourcenode a \\<noteq> pex", "assume \"pex = sourcenode ax\" and \"valid_edge ax\" and \"kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx\""], ["proof (state)\nthis:\n  pex = sourcenode ax\n  valid_edge ax\n  kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx\n\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>pex = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> sourcenode a \\<noteq> pex", "hence \"\\<forall>a'. valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow> \n        (\\<exists>Qx' fx'. kind a' = Qx'\\<hookleftarrow>\\<^bsub>px\\<^esub>fx')\""], ["proof (prove)\nusing this:\n  pex = sourcenode ax\n  valid_edge ax\n  kind ax = Qx\\<hookleftarrow>\\<^bsub>px\\<^esub>fx\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n       (\\<exists>Qx' fx'.\n           kind a' = Qx'\\<hookleftarrow>\\<^bsub>px\\<^esub>fx')", "by -(rule return_edges_only)"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n     (\\<exists>Qx' fx'. kind a' = Qx'\\<hookleftarrow>\\<^bsub>px\\<^esub>fx')\n\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>pex = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> sourcenode a \\<noteq> pex", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>pex = sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  pex = sourcenode ax\n  \\<forall>a'.\n     valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n     (\\<exists>Qx' fx'. kind a' = Qx'\\<hookleftarrow>\\<^bsub>px\\<^esub>fx')", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  pex = sourcenode ax\n  \\<forall>a'.\n     valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n     (\\<exists>Qx' fx'. kind a' = Qx'\\<hookleftarrow>\\<^bsub>px\\<^esub>fx')\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> pex", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> pex\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> pex\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> False", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> False", "with \\<open>distance (sourcenode a) pex x\\<close>"], ["proof (chain)\npicking this:\n  distance (sourcenode a) pex x\n  x = 0", "have \"sourcenode a = pex\""], ["proof (prove)\nusing this:\n  distance (sourcenode a) pex x\n  x = 0\n\ngoal (1 subgoal):\n 1. sourcenode a = pex", "by(fastforce elim:distance.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a = pex\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> False", "with \\<open>sourcenode a \\<noteq> pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<noteq> pex\n  sourcenode a = pex", "show False"], ["proof (prove)\nusing this:\n  sourcenode a \\<noteq> pex\n  sourcenode a = pex\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>distance (sourcenode a) pex x\\<close>"], ["proof (chain)\npicking this:\n  distance (sourcenode a) pex x\n  x \\<noteq> 0", "obtain ax' where \"valid_edge ax'\"\n      and \"sourcenode a = sourcenode ax'\" and \"intra_kind(kind ax')\"\n      and \"distance (targetnode ax') pex (x - 1)\"\n      and Some:\"targetnode ax' = (SOME nx. \\<exists>a'. sourcenode ax' = sourcenode a' \\<and> \n                                          distance (targetnode a') pex (x - 1) \\<and>\n                                          valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                          targetnode a' = nx)\""], ["proof (prove)\nusing this:\n  distance (sourcenode a) pex x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ax'.\n        \\<lbrakk>valid_edge ax'; sourcenode a = sourcenode ax';\n         intra_kind (kind ax'); distance (targetnode ax') pex (x - 1);\n         targetnode ax' =\n         (SOME nx.\n             \\<exists>a'.\n                sourcenode ax' = sourcenode a' \\<and>\n                distance (targetnode a') pex (x - 1) \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = nx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule distance_successor_distance)"], ["proof (state)\nthis:\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  intra_kind (kind ax')\n  distance (targetnode ax') pex (x - 1)\n  targetnode ax' =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode ax' = sourcenode a' \\<and>\n         distance (targetnode a') pex (x - 1) \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>valid_edge ax'\\<close> \\<open>sourcenode a = sourcenode ax'\\<close> \\<open>intra_kind(kind ax')\\<close>\n      \\<open>sourcenode a' = sourcenode a\\<close> all"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  intra_kind (kind ax')\n  sourcenode a' = sourcenode a\n  \\<forall>a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and>\n     intra_kind (kind a'') \\<longrightarrow>\n     a'' = a", "have [simp]:\"ax' = a\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  intra_kind (kind ax')\n  sourcenode a' = sourcenode a\n  \\<forall>a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and>\n     intra_kind (kind a'') \\<longrightarrow>\n     a'' = a\n\ngoal (1 subgoal):\n 1. ax' = a", "by fastforce"], ["proof (state)\nthis:\n  ax' = a\n\ngoal (2 subgoals):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>\n      True \\<open>method_exit pex\\<close> \\<open>get_proc (sourcenode a) = get_proc pex\\<close> \\<open>x \\<noteq> 0\\<close>\n      \\<open>distance (targetnode ax') pex (x - 1)\\<close> \\<open>distance (sourcenode a) pex x\\<close> Some"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit pex\n  get_proc (sourcenode a) = get_proc pex\n  x \\<noteq> 0\n  distance (targetnode ax') pex (x - 1)\n  distance (sourcenode a) pex x\n  targetnode ax' =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode ax' = sourcenode a' \\<and>\n         distance (targetnode a') pex (x - 1) \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit pex\n  get_proc (sourcenode a) = get_proc pex\n  x \\<noteq> 0\n  distance (targetnode ax') pex (x - 1)\n  distance (sourcenode a) pex x\n  targetnode ax' =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode ax' = sourcenode a' \\<and>\n         distance (targetnode a') pex (x - 1) \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce elim:slice_kind_Pred_empty_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "then"], ["proof (chain)\npicking this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}", "obtain m where \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice\n                           S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "then"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain as where \"sourcenode a-as\\<rightarrow>\\<^sub>\\<iota>* m\" and \"m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* m;\n         m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule obs_intraE)"], ["proof (state)\nthis:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* m\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>sourcenode a-as\\<rightarrow>\\<^sub>\\<iota>* m\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* m", "obtain x where \"distance (sourcenode a) m x\"\n      and \"x \\<le> length as\""], ["proof (prove)\nusing this:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance (sourcenode a) m x; x \\<le> length as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule every_path_distance)"], ["proof (state)\nthis:\n  distance (sourcenode a) m x\n  x \\<le> length as\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a \\<noteq> m\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> m", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> m\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> False", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> False", "with \\<open>distance (sourcenode a) m x\\<close>"], ["proof (chain)\npicking this:\n  distance (sourcenode a) m x\n  x = 0", "have \"sourcenode a = m\""], ["proof (prove)\nusing this:\n  distance (sourcenode a) m x\n  x = 0\n\ngoal (1 subgoal):\n 1. sourcenode a = m", "by(fastforce elim:distance.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a = m\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> False", "with \\<open>sourcenode a \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<noteq> m\n  sourcenode a = m", "show False"], ["proof (prove)\nusing this:\n  sourcenode a \\<noteq> m\n  sourcenode a = m\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>distance (sourcenode a) m x\\<close>"], ["proof (chain)\npicking this:\n  distance (sourcenode a) m x\n  x \\<noteq> 0", "obtain ax' where \"valid_edge ax'\"\n      and \"sourcenode a = sourcenode ax'\" and \"intra_kind(kind ax')\"\n      and \"distance (targetnode ax') m (x - 1)\"\n      and Some:\"targetnode ax' = (SOME nx. \\<exists>a'. sourcenode ax' = sourcenode a' \\<and> \n                                          distance (targetnode a') m (x - 1) \\<and>\n                                          valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                          targetnode a' = nx)\""], ["proof (prove)\nusing this:\n  distance (sourcenode a) m x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ax'.\n        \\<lbrakk>valid_edge ax'; sourcenode a = sourcenode ax';\n         intra_kind (kind ax'); distance (targetnode ax') m (x - 1);\n         targetnode ax' =\n         (SOME nx.\n             \\<exists>a'.\n                sourcenode ax' = sourcenode a' \\<and>\n                distance (targetnode a') m (x - 1) \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = nx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule distance_successor_distance)"], ["proof (state)\nthis:\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  intra_kind (kind ax')\n  distance (targetnode ax') m (x - 1)\n  targetnode ax' =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode ax' = sourcenode a' \\<and>\n         distance (targetnode a') m (x - 1) \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>valid_edge ax'\\<close> \\<open>sourcenode a = sourcenode ax'\\<close> \\<open>intra_kind(kind ax')\\<close>\n      \\<open>sourcenode a' = sourcenode a\\<close> all"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  intra_kind (kind ax')\n  sourcenode a' = sourcenode a\n  \\<forall>a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and>\n     intra_kind (kind a'') \\<longrightarrow>\n     a'' = a", "have [simp]:\"ax' = a\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  intra_kind (kind ax')\n  sourcenode a' = sourcenode a\n  \\<forall>a''.\n     valid_edge a'' \\<and>\n     sourcenode a'' = sourcenode a' \\<and>\n     intra_kind (kind a'') \\<longrightarrow>\n     a'' = a\n\ngoal (1 subgoal):\n 1. ax' = a", "by fastforce"], ["proof (state)\nthis:\n  ax' = a\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>\n      \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>x \\<noteq> 0\\<close>\n      \\<open>distance (targetnode ax') m (x - 1)\\<close> \\<open>distance (sourcenode a) m x\\<close> Some"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<noteq> 0\n  distance (targetnode ax') m (x - 1)\n  distance (sourcenode a) m x\n  targetnode ax' =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode ax' = sourcenode a' \\<and>\n         distance (targetnode a') m (x - 1) \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind ax = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<noteq> 0\n  distance (targetnode ax') m (x - 1)\n  distance (sourcenode a) m x\n  targetnode ax' =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode ax' = sourcenode a' \\<and>\n         distance (targetnode a') m (x - 1) \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce elim:slice_kind_Pred_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Return:\n  \"\\<lbrakk>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = (\\<lambda>cf. True)\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. cf')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a =\n                      \\<lambda>cf.\n                         True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Return_in_slice:\n  \"\\<lbrakk>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; \n   (p,ins,outs) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. rspp (targetnode a) (HRB_slice S) outs cf' cf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n     (p, ins, outs) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a =\n                      Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                     rspp (targetnode a) (HRB_slice S) outs cf' cf", "by(simp add:slice_kind_def,unfold formal_out_THE,simp)"], ["", "lemma length_transfer_kind_slice_kind:\n  assumes \"valid_edge a\" and \"length s\\<^sub>1 = length s\\<^sub>2\"\n  and \"transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\" and \"transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\"\n  shows \"length s\\<^sub>1' = length s\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "proof(cases \"kind a\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a) \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. \\<And>Q r p fs.\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'\n 3. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a)\n\ngoal (3 subgoals):\n 1. intra_kind (kind a) \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. \\<And>Q r p fs.\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'\n 3. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "with Intra assms"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "by(cases s\\<^sub>1)(cases s\\<^sub>2,auto dest:slice_intra_kind_in_slice simp:intra_kind_def)+"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "with Intra assms"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "by(cases s\\<^sub>1)(cases s\\<^sub>2,auto dest:slice_kind_Upd \n        elim:kind_Predicate_notin_slice_slice_kind_Predicate simp:intra_kind_def)+"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'\n 2. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'\n 2. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "case (Call Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'\n 2. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "with Call assms"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "by(cases s\\<^sub>1)(cases s\\<^sub>2,auto dest:slice_kind_Call_in_slice)+"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "with Call assms"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "by(cases s\\<^sub>1)(cases s\\<^sub>2,auto dest:slice_kind_Call)+"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       length s\\<^sub>1' = length s\\<^sub>2'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "from Return \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a", "obtain a' Q' r fs \n      where \"valid_edge a'\" and \"kind a' = Q':r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' r fs.\n        \\<lbrakk>valid_edge a';\n         kind a' = Q':r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule return_needs_call,auto)"], ["proof (state)\nthis:\n  valid_edge a'\n  kind a' = Q':r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "then"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain ins outs where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "with True \\<open>valid_edge a\\<close> Return assms"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  (p, ins, outs) \\<in> set procs", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "by(cases s\\<^sub>1)(cases s\\<^sub>2,auto dest:slice_kind_Return_in_slice split:list.split)+"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    length s\\<^sub>1' = length s\\<^sub>2'", "with Return assms"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length s\\<^sub>2'", "by(cases s\\<^sub>1)(cases s\\<^sub>2,auto dest:slice_kind_Return split:list.split)+"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length s\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The sliced graph of a deterministic CFG is still deterministic\\<close>"], ["", "lemma only_one_SOME_edge:\n  assumes \"valid_edge a\" and \"intra_kind(kind a)\" and \"distance (targetnode a) mex x\"\n  shows \"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and> intra_kind(kind a') \\<and>\n               targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              distance (targetnode a') mex x \\<and>\n                                              valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                              targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')\n 2. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       distance (targetnode a') mex x \\<and>\n                       valid_edge a' \\<and>\n                       intra_kind (kind a') \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        distance (targetnode y) mex x \\<and>\n        valid_edge y \\<and>\n        intra_kind (kind y) \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and>\n               intra_kind (kind a') \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "show \"\\<exists>a'. sourcenode a = sourcenode a' \\<and> distance (targetnode a') mex x \\<and>\n             valid_edge a' \\<and> intra_kind(kind a') \\<and>\n             targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                            distance (targetnode a') mex x \\<and>\n                                            valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                            targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "have \"(\\<exists>a'. sourcenode a = sourcenode a' \\<and> distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                               distance (targetnode a') mex x \\<and>\n                                               valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                               targetnode a' = n')) =\n      (\\<exists>n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> distance (targetnode a') mex x \\<and>\n                 valid_edge a' \\<and> intra_kind(kind a') \\<and> targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a'.\n        sourcenode a = sourcenode a' \\<and>\n        distance (targetnode a') mex x \\<and>\n        valid_edge a' \\<and>\n        intra_kind (kind a') \\<and>\n        targetnode a' =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and>\n               intra_kind (kind a') \\<and> targetnode a' = n')) =\n    (\\<exists>n' a'.\n        sourcenode a = sourcenode a' \\<and>\n        distance (targetnode a') mex x \\<and>\n        valid_edge a' \\<and> intra_kind (kind a') \\<and> targetnode a' = n')", "apply(unfold some_eq_ex[of \"\\<lambda>n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                            distance (targetnode a') mex x \\<and>\n                                            valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                            targetnode a' = n'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n' a'.\n        sourcenode a = sourcenode a' \\<and>\n        distance (targetnode a') mex x \\<and>\n        valid_edge a' \\<and>\n        intra_kind (kind a') \\<and> targetnode a' = n') =\n    (\\<exists>n' a'.\n        sourcenode a = sourcenode a' \\<and>\n        distance (targetnode a') mex x \\<and>\n        valid_edge a' \\<and> intra_kind (kind a') \\<and> targetnode a' = n')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a'.\n      sourcenode a = sourcenode a' \\<and>\n      distance (targetnode a') mex x \\<and>\n      valid_edge a' \\<and>\n      intra_kind (kind a') \\<and>\n      targetnode a' =\n      (SOME n'.\n          \\<exists>a'.\n             sourcenode a = sourcenode a' \\<and>\n             distance (targetnode a') mex x \\<and>\n             valid_edge a' \\<and>\n             intra_kind (kind a') \\<and> targetnode a' = n')) =\n  (\\<exists>n' a'.\n      sourcenode a = sourcenode a' \\<and>\n      distance (targetnode a') mex x \\<and>\n      valid_edge a' \\<and> intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "also"], ["proof (state)\nthis:\n  (\\<exists>a'.\n      sourcenode a = sourcenode a' \\<and>\n      distance (targetnode a') mex x \\<and>\n      valid_edge a' \\<and>\n      intra_kind (kind a') \\<and>\n      targetnode a' =\n      (SOME n'.\n          \\<exists>a'.\n             sourcenode a = sourcenode a' \\<and>\n             distance (targetnode a') mex x \\<and>\n             valid_edge a' \\<and>\n             intra_kind (kind a') \\<and> targetnode a' = n')) =\n  (\\<exists>n' a'.\n      sourcenode a = sourcenode a' \\<and>\n      distance (targetnode a') mex x \\<and>\n      valid_edge a' \\<and> intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n' a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and> intra_kind (kind a') \\<and> targetnode a' = n'", "using \\<open>valid_edge a\\<close> \\<open>intra_kind(kind a)\\<close> \\<open>distance (targetnode a) mex x\\<close>"], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  distance (targetnode a) mex x\n\ngoal (1 subgoal):\n 1. \\<exists>n' a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and> intra_kind (kind a') \\<and> targetnode a' = n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>n' a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and> intra_kind (kind a') \\<and> targetnode a' = n'\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "finally"], ["proof (chain)\npicking this:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') mex x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = n')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') mex x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "."], ["proof (state)\nthis:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') mex x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') mex x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       distance (targetnode a') mex x \\<and>\n                       valid_edge a' \\<and>\n                       intra_kind (kind a') \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        distance (targetnode y) mex x \\<and>\n        valid_edge y \\<and>\n        intra_kind (kind y) \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and>\n               intra_kind (kind a') \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       distance (targetnode a') mex x \\<and>\n                       valid_edge a' \\<and>\n                       intra_kind (kind a') \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        distance (targetnode y) mex x \\<and>\n        valid_edge y \\<and>\n        intra_kind (kind y) \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and>\n               intra_kind (kind a') \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' ax"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       distance (targetnode a') mex x \\<and>\n                       valid_edge a' \\<and>\n                       intra_kind (kind a') \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        distance (targetnode y) mex x \\<and>\n        valid_edge y \\<and>\n        intra_kind (kind y) \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and>\n               intra_kind (kind a') \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"sourcenode a = sourcenode a' \\<and> distance (targetnode a') mex x \\<and>\n    valid_edge a' \\<and> intra_kind(kind a') \\<and>\n    targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                   distance (targetnode a') mex x \\<and>\n                                   valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                   targetnode a' = n')\"\n    and \"sourcenode a = sourcenode ax \\<and> distance (targetnode ax) mex x \\<and>\n    valid_edge ax \\<and> intra_kind(kind ax) \\<and>\n    targetnode ax = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                   distance (targetnode a') mex x \\<and>\n                                   valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                   targetnode a' = n')\""], ["proof (state)\nthis:\n  sourcenode a = sourcenode a' \\<and>\n  distance (targetnode a') mex x \\<and>\n  valid_edge a' \\<and>\n  intra_kind (kind a') \\<and>\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  sourcenode a = sourcenode ax \\<and>\n  distance (targetnode ax) mex x \\<and>\n  valid_edge ax \\<and>\n  intra_kind (kind ax) \\<and>\n  targetnode ax =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       distance (targetnode a') mex x \\<and>\n                       valid_edge a' \\<and>\n                       intra_kind (kind a') \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        distance (targetnode y) mex x \\<and>\n        valid_edge y \\<and>\n        intra_kind (kind y) \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               distance (targetnode a') mex x \\<and>\n               valid_edge a' \\<and>\n               intra_kind (kind a') \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "thus \"a' = ax\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a' \\<and>\n  distance (targetnode a') mex x \\<and>\n  valid_edge a' \\<and>\n  intra_kind (kind a') \\<and>\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  sourcenode a = sourcenode ax \\<and>\n  distance (targetnode ax) mex x \\<and>\n  valid_edge ax \\<and>\n  intra_kind (kind ax) \\<and>\n  targetnode ax =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. a' = ax", "by(fastforce intro!:edge_det)"], ["proof (state)\nthis:\n  a' = ax\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_only_one_True_edge:\n  assumes \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\" \n  and \"valid_edge a\" and \"valid_edge a'\" and \"intra_kind (kind a)\" \n  and \"intra_kind (kind a')\" and \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"\n  shows \"slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "from assms"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain Q Q' where \"kind a = (Q)\\<^sub>\\<surd>\"\n    and \"kind a' = (Q')\\<^sub>\\<surd>\" and det:\"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>kind a = (Q)\\<^sub>\\<surd>; kind a' = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n  kind a' = (Q')\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"Q = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. Q = (\\<lambda>s. True)", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  Q = (\\<lambda>s. True)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with det"], ["proof (chain)\npicking this:\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q = (\\<lambda>s. True)", "have \"Q' = (\\<lambda>s. False)\""], ["proof (prove)\nusing this:\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. Q' = (\\<lambda>s. False)", "by(simp add:fun_eq_iff)"], ["proof (state)\nthis:\n  Q' = (\\<lambda>s. False)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with True \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  Q' = (\\<lambda>s. False)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  Q' = (\\<lambda>s. False)\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "hence \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof(cases \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>\n        \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}", "obtain mex x where mex:\"mex = (THE mex. method_exit mex \\<and> \n        get_proc (sourcenode a) = get_proc mex)\"\n        and dist:\"distance (targetnode a) mex x\" \"distance (sourcenode a) mex (x + 1)\"\n        and target:\"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                                 distance (targetnode a') mex x \\<and>\n                                                 valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                                 targetnode a' = n')\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>mex x.\n        \\<lbrakk>mex =\n                 (THE mex.\n                     method_exit mex \\<and>\n                     get_proc (sourcenode a) = get_proc mex);\n         distance (targetnode a) mex x; distance (sourcenode a) mex (x + 1);\n         targetnode a =\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = n')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:slice_kind_def Let_def fun_eq_iff split:if_split_asm)"], ["proof (state)\nthis:\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>distance (targetnode a) mex x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  distance (targetnode a) mex x", "have ex1:\"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> distance (targetnode a') mex x \\<and> \n        valid_edge a' \\<and> intra_kind(kind a') \\<and>\n        targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                       distance (targetnode a') mex x \\<and>\n                                       valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                       targetnode a' = n')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  distance (targetnode a) mex x\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') mex x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') mex x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = n')", "by(rule only_one_SOME_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') mex x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "have \"targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                           distance (targetnode a') mex x \\<and>\n                                           valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                           targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n')", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') mex x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "assume \"\\<not> targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                                 distance (targetnode a') mex x \\<and>\n                                                 valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                                 targetnode a' = n')\""], ["proof (state)\nthis:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') mex x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "hence \"targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              distance (targetnode a') mex x \\<and>\n                                              valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                              targetnode a' = n')\""], ["proof (prove)\nusing this:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') mex x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a' =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') mex x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n')", "by simp"], ["proof (state)\nthis:\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') mex x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "with ex1 target \\<open>sourcenode a = sourcenode a'\\<close> \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close>\n          \\<open>intra_kind(kind a)\\<close> \\<open>intra_kind(kind a')\\<close> \\<open>distance (targetnode a) mex x\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') mex x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = n')\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  distance (targetnode a) mex x\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "have \"a = a'\""], ["proof (prove)\nusing this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') mex x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') mex x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = n')\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  distance (targetnode a) mex x\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. a = a'", "by fastforce"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') mex x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "with \\<open>targetnode a \\<noteq> targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'", "show False"], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> True \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close>\n        \\<open>sourcenode a = sourcenode a'\\<close> mex dist"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  mex =\n  (THE mex. method_exit mex \\<and> get_proc (sourcenode a) = get_proc mex)\n  distance (targetnode a) mex x\n  distance (sourcenode a) mex (x + 1)\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') mex x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto dest:distance_det \n        simp:slice_kind_def Let_def fun_eq_iff split:if_split_asm)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "hence \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\""], ["proof (prove)\nusing this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "."], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "then"], ["proof (chain)\npicking this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}", "obtain m where \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice\n                           S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "hence \"m = (THE m. m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m =\n    (THE m.\n        m \\<in> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(auto dest:obs_intra_the_element)"], ["proof (state)\nthis:\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n        \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\\<close> \n        \\<open>slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "obtain x x' where \"distance (targetnode a) m x\" \n        \"distance (sourcenode a) m (x + 1)\"\n        and target:\"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                                 distance (targetnode a') m x \\<and>\n                                                 valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                                 targetnode a' = n')\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  m =\n  (THE m.\n      m \\<in> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance (targetnode a) m x;\n         distance (sourcenode a) m (x + 1);\n         targetnode a =\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = n')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:slice_kind_def Let_def fun_eq_iff split:if_split_asm)"], ["proof (state)\nthis:\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof(cases \"distance (targetnode a') m x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<not> distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  \\<not> distance (targetnode a') m x\n\ngoal (2 subgoals):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<not> distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close>\n          \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>\n          \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  sourcenode a = sourcenode a'\n  \\<not> distance (targetnode a') m x", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  sourcenode a = sourcenode a'\n  \\<not> distance (targetnode a') m x\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_not_nearer)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  distance (targetnode a') m x\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>valid_edge a\\<close> \\<open>intra_kind(kind a)\\<close> \\<open>distance (targetnode a) m x\\<close>\n          \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)", "have ex1:\"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> \n               distance (targetnode a') m x \\<and> valid_edge a' \\<and> intra_kind(kind a') \\<and> \n               targetnode a' = (SOME nx. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                              distance (targetnode a') m x \\<and>\n                                              valid_edge a' \\<and> intra_kind(kind a') \\<and> \n                                              targetnode a' = nx)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') m x \\<and>\n       valid_edge a' \\<and>\n       intra_kind (kind a') \\<and>\n       targetnode a' =\n       (SOME nx.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') m x \\<and>\n              valid_edge a' \\<and>\n              intra_kind (kind a') \\<and> targetnode a' = nx)", "by -(rule only_one_SOME_dist_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') m x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME nx.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') m x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "have \"targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                               distance (targetnode a') m x \\<and>\n                                               valid_edge a' \\<and> intra_kind(kind a') \\<and> \n                                               targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n')", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "assume \"\\<not> targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                                 distance (targetnode a') m x \\<and>\n                                                 valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                                 targetnode a' = n')\""], ["proof (state)\nthis:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "hence \"targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                                distance (targetnode a') m x \\<and>\n                                                valid_edge a' \\<and> intra_kind(kind a') \\<and>\n                                                targetnode a' = n')\""], ["proof (prove)\nusing this:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a' =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and>\n           intra_kind (kind a') \\<and> targetnode a' = n')", "by simp"], ["proof (state)\nthis:\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "with ex1 target \\<open>sourcenode a = sourcenode a'\\<close> \n            \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>intra_kind(kind a)\\<close> \\<open>intra_kind(kind a')\\<close>\n            \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') m x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME nx.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') m x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = nx)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "have \"a = a'\""], ["proof (prove)\nusing this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') m x \\<and>\n     valid_edge a' \\<and>\n     intra_kind (kind a') \\<and>\n     targetnode a' =\n     (SOME nx.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') m x \\<and>\n            valid_edge a' \\<and>\n            intra_kind (kind a') \\<and> targetnode a' = nx)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. a = a'", "by auto"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and>\n                  intra_kind (kind a') \\<and>\n                  targetnode a' = n') \\<Longrightarrow>\n    False", "with \\<open>targetnode a \\<noteq> targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'", "show False"], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n          \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>\n          True \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  distance (targetnode a') m x\n  sourcenode a = sourcenode a'\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  distance (targetnode a') m x\n  sourcenode a = sourcenode a'\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_nearer_not_SOME)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_deterministic:\n  assumes \"valid_edge a\" and \"valid_edge a'\"\n  and \"intra_kind (kind a)\" and \"intra_kind (kind a')\"\n  and \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\"\n  obtains Q Q' where \"slice_kind S a = (Q)\\<^sub>\\<surd>\" and \"slice_kind S a' = (Q')\\<^sub>\\<surd>\"\n  and \"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>slice_kind S a = (Q)\\<^sub>\\<surd>;\n         slice_kind S a' = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from assms"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'", "obtain Q Q' \n    where \"kind a = (Q)\\<^sub>\\<surd>\" and \"kind a' = (Q')\\<^sub>\\<surd>\" \n    and det:\"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>kind a = (Q)\\<^sub>\\<surd>; kind a' = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n  kind a' = (Q')\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "show \"\\<exists>Q Q'. slice_kind S a = (Q)\\<^sub>\\<surd> \\<and> slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and> \n                (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (Q)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from True \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'", "have \"slice_kind S a' = (Q')\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (Q')\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a' = (Q')\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>slice_kind S a = (Q)\\<^sub>\\<surd>\\<close> det"], ["proof (chain)\npicking this:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  slice_kind S a' = (Q')\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  slice_kind S a' = (Q')\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by blast"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or> slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n    slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume true:\"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>sourcenode a = sourcenode a'\\<close> \\<open>targetnode a \\<noteq> targetnode a'\\<close>\n        \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule slice_kind_only_one_True_edge)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with true"], ["proof (chain)\npicking this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume false:\"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from False \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'", "have \"slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with false"], ["proof (chain)\npicking this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by auto"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}